#![allow(clippy::cognitive_complexity)]

//! `phosphorus` CLI program.
//!
//! Currently just a demo program to test with!

use phosphorus::*;

fn main() {
  let version = env!("CARGO_PKG_VERSION");

  let bytes_vec = std::fs::read("xml/gl.xml").unwrap();
  let string = String::from_utf8(bytes_vec).unwrap();

  let reg = GlRegistry::from_gl_xml(&string).unwrap();

  let output = Output::new(
    &reg,
    feature_name_for(ApiCategory::Gl, 3, 3).unwrap(),
    Profile::Core,
    &[],
  );

  println!("#![cfg_attr(not(any(feature = \"trace_calls\", feature = \"error_checks\")), no_std)]");
  println!("#![allow(bad_style)]");
  println!("#![allow(clippy::unreadable_literal)]");
  println!("#![allow(clippy::missing_safety_doc)]");
  println!("#![allow(clippy::let_unit_value)]");
  println!("#![allow(clippy::let_and_return)]");
  println!("#![allow(clippy::too_many_arguments)]");
  println!("#![allow(clippy::many_single_char_names)]");
  println!();
  println!("/*");
  println!("Bindings for GL.");
  println!();
  println!("* API: {}", output.name);
  println!("* profile: {}", output.profile);
  println!("* extensions: {:?}", output.extensions);
  println!();
  println!("generated by phosphorus-{}", version);
  println!("*/");
  println!("fn main() {{ }}");
  println!();
  println!("// provides C types, replace with your own source if you like.");
  println!("pub use chlorine::*;");

  // TODO: note down how we picked the Output value (feature, extensions, etc)

  {
    println!();
    println!("pub use types::*;");
    println!("pub mod types {{");
    println!("  //! Type aliases used by GL.");
    println!();
    println!(
      "  // Note: A source of C types must be in scope! winapi, libc, etc."
    );
    println!("  use super::*;");
    let mut type_v: Vec<&Type> = output.types.iter().collect();
    type_v.sort();
    for t_ref in type_v {
      println!("  {}", t_ref);
    }
    println!("}}");
  }

  {
    println!();
    println!("pub use groups::*;");
    println!("pub mod groups {{");
    println!("  //! Various aliases for `GLenum`.");
    println!("  //!");
    println!("  //! This helps function signatures be more clear about what `GLenum` values");
    println!("  //! they allow.");
    println!("  //!");
    println!("  //! **Important**: The groups info is **not** necessarily correct! Khronos");
    println!("  //! considers it to be low-value metadata, and so they don't keep the groups");
    println!("  //! info up to date with all API levels and Extension alterations. That is why");
    println!("  //! it's presented only as an alias, because you might need to pass other");
    println!("  //! `GLenum` values based on your exact use case.");
    println!("  use super::*;");
    let mut group_v: Vec<String> = output
      .groups
      .iter()
      .map(|(name, entries)| format!("{}", GroupDisplay { name, entries }))
      .collect();
    group_v.sort();
    for group_string in group_v {
      println!("  {}", group_string);
    }
    println!("}}");
  }

  {
    println!();
    println!("pub use enums::*;");
    println!("pub mod enums {{");
    println!("  //! All the enumerated constants.");
    println!("  use super::*;");
    let mut enums_v: Vec<String> = output
      .enums
      .iter()
      .map(|(name, value)| {
        let key = &EnumKey { name: name.to_owned(), api: None };
        format!("{}", EnumDisplay { key, value })
      })
      .collect();
    enums_v.sort();
    for enum_string in enums_v {
      println!("  {}", enum_string);
    }
    println!("}}");
  }

  // Elements common to both loaders
  {
    println!();
    println!("/// Function pointer sanity check.");
    println!("///");
    println!("/// * Null pointers (0) are bad.");
    println!("/// * Sometimes windows will return non-null error values.");
    println!("///   * Known non-null error values include 1, 2, 3, and -1.");
    println!(
      r#"#[cfg(any(feature="global_loader", feature="struct_loader"))]"#
    );
    println!("fn fn_ptr_ok(p: *const c_void) -> bool {{");
    println!("  let p_u = p as usize;");
    println!("  (p_u >= 8) && (p_u != usize::max_value())");
    println!("}}");

    println!();
    println!(
      r#"#[cfg(any(feature="global_loader", feature="struct_loader"))]"#
    );
    println!("fn call_loader(");
    println!("  loader: &mut dyn FnMut(*const c_char) -> *mut c_void,");
    println!("  name: &[u8],");
    println!(") -> *mut c_void {{");
    println!("  debug_assert!(*name.last().unwrap() == 0_u8);");
    println!("  let p = loader(name.as_ptr() as *const c_char);");
    println!("  if fn_ptr_ok(p) {{");
    println!("    p");
    println!("  }} else {{");
    println!("    core::ptr::null_mut()");
    println!("  }}");
    println!("}}");

    let enum_prefix = "GL_";
    println!();
    println!(r#"#[cfg(feature="error_checks")]"#);
    println!("use std::borrow::Cow;");
    println!(r#"#[cfg(feature="error_checks")]"#);
    println!("fn error_name_for(err: GLenum) -> Cow<'static, str> {{");
    println!("  match err {{");
    for short_name in &[
      "INVALID_ENUM",
      "INVALID_VALUE",
      "INVALID_OPERATION",
      "INVALID_FRAMEBUFFER_OPERATION",
      "OUT_OF_MEMORY",
      "STACK_UNDERFLOW",
      "STACK_OVERFLOW",
    ] {
      let gl_name = format!("GL_{}", short_name);
      let prefixed_name = format!("{}{}", enum_prefix, short_name);
      if output.enums.keys().any(|k| k == &gl_name) {
        println!(
          "    {prefixed_name} => Cow::Borrowed(\"{prefixed_name}\"),",
          prefixed_name = prefixed_name
        );
      }
    }
    println!("    _ => Cow::Owned(format!(\"0x{{:X}}\", err)),");
    println!("  }}");
    println!("}}");
  }

  {
    let fn_prefix = "gl";
    println!();
    println!(r#"#[cfg(feature="global_loader")]"#);
    println!("pub use global_loader::*;");
    println!(r#"#[cfg(feature="global_loader")]"#);
    println!("pub mod global_loader {{");
    println!("  use super::*;");
    println!("  use core::ptr::null_mut;");
    println!("  use core::mem::transmute;");
    println!("  use core::ops::Not;");
    println!("  use core::sync::atomic::{{AtomicPtr, Ordering}};");
    println!();
    println!("  #[doc = \"Loads all the global GL functions.\\n\\nGiven a function from C string pointer to GL function pointer, loads all the GL functions.\\n\\n## Safety\\nThis can check for nulls and other common error values, but otherwise mostly trusts whatever pointer is returned.\"]");
    println!("  pub unsafe fn global_load<F>(mut f: F)");
    println!("    where F: FnMut(*const c_char) -> *mut c_void");
    println!("  {{");
    for command in output.commands.iter() {
      let name = &command.name[2..];
      println!(
        "    load_{fn_prefix}{name}(&mut f);",
        name = name,
        fn_prefix = fn_prefix
      )
    }
    println!("  }}");
    let mut command_v: Vec<String> = output
      .commands
      .iter()
      .map(|command| format!("{}", GlobalCommand { command }))
      .collect();
    command_v.sort();
    for command_string in command_v {
      println!();
      println!("  {}", command_string);
    }
    println!("}}");
    // TODO: output the commands as global functions.
  }

  {
    println!();
    println!(r#"#[cfg(feature="struct_loader")]"#);
    println!("pub use struct_loader::*;");
    println!(r#"#[cfg(feature="struct_loader")]"#);
    println!("pub mod struct_loader {{");
    println!("  use super::*;");
    println!("  // TODO!");
    println!("}}");
    // TODO: output the commands as struct functions.
  }
}
