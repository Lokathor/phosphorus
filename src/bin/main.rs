#![allow(clippy::cognitive_complexity)]

//! `phosphorus` CLI program.
//!
//! Currently just a demo program to test with!

use phosphorus::*;

fn main() {
  let version = env!("CARGO_PKG_VERSION");

  let bytes_vec = std::fs::read("xml/gl.xml").unwrap();
  let string = String::from_utf8(bytes_vec).unwrap();

  let reg = GlRegistry::from_gl_xml(&string).unwrap();

  let output = Output::new(
    &reg,
    feature_name_for(ApiCategory::Gl, 3, 3).unwrap(),
    Profile::Core,
    &[],
  );

  println!("#![no_std]");
  println!("#![allow(bad_style)]");
  println!("#![allow(clippy::unreadable_literal)]");
  println!();
  println!("/*");
  println!("Bindings for GL.");
  println!();
  println!("* API: {}", output.name);
  println!("* profile: {}", output.profile);
  println!("* extensions: {:?}", output.extensions);
  println!();
  println!("generated by phosphorus-{}", version);
  println!("*/");
  println!("fn main() {{ }}");
  println!();
  println!("// provides C types, replace with your own source if you like.");
  println!("pub use chlorine::*;");

  // TODO: note down how we picked the Output value (feature, extensions, etc)

  {
    println!();
    println!("pub use types::*;");
    println!("pub mod types {{");
    println!("  //! Type aliases used by GL.");
    println!();
    println!(
      "  // Note: A source of C types must be in scope! winapi, libc, etc."
    );
    println!("  use super::*;");
    let mut type_v: Vec<&Type> = output.types.iter().collect();
    type_v.sort();
    for t_ref in type_v {
      println!("  {}", t_ref);
    }
    println!("}}");
  }

  {
    println!();
    println!("pub use groups::*;");
    println!("pub mod groups {{");
    println!("  //! Various aliases for `GLenum`.");
    println!("  //!");
    println!("  //! This helps function signatures be more clear about what `GLenum` values");
    println!("  //! they allow.");
    println!("  //!");
    println!("  //! **Important**: The groups info is **not** necessarily correct! Khronos");
    println!("  //! considers it to be low-value metadata, and so they don't keep the groups");
    println!("  //! info up to date with all API levels and Extension alterations. That is why");
    println!("  //! it's presented only as an alias, because you might need to pass other");
    println!("  //! `GLenum` values based on your exact use case.");
    println!("  use super::*;");
    let mut group_v: Vec<String> = output
      .groups
      .iter()
      .map(|(name, entries)| format!("{}", GroupDisplay { name, entries }))
      .collect();
    group_v.sort();
    for group_string in group_v {
      println!("  {}", group_string);
    }
    println!("}}");
  }

  {
    println!();
    println!("pub use enums::*;");
    println!("pub mod enums {{");
    println!("  //! All the enumerated constants.");
    println!("  use super::*;");
    let mut enums_v: Vec<String> = output
      .enums
      .iter()
      .map(|(name, value)| {
        let key = &EnumKey { name: name.to_owned(), api: None };
        format!("{}", EnumDisplay { key, value })
      })
      .collect();
    enums_v.sort();
    for enum_string in enums_v {
      println!("  {}", enum_string);
    }
    println!("}}");
  }

  // Elements common to both loaders
  {
    println!();
    println!("/// Function pointer sanity check.");
    println!("///");
    println!("/// * Null pointers (0) are bad.");
    println!("/// * Sometimes windows will return non-null error values.");
    println!("///   * Known non-null error values include 1, 2, 3, and -1.");
    println!(
      r#"#[cfg(any(feature="global_loader", feature="struct_loader"))]"#
    );
    println!("fn fn_ptr_ok(p: *const c_void) -> bool {{");
    println!("  let p_u = p as usize;");
    println!("  (p_u >= 8) && (p_u != usize::max_value())");
    println!("}}");

    println!();
    println!(
      r#"#[cfg(any(feature="global_loader", feature="struct_loader"))]"#
    );
    println!("use core::ptr::NonNull;");
    println!(
      r#"#[cfg(any(feature="global_loader", feature="struct_loader"))]"#
    );
    println!("fn call_loader(");
    println!("  loader: &mut dyn FnMut(*const c_char) -> *const c_void,");
    println!("  name: &[u8],");
    println!(") -> Option<NonNull<c_void>> {{");
    println!("  debug_assert!(*name.last().unwrap() == 0_u8);");
    println!("  let p = loader(name.as_ptr() as *const c_char);");
    println!("  if fn_ptr_ok(p) {{");
    println!("    NonNull::new(p as *mut c_void)");
    println!("  }} else {{");
    println!("    None");
    println!("  }}");
    println!("}}");
  }

  {
    println!();
    println!(r#"#[cfg(feature="global_loader")]"#);
    println!("pub use global_loader::*;");
    println!(r#"#[cfg(feature="global_loader")]"#);
    println!("pub mod global_loader {{");
    println!("  use super::*;");
    println!("  use core::ptr::null_mut;");
    println!("  use core::sync::atomic::{{AtomicPtr, Ordering}};");
    for command in output.commands.iter() {
      println!();
      println!("  {}", GlobalCommand { command });
    }
    println!("  // TODO!");
    println!("}}");
    // TODO: output the commands as global functions.
  }

  {
    println!();
    println!(r#"#[cfg(feature="struct_loader")]"#);
    println!("pub use struct_loader::*;");
    println!(r#"#[cfg(feature="struct_loader")]"#);
    println!("pub mod struct_loader {{");
    println!("  use super::*;");
    println!("  // TODO!");
    println!("}}");
    // TODO: output the commands as struct functions.
  }
}
