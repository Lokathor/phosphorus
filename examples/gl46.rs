#![allow(bad_style)]
#![deny(missing_docs)]
#![deny(missing_debug_implementations)]

//! Bindings to Gl 4.6
//!
//! Generated by the [`phosphorus`](https://docs.rs/phosphorus) crate.
//! * License: CC0 OR Zlib OR Apache-2.0 OR MIT
//!
//! Supported Features:
//! * `global_loader`: Include all mechanisms necessary for calling GL using
//!   global functions.
//! * `struct_loader`: Include all mechanisms necessary for calling GL as
//!   methods on a struct.
//! * `debug_trace_calls`: if cfg!(debug_assertions), any call to a GL function
//!   will `trace!` what was called and with what args.
//! * `debug_automatic_glGetError`: If cfg!(debug_assertions), this will
//!   automatically call `glGetError` after every call to any *other* GL
//!   function. If an error code occurs it's shown via `error!` along with the
//!   name of the function that had the error.
//! * `log`: imports `trace!` and `error!` macros from the `log` crate.
//!   Otherwise they just call `println!` and `eprintln!` respectively.
//! * `chlorine`: gets all C types from the `chlorine` crate (which is `no_std`
//!   friendly). Otherwise they will be imported from `std::os::raw`.
//! * `bytemuck`: Adds support for the `bytemuck` crate, mostly in the form of
//!   `bytemuck::Zeroable` on `GlFns`.
//! * `inline`: Tags all GL calls as `#[inline]`.
//! * `inline_always`: Tags all GL calls as `#[inline(always)]`. This will
//!   effectively override the `inline` feature.
//!
//! The crate is `no_std` friendly by default, but features above can end up
//! requiring `std` to be available.
fn main() {} // TODO: disable EXAMPLE_MODE.

#[cfg(any(
  all(
    not(feature = "log"),
    any(feature = "debug_trace_calls", feature = "debug_automatic_glGetError")
  ),
  not(feature = "chlorine"),
))]
extern crate std;
#[cfg(feature = "chlorine")]
use chlorine::*;
#[cfg(not(feature = "chlorine"))]
use std::os::raw::*;

#[cfg(feature = "log")]
use log::{error, trace};
#[cfg(all(
  not(feature = "log"),
  any(feature = "debug_trace_calls", feature = "debug_automatic_glGetError")
))]
use std::{eprintln, println};
#[cfg(all(not(feature = "log"), feature = "debug_trace_calls"))]
macro_rules! trace { ($($arg:tt)*) => { println!($($arg)*) } }
#[cfg(all(not(feature = "log"), feature = "debug_automatic_glGetError"))]
macro_rules! error { ($($arg:tt)*) => { eprintln!($($arg)*) } }

use core::{
  mem::transmute as t_,
  ptr::null_mut,
  sync::atomic::{AtomicPtr, Ordering},
};
const RELAX: Ordering = Ordering::Relaxed;
type APcv = AtomicPtr<c_void>;
type GPA = dyn FnMut(*const c_char) -> *mut c_void;
type O<T> = Option<T>;
const fn ap_null() -> APcv {
  AtomicPtr::new(null_mut())
}

pub use types::*;
#[allow(missing_docs)]
mod types {
  use super::*;
  pub type GLenum = c_uint;
  pub type GLboolean = c_uchar;
  pub type GLbitfield = c_uint;
  pub type GLvoid = c_void;
  pub type GLbyte = i8;
  pub type GLubyte = u8;
  pub type GLshort = i16;
  pub type GLushort = u16;
  pub type GLint = c_int;
  pub type GLuint = c_uint;
  pub type GLclampx = i32;
  pub type GLsizei = c_int;
  pub type GLfloat = c_float;
  pub type GLclampf = c_float;
  pub type GLdouble = c_double;
  pub type GLclampd = c_double;
  pub type GLeglClientBufferEXT = *mut c_void;
  pub type GLeglImageOES = *mut c_void;
  pub type GLchar = c_char;
  pub type GLcharARB = c_char;
  #[cfg(any(target_os = "macos", target_os = "ios"))]
  pub type GLhandleARB = *mut c_void;
  #[cfg(not(any(target_os = "macos", target_os = "ios")))]
  pub type GLhandleARB = c_uint;
  pub type GLhalf = u16;
  pub type GLhalfARB = u16;
  pub type GLfixed = i32;
  pub type GLintptr = isize;
  pub type GLintptrARB = isize;
  pub type GLsizeiptr = isize;
  pub type GLsizeiptrARB = isize;
  pub type GLint64 = i64;
  pub type GLint64EXT = i64;
  pub type GLuint64 = u64;
  pub type GLuint64EXT = u64;
  pub struct __GLsync {
    _priv: u8,
  }
  impl core::fmt::Debug for __GLsync {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      write!(f, "__GLsync")
    }
  }
  pub type GLsync = *mut __GLsync;
  pub struct _cl_context {
    _priv: u8,
  }
  impl core::fmt::Debug for _cl_context {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      write!(f, "_cl_context")
    }
  }
  pub struct _cl_event {
    _priv: u8,
  }
  impl core::fmt::Debug for _cl_event {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      write!(f, "_cl_event")
    }
  }
  pub type GLDEBUGPROC = O<
    unsafe extern "system" fn(
      source: GLenum,
      gltype: GLenum,
      id: GLuint,
      severity: GLenum,
      length: GLsizei,
      message: *const GLchar,
      userParam: *mut c_void,
    ),
  >;
  pub type GLDEBUGPROCARB = O<
    extern "system" fn(
      source: GLenum,
      gltype: GLenum,
      id: GLuint,
      severity: GLenum,
      length: GLsizei,
      message: *const GLchar,
      userParam: *mut c_void,
    ),
  >;
  pub type GLDEBUGPROCKHR = O<
    extern "system" fn(
      source: GLenum,
      gltype: GLenum,
      id: GLuint,
      severity: GLenum,
      length: GLsizei,
      message: *const GLchar,
      userParam: *mut c_void,
    ),
  >;
  pub type GLDEBUGPROCAMD = O<
    extern "system" fn(
      id: GLuint,
      category: GLenum,
      severity: GLenum,
      length: GLsizei,
      message: *const GLchar,
      userParam: *mut c_void,
    ),
  >;
  pub type GLhalfNV = c_ushort;
  pub type GLvdpauSurfaceNV = GLintptr;
  pub type GLVULKANPROCNV = O<extern "system" fn()>;
}

pub use enums::*;
mod enums {
  use super::*;
  #[doc = "`GL_ACTIVE_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D9`\n* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D9;
  #[doc = "`GL_ACTIVE_ATTRIBUTES: GLenum = 0x8B89`\n* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_ATTRIBUTES: GLenum = 0x8B89;
  #[doc = "`GL_ACTIVE_ATTRIBUTE_MAX_LENGTH: GLenum = 0x8B8A`\n* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_ATTRIBUTE_MAX_LENGTH: GLenum = 0x8B8A;
  #[doc = "`GL_ACTIVE_PROGRAM: GLenum = 0x8259`\n* **Group:** PipelineParameterName"]
  pub const GL_ACTIVE_PROGRAM: GLenum = 0x8259;
  #[doc = "`GL_ACTIVE_RESOURCES: GLenum = 0x92F5`\n* **Group:** ProgramInterfacePName"]
  pub const GL_ACTIVE_RESOURCES: GLenum = 0x92F5;
  #[doc = "`GL_ACTIVE_SUBROUTINES: GLenum = 0x8DE5`\n* **Group:** ProgramStagePName"]
  pub const GL_ACTIVE_SUBROUTINES: GLenum = 0x8DE5;
  #[doc = "`GL_ACTIVE_SUBROUTINE_MAX_LENGTH: GLenum = 0x8E48`\n* **Group:** ProgramStagePName"]
  pub const GL_ACTIVE_SUBROUTINE_MAX_LENGTH: GLenum = 0x8E48;
  #[doc = "`GL_ACTIVE_SUBROUTINE_UNIFORMS: GLenum = 0x8DE6`\n* **Group:** ProgramStagePName"]
  pub const GL_ACTIVE_SUBROUTINE_UNIFORMS: GLenum = 0x8DE6;
  #[doc = "`GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS: GLenum = 0x8E47`\n* **Group:** ProgramStagePName"]
  pub const GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS: GLenum = 0x8E47;
  #[doc = "`GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH: GLenum = 0x8E49`\n* **Group:** ProgramStagePName"]
  pub const GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH: GLenum = 0x8E49;
  #[doc = "`GL_ACTIVE_TEXTURE: GLenum = 0x84E0`\n* **Group:** GetPName"]
  pub const GL_ACTIVE_TEXTURE: GLenum = 0x84E0;
  #[doc = "`GL_ACTIVE_UNIFORMS: GLenum = 0x8B86`\n* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_UNIFORMS: GLenum = 0x8B86;
  #[doc = "`GL_ACTIVE_UNIFORM_BLOCKS: GLenum = 0x8A36`\n* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_UNIFORM_BLOCKS: GLenum = 0x8A36;
  #[doc = "`GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: GLenum = 0x8A35`\n* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: GLenum = 0x8A35;
  #[doc = "`GL_ACTIVE_UNIFORM_MAX_LENGTH: GLenum = 0x8B87`\n* **Group:** ProgramPropertyARB"]
  pub const GL_ACTIVE_UNIFORM_MAX_LENGTH: GLenum = 0x8B87;
  #[doc = "`GL_ACTIVE_VARIABLES: GLenum = 0x9305`\n* **Group:** ProgramResourceProperty"]
  pub const GL_ACTIVE_VARIABLES: GLenum = 0x9305;
  #[doc = "`GL_ALIASED_LINE_WIDTH_RANGE: GLenum = 0x846E`\n* **Group:** GetPName"]
  pub const GL_ALIASED_LINE_WIDTH_RANGE: GLenum = 0x846E;
  #[doc = "`GL_ALL_BARRIER_BITS: GLbitfield = 0xFFFFFFFF`\n* **Group:** MemoryBarrierMask"]
  pub const GL_ALL_BARRIER_BITS: GLbitfield = 0xFFFFFFFF;
  #[doc = "`GL_ALL_SHADER_BITS: GLbitfield = 0xFFFFFFFF`\n* **Group:** UseProgramStageMask"]
  pub const GL_ALL_SHADER_BITS: GLbitfield = 0xFFFFFFFF;
  #[doc = "`GL_ALPHA: GLenum = 0x1906`\n* **Groups:** TextureSwizzle, CombinerPortionNV, PathColorFormat, CombinerComponentUsageNV, PixelFormat"]
  pub const GL_ALPHA: GLenum = 0x1906;
  #[doc = "`GL_ALREADY_SIGNALED: GLenum = 0x911A`\n* **Group:** SyncStatus"]
  pub const GL_ALREADY_SIGNALED: GLenum = 0x911A;
  #[doc = "`GL_ALWAYS: GLenum = 0x0207`\n* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_ALWAYS: GLenum = 0x0207;
  #[doc = "`GL_AND: GLenum = 0x1501`\n* **Group:** LogicOp"]
  pub const GL_AND: GLenum = 0x1501;
  #[doc = "`GL_AND_INVERTED: GLenum = 0x1504`\n* **Group:** LogicOp"]
  pub const GL_AND_INVERTED: GLenum = 0x1504;
  #[doc = "`GL_AND_REVERSE: GLenum = 0x1502`\n* **Group:** LogicOp"]
  pub const GL_AND_REVERSE: GLenum = 0x1502;
  #[doc = "`GL_ANY_SAMPLES_PASSED: GLenum = 0x8C2F`\n* **Group:** QueryTarget"]
  pub const GL_ANY_SAMPLES_PASSED: GLenum = 0x8C2F;
  #[doc = "`GL_ANY_SAMPLES_PASSED_CONSERVATIVE: GLenum = 0x8D6A`\n* **Group:** QueryTarget"]
  pub const GL_ANY_SAMPLES_PASSED_CONSERVATIVE: GLenum = 0x8D6A;
  #[doc = "`GL_ARRAY_BUFFER: GLenum = 0x8892`\n* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_ARRAY_BUFFER: GLenum = 0x8892;
  #[doc = "`GL_ARRAY_BUFFER_BINDING: GLenum = 0x8894`\n* **Group:** GetPName"]
  pub const GL_ARRAY_BUFFER_BINDING: GLenum = 0x8894;
  #[doc = "`GL_ARRAY_SIZE: GLenum = 0x92FB`\n* **Group:** ProgramResourceProperty"]
  pub const GL_ARRAY_SIZE: GLenum = 0x92FB;
  #[doc = "`GL_ARRAY_STRIDE: GLenum = 0x92FE`\n* **Group:** ProgramResourceProperty"]
  pub const GL_ARRAY_STRIDE: GLenum = 0x92FE;
  #[doc = "`GL_ATOMIC_COUNTER_BARRIER_BIT: GLbitfield = 0x00001000`\n* **Group:** MemoryBarrierMask"]
  pub const GL_ATOMIC_COUNTER_BARRIER_BIT: GLbitfield = 0x00001000;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER: GLenum = 0x92C0`\n* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_ATOMIC_COUNTER_BUFFER: GLenum = 0x92C0;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS: GLenum = 0x92C5`\n* **Group:** AtomicCounterBufferPName"]
  pub const GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS: GLenum = 0x92C5;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES: GLenum = 0x92C6`\n* **Group:** AtomicCounterBufferPName"]
  pub const GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES: GLenum =
    0x92C6;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_BINDING: GLenum = 0x92C1`\n* **Group:** AtomicCounterBufferPName"]
  pub const GL_ATOMIC_COUNTER_BUFFER_BINDING: GLenum = 0x92C1;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE: GLenum = 0x92C4`\n* **Group:** AtomicCounterBufferPName"]
  pub const GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE: GLenum = 0x92C4;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_INDEX: GLenum = 0x9301`\n* **Group:** ProgramResourceProperty"]
  pub const GL_ATOMIC_COUNTER_BUFFER_INDEX: GLenum = 0x9301;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x90ED`\n* **Group:** AtomicCounterBufferPName"]
  pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER: GLenum =
    0x90ED;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x92CB`\n* **Group:** AtomicCounterBufferPName"]
  pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER: GLenum =
    0x92CB;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x92CA`\n* **Group:** AtomicCounterBufferPName"]
  pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER: GLenum =
    0x92CA;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x92C8`\n* **Group:** AtomicCounterBufferPName"]
  pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum =
    0x92C8;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x92C9`\n* **Group:** AtomicCounterBufferPName"]
  pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER:
    GLenum = 0x92C9;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x92C7`\n* **Group:** AtomicCounterBufferPName"]
  pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER: GLenum =
    0x92C7;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_SIZE: GLenum = 0x92C3`"]
  pub const GL_ATOMIC_COUNTER_BUFFER_SIZE: GLenum = 0x92C3;
  #[doc = "`GL_ATOMIC_COUNTER_BUFFER_START: GLenum = 0x92C2`"]
  pub const GL_ATOMIC_COUNTER_BUFFER_START: GLenum = 0x92C2;
  #[doc = "`GL_ATTACHED_SHADERS: GLenum = 0x8B85`\n* **Group:** ProgramPropertyARB"]
  pub const GL_ATTACHED_SHADERS: GLenum = 0x8B85;
  #[doc = "`GL_AUTO_GENERATE_MIPMAP: GLenum = 0x8295`\n* **Group:** InternalFormatPName"]
  pub const GL_AUTO_GENERATE_MIPMAP: GLenum = 0x8295;
  #[doc = "`GL_BACK: GLenum = 0x0405`\n* **Groups:** ColorBuffer, ColorMaterialFace, CullFaceMode, DrawBufferMode, ReadBufferMode, StencilFaceDirection, MaterialFace"]
  pub const GL_BACK: GLenum = 0x0405;
  #[doc = "`GL_BACK_LEFT: GLenum = 0x0402`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode"]
  pub const GL_BACK_LEFT: GLenum = 0x0402;
  #[doc = "`GL_BACK_RIGHT: GLenum = 0x0403`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode"]
  pub const GL_BACK_RIGHT: GLenum = 0x0403;
  #[doc = "`GL_BGR: GLenum = 0x80E0`\n* **Group:** PixelFormat"]
  pub const GL_BGR: GLenum = 0x80E0;
  #[doc = "`GL_BGRA: GLenum = 0x80E1`\n* **Group:** PixelFormat"]
  pub const GL_BGRA: GLenum = 0x80E1;
  #[doc = "`GL_BGRA_INTEGER: GLenum = 0x8D9B`\n* **Group:** PixelFormat"]
  pub const GL_BGRA_INTEGER: GLenum = 0x8D9B;
  #[doc = "`GL_BGR_INTEGER: GLenum = 0x8D9A`\n* **Group:** PixelFormat"]
  pub const GL_BGR_INTEGER: GLenum = 0x8D9A;
  #[doc = "`GL_BLEND: GLenum = 0x0BE2`\n* **Groups:** TextureEnvMode, EnableCap, GetPName"]
  pub const GL_BLEND: GLenum = 0x0BE2;
  #[doc = "`GL_BLEND_COLOR: GLenum = 0x8005`\n* **Group:** GetPName"]
  pub const GL_BLEND_COLOR: GLenum = 0x8005;
  #[doc = "`GL_BLEND_DST: GLenum = 0x0BE0`\n* **Group:** GetPName"]
  pub const GL_BLEND_DST: GLenum = 0x0BE0;
  #[doc = "`GL_BLEND_DST_ALPHA: GLenum = 0x80CA`\n* **Group:** GetPName"]
  pub const GL_BLEND_DST_ALPHA: GLenum = 0x80CA;
  #[doc = "`GL_BLEND_DST_RGB: GLenum = 0x80C8`\n* **Group:** GetPName"]
  pub const GL_BLEND_DST_RGB: GLenum = 0x80C8;
  #[doc = "`GL_BLEND_EQUATION: GLenum = 0x8009`"]
  pub const GL_BLEND_EQUATION: GLenum = 0x8009;
  #[doc = "`GL_BLEND_EQUATION_ALPHA: GLenum = 0x883D`\n* **Group:** GetPName"]
  pub const GL_BLEND_EQUATION_ALPHA: GLenum = 0x883D;
  #[doc = "`GL_BLEND_EQUATION_RGB: GLenum = 0x8009`\n* **Group:** GetPName"]
  pub const GL_BLEND_EQUATION_RGB: GLenum = 0x8009;
  #[doc = "`GL_BLEND_SRC: GLenum = 0x0BE1`\n* **Group:** GetPName"]
  pub const GL_BLEND_SRC: GLenum = 0x0BE1;
  #[doc = "`GL_BLEND_SRC_ALPHA: GLenum = 0x80CB`\n* **Group:** GetPName"]
  pub const GL_BLEND_SRC_ALPHA: GLenum = 0x80CB;
  #[doc = "`GL_BLEND_SRC_RGB: GLenum = 0x80C9`\n* **Group:** GetPName"]
  pub const GL_BLEND_SRC_RGB: GLenum = 0x80C9;
  #[doc = "`GL_BLOCK_INDEX: GLenum = 0x92FD`\n* **Group:** ProgramResourceProperty"]
  pub const GL_BLOCK_INDEX: GLenum = 0x92FD;
  #[doc = "`GL_BLUE: GLenum = 0x1905`\n* **Groups:** TextureSwizzle, CombinerComponentUsageNV, PixelFormat"]
  pub const GL_BLUE: GLenum = 0x1905;
  #[doc = "`GL_BLUE_INTEGER: GLenum = 0x8D96`\n* **Group:** PixelFormat"]
  pub const GL_BLUE_INTEGER: GLenum = 0x8D96;
  #[doc = "`GL_BOOL: GLenum = 0x8B56`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_BOOL: GLenum = 0x8B56;
  #[doc = "`GL_BOOL_VEC2: GLenum = 0x8B57`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_BOOL_VEC2: GLenum = 0x8B57;
  #[doc = "`GL_BOOL_VEC3: GLenum = 0x8B58`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_BOOL_VEC3: GLenum = 0x8B58;
  #[doc = "`GL_BOOL_VEC4: GLenum = 0x8B59`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_BOOL_VEC4: GLenum = 0x8B59;
  #[doc = "`GL_BUFFER: GLenum = 0x82E0`\n* **Group:** ObjectIdentifier"]
  pub const GL_BUFFER: GLenum = 0x82E0;
  #[doc = "`GL_BUFFER_ACCESS: GLenum = 0x88BB`\n* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_ACCESS: GLenum = 0x88BB;
  #[doc = "`GL_BUFFER_ACCESS_FLAGS: GLenum = 0x911F`\n* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_ACCESS_FLAGS: GLenum = 0x911F;
  #[doc = "`GL_BUFFER_BINDING: GLenum = 0x9302`\n* **Group:** ProgramResourceProperty"]
  pub const GL_BUFFER_BINDING: GLenum = 0x9302;
  #[doc = "`GL_BUFFER_DATA_SIZE: GLenum = 0x9303`\n* **Group:** ProgramResourceProperty"]
  pub const GL_BUFFER_DATA_SIZE: GLenum = 0x9303;
  #[doc = "`GL_BUFFER_IMMUTABLE_STORAGE: GLenum = 0x821F`\n* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_IMMUTABLE_STORAGE: GLenum = 0x821F;
  #[doc = "`GL_BUFFER_MAPPED: GLenum = 0x88BC`\n* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_MAPPED: GLenum = 0x88BC;
  #[doc = "`GL_BUFFER_MAP_LENGTH: GLenum = 0x9120`\n* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_MAP_LENGTH: GLenum = 0x9120;
  #[doc = "`GL_BUFFER_MAP_OFFSET: GLenum = 0x9121`\n* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_MAP_OFFSET: GLenum = 0x9121;
  #[doc = "`GL_BUFFER_MAP_POINTER: GLenum = 0x88BD`\n* **Group:** BufferPointerNameARB"]
  pub const GL_BUFFER_MAP_POINTER: GLenum = 0x88BD;
  #[doc = "`GL_BUFFER_SIZE: GLenum = 0x8764`\n* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_SIZE: GLenum = 0x8764;
  #[doc = "`GL_BUFFER_STORAGE_FLAGS: GLenum = 0x8220`\n* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_STORAGE_FLAGS: GLenum = 0x8220;
  #[doc = "`GL_BUFFER_UPDATE_BARRIER_BIT: GLbitfield = 0x00000200`\n* **Group:** MemoryBarrierMask"]
  pub const GL_BUFFER_UPDATE_BARRIER_BIT: GLbitfield = 0x00000200;
  #[doc = "`GL_BUFFER_USAGE: GLenum = 0x8765`\n* **Groups:** VertexBufferObjectParameter, BufferPNameARB"]
  pub const GL_BUFFER_USAGE: GLenum = 0x8765;
  #[doc = "`GL_BUFFER_VARIABLE: GLenum = 0x92E5`\n* **Group:** ProgramInterface"]
  pub const GL_BUFFER_VARIABLE: GLenum = 0x92E5;
  #[doc = "`GL_BYTE: GLenum = 0x1400`\n* **Groups:** VertexAttribIType, WeightPointerTypeARB, TangentPointerTypeEXT, BinormalPointerTypeEXT, ColorPointerType, ListNameType, NormalPointerType, PixelType, VertexAttribType, VertexAttribPointerType"]
  pub const GL_BYTE: GLenum = 0x1400;
  #[doc = "`GL_CAVEAT_SUPPORT: GLenum = 0x82B8`"]
  pub const GL_CAVEAT_SUPPORT: GLenum = 0x82B8;
  #[doc = "`GL_CCW: GLenum = 0x0901`\n* **Group:** FrontFaceDirection"]
  pub const GL_CCW: GLenum = 0x0901;
  #[doc = "`GL_CLAMP_READ_COLOR: GLenum = 0x891C`\n* **Group:** ClampColorTargetARB"]
  pub const GL_CLAMP_READ_COLOR: GLenum = 0x891C;
  #[doc = "`GL_CLAMP_TO_BORDER: GLenum = 0x812D`\n* **Group:** TextureWrapMode"]
  pub const GL_CLAMP_TO_BORDER: GLenum = 0x812D;
  #[doc = "`GL_CLAMP_TO_EDGE: GLenum = 0x812F`\n* **Group:** TextureWrapMode"]
  pub const GL_CLAMP_TO_EDGE: GLenum = 0x812F;
  #[doc = "`GL_CLEAR: GLenum = 0x1500`\n* **Group:** LogicOp"]
  pub const GL_CLEAR: GLenum = 0x1500;
  #[doc = "`GL_CLEAR_BUFFER: GLenum = 0x82B4`\n* **Group:** InternalFormatPName"]
  pub const GL_CLEAR_BUFFER: GLenum = 0x82B4;
  #[doc = "`GL_CLEAR_TEXTURE: GLenum = 0x9365`\n* **Group:** InternalFormatPName"]
  pub const GL_CLEAR_TEXTURE: GLenum = 0x9365;
  #[doc = "`GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT: GLbitfield = 0x00004000`\n* **Group:** MemoryBarrierMask"]
  pub const GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT: GLbitfield = 0x00004000;
  #[doc = "`GL_CLIENT_STORAGE_BIT: GLbitfield = 0x0200`\n* **Group:** BufferStorageMask"]
  pub const GL_CLIENT_STORAGE_BIT: GLbitfield = 0x0200;
  #[doc = "`GL_CLIPPING_INPUT_PRIMITIVES: GLenum = 0x82F6`"]
  pub const GL_CLIPPING_INPUT_PRIMITIVES: GLenum = 0x82F6;
  #[doc = "`GL_CLIPPING_OUTPUT_PRIMITIVES: GLenum = 0x82F7`"]
  pub const GL_CLIPPING_OUTPUT_PRIMITIVES: GLenum = 0x82F7;
  #[doc = "`GL_CLIP_DEPTH_MODE: GLenum = 0x935D`"]
  pub const GL_CLIP_DEPTH_MODE: GLenum = 0x935D;
  #[doc = "`GL_CLIP_DISTANCE0: GLenum = 0x3000`\n* **Groups:** EnableCap, ClipPlaneName\n* **Alias Of:** `GL_CLIP_PLANE0`"]
  pub const GL_CLIP_DISTANCE0: GLenum = 0x3000;
  #[doc = "`GL_CLIP_DISTANCE1: GLenum = 0x3001`\n* **Groups:** EnableCap, ClipPlaneName\n* **Alias Of:** `GL_CLIP_PLANE1`"]
  pub const GL_CLIP_DISTANCE1: GLenum = 0x3001;
  #[doc = "`GL_CLIP_DISTANCE2: GLenum = 0x3002`\n* **Groups:** EnableCap, ClipPlaneName\n* **Alias Of:** `GL_CLIP_PLANE2`"]
  pub const GL_CLIP_DISTANCE2: GLenum = 0x3002;
  #[doc = "`GL_CLIP_DISTANCE3: GLenum = 0x3003`\n* **Groups:** EnableCap, ClipPlaneName\n* **Alias Of:** `GL_CLIP_PLANE3`"]
  pub const GL_CLIP_DISTANCE3: GLenum = 0x3003;
  #[doc = "`GL_CLIP_DISTANCE4: GLenum = 0x3004`\n* **Groups:** EnableCap, ClipPlaneName\n* **Alias Of:** `GL_CLIP_PLANE4`"]
  pub const GL_CLIP_DISTANCE4: GLenum = 0x3004;
  #[doc = "`GL_CLIP_DISTANCE5: GLenum = 0x3005`\n* **Groups:** EnableCap, ClipPlaneName\n* **Alias Of:** `GL_CLIP_PLANE5`"]
  pub const GL_CLIP_DISTANCE5: GLenum = 0x3005;
  #[doc = "`GL_CLIP_DISTANCE6: GLenum = 0x3006`\n* **Groups:** EnableCap, ClipPlaneName"]
  pub const GL_CLIP_DISTANCE6: GLenum = 0x3006;
  #[doc = "`GL_CLIP_DISTANCE7: GLenum = 0x3007`\n* **Groups:** EnableCap, ClipPlaneName"]
  pub const GL_CLIP_DISTANCE7: GLenum = 0x3007;
  #[doc = "`GL_CLIP_ORIGIN: GLenum = 0x935C`"]
  pub const GL_CLIP_ORIGIN: GLenum = 0x935C;
  #[doc = "`GL_COLOR: GLenum = 0x1800`\n* **Groups:** Buffer, PixelCopyType, InvalidateFramebufferAttachment"]
  pub const GL_COLOR: GLenum = 0x1800;
  #[doc = "`GL_COLOR_ATTACHMENT0: GLenum = 0x8CE0`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT0: GLenum = 0x8CE0;
  #[doc = "`GL_COLOR_ATTACHMENT1: GLenum = 0x8CE1`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT1: GLenum = 0x8CE1;
  #[doc = "`GL_COLOR_ATTACHMENT10: GLenum = 0x8CEA`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT10: GLenum = 0x8CEA;
  #[doc = "`GL_COLOR_ATTACHMENT11: GLenum = 0x8CEB`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT11: GLenum = 0x8CEB;
  #[doc = "`GL_COLOR_ATTACHMENT12: GLenum = 0x8CEC`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT12: GLenum = 0x8CEC;
  #[doc = "`GL_COLOR_ATTACHMENT13: GLenum = 0x8CED`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT13: GLenum = 0x8CED;
  #[doc = "`GL_COLOR_ATTACHMENT14: GLenum = 0x8CEE`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT14: GLenum = 0x8CEE;
  #[doc = "`GL_COLOR_ATTACHMENT15: GLenum = 0x8CEF`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT15: GLenum = 0x8CEF;
  #[doc = "`GL_COLOR_ATTACHMENT16: GLenum = 0x8CF0`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT16: GLenum = 0x8CF0;
  #[doc = "`GL_COLOR_ATTACHMENT17: GLenum = 0x8CF1`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT17: GLenum = 0x8CF1;
  #[doc = "`GL_COLOR_ATTACHMENT18: GLenum = 0x8CF2`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT18: GLenum = 0x8CF2;
  #[doc = "`GL_COLOR_ATTACHMENT19: GLenum = 0x8CF3`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT19: GLenum = 0x8CF3;
  #[doc = "`GL_COLOR_ATTACHMENT2: GLenum = 0x8CE2`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT2: GLenum = 0x8CE2;
  #[doc = "`GL_COLOR_ATTACHMENT20: GLenum = 0x8CF4`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT20: GLenum = 0x8CF4;
  #[doc = "`GL_COLOR_ATTACHMENT21: GLenum = 0x8CF5`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT21: GLenum = 0x8CF5;
  #[doc = "`GL_COLOR_ATTACHMENT22: GLenum = 0x8CF6`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT22: GLenum = 0x8CF6;
  #[doc = "`GL_COLOR_ATTACHMENT23: GLenum = 0x8CF7`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT23: GLenum = 0x8CF7;
  #[doc = "`GL_COLOR_ATTACHMENT24: GLenum = 0x8CF8`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT24: GLenum = 0x8CF8;
  #[doc = "`GL_COLOR_ATTACHMENT25: GLenum = 0x8CF9`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT25: GLenum = 0x8CF9;
  #[doc = "`GL_COLOR_ATTACHMENT26: GLenum = 0x8CFA`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT26: GLenum = 0x8CFA;
  #[doc = "`GL_COLOR_ATTACHMENT27: GLenum = 0x8CFB`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT27: GLenum = 0x8CFB;
  #[doc = "`GL_COLOR_ATTACHMENT28: GLenum = 0x8CFC`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT28: GLenum = 0x8CFC;
  #[doc = "`GL_COLOR_ATTACHMENT29: GLenum = 0x8CFD`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT29: GLenum = 0x8CFD;
  #[doc = "`GL_COLOR_ATTACHMENT3: GLenum = 0x8CE3`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT3: GLenum = 0x8CE3;
  #[doc = "`GL_COLOR_ATTACHMENT30: GLenum = 0x8CFE`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT30: GLenum = 0x8CFE;
  #[doc = "`GL_COLOR_ATTACHMENT31: GLenum = 0x8CFF`\n* **Groups:** ColorBuffer, DrawBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT31: GLenum = 0x8CFF;
  #[doc = "`GL_COLOR_ATTACHMENT4: GLenum = 0x8CE4`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT4: GLenum = 0x8CE4;
  #[doc = "`GL_COLOR_ATTACHMENT5: GLenum = 0x8CE5`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT5: GLenum = 0x8CE5;
  #[doc = "`GL_COLOR_ATTACHMENT6: GLenum = 0x8CE6`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT6: GLenum = 0x8CE6;
  #[doc = "`GL_COLOR_ATTACHMENT7: GLenum = 0x8CE7`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT7: GLenum = 0x8CE7;
  #[doc = "`GL_COLOR_ATTACHMENT8: GLenum = 0x8CE8`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT8: GLenum = 0x8CE8;
  #[doc = "`GL_COLOR_ATTACHMENT9: GLenum = 0x8CE9`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode, FramebufferAttachment, InvalidateFramebufferAttachment"]
  pub const GL_COLOR_ATTACHMENT9: GLenum = 0x8CE9;
  #[doc = "`GL_COLOR_BUFFER_BIT: GLbitfield = 0x00004000`\n* **Groups:** ClearBufferMask, AttribMask"]
  pub const GL_COLOR_BUFFER_BIT: GLbitfield = 0x00004000;
  #[doc = "`GL_COLOR_CLEAR_VALUE: GLenum = 0x0C22`\n* **Group:** GetPName"]
  pub const GL_COLOR_CLEAR_VALUE: GLenum = 0x0C22;
  #[doc = "`GL_COLOR_COMPONENTS: GLenum = 0x8283`\n* **Group:** InternalFormatPName"]
  pub const GL_COLOR_COMPONENTS: GLenum = 0x8283;
  #[doc = "`GL_COLOR_ENCODING: GLenum = 0x8296`\n* **Group:** InternalFormatPName"]
  pub const GL_COLOR_ENCODING: GLenum = 0x8296;
  #[doc = "`GL_COLOR_LOGIC_OP: GLenum = 0x0BF2`\n* **Groups:** GetPName, EnableCap"]
  pub const GL_COLOR_LOGIC_OP: GLenum = 0x0BF2;
  #[doc = "`GL_COLOR_RENDERABLE: GLenum = 0x8286`\n* **Group:** InternalFormatPName"]
  pub const GL_COLOR_RENDERABLE: GLenum = 0x8286;
  #[doc = "`GL_COLOR_WRITEMASK: GLenum = 0x0C23`\n* **Group:** GetPName"]
  pub const GL_COLOR_WRITEMASK: GLenum = 0x0C23;
  #[doc = "`GL_COMMAND_BARRIER_BIT: GLbitfield = 0x00000040`\n* **Group:** MemoryBarrierMask"]
  pub const GL_COMMAND_BARRIER_BIT: GLbitfield = 0x00000040;
  #[doc = "`GL_COMPARE_REF_TO_TEXTURE: GLenum = 0x884E`\n* **Group:** TextureCompareMode\n* **Alias Of:** `GL_COMPARE_R_TO_TEXTURE`"]
  pub const GL_COMPARE_REF_TO_TEXTURE: GLenum = 0x884E;
  #[doc = "`GL_COMPATIBLE_SUBROUTINES: GLenum = 0x8E4B`\n* **Groups:** ProgramResourceProperty, SubroutineParameterName"]
  pub const GL_COMPATIBLE_SUBROUTINES: GLenum = 0x8E4B;
  #[doc = "`GL_COMPILE_STATUS: GLenum = 0x8B81`\n* **Group:** ShaderParameterName"]
  pub const GL_COMPILE_STATUS: GLenum = 0x8B81;
  #[doc = "`GL_COMPRESSED_R11_EAC: GLenum = 0x9270`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_R11_EAC: GLenum = 0x9270;
  #[doc = "`GL_COMPRESSED_RED: GLenum = 0x8225`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RED: GLenum = 0x8225;
  #[doc = "`GL_COMPRESSED_RED_RGTC1: GLenum = 0x8DBB`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RED_RGTC1: GLenum = 0x8DBB;
  #[doc = "`GL_COMPRESSED_RG: GLenum = 0x8226`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RG: GLenum = 0x8226;
  #[doc = "`GL_COMPRESSED_RG11_EAC: GLenum = 0x9272`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RG11_EAC: GLenum = 0x9272;
  #[doc = "`GL_COMPRESSED_RGB: GLenum = 0x84ED`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RGB: GLenum = 0x84ED;
  #[doc = "`GL_COMPRESSED_RGB8_ETC2: GLenum = 0x9274`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RGB8_ETC2: GLenum = 0x9274;
  #[doc = "`GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum = 0x9276`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum = 0x9276;
  #[doc = "`GL_COMPRESSED_RGBA: GLenum = 0x84EE`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RGBA: GLenum = 0x84EE;
  #[doc = "`GL_COMPRESSED_RGBA8_ETC2_EAC: GLenum = 0x9278`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RGBA8_ETC2_EAC: GLenum = 0x9278;
  #[doc = "`GL_COMPRESSED_RGBA_BPTC_UNORM: GLenum = 0x8E8C`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RGBA_BPTC_UNORM: GLenum = 0x8E8C;
  #[doc = "`GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: GLenum = 0x8E8E`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: GLenum = 0x8E8E;
  #[doc = "`GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: GLenum = 0x8E8F`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: GLenum = 0x8E8F;
  #[doc = "`GL_COMPRESSED_RG_RGTC2: GLenum = 0x8DBD`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_RG_RGTC2: GLenum = 0x8DBD;
  #[doc = "`GL_COMPRESSED_SIGNED_R11_EAC: GLenum = 0x9271`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SIGNED_R11_EAC: GLenum = 0x9271;
  #[doc = "`GL_COMPRESSED_SIGNED_RED_RGTC1: GLenum = 0x8DBC`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SIGNED_RED_RGTC1: GLenum = 0x8DBC;
  #[doc = "`GL_COMPRESSED_SIGNED_RG11_EAC: GLenum = 0x9273`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SIGNED_RG11_EAC: GLenum = 0x9273;
  #[doc = "`GL_COMPRESSED_SIGNED_RG_RGTC2: GLenum = 0x8DBE`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SIGNED_RG_RGTC2: GLenum = 0x8DBE;
  #[doc = "`GL_COMPRESSED_SRGB: GLenum = 0x8C48`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SRGB: GLenum = 0x8C48;
  #[doc = "`GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: GLenum = 0x9279`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: GLenum = 0x9279;
  #[doc = "`GL_COMPRESSED_SRGB8_ETC2: GLenum = 0x9275`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SRGB8_ETC2: GLenum = 0x9275;
  #[doc = "`GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum = 0x9277`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum = 0x9277;
  #[doc = "`GL_COMPRESSED_SRGB_ALPHA: GLenum = 0x8C49`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SRGB_ALPHA: GLenum = 0x8C49;
  #[doc = "`GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM: GLenum = 0x8E8D`\n* **Group:** InternalFormat"]
  pub const GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM: GLenum = 0x8E8D;
  #[doc = "`GL_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A3`\n* **Group:** GetPName"]
  pub const GL_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A3;
  #[doc = "`GL_COMPUTE_SHADER: GLenum = 0x91B9`\n* **Group:** ShaderType"]
  pub const GL_COMPUTE_SHADER: GLenum = 0x91B9;
  #[doc = "`GL_COMPUTE_SHADER_BIT: GLbitfield = 0x00000020`\n* **Group:** UseProgramStageMask"]
  pub const GL_COMPUTE_SHADER_BIT: GLbitfield = 0x00000020;
  #[doc = "`GL_COMPUTE_SHADER_INVOCATIONS: GLenum = 0x82F5`"]
  pub const GL_COMPUTE_SHADER_INVOCATIONS: GLenum = 0x82F5;
  #[doc = "`GL_COMPUTE_SUBROUTINE: GLenum = 0x92ED`\n* **Group:** ProgramInterface"]
  pub const GL_COMPUTE_SUBROUTINE: GLenum = 0x92ED;
  #[doc = "`GL_COMPUTE_SUBROUTINE_UNIFORM: GLenum = 0x92F3`\n* **Group:** ProgramInterface"]
  pub const GL_COMPUTE_SUBROUTINE_UNIFORM: GLenum = 0x92F3;
  #[doc = "`GL_COMPUTE_TEXTURE: GLenum = 0x82A0`\n* **Group:** InternalFormatPName"]
  pub const GL_COMPUTE_TEXTURE: GLenum = 0x82A0;
  #[doc = "`GL_COMPUTE_WORK_GROUP_SIZE: GLenum = 0x8267`\n* **Group:** ProgramPropertyARB"]
  pub const GL_COMPUTE_WORK_GROUP_SIZE: GLenum = 0x8267;
  #[doc = "`GL_CONDITION_SATISFIED: GLenum = 0x911C`\n* **Group:** SyncStatus"]
  pub const GL_CONDITION_SATISFIED: GLenum = 0x911C;
  #[doc = "`GL_CONSTANT_ALPHA: GLenum = 0x8003`\n* **Group:** BlendingFactor"]
  pub const GL_CONSTANT_ALPHA: GLenum = 0x8003;
  #[doc = "`GL_CONSTANT_COLOR: GLenum = 0x8001`\n* **Group:** BlendingFactor"]
  pub const GL_CONSTANT_COLOR: GLenum = 0x8001;
  #[doc = "`GL_CONTEXT_COMPATIBILITY_PROFILE_BIT: GLbitfield = 0x00000002`\n* **Group:** ContextProfileMask"]
  pub const GL_CONTEXT_COMPATIBILITY_PROFILE_BIT: GLbitfield = 0x00000002;
  #[doc = "`GL_CONTEXT_CORE_PROFILE_BIT: GLbitfield = 0x00000001`\n* **Group:** ContextProfileMask"]
  pub const GL_CONTEXT_CORE_PROFILE_BIT: GLbitfield = 0x00000001;
  #[doc = "`GL_CONTEXT_FLAGS: GLenum = 0x821E`\n* **Group:** GetPName"]
  pub const GL_CONTEXT_FLAGS: GLenum = 0x821E;
  #[doc = "`GL_CONTEXT_FLAG_DEBUG_BIT: GLbitfield = 0x00000002`\n* **Group:** ContextFlagMask"]
  pub const GL_CONTEXT_FLAG_DEBUG_BIT: GLbitfield = 0x00000002;
  #[doc = "`GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: GLbitfield = 0x00000001`\n* **Group:** ContextFlagMask"]
  pub const GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: GLbitfield = 0x00000001;
  #[doc = "`GL_CONTEXT_FLAG_NO_ERROR_BIT: GLbitfield = 0x00000008`\n* **Group:** ContextFlagMask"]
  pub const GL_CONTEXT_FLAG_NO_ERROR_BIT: GLbitfield = 0x00000008;
  #[doc = "`GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT: GLbitfield = 0x00000004`\n* **Group:** ContextFlagMask"]
  pub const GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT: GLbitfield = 0x00000004;
  #[doc = "`GL_CONTEXT_LOST: GLenum = 0x0507`"]
  pub const GL_CONTEXT_LOST: GLenum = 0x0507;
  #[doc = "`GL_CONTEXT_PROFILE_MASK: GLenum = 0x9126`\n* **Group:** GetPName"]
  pub const GL_CONTEXT_PROFILE_MASK: GLenum = 0x9126;
  #[doc = "`GL_CONTEXT_RELEASE_BEHAVIOR: GLenum = 0x82FB`"]
  pub const GL_CONTEXT_RELEASE_BEHAVIOR: GLenum = 0x82FB;
  #[doc = "`GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: GLenum = 0x82FC`"]
  pub const GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: GLenum = 0x82FC;
  #[doc = "`GL_COPY: GLenum = 0x1503`\n* **Group:** LogicOp"]
  pub const GL_COPY: GLenum = 0x1503;
  #[doc = "`GL_COPY_INVERTED: GLenum = 0x150C`\n* **Group:** LogicOp"]
  pub const GL_COPY_INVERTED: GLenum = 0x150C;
  #[doc = "`GL_COPY_READ_BUFFER: GLenum = 0x8F36`\n* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_COPY_READ_BUFFER: GLenum = 0x8F36;
  #[doc = "`GL_COPY_READ_BUFFER_BINDING: GLenum = 0x8F36`\n* **Alias Of:** `GL_COPY_READ_BUFFER`"]
  pub const GL_COPY_READ_BUFFER_BINDING: GLenum = 0x8F36;
  #[doc = "`GL_COPY_WRITE_BUFFER: GLenum = 0x8F37`\n* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_COPY_WRITE_BUFFER: GLenum = 0x8F37;
  #[doc = "`GL_COPY_WRITE_BUFFER_BINDING: GLenum = 0x8F37`\n* **Alias Of:** `GL_COPY_WRITE_BUFFER`"]
  pub const GL_COPY_WRITE_BUFFER_BINDING: GLenum = 0x8F37;
  #[doc = "`GL_CULL_FACE: GLenum = 0x0B44`\n* **Groups:** GetPName, EnableCap"]
  pub const GL_CULL_FACE: GLenum = 0x0B44;
  #[doc = "`GL_CULL_FACE_MODE: GLenum = 0x0B45`\n* **Group:** GetPName"]
  pub const GL_CULL_FACE_MODE: GLenum = 0x0B45;
  #[doc = "`GL_CURRENT_PROGRAM: GLenum = 0x8B8D`\n* **Group:** GetPName"]
  pub const GL_CURRENT_PROGRAM: GLenum = 0x8B8D;
  #[doc = "`GL_CURRENT_QUERY: GLenum = 0x8865`\n* **Group:** QueryParameterName"]
  pub const GL_CURRENT_QUERY: GLenum = 0x8865;
  #[doc = "`GL_CURRENT_VERTEX_ATTRIB: GLenum = 0x8626`\n* **Groups:** VertexAttribEnum, VertexAttribPropertyARB"]
  pub const GL_CURRENT_VERTEX_ATTRIB: GLenum = 0x8626;
  #[doc = "`GL_CW: GLenum = 0x0900`\n* **Group:** FrontFaceDirection"]
  pub const GL_CW: GLenum = 0x0900;
  #[doc = "`GL_DEBUG_CALLBACK_FUNCTION: GLenum = 0x8244`\n* **Group:** GetPointervPName"]
  pub const GL_DEBUG_CALLBACK_FUNCTION: GLenum = 0x8244;
  #[doc = "`GL_DEBUG_CALLBACK_USER_PARAM: GLenum = 0x8245`\n* **Group:** GetPointervPName"]
  pub const GL_DEBUG_CALLBACK_USER_PARAM: GLenum = 0x8245;
  #[doc = "`GL_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826D`\n* **Group:** GetPName"]
  pub const GL_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826D;
  #[doc = "`GL_DEBUG_LOGGED_MESSAGES: GLenum = 0x9145`"]
  pub const GL_DEBUG_LOGGED_MESSAGES: GLenum = 0x9145;
  #[doc = "`GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: GLenum = 0x8243`"]
  pub const GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: GLenum = 0x8243;
  #[doc = "`GL_DEBUG_OUTPUT: GLenum = 0x92E0`\n* **Group:** EnableCap"]
  pub const GL_DEBUG_OUTPUT: GLenum = 0x92E0;
  #[doc = "`GL_DEBUG_OUTPUT_SYNCHRONOUS: GLenum = 0x8242`\n* **Group:** EnableCap"]
  pub const GL_DEBUG_OUTPUT_SYNCHRONOUS: GLenum = 0x8242;
  #[doc = "`GL_DEBUG_SEVERITY_HIGH: GLenum = 0x9146`\n* **Group:** DebugSeverity"]
  pub const GL_DEBUG_SEVERITY_HIGH: GLenum = 0x9146;
  #[doc = "`GL_DEBUG_SEVERITY_LOW: GLenum = 0x9148`\n* **Group:** DebugSeverity"]
  pub const GL_DEBUG_SEVERITY_LOW: GLenum = 0x9148;
  #[doc = "`GL_DEBUG_SEVERITY_MEDIUM: GLenum = 0x9147`\n* **Group:** DebugSeverity"]
  pub const GL_DEBUG_SEVERITY_MEDIUM: GLenum = 0x9147;
  #[doc = "`GL_DEBUG_SEVERITY_NOTIFICATION: GLenum = 0x826B`\n* **Group:** DebugSeverity"]
  pub const GL_DEBUG_SEVERITY_NOTIFICATION: GLenum = 0x826B;
  #[doc = "`GL_DEBUG_SOURCE_API: GLenum = 0x8246`\n* **Group:** DebugSource"]
  pub const GL_DEBUG_SOURCE_API: GLenum = 0x8246;
  #[doc = "`GL_DEBUG_SOURCE_APPLICATION: GLenum = 0x824A`\n* **Group:** DebugSource"]
  pub const GL_DEBUG_SOURCE_APPLICATION: GLenum = 0x824A;
  #[doc = "`GL_DEBUG_SOURCE_OTHER: GLenum = 0x824B`\n* **Group:** DebugSource"]
  pub const GL_DEBUG_SOURCE_OTHER: GLenum = 0x824B;
  #[doc = "`GL_DEBUG_SOURCE_SHADER_COMPILER: GLenum = 0x8248`\n* **Group:** DebugSource"]
  pub const GL_DEBUG_SOURCE_SHADER_COMPILER: GLenum = 0x8248;
  #[doc = "`GL_DEBUG_SOURCE_THIRD_PARTY: GLenum = 0x8249`\n* **Group:** DebugSource"]
  pub const GL_DEBUG_SOURCE_THIRD_PARTY: GLenum = 0x8249;
  #[doc = "`GL_DEBUG_SOURCE_WINDOW_SYSTEM: GLenum = 0x8247`\n* **Group:** DebugSource"]
  pub const GL_DEBUG_SOURCE_WINDOW_SYSTEM: GLenum = 0x8247;
  #[doc = "`GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: GLenum = 0x824D`\n* **Group:** DebugType"]
  pub const GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: GLenum = 0x824D;
  #[doc = "`GL_DEBUG_TYPE_ERROR: GLenum = 0x824C`\n* **Group:** DebugType"]
  pub const GL_DEBUG_TYPE_ERROR: GLenum = 0x824C;
  #[doc = "`GL_DEBUG_TYPE_MARKER: GLenum = 0x8268`\n* **Group:** DebugType"]
  pub const GL_DEBUG_TYPE_MARKER: GLenum = 0x8268;
  #[doc = "`GL_DEBUG_TYPE_OTHER: GLenum = 0x8251`\n* **Group:** DebugType"]
  pub const GL_DEBUG_TYPE_OTHER: GLenum = 0x8251;
  #[doc = "`GL_DEBUG_TYPE_PERFORMANCE: GLenum = 0x8250`\n* **Group:** DebugType"]
  pub const GL_DEBUG_TYPE_PERFORMANCE: GLenum = 0x8250;
  #[doc = "`GL_DEBUG_TYPE_POP_GROUP: GLenum = 0x826A`\n* **Group:** DebugType"]
  pub const GL_DEBUG_TYPE_POP_GROUP: GLenum = 0x826A;
  #[doc = "`GL_DEBUG_TYPE_PORTABILITY: GLenum = 0x824F`\n* **Group:** DebugType"]
  pub const GL_DEBUG_TYPE_PORTABILITY: GLenum = 0x824F;
  #[doc = "`GL_DEBUG_TYPE_PUSH_GROUP: GLenum = 0x8269`\n* **Group:** DebugType"]
  pub const GL_DEBUG_TYPE_PUSH_GROUP: GLenum = 0x8269;
  #[doc = "`GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: GLenum = 0x824E`\n* **Group:** DebugType"]
  pub const GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: GLenum = 0x824E;
  #[doc = "`GL_DECR: GLenum = 0x1E03`\n* **Group:** StencilOp"]
  pub const GL_DECR: GLenum = 0x1E03;
  #[doc = "`GL_DECR_WRAP: GLenum = 0x8508`\n* **Group:** StencilOp"]
  pub const GL_DECR_WRAP: GLenum = 0x8508;
  #[doc = "`GL_DELETE_STATUS: GLenum = 0x8B80`\n* **Groups:** ProgramPropertyARB, ShaderParameterName"]
  pub const GL_DELETE_STATUS: GLenum = 0x8B80;
  #[doc = "`GL_DEPTH: GLenum = 0x1801`\n* **Groups:** Buffer, PixelCopyType, InvalidateFramebufferAttachment"]
  pub const GL_DEPTH: GLenum = 0x1801;
  #[doc = "`GL_DEPTH24_STENCIL8: GLenum = 0x88F0`\n* **Group:** InternalFormat"]
  pub const GL_DEPTH24_STENCIL8: GLenum = 0x88F0;
  #[doc = "`GL_DEPTH32F_STENCIL8: GLenum = 0x8CAD`\n* **Group:** InternalFormat"]
  pub const GL_DEPTH32F_STENCIL8: GLenum = 0x8CAD;
  #[doc = "`GL_DEPTH_ATTACHMENT: GLenum = 0x8D00`\n* **Group:** InvalidateFramebufferAttachment"]
  pub const GL_DEPTH_ATTACHMENT: GLenum = 0x8D00;
  #[doc = "`GL_DEPTH_BUFFER_BIT: GLbitfield = 0x00000100`\n* **Groups:** ClearBufferMask, AttribMask"]
  pub const GL_DEPTH_BUFFER_BIT: GLbitfield = 0x00000100;
  #[doc = "`GL_DEPTH_CLAMP: GLenum = 0x864F`\n* **Group:** EnableCap"]
  pub const GL_DEPTH_CLAMP: GLenum = 0x864F;
  #[doc = "`GL_DEPTH_CLEAR_VALUE: GLenum = 0x0B73`\n* **Group:** GetPName"]
  pub const GL_DEPTH_CLEAR_VALUE: GLenum = 0x0B73;
  #[doc = "`GL_DEPTH_COMPONENT: GLenum = 0x1902`\n* **Groups:** InternalFormat, PixelFormat"]
  pub const GL_DEPTH_COMPONENT: GLenum = 0x1902;
  #[doc = "`GL_DEPTH_COMPONENT16: GLenum = 0x81A5`\n* **Group:** InternalFormat"]
  pub const GL_DEPTH_COMPONENT16: GLenum = 0x81A5;
  #[doc = "`GL_DEPTH_COMPONENT24: GLenum = 0x81A6`"]
  pub const GL_DEPTH_COMPONENT24: GLenum = 0x81A6;
  #[doc = "`GL_DEPTH_COMPONENT32: GLenum = 0x81A7`"]
  pub const GL_DEPTH_COMPONENT32: GLenum = 0x81A7;
  #[doc = "`GL_DEPTH_COMPONENT32F: GLenum = 0x8CAC`\n* **Group:** InternalFormat"]
  pub const GL_DEPTH_COMPONENT32F: GLenum = 0x8CAC;
  #[doc = "`GL_DEPTH_COMPONENTS: GLenum = 0x8284`"]
  pub const GL_DEPTH_COMPONENTS: GLenum = 0x8284;
  #[doc = "`GL_DEPTH_FUNC: GLenum = 0x0B74`\n* **Group:** GetPName"]
  pub const GL_DEPTH_FUNC: GLenum = 0x0B74;
  #[doc = "`GL_DEPTH_RANGE: GLenum = 0x0B70`\n* **Group:** GetPName"]
  pub const GL_DEPTH_RANGE: GLenum = 0x0B70;
  #[doc = "`GL_DEPTH_RENDERABLE: GLenum = 0x8287`\n* **Group:** InternalFormatPName"]
  pub const GL_DEPTH_RENDERABLE: GLenum = 0x8287;
  #[doc = "`GL_DEPTH_STENCIL: GLenum = 0x84F9`\n* **Groups:** InternalFormat, PixelFormat"]
  pub const GL_DEPTH_STENCIL: GLenum = 0x84F9;
  #[doc = "`GL_DEPTH_STENCIL_ATTACHMENT: GLenum = 0x821A`\n* **Group:** InvalidateFramebufferAttachment"]
  pub const GL_DEPTH_STENCIL_ATTACHMENT: GLenum = 0x821A;
  #[doc = "`GL_DEPTH_STENCIL_TEXTURE_MODE: GLenum = 0x90EA`\n* **Group:** TextureParameterName"]
  pub const GL_DEPTH_STENCIL_TEXTURE_MODE: GLenum = 0x90EA;
  #[doc = "`GL_DEPTH_TEST: GLenum = 0x0B71`\n* **Groups:** GetPName, EnableCap"]
  pub const GL_DEPTH_TEST: GLenum = 0x0B71;
  #[doc = "`GL_DEPTH_WRITEMASK: GLenum = 0x0B72`\n* **Group:** GetPName"]
  pub const GL_DEPTH_WRITEMASK: GLenum = 0x0B72;
  #[doc = "`GL_DISPATCH_INDIRECT_BUFFER: GLenum = 0x90EE`\n* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_DISPATCH_INDIRECT_BUFFER: GLenum = 0x90EE;
  #[doc = "`GL_DISPATCH_INDIRECT_BUFFER_BINDING: GLenum = 0x90EF`\n* **Group:** GetPName"]
  pub const GL_DISPATCH_INDIRECT_BUFFER_BINDING: GLenum = 0x90EF;
  #[doc = "`GL_DITHER: GLenum = 0x0BD0`\n* **Groups:** GetPName, EnableCap"]
  pub const GL_DITHER: GLenum = 0x0BD0;
  #[doc = "`GL_DONT_CARE: GLenum = 0x1100`\n* **Groups:** DebugSeverity, HintMode, DebugSource, DebugType"]
  pub const GL_DONT_CARE: GLenum = 0x1100;
  #[doc = "`GL_DOUBLE: GLenum = 0x140A`\n* **Groups:** VertexAttribLType, MapTypeNV, SecondaryColorPointerTypeIBM, WeightPointerTypeARB, TangentPointerTypeEXT, BinormalPointerTypeEXT, FogCoordinatePointerType, FogPointerTypeEXT, FogPointerTypeIBM, IndexPointerType, NormalPointerType, TexCoordPointerType, VertexPointerType, VertexAttribType, AttributeType, UniformType, VertexAttribPointerType, GlslTypeToken"]
  pub const GL_DOUBLE: GLenum = 0x140A;
  #[doc = "`GL_DOUBLEBUFFER: GLenum = 0x0C32`\n* **Groups:** GetFramebufferParameter, GetPName"]
  pub const GL_DOUBLEBUFFER: GLenum = 0x0C32;
  #[doc = "`GL_DOUBLE_MAT2: GLenum = 0x8F46`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_DOUBLE_MAT2: GLenum = 0x8F46;
  #[doc = "`GL_DOUBLE_MAT2x3: GLenum = 0x8F49`\n* **Groups:** UniformType, AttributeType"]
  pub const GL_DOUBLE_MAT2x3: GLenum = 0x8F49;
  #[doc = "`GL_DOUBLE_MAT2x4: GLenum = 0x8F4A`\n* **Groups:** UniformType, AttributeType"]
  pub const GL_DOUBLE_MAT2x4: GLenum = 0x8F4A;
  #[doc = "`GL_DOUBLE_MAT3: GLenum = 0x8F47`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_DOUBLE_MAT3: GLenum = 0x8F47;
  #[doc = "`GL_DOUBLE_MAT3x2: GLenum = 0x8F4B`\n* **Groups:** UniformType, AttributeType"]
  pub const GL_DOUBLE_MAT3x2: GLenum = 0x8F4B;
  #[doc = "`GL_DOUBLE_MAT3x4: GLenum = 0x8F4C`\n* **Groups:** UniformType, AttributeType"]
  pub const GL_DOUBLE_MAT3x4: GLenum = 0x8F4C;
  #[doc = "`GL_DOUBLE_MAT4: GLenum = 0x8F48`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_DOUBLE_MAT4: GLenum = 0x8F48;
  #[doc = "`GL_DOUBLE_MAT4x2: GLenum = 0x8F4D`\n* **Groups:** UniformType, AttributeType"]
  pub const GL_DOUBLE_MAT4x2: GLenum = 0x8F4D;
  #[doc = "`GL_DOUBLE_MAT4x3: GLenum = 0x8F4E`\n* **Groups:** UniformType, AttributeType"]
  pub const GL_DOUBLE_MAT4x3: GLenum = 0x8F4E;
  #[doc = "`GL_DOUBLE_VEC2: GLenum = 0x8FFC`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_DOUBLE_VEC2: GLenum = 0x8FFC;
  #[doc = "`GL_DOUBLE_VEC3: GLenum = 0x8FFD`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_DOUBLE_VEC3: GLenum = 0x8FFD;
  #[doc = "`GL_DOUBLE_VEC4: GLenum = 0x8FFE`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_DOUBLE_VEC4: GLenum = 0x8FFE;
  #[doc = "`GL_DRAW_BUFFER: GLenum = 0x0C01`\n* **Group:** GetPName"]
  pub const GL_DRAW_BUFFER: GLenum = 0x0C01;
  #[doc = "`GL_DRAW_BUFFER0: GLenum = 0x8825`"]
  pub const GL_DRAW_BUFFER0: GLenum = 0x8825;
  #[doc = "`GL_DRAW_BUFFER1: GLenum = 0x8826`"]
  pub const GL_DRAW_BUFFER1: GLenum = 0x8826;
  #[doc = "`GL_DRAW_BUFFER10: GLenum = 0x882F`"]
  pub const GL_DRAW_BUFFER10: GLenum = 0x882F;
  #[doc = "`GL_DRAW_BUFFER11: GLenum = 0x8830`"]
  pub const GL_DRAW_BUFFER11: GLenum = 0x8830;
  #[doc = "`GL_DRAW_BUFFER12: GLenum = 0x8831`"]
  pub const GL_DRAW_BUFFER12: GLenum = 0x8831;
  #[doc = "`GL_DRAW_BUFFER13: GLenum = 0x8832`"]
  pub const GL_DRAW_BUFFER13: GLenum = 0x8832;
  #[doc = "`GL_DRAW_BUFFER14: GLenum = 0x8833`"]
  pub const GL_DRAW_BUFFER14: GLenum = 0x8833;
  #[doc = "`GL_DRAW_BUFFER15: GLenum = 0x8834`"]
  pub const GL_DRAW_BUFFER15: GLenum = 0x8834;
  #[doc = "`GL_DRAW_BUFFER2: GLenum = 0x8827`"]
  pub const GL_DRAW_BUFFER2: GLenum = 0x8827;
  #[doc = "`GL_DRAW_BUFFER3: GLenum = 0x8828`"]
  pub const GL_DRAW_BUFFER3: GLenum = 0x8828;
  #[doc = "`GL_DRAW_BUFFER4: GLenum = 0x8829`"]
  pub const GL_DRAW_BUFFER4: GLenum = 0x8829;
  #[doc = "`GL_DRAW_BUFFER5: GLenum = 0x882A`"]
  pub const GL_DRAW_BUFFER5: GLenum = 0x882A;
  #[doc = "`GL_DRAW_BUFFER6: GLenum = 0x882B`"]
  pub const GL_DRAW_BUFFER6: GLenum = 0x882B;
  #[doc = "`GL_DRAW_BUFFER7: GLenum = 0x882C`"]
  pub const GL_DRAW_BUFFER7: GLenum = 0x882C;
  #[doc = "`GL_DRAW_BUFFER8: GLenum = 0x882D`"]
  pub const GL_DRAW_BUFFER8: GLenum = 0x882D;
  #[doc = "`GL_DRAW_BUFFER9: GLenum = 0x882E`"]
  pub const GL_DRAW_BUFFER9: GLenum = 0x882E;
  #[doc = "`GL_DRAW_FRAMEBUFFER: GLenum = 0x8CA9`\n* **Groups:** CheckFramebufferStatusTarget, FramebufferTarget"]
  pub const GL_DRAW_FRAMEBUFFER: GLenum = 0x8CA9;
  #[doc = "`GL_DRAW_FRAMEBUFFER_BINDING: GLenum = 0x8CA6`\n* **Group:** GetPName"]
  pub const GL_DRAW_FRAMEBUFFER_BINDING: GLenum = 0x8CA6;
  #[doc = "`GL_DRAW_INDIRECT_BUFFER: GLenum = 0x8F3F`\n* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_DRAW_INDIRECT_BUFFER: GLenum = 0x8F3F;
  #[doc = "`GL_DRAW_INDIRECT_BUFFER_BINDING: GLenum = 0x8F43`"]
  pub const GL_DRAW_INDIRECT_BUFFER_BINDING: GLenum = 0x8F43;
  #[doc = "`GL_DST_ALPHA: GLenum = 0x0304`\n* **Group:** BlendingFactor"]
  pub const GL_DST_ALPHA: GLenum = 0x0304;
  #[doc = "`GL_DST_COLOR: GLenum = 0x0306`\n* **Group:** BlendingFactor"]
  pub const GL_DST_COLOR: GLenum = 0x0306;
  #[doc = "`GL_DYNAMIC_COPY: GLenum = 0x88EA`\n* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_DYNAMIC_COPY: GLenum = 0x88EA;
  #[doc = "`GL_DYNAMIC_DRAW: GLenum = 0x88E8`\n* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_DYNAMIC_DRAW: GLenum = 0x88E8;
  #[doc = "`GL_DYNAMIC_READ: GLenum = 0x88E9`\n* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_DYNAMIC_READ: GLenum = 0x88E9;
  #[doc = "`GL_DYNAMIC_STORAGE_BIT: GLbitfield = 0x0100`\n* **Group:** BufferStorageMask"]
  pub const GL_DYNAMIC_STORAGE_BIT: GLbitfield = 0x0100;
  #[doc = "`GL_ELEMENT_ARRAY_BARRIER_BIT: GLbitfield = 0x00000002`\n* **Group:** MemoryBarrierMask"]
  pub const GL_ELEMENT_ARRAY_BARRIER_BIT: GLbitfield = 0x00000002;
  #[doc = "`GL_ELEMENT_ARRAY_BUFFER: GLenum = 0x8893`\n* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_ELEMENT_ARRAY_BUFFER: GLenum = 0x8893;
  #[doc = "`GL_ELEMENT_ARRAY_BUFFER_BINDING: GLenum = 0x8895`\n* **Group:** GetPName"]
  pub const GL_ELEMENT_ARRAY_BUFFER_BINDING: GLenum = 0x8895;
  #[doc = "`GL_EQUAL: GLenum = 0x0202`\n* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_EQUAL: GLenum = 0x0202;
  #[doc = "`GL_EQUIV: GLenum = 0x1509`\n* **Group:** LogicOp"]
  pub const GL_EQUIV: GLenum = 0x1509;
  #[doc = "`GL_EXTENSIONS: GLenum = 0x1F03`\n* **Group:** StringName"]
  pub const GL_EXTENSIONS: GLenum = 0x1F03;
  #[doc = "`GL_FALSE: GLenum = 0`\n* **Groups:** Boolean, VertexShaderWriteMaskEXT, ClampColorModeARB"]
  pub const GL_FALSE: GLenum = 0;
  #[doc = "`GL_FASTEST: GLenum = 0x1101`\n* **Group:** HintMode"]
  pub const GL_FASTEST: GLenum = 0x1101;
  #[doc = "`GL_FILL: GLenum = 0x1B02`\n* **Groups:** PolygonMode, MeshMode2"]
  pub const GL_FILL: GLenum = 0x1B02;
  #[doc = "`GL_FILTER: GLenum = 0x829A`\n* **Group:** InternalFormatPName"]
  pub const GL_FILTER: GLenum = 0x829A;
  #[doc = "`GL_FIRST_VERTEX_CONVENTION: GLenum = 0x8E4D`\n* **Group:** VertexProvokingMode"]
  pub const GL_FIRST_VERTEX_CONVENTION: GLenum = 0x8E4D;
  #[doc = "`GL_FIXED: GLenum = 0x140C`\n* **Groups:** VertexAttribPointerType, VertexAttribType"]
  pub const GL_FIXED: GLenum = 0x140C;
  #[doc = "`GL_FIXED_ONLY: GLenum = 0x891D`\n* **Group:** ClampColorModeARB"]
  pub const GL_FIXED_ONLY: GLenum = 0x891D;
  #[doc = "`GL_FLOAT: GLenum = 0x1406`\n* **Groups:** GlslTypeToken, MapTypeNV, SecondaryColorPointerTypeIBM, WeightPointerTypeARB, VertexWeightPointerTypeEXT, TangentPointerTypeEXT, BinormalPointerTypeEXT, FogCoordinatePointerType, FogPointerTypeEXT, FogPointerTypeIBM, IndexPointerType, ListNameType, NormalPointerType, PixelType, TexCoordPointerType, VertexPointerType, VertexAttribType, AttributeType, UniformType, VertexAttribPointerType"]
  pub const GL_FLOAT: GLenum = 0x1406;
  #[doc = "`GL_FLOAT_32_UNSIGNED_INT_24_8_REV: GLenum = 0x8DAD`"]
  pub const GL_FLOAT_32_UNSIGNED_INT_24_8_REV: GLenum = 0x8DAD;
  #[doc = "`GL_FLOAT_MAT2: GLenum = 0x8B5A`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT2: GLenum = 0x8B5A;
  #[doc = "`GL_FLOAT_MAT2x3: GLenum = 0x8B65`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT2x3: GLenum = 0x8B65;
  #[doc = "`GL_FLOAT_MAT2x4: GLenum = 0x8B66`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT2x4: GLenum = 0x8B66;
  #[doc = "`GL_FLOAT_MAT3: GLenum = 0x8B5B`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT3: GLenum = 0x8B5B;
  #[doc = "`GL_FLOAT_MAT3x2: GLenum = 0x8B67`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT3x2: GLenum = 0x8B67;
  #[doc = "`GL_FLOAT_MAT3x4: GLenum = 0x8B68`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT3x4: GLenum = 0x8B68;
  #[doc = "`GL_FLOAT_MAT4: GLenum = 0x8B5C`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT4: GLenum = 0x8B5C;
  #[doc = "`GL_FLOAT_MAT4x2: GLenum = 0x8B69`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT4x2: GLenum = 0x8B69;
  #[doc = "`GL_FLOAT_MAT4x3: GLenum = 0x8B6A`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_MAT4x3: GLenum = 0x8B6A;
  #[doc = "`GL_FLOAT_VEC2: GLenum = 0x8B50`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_VEC2: GLenum = 0x8B50;
  #[doc = "`GL_FLOAT_VEC3: GLenum = 0x8B51`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_VEC3: GLenum = 0x8B51;
  #[doc = "`GL_FLOAT_VEC4: GLenum = 0x8B52`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_FLOAT_VEC4: GLenum = 0x8B52;
  #[doc = "`GL_FRACTIONAL_EVEN: GLenum = 0x8E7C`"]
  pub const GL_FRACTIONAL_EVEN: GLenum = 0x8E7C;
  #[doc = "`GL_FRACTIONAL_ODD: GLenum = 0x8E7B`"]
  pub const GL_FRACTIONAL_ODD: GLenum = 0x8E7B;
  #[doc = "`GL_FRAGMENT_INTERPOLATION_OFFSET_BITS: GLenum = 0x8E5D`"]
  pub const GL_FRAGMENT_INTERPOLATION_OFFSET_BITS: GLenum = 0x8E5D;
  #[doc = "`GL_FRAGMENT_SHADER: GLenum = 0x8B30`\n* **Groups:** PipelineParameterName, ShaderType"]
  pub const GL_FRAGMENT_SHADER: GLenum = 0x8B30;
  #[doc = "`GL_FRAGMENT_SHADER_BIT: GLbitfield = 0x00000002`\n* **Group:** UseProgramStageMask"]
  pub const GL_FRAGMENT_SHADER_BIT: GLbitfield = 0x00000002;
  #[doc = "`GL_FRAGMENT_SHADER_DERIVATIVE_HINT: GLenum = 0x8B8B`\n* **Groups:** HintTarget, GetPName"]
  pub const GL_FRAGMENT_SHADER_DERIVATIVE_HINT: GLenum = 0x8B8B;
  #[doc = "`GL_FRAGMENT_SHADER_INVOCATIONS: GLenum = 0x82F4`"]
  pub const GL_FRAGMENT_SHADER_INVOCATIONS: GLenum = 0x82F4;
  #[doc = "`GL_FRAGMENT_SUBROUTINE: GLenum = 0x92EC`\n* **Group:** ProgramInterface"]
  pub const GL_FRAGMENT_SUBROUTINE: GLenum = 0x92EC;
  #[doc = "`GL_FRAGMENT_SUBROUTINE_UNIFORM: GLenum = 0x92F2`\n* **Group:** ProgramInterface"]
  pub const GL_FRAGMENT_SUBROUTINE_UNIFORM: GLenum = 0x92F2;
  #[doc = "`GL_FRAGMENT_TEXTURE: GLenum = 0x829F`\n* **Group:** InternalFormatPName"]
  pub const GL_FRAGMENT_TEXTURE: GLenum = 0x829F;
  #[doc = "`GL_FRAMEBUFFER: GLenum = 0x8D40`\n* **Groups:** ObjectIdentifier, FramebufferTarget, CheckFramebufferStatusTarget"]
  pub const GL_FRAMEBUFFER: GLenum = 0x8D40;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: GLenum = 0x8215`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: GLenum = 0x8215;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: GLenum = 0x8214`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: GLenum = 0x8214;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: GLenum = 0x8210`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: GLenum = 0x8210;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: GLenum = 0x8211`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: GLenum = 0x8211;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: GLenum = 0x8216`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: GLenum = 0x8216;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: GLenum = 0x8213`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: GLenum = 0x8213;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_LAYERED: GLenum = 0x8DA7`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_LAYERED: GLenum = 0x8DA7;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum = 0x8CD1`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum = 0x8CD1;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum = 0x8CD0`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum = 0x8CD0;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE: GLenum = 0x8212`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE: GLenum = 0x8212;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: GLenum = 0x8217`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: GLenum = 0x8217;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum = 0x8CD3`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum = 0x8CD3;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: GLenum = 0x8CD4`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: GLenum = 0x8CD4;
  #[doc = "`GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum = 0x8CD2`\n* **Group:** FramebufferAttachmentParameterName"]
  pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum = 0x8CD2;
  #[doc = "`GL_FRAMEBUFFER_BARRIER_BIT: GLbitfield = 0x00000400`\n* **Group:** MemoryBarrierMask"]
  pub const GL_FRAMEBUFFER_BARRIER_BIT: GLbitfield = 0x00000400;
  #[doc = "`GL_FRAMEBUFFER_BINDING: GLenum = 0x8CA6`"]
  pub const GL_FRAMEBUFFER_BINDING: GLenum = 0x8CA6;
  #[doc = "`GL_FRAMEBUFFER_BLEND: GLenum = 0x828B`\n* **Group:** InternalFormatPName"]
  pub const GL_FRAMEBUFFER_BLEND: GLenum = 0x828B;
  #[doc = "`GL_FRAMEBUFFER_COMPLETE: GLenum = 0x8CD5`\n* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_COMPLETE: GLenum = 0x8CD5;
  #[doc = "`GL_FRAMEBUFFER_DEFAULT: GLenum = 0x8218`"]
  pub const GL_FRAMEBUFFER_DEFAULT: GLenum = 0x8218;
  #[doc = "`GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: GLenum = 0x9314`\n* **Groups:** GetFramebufferParameter, FramebufferParameterName"]
  pub const GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: GLenum = 0x9314;
  #[doc = "`GL_FRAMEBUFFER_DEFAULT_HEIGHT: GLenum = 0x9311`\n* **Groups:** GetFramebufferParameter, FramebufferParameterName"]
  pub const GL_FRAMEBUFFER_DEFAULT_HEIGHT: GLenum = 0x9311;
  #[doc = "`GL_FRAMEBUFFER_DEFAULT_LAYERS: GLenum = 0x9312`\n* **Groups:** GetFramebufferParameter, FramebufferParameterName"]
  pub const GL_FRAMEBUFFER_DEFAULT_LAYERS: GLenum = 0x9312;
  #[doc = "`GL_FRAMEBUFFER_DEFAULT_SAMPLES: GLenum = 0x9313`\n* **Groups:** GetFramebufferParameter, FramebufferParameterName"]
  pub const GL_FRAMEBUFFER_DEFAULT_SAMPLES: GLenum = 0x9313;
  #[doc = "`GL_FRAMEBUFFER_DEFAULT_WIDTH: GLenum = 0x9310`\n* **Groups:** GetFramebufferParameter, FramebufferParameterName"]
  pub const GL_FRAMEBUFFER_DEFAULT_WIDTH: GLenum = 0x9310;
  #[doc = "`GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum = 0x8CD6`\n* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum = 0x8CD6;
  #[doc = "`GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: GLenum = 0x8CDB`\n* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: GLenum = 0x8CDB;
  #[doc = "`GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: GLenum = 0x8DA8`\n* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: GLenum = 0x8DA8;
  #[doc = "`GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum = 0x8CD7`\n* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum = 0x8CD7;
  #[doc = "`GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: GLenum = 0x8D56`\n* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: GLenum = 0x8D56;
  #[doc = "`GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER: GLenum = 0x8CDC`\n* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER: GLenum = 0x8CDC;
  #[doc = "`GL_FRAMEBUFFER_RENDERABLE: GLenum = 0x8289`\n* **Group:** InternalFormatPName"]
  pub const GL_FRAMEBUFFER_RENDERABLE: GLenum = 0x8289;
  #[doc = "`GL_FRAMEBUFFER_RENDERABLE_LAYERED: GLenum = 0x828A`\n* **Group:** InternalFormatPName"]
  pub const GL_FRAMEBUFFER_RENDERABLE_LAYERED: GLenum = 0x828A;
  #[doc = "`GL_FRAMEBUFFER_SRGB: GLenum = 0x8DB9`\n* **Group:** EnableCap"]
  pub const GL_FRAMEBUFFER_SRGB: GLenum = 0x8DB9;
  #[doc = "`GL_FRAMEBUFFER_UNDEFINED: GLenum = 0x8219`\n* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_UNDEFINED: GLenum = 0x8219;
  #[doc = "`GL_FRAMEBUFFER_UNSUPPORTED: GLenum = 0x8CDD`\n* **Group:** FramebufferStatus"]
  pub const GL_FRAMEBUFFER_UNSUPPORTED: GLenum = 0x8CDD;
  #[doc = "`GL_FRONT: GLenum = 0x0404`\n* **Groups:** ColorBuffer, ColorMaterialFace, CullFaceMode, DrawBufferMode, ReadBufferMode, StencilFaceDirection, MaterialFace"]
  pub const GL_FRONT: GLenum = 0x0404;
  #[doc = "`GL_FRONT_AND_BACK: GLenum = 0x0408`\n* **Groups:** ColorBuffer, ColorMaterialFace, CullFaceMode, DrawBufferMode, StencilFaceDirection, MaterialFace"]
  pub const GL_FRONT_AND_BACK: GLenum = 0x0408;
  #[doc = "`GL_FRONT_FACE: GLenum = 0x0B46`\n* **Group:** GetPName"]
  pub const GL_FRONT_FACE: GLenum = 0x0B46;
  #[doc = "`GL_FRONT_LEFT: GLenum = 0x0400`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode"]
  pub const GL_FRONT_LEFT: GLenum = 0x0400;
  #[doc = "`GL_FRONT_RIGHT: GLenum = 0x0401`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode"]
  pub const GL_FRONT_RIGHT: GLenum = 0x0401;
  #[doc = "`GL_FULL_SUPPORT: GLenum = 0x82B7`"]
  pub const GL_FULL_SUPPORT: GLenum = 0x82B7;
  #[doc = "`GL_FUNC_ADD: GLenum = 0x8006`\n* **Group:** BlendEquationModeEXT"]
  pub const GL_FUNC_ADD: GLenum = 0x8006;
  #[doc = "`GL_FUNC_REVERSE_SUBTRACT: GLenum = 0x800B`\n* **Group:** BlendEquationModeEXT"]
  pub const GL_FUNC_REVERSE_SUBTRACT: GLenum = 0x800B;
  #[doc = "`GL_FUNC_SUBTRACT: GLenum = 0x800A`\n* **Group:** BlendEquationModeEXT"]
  pub const GL_FUNC_SUBTRACT: GLenum = 0x800A;
  #[doc = "`GL_GEOMETRY_INPUT_TYPE: GLenum = 0x8917`\n* **Group:** ProgramPropertyARB"]
  pub const GL_GEOMETRY_INPUT_TYPE: GLenum = 0x8917;
  #[doc = "`GL_GEOMETRY_OUTPUT_TYPE: GLenum = 0x8918`\n* **Group:** ProgramPropertyARB"]
  pub const GL_GEOMETRY_OUTPUT_TYPE: GLenum = 0x8918;
  #[doc = "`GL_GEOMETRY_SHADER: GLenum = 0x8DD9`\n* **Groups:** PipelineParameterName, ShaderType"]
  pub const GL_GEOMETRY_SHADER: GLenum = 0x8DD9;
  #[doc = "`GL_GEOMETRY_SHADER_BIT: GLbitfield = 0x00000004`\n* **Group:** UseProgramStageMask"]
  pub const GL_GEOMETRY_SHADER_BIT: GLbitfield = 0x00000004;
  #[doc = "`GL_GEOMETRY_SHADER_INVOCATIONS: GLenum = 0x887F`"]
  pub const GL_GEOMETRY_SHADER_INVOCATIONS: GLenum = 0x887F;
  #[doc = "`GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED: GLenum = 0x82F3`"]
  pub const GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED: GLenum = 0x82F3;
  #[doc = "`GL_GEOMETRY_SUBROUTINE: GLenum = 0x92EB`\n* **Group:** ProgramInterface"]
  pub const GL_GEOMETRY_SUBROUTINE: GLenum = 0x92EB;
  #[doc = "`GL_GEOMETRY_SUBROUTINE_UNIFORM: GLenum = 0x92F1`\n* **Group:** ProgramInterface"]
  pub const GL_GEOMETRY_SUBROUTINE_UNIFORM: GLenum = 0x92F1;
  #[doc = "`GL_GEOMETRY_TEXTURE: GLenum = 0x829E`\n* **Group:** InternalFormatPName"]
  pub const GL_GEOMETRY_TEXTURE: GLenum = 0x829E;
  #[doc = "`GL_GEOMETRY_VERTICES_OUT: GLenum = 0x8916`\n* **Group:** ProgramPropertyARB"]
  pub const GL_GEOMETRY_VERTICES_OUT: GLenum = 0x8916;
  #[doc = "`GL_GEQUAL: GLenum = 0x0206`\n* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_GEQUAL: GLenum = 0x0206;
  #[doc = "`GL_GET_TEXTURE_IMAGE_FORMAT: GLenum = 0x8291`\n* **Group:** InternalFormatPName"]
  pub const GL_GET_TEXTURE_IMAGE_FORMAT: GLenum = 0x8291;
  #[doc = "`GL_GET_TEXTURE_IMAGE_TYPE: GLenum = 0x8292`\n* **Group:** InternalFormatPName"]
  pub const GL_GET_TEXTURE_IMAGE_TYPE: GLenum = 0x8292;
  #[doc = "`GL_GREATER: GLenum = 0x0204`\n* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_GREATER: GLenum = 0x0204;
  #[doc = "`GL_GREEN: GLenum = 0x1904`\n* **Groups:** TextureSwizzle, PixelFormat"]
  pub const GL_GREEN: GLenum = 0x1904;
  #[doc = "`GL_GREEN_INTEGER: GLenum = 0x8D95`\n* **Group:** PixelFormat"]
  pub const GL_GREEN_INTEGER: GLenum = 0x8D95;
  #[doc = "`GL_GUILTY_CONTEXT_RESET: GLenum = 0x8253`\n* **Group:** GraphicsResetStatus"]
  pub const GL_GUILTY_CONTEXT_RESET: GLenum = 0x8253;
  #[doc = "`GL_HALF_FLOAT: GLenum = 0x140B`\n* **Groups:** VertexAttribPointerType, VertexAttribType"]
  pub const GL_HALF_FLOAT: GLenum = 0x140B;
  #[doc = "`GL_HIGH_FLOAT: GLenum = 0x8DF2`\n* **Group:** PrecisionType"]
  pub const GL_HIGH_FLOAT: GLenum = 0x8DF2;
  #[doc = "`GL_HIGH_INT: GLenum = 0x8DF5`\n* **Group:** PrecisionType"]
  pub const GL_HIGH_INT: GLenum = 0x8DF5;
  #[doc = "`GL_IMAGE_1D: GLenum = 0x904C`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_IMAGE_1D: GLenum = 0x904C;
  #[doc = "`GL_IMAGE_1D_ARRAY: GLenum = 0x9052`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_IMAGE_1D_ARRAY: GLenum = 0x9052;
  #[doc = "`GL_IMAGE_2D: GLenum = 0x904D`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_IMAGE_2D: GLenum = 0x904D;
  #[doc = "`GL_IMAGE_2D_ARRAY: GLenum = 0x9053`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_IMAGE_2D_ARRAY: GLenum = 0x9053;
  #[doc = "`GL_IMAGE_2D_MULTISAMPLE: GLenum = 0x9055`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_IMAGE_2D_MULTISAMPLE: GLenum = 0x9055;
  #[doc = "`GL_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9056`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9056;
  #[doc = "`GL_IMAGE_2D_RECT: GLenum = 0x904F`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_IMAGE_2D_RECT: GLenum = 0x904F;
  #[doc = "`GL_IMAGE_3D: GLenum = 0x904E`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_IMAGE_3D: GLenum = 0x904E;
  #[doc = "`GL_IMAGE_BINDING_ACCESS: GLenum = 0x8F3E`"]
  pub const GL_IMAGE_BINDING_ACCESS: GLenum = 0x8F3E;
  #[doc = "`GL_IMAGE_BINDING_FORMAT: GLenum = 0x906E`"]
  pub const GL_IMAGE_BINDING_FORMAT: GLenum = 0x906E;
  #[doc = "`GL_IMAGE_BINDING_LAYER: GLenum = 0x8F3D`"]
  pub const GL_IMAGE_BINDING_LAYER: GLenum = 0x8F3D;
  #[doc = "`GL_IMAGE_BINDING_LAYERED: GLenum = 0x8F3C`"]
  pub const GL_IMAGE_BINDING_LAYERED: GLenum = 0x8F3C;
  #[doc = "`GL_IMAGE_BINDING_LEVEL: GLenum = 0x8F3B`"]
  pub const GL_IMAGE_BINDING_LEVEL: GLenum = 0x8F3B;
  #[doc = "`GL_IMAGE_BINDING_NAME: GLenum = 0x8F3A`"]
  pub const GL_IMAGE_BINDING_NAME: GLenum = 0x8F3A;
  #[doc = "`GL_IMAGE_BUFFER: GLenum = 0x9051`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_IMAGE_BUFFER: GLenum = 0x9051;
  #[doc = "`GL_IMAGE_CLASS_10_10_10_2: GLenum = 0x82C3`"]
  pub const GL_IMAGE_CLASS_10_10_10_2: GLenum = 0x82C3;
  #[doc = "`GL_IMAGE_CLASS_11_11_10: GLenum = 0x82C2`"]
  pub const GL_IMAGE_CLASS_11_11_10: GLenum = 0x82C2;
  #[doc = "`GL_IMAGE_CLASS_1_X_16: GLenum = 0x82BE`"]
  pub const GL_IMAGE_CLASS_1_X_16: GLenum = 0x82BE;
  #[doc = "`GL_IMAGE_CLASS_1_X_32: GLenum = 0x82BB`"]
  pub const GL_IMAGE_CLASS_1_X_32: GLenum = 0x82BB;
  #[doc = "`GL_IMAGE_CLASS_1_X_8: GLenum = 0x82C1`"]
  pub const GL_IMAGE_CLASS_1_X_8: GLenum = 0x82C1;
  #[doc = "`GL_IMAGE_CLASS_2_X_16: GLenum = 0x82BD`"]
  pub const GL_IMAGE_CLASS_2_X_16: GLenum = 0x82BD;
  #[doc = "`GL_IMAGE_CLASS_2_X_32: GLenum = 0x82BA`"]
  pub const GL_IMAGE_CLASS_2_X_32: GLenum = 0x82BA;
  #[doc = "`GL_IMAGE_CLASS_2_X_8: GLenum = 0x82C0`"]
  pub const GL_IMAGE_CLASS_2_X_8: GLenum = 0x82C0;
  #[doc = "`GL_IMAGE_CLASS_4_X_16: GLenum = 0x82BC`"]
  pub const GL_IMAGE_CLASS_4_X_16: GLenum = 0x82BC;
  #[doc = "`GL_IMAGE_CLASS_4_X_32: GLenum = 0x82B9`"]
  pub const GL_IMAGE_CLASS_4_X_32: GLenum = 0x82B9;
  #[doc = "`GL_IMAGE_CLASS_4_X_8: GLenum = 0x82BF`"]
  pub const GL_IMAGE_CLASS_4_X_8: GLenum = 0x82BF;
  #[doc = "`GL_IMAGE_COMPATIBILITY_CLASS: GLenum = 0x82A8`\n* **Group:** InternalFormatPName"]
  pub const GL_IMAGE_COMPATIBILITY_CLASS: GLenum = 0x82A8;
  #[doc = "`GL_IMAGE_CUBE: GLenum = 0x9050`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_IMAGE_CUBE: GLenum = 0x9050;
  #[doc = "`GL_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x9054`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x9054;
  #[doc = "`GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS: GLenum = 0x90C9`"]
  pub const GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS: GLenum = 0x90C9;
  #[doc = "`GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE: GLenum = 0x90C8`"]
  pub const GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE: GLenum = 0x90C8;
  #[doc = "`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE: GLenum = 0x90C7`\n* **Group:** InternalFormatPName"]
  pub const GL_IMAGE_FORMAT_COMPATIBILITY_TYPE: GLenum = 0x90C7;
  #[doc = "`GL_IMAGE_PIXEL_FORMAT: GLenum = 0x82A9`\n* **Group:** InternalFormatPName"]
  pub const GL_IMAGE_PIXEL_FORMAT: GLenum = 0x82A9;
  #[doc = "`GL_IMAGE_PIXEL_TYPE: GLenum = 0x82AA`\n* **Group:** InternalFormatPName"]
  pub const GL_IMAGE_PIXEL_TYPE: GLenum = 0x82AA;
  #[doc = "`GL_IMAGE_TEXEL_SIZE: GLenum = 0x82A7`\n* **Group:** InternalFormatPName"]
  pub const GL_IMAGE_TEXEL_SIZE: GLenum = 0x82A7;
  #[doc = "`GL_IMPLEMENTATION_COLOR_READ_FORMAT: GLenum = 0x8B9B`\n* **Groups:** GetFramebufferParameter, GetPName"]
  pub const GL_IMPLEMENTATION_COLOR_READ_FORMAT: GLenum = 0x8B9B;
  #[doc = "`GL_IMPLEMENTATION_COLOR_READ_TYPE: GLenum = 0x8B9A`\n* **Groups:** GetFramebufferParameter, GetPName"]
  pub const GL_IMPLEMENTATION_COLOR_READ_TYPE: GLenum = 0x8B9A;
  #[doc = "`GL_INCR: GLenum = 0x1E02`\n* **Group:** StencilOp"]
  pub const GL_INCR: GLenum = 0x1E02;
  #[doc = "`GL_INCR_WRAP: GLenum = 0x8507`\n* **Group:** StencilOp"]
  pub const GL_INCR_WRAP: GLenum = 0x8507;
  #[doc = "`GL_INFO_LOG_LENGTH: GLenum = 0x8B84`\n* **Groups:** ProgramPropertyARB, ShaderParameterName, PipelineParameterName"]
  pub const GL_INFO_LOG_LENGTH: GLenum = 0x8B84;
  #[doc = "`GL_INNOCENT_CONTEXT_RESET: GLenum = 0x8254`\n* **Group:** GraphicsResetStatus"]
  pub const GL_INNOCENT_CONTEXT_RESET: GLenum = 0x8254;
  #[doc = "`GL_INT: GLenum = 0x1404`\n* **Groups:** VertexAttribIType, SecondaryColorPointerTypeIBM, WeightPointerTypeARB, TangentPointerTypeEXT, BinormalPointerTypeEXT, IndexPointerType, ListNameType, NormalPointerType, PixelType, TexCoordPointerType, VertexPointerType, VertexAttribType, AttributeType, UniformType, VertexAttribPointerType, GlslTypeToken"]
  pub const GL_INT: GLenum = 0x1404;
  #[doc = "`GL_INTERLEAVED_ATTRIBS: GLenum = 0x8C8C`\n* **Group:** TransformFeedbackBufferMode"]
  pub const GL_INTERLEAVED_ATTRIBS: GLenum = 0x8C8C;
  #[doc = "`GL_INTERNALFORMAT_ALPHA_SIZE: GLenum = 0x8274`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_ALPHA_SIZE: GLenum = 0x8274;
  #[doc = "`GL_INTERNALFORMAT_ALPHA_TYPE: GLenum = 0x827B`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_ALPHA_TYPE: GLenum = 0x827B;
  #[doc = "`GL_INTERNALFORMAT_BLUE_SIZE: GLenum = 0x8273`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_BLUE_SIZE: GLenum = 0x8273;
  #[doc = "`GL_INTERNALFORMAT_BLUE_TYPE: GLenum = 0x827A`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_BLUE_TYPE: GLenum = 0x827A;
  #[doc = "`GL_INTERNALFORMAT_DEPTH_SIZE: GLenum = 0x8275`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_DEPTH_SIZE: GLenum = 0x8275;
  #[doc = "`GL_INTERNALFORMAT_DEPTH_TYPE: GLenum = 0x827C`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_DEPTH_TYPE: GLenum = 0x827C;
  #[doc = "`GL_INTERNALFORMAT_GREEN_SIZE: GLenum = 0x8272`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_GREEN_SIZE: GLenum = 0x8272;
  #[doc = "`GL_INTERNALFORMAT_GREEN_TYPE: GLenum = 0x8279`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_GREEN_TYPE: GLenum = 0x8279;
  #[doc = "`GL_INTERNALFORMAT_PREFERRED: GLenum = 0x8270`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_PREFERRED: GLenum = 0x8270;
  #[doc = "`GL_INTERNALFORMAT_RED_SIZE: GLenum = 0x8271`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_RED_SIZE: GLenum = 0x8271;
  #[doc = "`GL_INTERNALFORMAT_RED_TYPE: GLenum = 0x8278`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_RED_TYPE: GLenum = 0x8278;
  #[doc = "`GL_INTERNALFORMAT_SHARED_SIZE: GLenum = 0x8277`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_SHARED_SIZE: GLenum = 0x8277;
  #[doc = "`GL_INTERNALFORMAT_STENCIL_SIZE: GLenum = 0x8276`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_STENCIL_SIZE: GLenum = 0x8276;
  #[doc = "`GL_INTERNALFORMAT_STENCIL_TYPE: GLenum = 0x827D`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_STENCIL_TYPE: GLenum = 0x827D;
  #[doc = "`GL_INTERNALFORMAT_SUPPORTED: GLenum = 0x826F`\n* **Group:** InternalFormatPName"]
  pub const GL_INTERNALFORMAT_SUPPORTED: GLenum = 0x826F;
  #[doc = "`GL_INT_2_10_10_10_REV: GLenum = 0x8D9F`\n* **Groups:** VertexAttribPointerType, VertexAttribType"]
  pub const GL_INT_2_10_10_10_REV: GLenum = 0x8D9F;
  #[doc = "`GL_INT_IMAGE_1D: GLenum = 0x9057`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_INT_IMAGE_1D: GLenum = 0x9057;
  #[doc = "`GL_INT_IMAGE_1D_ARRAY: GLenum = 0x905D`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_INT_IMAGE_1D_ARRAY: GLenum = 0x905D;
  #[doc = "`GL_INT_IMAGE_2D: GLenum = 0x9058`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_INT_IMAGE_2D: GLenum = 0x9058;
  #[doc = "`GL_INT_IMAGE_2D_ARRAY: GLenum = 0x905E`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_INT_IMAGE_2D_ARRAY: GLenum = 0x905E;
  #[doc = "`GL_INT_IMAGE_2D_MULTISAMPLE: GLenum = 0x9060`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_INT_IMAGE_2D_MULTISAMPLE: GLenum = 0x9060;
  #[doc = "`GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9061`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9061;
  #[doc = "`GL_INT_IMAGE_2D_RECT: GLenum = 0x905A`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_INT_IMAGE_2D_RECT: GLenum = 0x905A;
  #[doc = "`GL_INT_IMAGE_3D: GLenum = 0x9059`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_INT_IMAGE_3D: GLenum = 0x9059;
  #[doc = "`GL_INT_IMAGE_BUFFER: GLenum = 0x905C`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_INT_IMAGE_BUFFER: GLenum = 0x905C;
  #[doc = "`GL_INT_IMAGE_CUBE: GLenum = 0x905B`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_INT_IMAGE_CUBE: GLenum = 0x905B;
  #[doc = "`GL_INT_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x905F`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_INT_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x905F;
  #[doc = "`GL_INT_SAMPLER_1D: GLenum = 0x8DC9`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_1D: GLenum = 0x8DC9;
  #[doc = "`GL_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DCE`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DCE;
  #[doc = "`GL_INT_SAMPLER_2D: GLenum = 0x8DCA`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_2D: GLenum = 0x8DCA;
  #[doc = "`GL_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DCF`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DCF;
  #[doc = "`GL_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9109`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9109;
  #[doc = "`GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910C`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910C;
  #[doc = "`GL_INT_SAMPLER_2D_RECT: GLenum = 0x8DCD`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_2D_RECT: GLenum = 0x8DCD;
  #[doc = "`GL_INT_SAMPLER_3D: GLenum = 0x8DCB`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_3D: GLenum = 0x8DCB;
  #[doc = "`GL_INT_SAMPLER_BUFFER: GLenum = 0x8DD0`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_BUFFER: GLenum = 0x8DD0;
  #[doc = "`GL_INT_SAMPLER_CUBE: GLenum = 0x8DCC`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_CUBE: GLenum = 0x8DCC;
  #[doc = "`GL_INT_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900E`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900E;
  #[doc = "`GL_INT_VEC2: GLenum = 0x8B53`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_VEC2: GLenum = 0x8B53;
  #[doc = "`GL_INT_VEC3: GLenum = 0x8B54`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_VEC3: GLenum = 0x8B54;
  #[doc = "`GL_INT_VEC4: GLenum = 0x8B55`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_INT_VEC4: GLenum = 0x8B55;
  #[doc = "`GL_INVALID_ENUM: GLenum = 0x0500`\n* **Group:** ErrorCode"]
  pub const GL_INVALID_ENUM: GLenum = 0x0500;
  #[doc = "`GL_INVALID_FRAMEBUFFER_OPERATION: GLenum = 0x0506`\n* **Group:** ErrorCode"]
  pub const GL_INVALID_FRAMEBUFFER_OPERATION: GLenum = 0x0506;
  #[doc = "`GL_INVALID_INDEX: GLenum = 0xFFFFFFFF`"]
  pub const GL_INVALID_INDEX: GLenum = 0xFFFFFFFF;
  #[doc = "`GL_INVALID_OPERATION: GLenum = 0x0502`\n* **Group:** ErrorCode"]
  pub const GL_INVALID_OPERATION: GLenum = 0x0502;
  #[doc = "`GL_INVALID_VALUE: GLenum = 0x0501`\n* **Group:** ErrorCode"]
  pub const GL_INVALID_VALUE: GLenum = 0x0501;
  #[doc = "`GL_INVERT: GLenum = 0x150A`\n* **Groups:** PathFillMode, LogicOp, StencilOp"]
  pub const GL_INVERT: GLenum = 0x150A;
  #[doc = "`GL_ISOLINES: GLenum = 0x8E7A`"]
  pub const GL_ISOLINES: GLenum = 0x8E7A;
  #[doc = "`GL_IS_PER_PATCH: GLenum = 0x92E7`\n* **Group:** ProgramResourceProperty"]
  pub const GL_IS_PER_PATCH: GLenum = 0x92E7;
  #[doc = "`GL_IS_ROW_MAJOR: GLenum = 0x9300`\n* **Group:** ProgramResourceProperty"]
  pub const GL_IS_ROW_MAJOR: GLenum = 0x9300;
  #[doc = "`GL_KEEP: GLenum = 0x1E00`\n* **Group:** StencilOp"]
  pub const GL_KEEP: GLenum = 0x1E00;
  #[doc = "`GL_LAST_VERTEX_CONVENTION: GLenum = 0x8E4E`\n* **Group:** VertexProvokingMode"]
  pub const GL_LAST_VERTEX_CONVENTION: GLenum = 0x8E4E;
  #[doc = "`GL_LAYER_PROVOKING_VERTEX: GLenum = 0x825E`\n* **Group:** GetPName"]
  pub const GL_LAYER_PROVOKING_VERTEX: GLenum = 0x825E;
  #[doc = "`GL_LEFT: GLenum = 0x0406`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode"]
  pub const GL_LEFT: GLenum = 0x0406;
  #[doc = "`GL_LEQUAL: GLenum = 0x0203`\n* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_LEQUAL: GLenum = 0x0203;
  #[doc = "`GL_LESS: GLenum = 0x0201`\n* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_LESS: GLenum = 0x0201;
  #[doc = "`GL_LINE: GLenum = 0x1B01`\n* **Groups:** PolygonMode, MeshMode1, MeshMode2"]
  pub const GL_LINE: GLenum = 0x1B01;
  #[doc = "`GL_LINEAR: GLenum = 0x2601`\n* **Groups:** BlitFramebufferFilter, FogMode, TextureMagFilter, TextureMinFilter"]
  pub const GL_LINEAR: GLenum = 0x2601;
  #[doc = "`GL_LINEAR_MIPMAP_LINEAR: GLenum = 0x2703`\n* **Groups:** TextureWrapMode, TextureMinFilter"]
  pub const GL_LINEAR_MIPMAP_LINEAR: GLenum = 0x2703;
  #[doc = "`GL_LINEAR_MIPMAP_NEAREST: GLenum = 0x2701`\n* **Group:** TextureMinFilter"]
  pub const GL_LINEAR_MIPMAP_NEAREST: GLenum = 0x2701;
  #[doc = "`GL_LINES: GLenum = 0x0001`\n* **Group:** PrimitiveType"]
  pub const GL_LINES: GLenum = 0x0001;
  #[doc = "`GL_LINES_ADJACENCY: GLenum = 0x000A`\n* **Group:** PrimitiveType"]
  pub const GL_LINES_ADJACENCY: GLenum = 0x000A;
  #[doc = "`GL_LINE_LOOP: GLenum = 0x0002`\n* **Group:** PrimitiveType"]
  pub const GL_LINE_LOOP: GLenum = 0x0002;
  #[doc = "`GL_LINE_SMOOTH: GLenum = 0x0B20`\n* **Groups:** GetPName, EnableCap"]
  pub const GL_LINE_SMOOTH: GLenum = 0x0B20;
  #[doc = "`GL_LINE_SMOOTH_HINT: GLenum = 0x0C52`\n* **Groups:** HintTarget, GetPName"]
  pub const GL_LINE_SMOOTH_HINT: GLenum = 0x0C52;
  #[doc = "`GL_LINE_STRIP: GLenum = 0x0003`\n* **Group:** PrimitiveType"]
  pub const GL_LINE_STRIP: GLenum = 0x0003;
  #[doc = "`GL_LINE_STRIP_ADJACENCY: GLenum = 0x000B`\n* **Group:** PrimitiveType"]
  pub const GL_LINE_STRIP_ADJACENCY: GLenum = 0x000B;
  #[doc = "`GL_LINE_WIDTH: GLenum = 0x0B21`\n* **Group:** GetPName"]
  pub const GL_LINE_WIDTH: GLenum = 0x0B21;
  #[doc = "`GL_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23`\n* **Group:** GetPName"]
  pub const GL_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23;
  #[doc = "`GL_LINE_WIDTH_RANGE: GLenum = 0x0B22`\n* **Group:** GetPName"]
  pub const GL_LINE_WIDTH_RANGE: GLenum = 0x0B22;
  #[doc = "`GL_LINK_STATUS: GLenum = 0x8B82`\n* **Group:** ProgramPropertyARB"]
  pub const GL_LINK_STATUS: GLenum = 0x8B82;
  #[doc = "`GL_LOCATION: GLenum = 0x930E`\n* **Group:** ProgramResourceProperty"]
  pub const GL_LOCATION: GLenum = 0x930E;
  #[doc = "`GL_LOCATION_COMPONENT: GLenum = 0x934A`\n* **Group:** ProgramResourceProperty"]
  pub const GL_LOCATION_COMPONENT: GLenum = 0x934A;
  #[doc = "`GL_LOCATION_INDEX: GLenum = 0x930F`\n* **Group:** ProgramResourceProperty"]
  pub const GL_LOCATION_INDEX: GLenum = 0x930F;
  #[doc = "`GL_LOGIC_OP_MODE: GLenum = 0x0BF0`\n* **Group:** GetPName"]
  pub const GL_LOGIC_OP_MODE: GLenum = 0x0BF0;
  #[doc = "`GL_LOSE_CONTEXT_ON_RESET: GLenum = 0x8252`"]
  pub const GL_LOSE_CONTEXT_ON_RESET: GLenum = 0x8252;
  #[doc = "`GL_LOWER_LEFT: GLenum = 0x8CA1`\n* **Group:** ClipControlOrigin"]
  pub const GL_LOWER_LEFT: GLenum = 0x8CA1;
  #[doc = "`GL_LOW_FLOAT: GLenum = 0x8DF0`\n* **Group:** PrecisionType"]
  pub const GL_LOW_FLOAT: GLenum = 0x8DF0;
  #[doc = "`GL_LOW_INT: GLenum = 0x8DF3`\n* **Group:** PrecisionType"]
  pub const GL_LOW_INT: GLenum = 0x8DF3;
  #[doc = "`GL_MAJOR_VERSION: GLenum = 0x821B`\n* **Group:** GetPName"]
  pub const GL_MAJOR_VERSION: GLenum = 0x821B;
  #[doc = "`GL_MANUAL_GENERATE_MIPMAP: GLenum = 0x8294`"]
  pub const GL_MANUAL_GENERATE_MIPMAP: GLenum = 0x8294;
  #[doc = "`GL_MAP_COHERENT_BIT: GLbitfield = 0x0080`\n* **Groups:** MapBufferAccessMask, BufferStorageMask"]
  pub const GL_MAP_COHERENT_BIT: GLbitfield = 0x0080;
  #[doc = "`GL_MAP_FLUSH_EXPLICIT_BIT: GLbitfield = 0x0010`\n* **Group:** MapBufferAccessMask"]
  pub const GL_MAP_FLUSH_EXPLICIT_BIT: GLbitfield = 0x0010;
  #[doc = "`GL_MAP_INVALIDATE_BUFFER_BIT: GLbitfield = 0x0008`\n* **Group:** MapBufferAccessMask"]
  pub const GL_MAP_INVALIDATE_BUFFER_BIT: GLbitfield = 0x0008;
  #[doc = "`GL_MAP_INVALIDATE_RANGE_BIT: GLbitfield = 0x0004`\n* **Group:** MapBufferAccessMask"]
  pub const GL_MAP_INVALIDATE_RANGE_BIT: GLbitfield = 0x0004;
  #[doc = "`GL_MAP_PERSISTENT_BIT: GLbitfield = 0x0040`\n* **Groups:** MapBufferAccessMask, BufferStorageMask"]
  pub const GL_MAP_PERSISTENT_BIT: GLbitfield = 0x0040;
  #[doc = "`GL_MAP_READ_BIT: GLbitfield = 0x0001`\n* **Groups:** MapBufferAccessMask, BufferStorageMask"]
  pub const GL_MAP_READ_BIT: GLbitfield = 0x0001;
  #[doc = "`GL_MAP_UNSYNCHRONIZED_BIT: GLbitfield = 0x0020`\n* **Group:** MapBufferAccessMask"]
  pub const GL_MAP_UNSYNCHRONIZED_BIT: GLbitfield = 0x0020;
  #[doc = "`GL_MAP_WRITE_BIT: GLbitfield = 0x0002`\n* **Groups:** MapBufferAccessMask, BufferStorageMask"]
  pub const GL_MAP_WRITE_BIT: GLbitfield = 0x0002;
  #[doc = "`GL_MATRIX_STRIDE: GLenum = 0x92FF`\n* **Group:** ProgramResourceProperty"]
  pub const GL_MATRIX_STRIDE: GLenum = 0x92FF;
  #[doc = "`GL_MAX: GLenum = 0x8008`\n* **Group:** BlendEquationModeEXT"]
  pub const GL_MAX: GLenum = 0x8008;
  #[doc = "`GL_MAX_3D_TEXTURE_SIZE: GLenum = 0x8073`\n* **Group:** GetPName"]
  pub const GL_MAX_3D_TEXTURE_SIZE: GLenum = 0x8073;
  #[doc = "`GL_MAX_ARRAY_TEXTURE_LAYERS: GLenum = 0x88FF`\n* **Group:** GetPName"]
  pub const GL_MAX_ARRAY_TEXTURE_LAYERS: GLenum = 0x88FF;
  #[doc = "`GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS: GLenum = 0x92DC`"]
  pub const GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS: GLenum = 0x92DC;
  #[doc = "`GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE: GLenum = 0x92D8`"]
  pub const GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE: GLenum = 0x92D8;
  #[doc = "`GL_MAX_CLIP_DISTANCES: GLenum = 0x0D32`\n* **Group:** GetPName\n* **Alias Of:** `GL_MAX_CLIP_PLANES`"]
  pub const GL_MAX_CLIP_DISTANCES: GLenum = 0x0D32;
  #[doc = "`GL_MAX_COLOR_ATTACHMENTS: GLenum = 0x8CDF`"]
  pub const GL_MAX_COLOR_ATTACHMENTS: GLenum = 0x8CDF;
  #[doc = "`GL_MAX_COLOR_TEXTURE_SAMPLES: GLenum = 0x910E`\n* **Group:** GetPName"]
  pub const GL_MAX_COLOR_TEXTURE_SAMPLES: GLenum = 0x910E;
  #[doc = "`GL_MAX_COMBINED_ATOMIC_COUNTERS: GLenum = 0x92D7`\n* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_ATOMIC_COUNTERS: GLenum = 0x92D7;
  #[doc = "`GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D1`"]
  pub const GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D1;
  #[doc = "`GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES: GLenum = 0x82FA`"]
  pub const GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES: GLenum = 0x82FA;
  #[doc = "`GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS: GLenum = 0x8266`\n* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS: GLenum = 0x8266;
  #[doc = "`GL_MAX_COMBINED_DIMENSIONS: GLenum = 0x8282`"]
  pub const GL_MAX_COMBINED_DIMENSIONS: GLenum = 0x8282;
  #[doc = "`GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8A33`\n* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8A33;
  #[doc = "`GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8A32`\n* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8A32;
  #[doc = "`GL_MAX_COMBINED_IMAGE_UNIFORMS: GLenum = 0x90CF`"]
  pub const GL_MAX_COMBINED_IMAGE_UNIFORMS: GLenum = 0x90CF;
  #[doc = "`GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS: GLenum = 0x8F39`"]
  pub const GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS: GLenum = 0x8F39;
  #[doc = "`GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES: GLenum = 0x8F39`\n* **Alias Of:** `GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS`"]
  pub const GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES: GLenum = 0x8F39;
  #[doc = "`GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS: GLenum = 0x90DC`\n* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS: GLenum = 0x90DC;
  #[doc = "`GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS: GLenum = 0x8E1E`"]
  pub const GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS: GLenum = 0x8E1E;
  #[doc = "`GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS: GLenum = 0x8E1F`"]
  pub const GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS: GLenum = 0x8E1F;
  #[doc = "`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4D`\n* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4D;
  #[doc = "`GL_MAX_COMBINED_UNIFORM_BLOCKS: GLenum = 0x8A2E`\n* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_UNIFORM_BLOCKS: GLenum = 0x8A2E;
  #[doc = "`GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8A31`\n* **Group:** GetPName"]
  pub const GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8A31;
  #[doc = "`GL_MAX_COMPUTE_ATOMIC_COUNTERS: GLenum = 0x8265`\n* **Group:** GetPName"]
  pub const GL_MAX_COMPUTE_ATOMIC_COUNTERS: GLenum = 0x8265;
  #[doc = "`GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS: GLenum = 0x8264`\n* **Group:** GetPName"]
  pub const GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS: GLenum = 0x8264;
  #[doc = "`GL_MAX_COMPUTE_IMAGE_UNIFORMS: GLenum = 0x91BD`"]
  pub const GL_MAX_COMPUTE_IMAGE_UNIFORMS: GLenum = 0x91BD;
  #[doc = "`GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS: GLenum = 0x90DB`\n* **Group:** GetPName"]
  pub const GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS: GLenum = 0x90DB;
  #[doc = "`GL_MAX_COMPUTE_SHARED_MEMORY_SIZE: GLenum = 0x8262`"]
  pub const GL_MAX_COMPUTE_SHARED_MEMORY_SIZE: GLenum = 0x8262;
  #[doc = "`GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS: GLenum = 0x91BC`\n* **Group:** GetPName"]
  pub const GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS: GLenum = 0x91BC;
  #[doc = "`GL_MAX_COMPUTE_UNIFORM_BLOCKS: GLenum = 0x91BB`\n* **Group:** GetPName"]
  pub const GL_MAX_COMPUTE_UNIFORM_BLOCKS: GLenum = 0x91BB;
  #[doc = "`GL_MAX_COMPUTE_UNIFORM_COMPONENTS: GLenum = 0x8263`\n* **Group:** GetPName"]
  pub const GL_MAX_COMPUTE_UNIFORM_COMPONENTS: GLenum = 0x8263;
  #[doc = "`GL_MAX_COMPUTE_WORK_GROUP_COUNT: GLenum = 0x91BE`\n* **Group:** GetPName"]
  pub const GL_MAX_COMPUTE_WORK_GROUP_COUNT: GLenum = 0x91BE;
  #[doc = "`GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS: GLenum = 0x90EB`\n* **Group:** GetPName"]
  pub const GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS: GLenum = 0x90EB;
  #[doc = "`GL_MAX_COMPUTE_WORK_GROUP_SIZE: GLenum = 0x91BF`\n* **Group:** GetPName"]
  pub const GL_MAX_COMPUTE_WORK_GROUP_SIZE: GLenum = 0x91BF;
  #[doc = "`GL_MAX_CUBE_MAP_TEXTURE_SIZE: GLenum = 0x851C`\n* **Group:** GetPName"]
  pub const GL_MAX_CUBE_MAP_TEXTURE_SIZE: GLenum = 0x851C;
  #[doc = "`GL_MAX_CULL_DISTANCES: GLenum = 0x82F9`"]
  pub const GL_MAX_CULL_DISTANCES: GLenum = 0x82F9;
  #[doc = "`GL_MAX_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826C`\n* **Group:** GetPName"]
  pub const GL_MAX_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826C;
  #[doc = "`GL_MAX_DEBUG_LOGGED_MESSAGES: GLenum = 0x9144`"]
  pub const GL_MAX_DEBUG_LOGGED_MESSAGES: GLenum = 0x9144;
  #[doc = "`GL_MAX_DEBUG_MESSAGE_LENGTH: GLenum = 0x9143`"]
  pub const GL_MAX_DEBUG_MESSAGE_LENGTH: GLenum = 0x9143;
  #[doc = "`GL_MAX_DEPTH: GLenum = 0x8280`\n* **Group:** InternalFormatPName"]
  pub const GL_MAX_DEPTH: GLenum = 0x8280;
  #[doc = "`GL_MAX_DEPTH_TEXTURE_SAMPLES: GLenum = 0x910F`\n* **Group:** GetPName"]
  pub const GL_MAX_DEPTH_TEXTURE_SAMPLES: GLenum = 0x910F;
  #[doc = "`GL_MAX_DRAW_BUFFERS: GLenum = 0x8824`\n* **Group:** GetPName"]
  pub const GL_MAX_DRAW_BUFFERS: GLenum = 0x8824;
  #[doc = "`GL_MAX_DUAL_SOURCE_DRAW_BUFFERS: GLenum = 0x88FC`\n* **Group:** GetPName"]
  pub const GL_MAX_DUAL_SOURCE_DRAW_BUFFERS: GLenum = 0x88FC;
  #[doc = "`GL_MAX_ELEMENTS_INDICES: GLenum = 0x80E9`\n* **Group:** GetPName"]
  pub const GL_MAX_ELEMENTS_INDICES: GLenum = 0x80E9;
  #[doc = "`GL_MAX_ELEMENTS_VERTICES: GLenum = 0x80E8`\n* **Group:** GetPName"]
  pub const GL_MAX_ELEMENTS_VERTICES: GLenum = 0x80E8;
  #[doc = "`GL_MAX_ELEMENT_INDEX: GLenum = 0x8D6B`\n* **Group:** GetPName"]
  pub const GL_MAX_ELEMENT_INDEX: GLenum = 0x8D6B;
  #[doc = "`GL_MAX_FRAGMENT_ATOMIC_COUNTERS: GLenum = 0x92D6`\n* **Group:** GetPName"]
  pub const GL_MAX_FRAGMENT_ATOMIC_COUNTERS: GLenum = 0x92D6;
  #[doc = "`GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D0`"]
  pub const GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D0;
  #[doc = "`GL_MAX_FRAGMENT_IMAGE_UNIFORMS: GLenum = 0x90CE`"]
  pub const GL_MAX_FRAGMENT_IMAGE_UNIFORMS: GLenum = 0x90CE;
  #[doc = "`GL_MAX_FRAGMENT_INPUT_COMPONENTS: GLenum = 0x9125`\n* **Group:** GetPName"]
  pub const GL_MAX_FRAGMENT_INPUT_COMPONENTS: GLenum = 0x9125;
  #[doc = "`GL_MAX_FRAGMENT_INTERPOLATION_OFFSET: GLenum = 0x8E5C`"]
  pub const GL_MAX_FRAGMENT_INTERPOLATION_OFFSET: GLenum = 0x8E5C;
  #[doc = "`GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS: GLenum = 0x90DA`\n* **Group:** GetPName"]
  pub const GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS: GLenum = 0x90DA;
  #[doc = "`GL_MAX_FRAGMENT_UNIFORM_BLOCKS: GLenum = 0x8A2D`\n* **Group:** GetPName"]
  pub const GL_MAX_FRAGMENT_UNIFORM_BLOCKS: GLenum = 0x8A2D;
  #[doc = "`GL_MAX_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8B49`\n* **Group:** GetPName"]
  pub const GL_MAX_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8B49;
  #[doc = "`GL_MAX_FRAGMENT_UNIFORM_VECTORS: GLenum = 0x8DFD`\n* **Group:** GetPName"]
  pub const GL_MAX_FRAGMENT_UNIFORM_VECTORS: GLenum = 0x8DFD;
  #[doc = "`GL_MAX_FRAMEBUFFER_HEIGHT: GLenum = 0x9316`\n* **Group:** GetPName"]
  pub const GL_MAX_FRAMEBUFFER_HEIGHT: GLenum = 0x9316;
  #[doc = "`GL_MAX_FRAMEBUFFER_LAYERS: GLenum = 0x9317`\n* **Group:** GetPName"]
  pub const GL_MAX_FRAMEBUFFER_LAYERS: GLenum = 0x9317;
  #[doc = "`GL_MAX_FRAMEBUFFER_SAMPLES: GLenum = 0x9318`\n* **Group:** GetPName"]
  pub const GL_MAX_FRAMEBUFFER_SAMPLES: GLenum = 0x9318;
  #[doc = "`GL_MAX_FRAMEBUFFER_WIDTH: GLenum = 0x9315`\n* **Group:** GetPName"]
  pub const GL_MAX_FRAMEBUFFER_WIDTH: GLenum = 0x9315;
  #[doc = "`GL_MAX_GEOMETRY_ATOMIC_COUNTERS: GLenum = 0x92D5`\n* **Group:** GetPName"]
  pub const GL_MAX_GEOMETRY_ATOMIC_COUNTERS: GLenum = 0x92D5;
  #[doc = "`GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CF`"]
  pub const GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CF;
  #[doc = "`GL_MAX_GEOMETRY_IMAGE_UNIFORMS: GLenum = 0x90CD`"]
  pub const GL_MAX_GEOMETRY_IMAGE_UNIFORMS: GLenum = 0x90CD;
  #[doc = "`GL_MAX_GEOMETRY_INPUT_COMPONENTS: GLenum = 0x9123`\n* **Group:** GetPName"]
  pub const GL_MAX_GEOMETRY_INPUT_COMPONENTS: GLenum = 0x9123;
  #[doc = "`GL_MAX_GEOMETRY_OUTPUT_COMPONENTS: GLenum = 0x9124`\n* **Group:** GetPName"]
  pub const GL_MAX_GEOMETRY_OUTPUT_COMPONENTS: GLenum = 0x9124;
  #[doc = "`GL_MAX_GEOMETRY_OUTPUT_VERTICES: GLenum = 0x8DE0`"]
  pub const GL_MAX_GEOMETRY_OUTPUT_VERTICES: GLenum = 0x8DE0;
  #[doc = "`GL_MAX_GEOMETRY_SHADER_INVOCATIONS: GLenum = 0x8E5A`"]
  pub const GL_MAX_GEOMETRY_SHADER_INVOCATIONS: GLenum = 0x8E5A;
  #[doc = "`GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS: GLenum = 0x90D7`\n* **Group:** GetPName"]
  pub const GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS: GLenum = 0x90D7;
  #[doc = "`GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: GLenum = 0x8C29`\n* **Group:** GetPName"]
  pub const GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: GLenum = 0x8C29;
  #[doc = "`GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: GLenum = 0x8DE1`"]
  pub const GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: GLenum = 0x8DE1;
  #[doc = "`GL_MAX_GEOMETRY_UNIFORM_BLOCKS: GLenum = 0x8A2C`\n* **Group:** GetPName"]
  pub const GL_MAX_GEOMETRY_UNIFORM_BLOCKS: GLenum = 0x8A2C;
  #[doc = "`GL_MAX_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8DDF`\n* **Group:** GetPName"]
  pub const GL_MAX_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8DDF;
  #[doc = "`GL_MAX_HEIGHT: GLenum = 0x827F`\n* **Group:** InternalFormatPName"]
  pub const GL_MAX_HEIGHT: GLenum = 0x827F;
  #[doc = "`GL_MAX_IMAGE_SAMPLES: GLenum = 0x906D`"]
  pub const GL_MAX_IMAGE_SAMPLES: GLenum = 0x906D;
  #[doc = "`GL_MAX_IMAGE_UNITS: GLenum = 0x8F38`"]
  pub const GL_MAX_IMAGE_UNITS: GLenum = 0x8F38;
  #[doc = "`GL_MAX_INTEGER_SAMPLES: GLenum = 0x9110`\n* **Group:** GetPName"]
  pub const GL_MAX_INTEGER_SAMPLES: GLenum = 0x9110;
  #[doc = "`GL_MAX_LABEL_LENGTH: GLenum = 0x82E8`\n* **Group:** GetPName"]
  pub const GL_MAX_LABEL_LENGTH: GLenum = 0x82E8;
  #[doc = "`GL_MAX_LAYERS: GLenum = 0x8281`\n* **Group:** InternalFormatPName"]
  pub const GL_MAX_LAYERS: GLenum = 0x8281;
  #[doc = "`GL_MAX_NAME_LENGTH: GLenum = 0x92F6`\n* **Group:** ProgramInterfacePName"]
  pub const GL_MAX_NAME_LENGTH: GLenum = 0x92F6;
  #[doc = "`GL_MAX_NUM_ACTIVE_VARIABLES: GLenum = 0x92F7`\n* **Group:** ProgramInterfacePName"]
  pub const GL_MAX_NUM_ACTIVE_VARIABLES: GLenum = 0x92F7;
  #[doc = "`GL_MAX_NUM_COMPATIBLE_SUBROUTINES: GLenum = 0x92F8`\n* **Group:** ProgramInterfacePName"]
  pub const GL_MAX_NUM_COMPATIBLE_SUBROUTINES: GLenum = 0x92F8;
  #[doc = "`GL_MAX_PATCH_VERTICES: GLenum = 0x8E7D`"]
  pub const GL_MAX_PATCH_VERTICES: GLenum = 0x8E7D;
  #[doc = "`GL_MAX_PROGRAM_TEXEL_OFFSET: GLenum = 0x8905`\n* **Group:** GetPName"]
  pub const GL_MAX_PROGRAM_TEXEL_OFFSET: GLenum = 0x8905;
  #[doc = "`GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET: GLenum = 0x8E5F`"]
  pub const GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET: GLenum = 0x8E5F;
  #[doc = "`GL_MAX_RECTANGLE_TEXTURE_SIZE: GLenum = 0x84F8`\n* **Group:** GetPName"]
  pub const GL_MAX_RECTANGLE_TEXTURE_SIZE: GLenum = 0x84F8;
  #[doc = "`GL_MAX_RENDERBUFFER_SIZE: GLenum = 0x84E8`\n* **Group:** GetPName"]
  pub const GL_MAX_RENDERBUFFER_SIZE: GLenum = 0x84E8;
  #[doc = "`GL_MAX_SAMPLES: GLenum = 0x8D57`"]
  pub const GL_MAX_SAMPLES: GLenum = 0x8D57;
  #[doc = "`GL_MAX_SAMPLE_MASK_WORDS: GLenum = 0x8E59`\n* **Group:** GetPName"]
  pub const GL_MAX_SAMPLE_MASK_WORDS: GLenum = 0x8E59;
  #[doc = "`GL_MAX_SERVER_WAIT_TIMEOUT: GLenum = 0x9111`\n* **Group:** GetPName"]
  pub const GL_MAX_SERVER_WAIT_TIMEOUT: GLenum = 0x9111;
  #[doc = "`GL_MAX_SHADER_STORAGE_BLOCK_SIZE: GLenum = 0x90DE`"]
  pub const GL_MAX_SHADER_STORAGE_BLOCK_SIZE: GLenum = 0x90DE;
  #[doc = "`GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS: GLenum = 0x90DD`\n* **Group:** GetPName"]
  pub const GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS: GLenum = 0x90DD;
  #[doc = "`GL_MAX_SUBROUTINES: GLenum = 0x8DE7`"]
  pub const GL_MAX_SUBROUTINES: GLenum = 0x8DE7;
  #[doc = "`GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS: GLenum = 0x8DE8`"]
  pub const GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS: GLenum = 0x8DE8;
  #[doc = "`GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS: GLenum = 0x92D3`\n* **Group:** GetPName"]
  pub const GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS: GLenum = 0x92D3;
  #[doc = "`GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CD`"]
  pub const GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CD;
  #[doc = "`GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS: GLenum = 0x90CB`"]
  pub const GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS: GLenum = 0x90CB;
  #[doc = "`GL_MAX_TESS_CONTROL_INPUT_COMPONENTS: GLenum = 0x886C`"]
  pub const GL_MAX_TESS_CONTROL_INPUT_COMPONENTS: GLenum = 0x886C;
  #[doc = "`GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS: GLenum = 0x8E83`"]
  pub const GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS: GLenum = 0x8E83;
  #[doc = "`GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS: GLenum = 0x90D8`\n* **Group:** GetPName"]
  pub const GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS: GLenum = 0x90D8;
  #[doc = "`GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS: GLenum = 0x8E81`"]
  pub const GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS: GLenum = 0x8E81;
  #[doc = "`GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS: GLenum = 0x8E85`"]
  pub const GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS: GLenum = 0x8E85;
  #[doc = "`GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS: GLenum = 0x8E89`\n* **Group:** GetPName"]
  pub const GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS: GLenum = 0x8E89;
  #[doc = "`GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS: GLenum = 0x8E7F`"]
  pub const GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS: GLenum = 0x8E7F;
  #[doc = "`GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS: GLenum = 0x92D4`\n* **Group:** GetPName"]
  pub const GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS: GLenum = 0x92D4;
  #[doc = "`GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CE`"]
  pub const GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CE;
  #[doc = "`GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS: GLenum = 0x90CC`"]
  pub const GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS: GLenum = 0x90CC;
  #[doc = "`GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS: GLenum = 0x886D`"]
  pub const GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS: GLenum = 0x886D;
  #[doc = "`GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS: GLenum = 0x8E86`"]
  pub const GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS: GLenum = 0x8E86;
  #[doc = "`GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS: GLenum = 0x90D9`\n* **Group:** GetPName"]
  pub const GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS: GLenum = 0x90D9;
  #[doc = "`GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS: GLenum = 0x8E82`"]
  pub const GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS: GLenum = 0x8E82;
  #[doc = "`GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS: GLenum = 0x8E8A`\n* **Group:** GetPName"]
  pub const GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS: GLenum = 0x8E8A;
  #[doc = "`GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS: GLenum = 0x8E80`"]
  pub const GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS: GLenum = 0x8E80;
  #[doc = "`GL_MAX_TESS_GEN_LEVEL: GLenum = 0x8E7E`"]
  pub const GL_MAX_TESS_GEN_LEVEL: GLenum = 0x8E7E;
  #[doc = "`GL_MAX_TESS_PATCH_COMPONENTS: GLenum = 0x8E84`"]
  pub const GL_MAX_TESS_PATCH_COMPONENTS: GLenum = 0x8E84;
  #[doc = "`GL_MAX_TEXTURE_BUFFER_SIZE: GLenum = 0x8C2B`\n* **Group:** GetPName"]
  pub const GL_MAX_TEXTURE_BUFFER_SIZE: GLenum = 0x8C2B;
  #[doc = "`GL_MAX_TEXTURE_IMAGE_UNITS: GLenum = 0x8872`\n* **Group:** GetPName"]
  pub const GL_MAX_TEXTURE_IMAGE_UNITS: GLenum = 0x8872;
  #[doc = "`GL_MAX_TEXTURE_LOD_BIAS: GLenum = 0x84FD`\n* **Group:** GetPName"]
  pub const GL_MAX_TEXTURE_LOD_BIAS: GLenum = 0x84FD;
  #[doc = "`GL_MAX_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FF`"]
  pub const GL_MAX_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FF;
  #[doc = "`GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT: GLenum = 0x84FF`\n* **Alias Of:** `GL_MAX_TEXTURE_MAX_ANISOTROPY`"]
  pub const GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT: GLenum = 0x84FF;
  #[doc = "`GL_MAX_TEXTURE_SIZE: GLenum = 0x0D33`\n* **Group:** GetPName"]
  pub const GL_MAX_TEXTURE_SIZE: GLenum = 0x0D33;
  #[doc = "`GL_MAX_TRANSFORM_FEEDBACK_BUFFERS: GLenum = 0x8E70`"]
  pub const GL_MAX_TRANSFORM_FEEDBACK_BUFFERS: GLenum = 0x8E70;
  #[doc = "`GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: GLenum = 0x8C8A`"]
  pub const GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: GLenum = 0x8C8A;
  #[doc = "`GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: GLenum = 0x8C8B`"]
  pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: GLenum = 0x8C8B;
  #[doc = "`GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: GLenum = 0x8C80`"]
  pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: GLenum = 0x8C80;
  #[doc = "`GL_MAX_UNIFORM_BLOCK_SIZE: GLenum = 0x8A30`\n* **Group:** GetPName"]
  pub const GL_MAX_UNIFORM_BLOCK_SIZE: GLenum = 0x8A30;
  #[doc = "`GL_MAX_UNIFORM_BUFFER_BINDINGS: GLenum = 0x8A2F`\n* **Group:** GetPName"]
  pub const GL_MAX_UNIFORM_BUFFER_BINDINGS: GLenum = 0x8A2F;
  #[doc = "`GL_MAX_UNIFORM_LOCATIONS: GLenum = 0x826E`\n* **Group:** GetPName"]
  pub const GL_MAX_UNIFORM_LOCATIONS: GLenum = 0x826E;
  #[doc = "`GL_MAX_VARYING_COMPONENTS: GLenum = 0x8B4B`\n* **Group:** GetPName\n* **Alias Of:** `MAX_VARYING_FLOATS`"]
  pub const GL_MAX_VARYING_COMPONENTS: GLenum = 0x8B4B;
  #[doc = "`GL_MAX_VARYING_FLOATS: GLenum = 0x8B4B`\n* **Group:** GetPName"]
  pub const GL_MAX_VARYING_FLOATS: GLenum = 0x8B4B;
  #[doc = "`GL_MAX_VARYING_VECTORS: GLenum = 0x8DFC`\n* **Group:** GetPName"]
  pub const GL_MAX_VARYING_VECTORS: GLenum = 0x8DFC;
  #[doc = "`GL_MAX_VERTEX_ATOMIC_COUNTERS: GLenum = 0x92D2`\n* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_ATOMIC_COUNTERS: GLenum = 0x92D2;
  #[doc = "`GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CC`"]
  pub const GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CC;
  #[doc = "`GL_MAX_VERTEX_ATTRIBS: GLenum = 0x8869`\n* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_ATTRIBS: GLenum = 0x8869;
  #[doc = "`GL_MAX_VERTEX_ATTRIB_BINDINGS: GLenum = 0x82DA`\n* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_ATTRIB_BINDINGS: GLenum = 0x82DA;
  #[doc = "`GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET: GLenum = 0x82D9`\n* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET: GLenum = 0x82D9;
  #[doc = "`GL_MAX_VERTEX_ATTRIB_STRIDE: GLenum = 0x82E5`"]
  pub const GL_MAX_VERTEX_ATTRIB_STRIDE: GLenum = 0x82E5;
  #[doc = "`GL_MAX_VERTEX_IMAGE_UNIFORMS: GLenum = 0x90CA`"]
  pub const GL_MAX_VERTEX_IMAGE_UNIFORMS: GLenum = 0x90CA;
  #[doc = "`GL_MAX_VERTEX_OUTPUT_COMPONENTS: GLenum = 0x9122`\n* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_OUTPUT_COMPONENTS: GLenum = 0x9122;
  #[doc = "`GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS: GLenum = 0x90D6`\n* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS: GLenum = 0x90D6;
  #[doc = "`GL_MAX_VERTEX_STREAMS: GLenum = 0x8E71`"]
  pub const GL_MAX_VERTEX_STREAMS: GLenum = 0x8E71;
  #[doc = "`GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4C`\n* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4C;
  #[doc = "`GL_MAX_VERTEX_UNIFORM_BLOCKS: GLenum = 0x8A2B`\n* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_UNIFORM_BLOCKS: GLenum = 0x8A2B;
  #[doc = "`GL_MAX_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8B4A`\n* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8B4A;
  #[doc = "`GL_MAX_VERTEX_UNIFORM_VECTORS: GLenum = 0x8DFB`\n* **Group:** GetPName"]
  pub const GL_MAX_VERTEX_UNIFORM_VECTORS: GLenum = 0x8DFB;
  #[doc = "`GL_MAX_VIEWPORTS: GLenum = 0x825B`\n* **Group:** GetPName"]
  pub const GL_MAX_VIEWPORTS: GLenum = 0x825B;
  #[doc = "`GL_MAX_VIEWPORT_DIMS: GLenum = 0x0D3A`\n* **Group:** GetPName"]
  pub const GL_MAX_VIEWPORT_DIMS: GLenum = 0x0D3A;
  #[doc = "`GL_MAX_WIDTH: GLenum = 0x827E`\n* **Group:** InternalFormatPName"]
  pub const GL_MAX_WIDTH: GLenum = 0x827E;
  #[doc = "`GL_MEDIUM_FLOAT: GLenum = 0x8DF1`\n* **Group:** PrecisionType"]
  pub const GL_MEDIUM_FLOAT: GLenum = 0x8DF1;
  #[doc = "`GL_MEDIUM_INT: GLenum = 0x8DF4`\n* **Group:** PrecisionType"]
  pub const GL_MEDIUM_INT: GLenum = 0x8DF4;
  #[doc = "`GL_MIN: GLenum = 0x8007`\n* **Group:** BlendEquationModeEXT"]
  pub const GL_MIN: GLenum = 0x8007;
  #[doc = "`GL_MINOR_VERSION: GLenum = 0x821C`\n* **Group:** GetPName"]
  pub const GL_MINOR_VERSION: GLenum = 0x821C;
  #[doc = "`GL_MIN_FRAGMENT_INTERPOLATION_OFFSET: GLenum = 0x8E5B`"]
  pub const GL_MIN_FRAGMENT_INTERPOLATION_OFFSET: GLenum = 0x8E5B;
  #[doc = "`GL_MIN_MAP_BUFFER_ALIGNMENT: GLenum = 0x90BC`\n* **Group:** GetPName"]
  pub const GL_MIN_MAP_BUFFER_ALIGNMENT: GLenum = 0x90BC;
  #[doc = "`GL_MIN_PROGRAM_TEXEL_OFFSET: GLenum = 0x8904`\n* **Group:** GetPName"]
  pub const GL_MIN_PROGRAM_TEXEL_OFFSET: GLenum = 0x8904;
  #[doc = "`GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET: GLenum = 0x8E5E`"]
  pub const GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET: GLenum = 0x8E5E;
  #[doc = "`GL_MIN_SAMPLE_SHADING_VALUE: GLenum = 0x8C37`"]
  pub const GL_MIN_SAMPLE_SHADING_VALUE: GLenum = 0x8C37;
  #[doc = "`GL_MIPMAP: GLenum = 0x8293`\n* **Group:** InternalFormatPName"]
  pub const GL_MIPMAP: GLenum = 0x8293;
  #[doc = "`GL_MIRRORED_REPEAT: GLenum = 0x8370`\n* **Group:** TextureWrapMode"]
  pub const GL_MIRRORED_REPEAT: GLenum = 0x8370;
  #[doc = "`GL_MIRROR_CLAMP_TO_EDGE: GLenum = 0x8743`"]
  pub const GL_MIRROR_CLAMP_TO_EDGE: GLenum = 0x8743;
  #[doc = "`GL_MULTISAMPLE: GLenum = 0x809D`\n* **Group:** EnableCap"]
  pub const GL_MULTISAMPLE: GLenum = 0x809D;
  #[doc = "`GL_NAME_LENGTH: GLenum = 0x92F9`\n* **Group:** ProgramResourceProperty"]
  pub const GL_NAME_LENGTH: GLenum = 0x92F9;
  #[doc = "`GL_NAND: GLenum = 0x150E`\n* **Group:** LogicOp"]
  pub const GL_NAND: GLenum = 0x150E;
  #[doc = "`GL_NEAREST: GLenum = 0x2600`\n* **Groups:** BlitFramebufferFilter, TextureMagFilter, TextureMinFilter"]
  pub const GL_NEAREST: GLenum = 0x2600;
  #[doc = "`GL_NEAREST_MIPMAP_LINEAR: GLenum = 0x2702`\n* **Group:** TextureMinFilter"]
  pub const GL_NEAREST_MIPMAP_LINEAR: GLenum = 0x2702;
  #[doc = "`GL_NEAREST_MIPMAP_NEAREST: GLenum = 0x2700`\n* **Group:** TextureMinFilter"]
  pub const GL_NEAREST_MIPMAP_NEAREST: GLenum = 0x2700;
  #[doc = "`GL_NEGATIVE_ONE_TO_ONE: GLenum = 0x935E`\n* **Group:** ClipControlDepth"]
  pub const GL_NEGATIVE_ONE_TO_ONE: GLenum = 0x935E;
  #[doc = "`GL_NEVER: GLenum = 0x0200`\n* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_NEVER: GLenum = 0x0200;
  #[doc = "`GL_NICEST: GLenum = 0x1102`\n* **Group:** HintMode"]
  pub const GL_NICEST: GLenum = 0x1102;
  #[doc = "`GL_NONE: GLenum = 0`\n* **Groups:** TextureCompareMode, PathColorFormat, CombinerBiasNV, CombinerScaleNV, DrawBufferMode, PixelTexGenMode, ReadBufferMode, ColorBuffer, PathGenMode, PathTransformType, PathFontStyle"]
  pub const GL_NONE: GLenum = 0;
  #[doc = "`GL_NOOP: GLenum = 0x1505`\n* **Group:** LogicOp"]
  pub const GL_NOOP: GLenum = 0x1505;
  #[doc = "`GL_NOR: GLenum = 0x1508`\n* **Group:** LogicOp"]
  pub const GL_NOR: GLenum = 0x1508;
  #[doc = "`GL_NOTEQUAL: GLenum = 0x0205`\n* **Groups:** StencilFunction, IndexFunctionEXT, AlphaFunction, DepthFunction"]
  pub const GL_NOTEQUAL: GLenum = 0x0205;
  #[doc = "`GL_NO_ERROR: GLenum = 0`\n* **Groups:** GraphicsResetStatus, ErrorCode"]
  pub const GL_NO_ERROR: GLenum = 0;
  #[doc = "`GL_NO_RESET_NOTIFICATION: GLenum = 0x8261`"]
  pub const GL_NO_RESET_NOTIFICATION: GLenum = 0x8261;
  #[doc = "`GL_NUM_ACTIVE_VARIABLES: GLenum = 0x9304`\n* **Group:** ProgramResourceProperty"]
  pub const GL_NUM_ACTIVE_VARIABLES: GLenum = 0x9304;
  #[doc = "`GL_NUM_COMPATIBLE_SUBROUTINES: GLenum = 0x8E4A`\n* **Groups:** ProgramResourceProperty, SubroutineParameterName"]
  pub const GL_NUM_COMPATIBLE_SUBROUTINES: GLenum = 0x8E4A;
  #[doc = "`GL_NUM_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A2`\n* **Group:** GetPName"]
  pub const GL_NUM_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A2;
  #[doc = "`GL_NUM_EXTENSIONS: GLenum = 0x821D`\n* **Group:** GetPName"]
  pub const GL_NUM_EXTENSIONS: GLenum = 0x821D;
  #[doc = "`GL_NUM_PROGRAM_BINARY_FORMATS: GLenum = 0x87FE`\n* **Group:** GetPName"]
  pub const GL_NUM_PROGRAM_BINARY_FORMATS: GLenum = 0x87FE;
  #[doc = "`GL_NUM_SAMPLE_COUNTS: GLenum = 0x9380`\n* **Group:** InternalFormatPName"]
  pub const GL_NUM_SAMPLE_COUNTS: GLenum = 0x9380;
  #[doc = "`GL_NUM_SHADER_BINARY_FORMATS: GLenum = 0x8DF9`\n* **Group:** GetPName"]
  pub const GL_NUM_SHADER_BINARY_FORMATS: GLenum = 0x8DF9;
  #[doc = "`GL_NUM_SHADING_LANGUAGE_VERSIONS: GLenum = 0x82E9`"]
  pub const GL_NUM_SHADING_LANGUAGE_VERSIONS: GLenum = 0x82E9;
  #[doc = "`GL_NUM_SPIR_V_EXTENSIONS: GLenum = 0x9554`"]
  pub const GL_NUM_SPIR_V_EXTENSIONS: GLenum = 0x9554;
  #[doc = "`GL_OBJECT_TYPE: GLenum = 0x9112`\n* **Group:** SyncParameterName"]
  pub const GL_OBJECT_TYPE: GLenum = 0x9112;
  #[doc = "`GL_OFFSET: GLenum = 0x92FC`\n* **Group:** ProgramResourceProperty"]
  pub const GL_OFFSET: GLenum = 0x92FC;
  #[doc = "`GL_ONE: GLenum = 1`\n* **Groups:** TextureSwizzle, BlendingFactor"]
  pub const GL_ONE: GLenum = 1;
  #[doc = "`GL_ONE_MINUS_CONSTANT_ALPHA: GLenum = 0x8004`\n* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_CONSTANT_ALPHA: GLenum = 0x8004;
  #[doc = "`GL_ONE_MINUS_CONSTANT_COLOR: GLenum = 0x8002`\n* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_CONSTANT_COLOR: GLenum = 0x8002;
  #[doc = "`GL_ONE_MINUS_DST_ALPHA: GLenum = 0x0305`\n* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_DST_ALPHA: GLenum = 0x0305;
  #[doc = "`GL_ONE_MINUS_DST_COLOR: GLenum = 0x0307`\n* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_DST_COLOR: GLenum = 0x0307;
  #[doc = "`GL_ONE_MINUS_SRC1_ALPHA: GLenum = 0x88FB`\n* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_SRC1_ALPHA: GLenum = 0x88FB;
  #[doc = "`GL_ONE_MINUS_SRC1_COLOR: GLenum = 0x88FA`\n* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_SRC1_COLOR: GLenum = 0x88FA;
  #[doc = "`GL_ONE_MINUS_SRC_ALPHA: GLenum = 0x0303`\n* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_SRC_ALPHA: GLenum = 0x0303;
  #[doc = "`GL_ONE_MINUS_SRC_COLOR: GLenum = 0x0301`\n* **Group:** BlendingFactor"]
  pub const GL_ONE_MINUS_SRC_COLOR: GLenum = 0x0301;
  #[doc = "`GL_OR: GLenum = 0x1507`\n* **Group:** LogicOp"]
  pub const GL_OR: GLenum = 0x1507;
  #[doc = "`GL_OR_INVERTED: GLenum = 0x150D`\n* **Group:** LogicOp"]
  pub const GL_OR_INVERTED: GLenum = 0x150D;
  #[doc = "`GL_OR_REVERSE: GLenum = 0x150B`\n* **Group:** LogicOp"]
  pub const GL_OR_REVERSE: GLenum = 0x150B;
  #[doc = "`GL_OUT_OF_MEMORY: GLenum = 0x0505`\n* **Group:** ErrorCode"]
  pub const GL_OUT_OF_MEMORY: GLenum = 0x0505;
  #[doc = "`GL_PACK_ALIGNMENT: GLenum = 0x0D05`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_ALIGNMENT: GLenum = 0x0D05;
  #[doc = "`GL_PACK_COMPRESSED_BLOCK_DEPTH: GLenum = 0x912D`"]
  pub const GL_PACK_COMPRESSED_BLOCK_DEPTH: GLenum = 0x912D;
  #[doc = "`GL_PACK_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x912C`"]
  pub const GL_PACK_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x912C;
  #[doc = "`GL_PACK_COMPRESSED_BLOCK_SIZE: GLenum = 0x912E`"]
  pub const GL_PACK_COMPRESSED_BLOCK_SIZE: GLenum = 0x912E;
  #[doc = "`GL_PACK_COMPRESSED_BLOCK_WIDTH: GLenum = 0x912B`"]
  pub const GL_PACK_COMPRESSED_BLOCK_WIDTH: GLenum = 0x912B;
  #[doc = "`GL_PACK_IMAGE_HEIGHT: GLenum = 0x806C`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_IMAGE_HEIGHT: GLenum = 0x806C;
  #[doc = "`GL_PACK_LSB_FIRST: GLenum = 0x0D01`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_LSB_FIRST: GLenum = 0x0D01;
  #[doc = "`GL_PACK_ROW_LENGTH: GLenum = 0x0D02`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_ROW_LENGTH: GLenum = 0x0D02;
  #[doc = "`GL_PACK_SKIP_IMAGES: GLenum = 0x806B`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_SKIP_IMAGES: GLenum = 0x806B;
  #[doc = "`GL_PACK_SKIP_PIXELS: GLenum = 0x0D04`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_SKIP_PIXELS: GLenum = 0x0D04;
  #[doc = "`GL_PACK_SKIP_ROWS: GLenum = 0x0D03`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_SKIP_ROWS: GLenum = 0x0D03;
  #[doc = "`GL_PACK_SWAP_BYTES: GLenum = 0x0D00`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_PACK_SWAP_BYTES: GLenum = 0x0D00;
  #[doc = "`GL_PARAMETER_BUFFER: GLenum = 0x80EE`\n* **Group:** BufferTargetARB"]
  pub const GL_PARAMETER_BUFFER: GLenum = 0x80EE;
  #[doc = "`GL_PARAMETER_BUFFER_BINDING: GLenum = 0x80EF`"]
  pub const GL_PARAMETER_BUFFER_BINDING: GLenum = 0x80EF;
  #[doc = "`GL_PATCHES: GLenum = 0x000E`\n* **Group:** PrimitiveType"]
  pub const GL_PATCHES: GLenum = 0x000E;
  #[doc = "`GL_PATCH_DEFAULT_INNER_LEVEL: GLenum = 0x8E73`\n* **Group:** PatchParameterName"]
  pub const GL_PATCH_DEFAULT_INNER_LEVEL: GLenum = 0x8E73;
  #[doc = "`GL_PATCH_DEFAULT_OUTER_LEVEL: GLenum = 0x8E74`\n* **Group:** PatchParameterName"]
  pub const GL_PATCH_DEFAULT_OUTER_LEVEL: GLenum = 0x8E74;
  #[doc = "`GL_PATCH_VERTICES: GLenum = 0x8E72`\n* **Group:** PatchParameterName"]
  pub const GL_PATCH_VERTICES: GLenum = 0x8E72;
  #[doc = "`GL_PIXEL_BUFFER_BARRIER_BIT: GLbitfield = 0x00000080`\n* **Group:** MemoryBarrierMask"]
  pub const GL_PIXEL_BUFFER_BARRIER_BIT: GLbitfield = 0x00000080;
  #[doc = "`GL_PIXEL_PACK_BUFFER: GLenum = 0x88EB`\n* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_PIXEL_PACK_BUFFER: GLenum = 0x88EB;
  #[doc = "`GL_PIXEL_PACK_BUFFER_BINDING: GLenum = 0x88ED`\n* **Group:** GetPName"]
  pub const GL_PIXEL_PACK_BUFFER_BINDING: GLenum = 0x88ED;
  #[doc = "`GL_PIXEL_UNPACK_BUFFER: GLenum = 0x88EC`\n* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_PIXEL_UNPACK_BUFFER: GLenum = 0x88EC;
  #[doc = "`GL_PIXEL_UNPACK_BUFFER_BINDING: GLenum = 0x88EF`\n* **Group:** GetPName"]
  pub const GL_PIXEL_UNPACK_BUFFER_BINDING: GLenum = 0x88EF;
  #[doc = "`GL_POINT: GLenum = 0x1B00`\n* **Groups:** PolygonMode, MeshMode1, MeshMode2"]
  pub const GL_POINT: GLenum = 0x1B00;
  #[doc = "`GL_POINTS: GLenum = 0x0000`\n* **Group:** PrimitiveType"]
  pub const GL_POINTS: GLenum = 0x0000;
  #[doc = "`GL_POINT_FADE_THRESHOLD_SIZE: GLenum = 0x8128`\n* **Groups:** PointParameterNameSGIS, PointParameterNameARB, GetPName"]
  pub const GL_POINT_FADE_THRESHOLD_SIZE: GLenum = 0x8128;
  #[doc = "`GL_POINT_SIZE: GLenum = 0x0B11`\n* **Group:** GetPName"]
  pub const GL_POINT_SIZE: GLenum = 0x0B11;
  #[doc = "`GL_POINT_SIZE_GRANULARITY: GLenum = 0x0B13`\n* **Group:** GetPName"]
  pub const GL_POINT_SIZE_GRANULARITY: GLenum = 0x0B13;
  #[doc = "`GL_POINT_SIZE_RANGE: GLenum = 0x0B12`\n* **Group:** GetPName"]
  pub const GL_POINT_SIZE_RANGE: GLenum = 0x0B12;
  #[doc = "`GL_POINT_SPRITE_COORD_ORIGIN: GLenum = 0x8CA0`"]
  pub const GL_POINT_SPRITE_COORD_ORIGIN: GLenum = 0x8CA0;
  #[doc = "`GL_POLYGON_MODE: GLenum = 0x0B40`\n* **Group:** GetPName"]
  pub const GL_POLYGON_MODE: GLenum = 0x0B40;
  #[doc = "`GL_POLYGON_OFFSET_CLAMP: GLenum = 0x8E1B`"]
  pub const GL_POLYGON_OFFSET_CLAMP: GLenum = 0x8E1B;
  #[doc = "`GL_POLYGON_OFFSET_FACTOR: GLenum = 0x8038`\n* **Group:** GetPName"]
  pub const GL_POLYGON_OFFSET_FACTOR: GLenum = 0x8038;
  #[doc = "`GL_POLYGON_OFFSET_FILL: GLenum = 0x8037`\n* **Groups:** GetPName, EnableCap"]
  pub const GL_POLYGON_OFFSET_FILL: GLenum = 0x8037;
  #[doc = "`GL_POLYGON_OFFSET_LINE: GLenum = 0x2A02`\n* **Groups:** GetPName, EnableCap"]
  pub const GL_POLYGON_OFFSET_LINE: GLenum = 0x2A02;
  #[doc = "`GL_POLYGON_OFFSET_POINT: GLenum = 0x2A01`\n* **Groups:** GetPName, EnableCap"]
  pub const GL_POLYGON_OFFSET_POINT: GLenum = 0x2A01;
  #[doc = "`GL_POLYGON_OFFSET_UNITS: GLenum = 0x2A00`\n* **Group:** GetPName"]
  pub const GL_POLYGON_OFFSET_UNITS: GLenum = 0x2A00;
  #[doc = "`GL_POLYGON_SMOOTH: GLenum = 0x0B41`\n* **Groups:** GetPName, EnableCap"]
  pub const GL_POLYGON_SMOOTH: GLenum = 0x0B41;
  #[doc = "`GL_POLYGON_SMOOTH_HINT: GLenum = 0x0C53`\n* **Groups:** HintTarget, GetPName"]
  pub const GL_POLYGON_SMOOTH_HINT: GLenum = 0x0C53;
  #[doc = "`GL_PRIMITIVES_GENERATED: GLenum = 0x8C87`\n* **Group:** QueryTarget"]
  pub const GL_PRIMITIVES_GENERATED: GLenum = 0x8C87;
  #[doc = "`GL_PRIMITIVES_SUBMITTED: GLenum = 0x82EF`\n* **Group:** QueryTarget"]
  pub const GL_PRIMITIVES_SUBMITTED: GLenum = 0x82EF;
  #[doc = "`GL_PRIMITIVE_RESTART: GLenum = 0x8F9D`\n* **Group:** EnableCap"]
  pub const GL_PRIMITIVE_RESTART: GLenum = 0x8F9D;
  #[doc = "`GL_PRIMITIVE_RESTART_FIXED_INDEX: GLenum = 0x8D69`\n* **Group:** EnableCap"]
  pub const GL_PRIMITIVE_RESTART_FIXED_INDEX: GLenum = 0x8D69;
  #[doc = "`GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED: GLenum = 0x8221`"]
  pub const GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED: GLenum = 0x8221;
  #[doc = "`GL_PRIMITIVE_RESTART_INDEX: GLenum = 0x8F9E`\n* **Group:** GetPName"]
  pub const GL_PRIMITIVE_RESTART_INDEX: GLenum = 0x8F9E;
  #[doc = "`GL_PROGRAM: GLenum = 0x82E2`\n* **Group:** ObjectIdentifier"]
  pub const GL_PROGRAM: GLenum = 0x82E2;
  #[doc = "`GL_PROGRAM_BINARY_FORMATS: GLenum = 0x87FF`\n* **Group:** GetPName"]
  pub const GL_PROGRAM_BINARY_FORMATS: GLenum = 0x87FF;
  #[doc = "`GL_PROGRAM_BINARY_LENGTH: GLenum = 0x8741`\n* **Group:** ProgramPropertyARB"]
  pub const GL_PROGRAM_BINARY_LENGTH: GLenum = 0x8741;
  #[doc = "`GL_PROGRAM_BINARY_RETRIEVABLE_HINT: GLenum = 0x8257`\n* **Groups:** ProgramParameterPName, HintTarget"]
  pub const GL_PROGRAM_BINARY_RETRIEVABLE_HINT: GLenum = 0x8257;
  #[doc = "`GL_PROGRAM_INPUT: GLenum = 0x92E3`\n* **Group:** ProgramInterface"]
  pub const GL_PROGRAM_INPUT: GLenum = 0x92E3;
  #[doc = "`GL_PROGRAM_OUTPUT: GLenum = 0x92E4`\n* **Group:** ProgramInterface"]
  pub const GL_PROGRAM_OUTPUT: GLenum = 0x92E4;
  #[doc = "`GL_PROGRAM_PIPELINE: GLenum = 0x82E4`\n* **Group:** ObjectIdentifier"]
  pub const GL_PROGRAM_PIPELINE: GLenum = 0x82E4;
  #[doc = "`GL_PROGRAM_PIPELINE_BINDING: GLenum = 0x825A`\n* **Group:** GetPName"]
  pub const GL_PROGRAM_PIPELINE_BINDING: GLenum = 0x825A;
  #[doc = "`GL_PROGRAM_POINT_SIZE: GLenum = 0x8642`\n* **Groups:** GetPName, EnableCap\n* **Alias Of:** `GL_VERTEX_PROGRAM_POINT_SIZE`"]
  pub const GL_PROGRAM_POINT_SIZE: GLenum = 0x8642;
  #[doc = "`GL_PROGRAM_SEPARABLE: GLenum = 0x8258`\n* **Group:** ProgramParameterPName"]
  pub const GL_PROGRAM_SEPARABLE: GLenum = 0x8258;
  #[doc = "`GL_PROVOKING_VERTEX: GLenum = 0x8E4F`\n* **Group:** GetPName"]
  pub const GL_PROVOKING_VERTEX: GLenum = 0x8E4F;
  #[doc = "`GL_PROXY_TEXTURE_1D: GLenum = 0x8063`\n* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_1D: GLenum = 0x8063;
  #[doc = "`GL_PROXY_TEXTURE_1D_ARRAY: GLenum = 0x8C19`\n* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_1D_ARRAY: GLenum = 0x8C19;
  #[doc = "`GL_PROXY_TEXTURE_2D: GLenum = 0x8064`\n* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_2D: GLenum = 0x8064;
  #[doc = "`GL_PROXY_TEXTURE_2D_ARRAY: GLenum = 0x8C1B`\n* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_2D_ARRAY: GLenum = 0x8C1B;
  #[doc = "`GL_PROXY_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9101`\n* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9101;
  #[doc = "`GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9103`\n* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9103;
  #[doc = "`GL_PROXY_TEXTURE_3D: GLenum = 0x8070`\n* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_3D: GLenum = 0x8070;
  #[doc = "`GL_PROXY_TEXTURE_CUBE_MAP: GLenum = 0x851B`\n* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_CUBE_MAP: GLenum = 0x851B;
  #[doc = "`GL_PROXY_TEXTURE_CUBE_MAP_ARRAY: GLenum = 0x900B`\n* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_CUBE_MAP_ARRAY: GLenum = 0x900B;
  #[doc = "`GL_PROXY_TEXTURE_RECTANGLE: GLenum = 0x84F7`\n* **Group:** TextureTarget"]
  pub const GL_PROXY_TEXTURE_RECTANGLE: GLenum = 0x84F7;
  #[doc = "`GL_QUADS: GLenum = 0x0007`\n* **Group:** PrimitiveType"]
  pub const GL_QUADS: GLenum = 0x0007;
  #[doc = "`GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: GLenum = 0x8E4C`"]
  pub const GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: GLenum = 0x8E4C;
  #[doc = "`GL_QUERY: GLenum = 0x82E3`\n* **Group:** ObjectIdentifier"]
  pub const GL_QUERY: GLenum = 0x82E3;
  #[doc = "`GL_QUERY_BUFFER: GLenum = 0x9192`\n* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_QUERY_BUFFER: GLenum = 0x9192;
  #[doc = "`GL_QUERY_BUFFER_BARRIER_BIT: GLbitfield = 0x00008000`\n* **Group:** MemoryBarrierMask"]
  pub const GL_QUERY_BUFFER_BARRIER_BIT: GLbitfield = 0x00008000;
  #[doc = "`GL_QUERY_BUFFER_BINDING: GLenum = 0x9193`"]
  pub const GL_QUERY_BUFFER_BINDING: GLenum = 0x9193;
  #[doc = "`GL_QUERY_BY_REGION_NO_WAIT: GLenum = 0x8E16`\n* **Group:** ConditionalRenderMode"]
  pub const GL_QUERY_BY_REGION_NO_WAIT: GLenum = 0x8E16;
  #[doc = "`GL_QUERY_BY_REGION_NO_WAIT_INVERTED: GLenum = 0x8E1A`\n* **Group:** ConditionalRenderMode"]
  pub const GL_QUERY_BY_REGION_NO_WAIT_INVERTED: GLenum = 0x8E1A;
  #[doc = "`GL_QUERY_BY_REGION_WAIT: GLenum = 0x8E15`\n* **Group:** ConditionalRenderMode"]
  pub const GL_QUERY_BY_REGION_WAIT: GLenum = 0x8E15;
  #[doc = "`GL_QUERY_BY_REGION_WAIT_INVERTED: GLenum = 0x8E19`\n* **Group:** ConditionalRenderMode"]
  pub const GL_QUERY_BY_REGION_WAIT_INVERTED: GLenum = 0x8E19;
  #[doc = "`GL_QUERY_COUNTER_BITS: GLenum = 0x8864`\n* **Group:** QueryParameterName"]
  pub const GL_QUERY_COUNTER_BITS: GLenum = 0x8864;
  #[doc = "`GL_QUERY_NO_WAIT: GLenum = 0x8E14`\n* **Group:** ConditionalRenderMode"]
  pub const GL_QUERY_NO_WAIT: GLenum = 0x8E14;
  #[doc = "`GL_QUERY_NO_WAIT_INVERTED: GLenum = 0x8E18`\n* **Group:** ConditionalRenderMode"]
  pub const GL_QUERY_NO_WAIT_INVERTED: GLenum = 0x8E18;
  #[doc = "`GL_QUERY_RESULT: GLenum = 0x8866`\n* **Group:** QueryObjectParameterName"]
  pub const GL_QUERY_RESULT: GLenum = 0x8866;
  #[doc = "`GL_QUERY_RESULT_AVAILABLE: GLenum = 0x8867`\n* **Group:** QueryObjectParameterName"]
  pub const GL_QUERY_RESULT_AVAILABLE: GLenum = 0x8867;
  #[doc = "`GL_QUERY_RESULT_NO_WAIT: GLenum = 0x9194`\n* **Group:** QueryObjectParameterName"]
  pub const GL_QUERY_RESULT_NO_WAIT: GLenum = 0x9194;
  #[doc = "`GL_QUERY_TARGET: GLenum = 0x82EA`\n* **Group:** QueryObjectParameterName"]
  pub const GL_QUERY_TARGET: GLenum = 0x82EA;
  #[doc = "`GL_QUERY_WAIT: GLenum = 0x8E13`\n* **Group:** ConditionalRenderMode"]
  pub const GL_QUERY_WAIT: GLenum = 0x8E13;
  #[doc = "`GL_QUERY_WAIT_INVERTED: GLenum = 0x8E17`\n* **Group:** ConditionalRenderMode"]
  pub const GL_QUERY_WAIT_INVERTED: GLenum = 0x8E17;
  #[doc = "`GL_R11F_G11F_B10F: GLenum = 0x8C3A`\n* **Group:** InternalFormat"]
  pub const GL_R11F_G11F_B10F: GLenum = 0x8C3A;
  #[doc = "`GL_R16: GLenum = 0x822A`\n* **Group:** InternalFormat"]
  pub const GL_R16: GLenum = 0x822A;
  #[doc = "`GL_R16F: GLenum = 0x822D`\n* **Group:** InternalFormat"]
  pub const GL_R16F: GLenum = 0x822D;
  #[doc = "`GL_R16I: GLenum = 0x8233`\n* **Group:** InternalFormat"]
  pub const GL_R16I: GLenum = 0x8233;
  #[doc = "`GL_R16UI: GLenum = 0x8234`\n* **Group:** InternalFormat"]
  pub const GL_R16UI: GLenum = 0x8234;
  #[doc = "`GL_R16_SNORM: GLenum = 0x8F98`\n* **Group:** InternalFormat"]
  pub const GL_R16_SNORM: GLenum = 0x8F98;
  #[doc = "`GL_R32F: GLenum = 0x822E`\n* **Group:** InternalFormat"]
  pub const GL_R32F: GLenum = 0x822E;
  #[doc = "`GL_R32I: GLenum = 0x8235`\n* **Group:** InternalFormat"]
  pub const GL_R32I: GLenum = 0x8235;
  #[doc = "`GL_R32UI: GLenum = 0x8236`\n* **Group:** InternalFormat"]
  pub const GL_R32UI: GLenum = 0x8236;
  #[doc = "`GL_R3_G3_B2: GLenum = 0x2A10`\n* **Group:** InternalFormat"]
  pub const GL_R3_G3_B2: GLenum = 0x2A10;
  #[doc = "`GL_R8: GLenum = 0x8229`\n* **Group:** InternalFormat"]
  pub const GL_R8: GLenum = 0x8229;
  #[doc = "`GL_R8I: GLenum = 0x8231`\n* **Group:** InternalFormat"]
  pub const GL_R8I: GLenum = 0x8231;
  #[doc = "`GL_R8UI: GLenum = 0x8232`\n* **Group:** InternalFormat"]
  pub const GL_R8UI: GLenum = 0x8232;
  #[doc = "`GL_R8_SNORM: GLenum = 0x8F94`\n* **Group:** InternalFormat"]
  pub const GL_R8_SNORM: GLenum = 0x8F94;
  #[doc = "`GL_RASTERIZER_DISCARD: GLenum = 0x8C89`\n* **Group:** EnableCap"]
  pub const GL_RASTERIZER_DISCARD: GLenum = 0x8C89;
  #[doc = "`GL_READ_BUFFER: GLenum = 0x0C02`\n* **Group:** GetPName"]
  pub const GL_READ_BUFFER: GLenum = 0x0C02;
  #[doc = "`GL_READ_FRAMEBUFFER: GLenum = 0x8CA8`\n* **Groups:** CheckFramebufferStatusTarget, FramebufferTarget"]
  pub const GL_READ_FRAMEBUFFER: GLenum = 0x8CA8;
  #[doc = "`GL_READ_FRAMEBUFFER_BINDING: GLenum = 0x8CAA`\n* **Group:** GetPName"]
  pub const GL_READ_FRAMEBUFFER_BINDING: GLenum = 0x8CAA;
  #[doc = "`GL_READ_ONLY: GLenum = 0x88B8`\n* **Group:** BufferAccessARB"]
  pub const GL_READ_ONLY: GLenum = 0x88B8;
  #[doc = "`GL_READ_PIXELS: GLenum = 0x828C`\n* **Group:** InternalFormatPName"]
  pub const GL_READ_PIXELS: GLenum = 0x828C;
  #[doc = "`GL_READ_PIXELS_FORMAT: GLenum = 0x828D`\n* **Group:** InternalFormatPName"]
  pub const GL_READ_PIXELS_FORMAT: GLenum = 0x828D;
  #[doc = "`GL_READ_PIXELS_TYPE: GLenum = 0x828E`\n* **Group:** InternalFormatPName"]
  pub const GL_READ_PIXELS_TYPE: GLenum = 0x828E;
  #[doc = "`GL_READ_WRITE: GLenum = 0x88BA`\n* **Group:** BufferAccessARB"]
  pub const GL_READ_WRITE: GLenum = 0x88BA;
  #[doc = "`GL_RED: GLenum = 0x1903`\n* **Groups:** TextureSwizzle, PixelFormat, InternalFormat"]
  pub const GL_RED: GLenum = 0x1903;
  #[doc = "`GL_RED_INTEGER: GLenum = 0x8D94`\n* **Group:** PixelFormat"]
  pub const GL_RED_INTEGER: GLenum = 0x8D94;
  #[doc = "`GL_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x930B`\n* **Group:** ProgramResourceProperty"]
  pub const GL_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x930B;
  #[doc = "`GL_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x930A`\n* **Group:** ProgramResourceProperty"]
  pub const GL_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x930A;
  #[doc = "`GL_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x9309`\n* **Group:** ProgramResourceProperty"]
  pub const GL_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x9309;
  #[doc = "`GL_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x9307`\n* **Group:** ProgramResourceProperty"]
  pub const GL_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x9307;
  #[doc = "`GL_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x9308`\n* **Group:** ProgramResourceProperty"]
  pub const GL_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x9308;
  #[doc = "`GL_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x9306`\n* **Group:** ProgramResourceProperty"]
  pub const GL_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x9306;
  #[doc = "`GL_RENDERBUFFER: GLenum = 0x8D41`\n* **Groups:** ObjectIdentifier, RenderbufferTarget, CopyImageSubDataTarget"]
  pub const GL_RENDERBUFFER: GLenum = 0x8D41;
  #[doc = "`GL_RENDERBUFFER_ALPHA_SIZE: GLenum = 0x8D53`\n* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_ALPHA_SIZE: GLenum = 0x8D53;
  #[doc = "`GL_RENDERBUFFER_BINDING: GLenum = 0x8CA7`\n* **Group:** GetPName"]
  pub const GL_RENDERBUFFER_BINDING: GLenum = 0x8CA7;
  #[doc = "`GL_RENDERBUFFER_BLUE_SIZE: GLenum = 0x8D52`\n* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_BLUE_SIZE: GLenum = 0x8D52;
  #[doc = "`GL_RENDERBUFFER_DEPTH_SIZE: GLenum = 0x8D54`\n* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_DEPTH_SIZE: GLenum = 0x8D54;
  #[doc = "`GL_RENDERBUFFER_GREEN_SIZE: GLenum = 0x8D51`\n* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_GREEN_SIZE: GLenum = 0x8D51;
  #[doc = "`GL_RENDERBUFFER_HEIGHT: GLenum = 0x8D43`\n* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_HEIGHT: GLenum = 0x8D43;
  #[doc = "`GL_RENDERBUFFER_INTERNAL_FORMAT: GLenum = 0x8D44`\n* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_INTERNAL_FORMAT: GLenum = 0x8D44;
  #[doc = "`GL_RENDERBUFFER_RED_SIZE: GLenum = 0x8D50`\n* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_RED_SIZE: GLenum = 0x8D50;
  #[doc = "`GL_RENDERBUFFER_SAMPLES: GLenum = 0x8CAB`\n* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_SAMPLES: GLenum = 0x8CAB;
  #[doc = "`GL_RENDERBUFFER_STENCIL_SIZE: GLenum = 0x8D55`\n* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_STENCIL_SIZE: GLenum = 0x8D55;
  #[doc = "`GL_RENDERBUFFER_WIDTH: GLenum = 0x8D42`\n* **Group:** RenderbufferParameterName"]
  pub const GL_RENDERBUFFER_WIDTH: GLenum = 0x8D42;
  #[doc = "`GL_RENDERER: GLenum = 0x1F01`\n* **Group:** StringName"]
  pub const GL_RENDERER: GLenum = 0x1F01;
  #[doc = "`GL_REPEAT: GLenum = 0x2901`\n* **Group:** TextureWrapMode"]
  pub const GL_REPEAT: GLenum = 0x2901;
  #[doc = "`GL_REPLACE: GLenum = 0x1E01`\n* **Groups:** StencilOp, LightEnvModeSGIX"]
  pub const GL_REPLACE: GLenum = 0x1E01;
  #[doc = "`GL_RESET_NOTIFICATION_STRATEGY: GLenum = 0x8256`"]
  pub const GL_RESET_NOTIFICATION_STRATEGY: GLenum = 0x8256;
  #[doc = "`GL_RG: GLenum = 0x8227`\n* **Groups:** InternalFormat, PixelFormat"]
  pub const GL_RG: GLenum = 0x8227;
  #[doc = "`GL_RG16: GLenum = 0x822C`\n* **Group:** InternalFormat"]
  pub const GL_RG16: GLenum = 0x822C;
  #[doc = "`GL_RG16F: GLenum = 0x822F`\n* **Group:** InternalFormat"]
  pub const GL_RG16F: GLenum = 0x822F;
  #[doc = "`GL_RG16I: GLenum = 0x8239`\n* **Group:** InternalFormat"]
  pub const GL_RG16I: GLenum = 0x8239;
  #[doc = "`GL_RG16UI: GLenum = 0x823A`\n* **Group:** InternalFormat"]
  pub const GL_RG16UI: GLenum = 0x823A;
  #[doc = "`GL_RG16_SNORM: GLenum = 0x8F99`\n* **Group:** InternalFormat"]
  pub const GL_RG16_SNORM: GLenum = 0x8F99;
  #[doc = "`GL_RG32F: GLenum = 0x8230`\n* **Group:** InternalFormat"]
  pub const GL_RG32F: GLenum = 0x8230;
  #[doc = "`GL_RG32I: GLenum = 0x823B`\n* **Group:** InternalFormat"]
  pub const GL_RG32I: GLenum = 0x823B;
  #[doc = "`GL_RG32UI: GLenum = 0x823C`\n* **Group:** InternalFormat"]
  pub const GL_RG32UI: GLenum = 0x823C;
  #[doc = "`GL_RG8: GLenum = 0x822B`\n* **Group:** InternalFormat"]
  pub const GL_RG8: GLenum = 0x822B;
  #[doc = "`GL_RG8I: GLenum = 0x8237`\n* **Group:** InternalFormat"]
  pub const GL_RG8I: GLenum = 0x8237;
  #[doc = "`GL_RG8UI: GLenum = 0x8238`\n* **Group:** InternalFormat"]
  pub const GL_RG8UI: GLenum = 0x8238;
  #[doc = "`GL_RG8_SNORM: GLenum = 0x8F95`\n* **Group:** InternalFormat"]
  pub const GL_RG8_SNORM: GLenum = 0x8F95;
  #[doc = "`GL_RGB: GLenum = 0x1907`\n* **Groups:** PixelTexGenMode, CombinerPortionNV, PathColorFormat, CombinerComponentUsageNV, PixelFormat, InternalFormat"]
  pub const GL_RGB: GLenum = 0x1907;
  #[doc = "`GL_RGB10: GLenum = 0x8052`\n* **Group:** InternalFormat"]
  pub const GL_RGB10: GLenum = 0x8052;
  #[doc = "`GL_RGB10_A2: GLenum = 0x8059`\n* **Group:** InternalFormat"]
  pub const GL_RGB10_A2: GLenum = 0x8059;
  #[doc = "`GL_RGB10_A2UI: GLenum = 0x906F`\n* **Group:** InternalFormat"]
  pub const GL_RGB10_A2UI: GLenum = 0x906F;
  #[doc = "`GL_RGB12: GLenum = 0x8053`\n* **Group:** InternalFormat"]
  pub const GL_RGB12: GLenum = 0x8053;
  #[doc = "`GL_RGB16: GLenum = 0x8054`\n* **Group:** InternalFormat"]
  pub const GL_RGB16: GLenum = 0x8054;
  #[doc = "`GL_RGB16F: GLenum = 0x881B`\n* **Group:** InternalFormat"]
  pub const GL_RGB16F: GLenum = 0x881B;
  #[doc = "`GL_RGB16I: GLenum = 0x8D89`\n* **Group:** InternalFormat"]
  pub const GL_RGB16I: GLenum = 0x8D89;
  #[doc = "`GL_RGB16UI: GLenum = 0x8D77`\n* **Group:** InternalFormat"]
  pub const GL_RGB16UI: GLenum = 0x8D77;
  #[doc = "`GL_RGB16_SNORM: GLenum = 0x8F9A`\n* **Group:** InternalFormat"]
  pub const GL_RGB16_SNORM: GLenum = 0x8F9A;
  #[doc = "`GL_RGB32F: GLenum = 0x8815`\n* **Group:** InternalFormat"]
  pub const GL_RGB32F: GLenum = 0x8815;
  #[doc = "`GL_RGB32I: GLenum = 0x8D83`\n* **Group:** InternalFormat"]
  pub const GL_RGB32I: GLenum = 0x8D83;
  #[doc = "`GL_RGB32UI: GLenum = 0x8D71`\n* **Group:** InternalFormat"]
  pub const GL_RGB32UI: GLenum = 0x8D71;
  #[doc = "`GL_RGB4: GLenum = 0x804F`\n* **Group:** InternalFormat"]
  pub const GL_RGB4: GLenum = 0x804F;
  #[doc = "`GL_RGB5: GLenum = 0x8050`\n* **Group:** InternalFormat"]
  pub const GL_RGB5: GLenum = 0x8050;
  #[doc = "`GL_RGB565: GLenum = 0x8D62`"]
  pub const GL_RGB565: GLenum = 0x8D62;
  #[doc = "`GL_RGB5_A1: GLenum = 0x8057`\n* **Group:** InternalFormat"]
  pub const GL_RGB5_A1: GLenum = 0x8057;
  #[doc = "`GL_RGB8: GLenum = 0x8051`\n* **Group:** InternalFormat"]
  pub const GL_RGB8: GLenum = 0x8051;
  #[doc = "`GL_RGB8I: GLenum = 0x8D8F`\n* **Group:** InternalFormat"]
  pub const GL_RGB8I: GLenum = 0x8D8F;
  #[doc = "`GL_RGB8UI: GLenum = 0x8D7D`\n* **Group:** InternalFormat"]
  pub const GL_RGB8UI: GLenum = 0x8D7D;
  #[doc = "`GL_RGB8_SNORM: GLenum = 0x8F96`\n* **Group:** InternalFormat"]
  pub const GL_RGB8_SNORM: GLenum = 0x8F96;
  #[doc = "`GL_RGB9_E5: GLenum = 0x8C3D`\n* **Group:** InternalFormat"]
  pub const GL_RGB9_E5: GLenum = 0x8C3D;
  #[doc = "`GL_RGBA: GLenum = 0x1908`\n* **Groups:** PixelTexGenMode, PathColorFormat, PixelFormat, InternalFormat"]
  pub const GL_RGBA: GLenum = 0x1908;
  #[doc = "`GL_RGBA12: GLenum = 0x805A`\n* **Group:** InternalFormat"]
  pub const GL_RGBA12: GLenum = 0x805A;
  #[doc = "`GL_RGBA16: GLenum = 0x805B`\n* **Group:** InternalFormat"]
  pub const GL_RGBA16: GLenum = 0x805B;
  #[doc = "`GL_RGBA16F: GLenum = 0x881A`\n* **Group:** InternalFormat"]
  pub const GL_RGBA16F: GLenum = 0x881A;
  #[doc = "`GL_RGBA16I: GLenum = 0x8D88`\n* **Group:** InternalFormat"]
  pub const GL_RGBA16I: GLenum = 0x8D88;
  #[doc = "`GL_RGBA16UI: GLenum = 0x8D76`\n* **Group:** InternalFormat"]
  pub const GL_RGBA16UI: GLenum = 0x8D76;
  #[doc = "`GL_RGBA16_SNORM: GLenum = 0x8F9B`"]
  pub const GL_RGBA16_SNORM: GLenum = 0x8F9B;
  #[doc = "`GL_RGBA2: GLenum = 0x8055`"]
  pub const GL_RGBA2: GLenum = 0x8055;
  #[doc = "`GL_RGBA32F: GLenum = 0x8814`\n* **Group:** InternalFormat"]
  pub const GL_RGBA32F: GLenum = 0x8814;
  #[doc = "`GL_RGBA32I: GLenum = 0x8D82`\n* **Group:** InternalFormat"]
  pub const GL_RGBA32I: GLenum = 0x8D82;
  #[doc = "`GL_RGBA32UI: GLenum = 0x8D70`\n* **Group:** InternalFormat"]
  pub const GL_RGBA32UI: GLenum = 0x8D70;
  #[doc = "`GL_RGBA4: GLenum = 0x8056`\n* **Group:** InternalFormat"]
  pub const GL_RGBA4: GLenum = 0x8056;
  #[doc = "`GL_RGBA8: GLenum = 0x8058`\n* **Group:** InternalFormat"]
  pub const GL_RGBA8: GLenum = 0x8058;
  #[doc = "`GL_RGBA8I: GLenum = 0x8D8E`\n* **Group:** InternalFormat"]
  pub const GL_RGBA8I: GLenum = 0x8D8E;
  #[doc = "`GL_RGBA8UI: GLenum = 0x8D7C`\n* **Group:** InternalFormat"]
  pub const GL_RGBA8UI: GLenum = 0x8D7C;
  #[doc = "`GL_RGBA8_SNORM: GLenum = 0x8F97`\n* **Group:** InternalFormat"]
  pub const GL_RGBA8_SNORM: GLenum = 0x8F97;
  #[doc = "`GL_RGBA_INTEGER: GLenum = 0x8D99`\n* **Group:** PixelFormat"]
  pub const GL_RGBA_INTEGER: GLenum = 0x8D99;
  #[doc = "`GL_RGB_INTEGER: GLenum = 0x8D98`\n* **Group:** PixelFormat"]
  pub const GL_RGB_INTEGER: GLenum = 0x8D98;
  #[doc = "`GL_RG_INTEGER: GLenum = 0x8228`\n* **Group:** PixelFormat"]
  pub const GL_RG_INTEGER: GLenum = 0x8228;
  #[doc = "`GL_RIGHT: GLenum = 0x0407`\n* **Groups:** ColorBuffer, DrawBufferMode, ReadBufferMode"]
  pub const GL_RIGHT: GLenum = 0x0407;
  #[doc = "`GL_SAMPLER: GLenum = 0x82E6`\n* **Group:** ObjectIdentifier"]
  pub const GL_SAMPLER: GLenum = 0x82E6;
  #[doc = "`GL_SAMPLER_1D: GLenum = 0x8B5D`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_1D: GLenum = 0x8B5D;
  #[doc = "`GL_SAMPLER_1D_ARRAY: GLenum = 0x8DC0`\n* **Groups:** GlslTypeToken, UniformType"]
  pub const GL_SAMPLER_1D_ARRAY: GLenum = 0x8DC0;
  #[doc = "`GL_SAMPLER_1D_ARRAY_SHADOW: GLenum = 0x8DC3`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_1D_ARRAY_SHADOW: GLenum = 0x8DC3;
  #[doc = "`GL_SAMPLER_1D_SHADOW: GLenum = 0x8B61`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_1D_SHADOW: GLenum = 0x8B61;
  #[doc = "`GL_SAMPLER_2D: GLenum = 0x8B5E`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D: GLenum = 0x8B5E;
  #[doc = "`GL_SAMPLER_2D_ARRAY: GLenum = 0x8DC1`\n* **Groups:** GlslTypeToken, UniformType"]
  pub const GL_SAMPLER_2D_ARRAY: GLenum = 0x8DC1;
  #[doc = "`GL_SAMPLER_2D_ARRAY_SHADOW: GLenum = 0x8DC4`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D_ARRAY_SHADOW: GLenum = 0x8DC4;
  #[doc = "`GL_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9108`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9108;
  #[doc = "`GL_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910B`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910B;
  #[doc = "`GL_SAMPLER_2D_RECT: GLenum = 0x8B63`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D_RECT: GLenum = 0x8B63;
  #[doc = "`GL_SAMPLER_2D_RECT_SHADOW: GLenum = 0x8B64`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D_RECT_SHADOW: GLenum = 0x8B64;
  #[doc = "`GL_SAMPLER_2D_SHADOW: GLenum = 0x8B62`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_2D_SHADOW: GLenum = 0x8B62;
  #[doc = "`GL_SAMPLER_3D: GLenum = 0x8B5F`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_3D: GLenum = 0x8B5F;
  #[doc = "`GL_SAMPLER_BINDING: GLenum = 0x8919`\n* **Group:** GetPName"]
  pub const GL_SAMPLER_BINDING: GLenum = 0x8919;
  #[doc = "`GL_SAMPLER_BUFFER: GLenum = 0x8DC2`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_BUFFER: GLenum = 0x8DC2;
  #[doc = "`GL_SAMPLER_CUBE: GLenum = 0x8B60`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_CUBE: GLenum = 0x8B60;
  #[doc = "`GL_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900C`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900C;
  #[doc = "`GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW: GLenum = 0x900D`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW: GLenum = 0x900D;
  #[doc = "`GL_SAMPLER_CUBE_SHADOW: GLenum = 0x8DC5`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_SAMPLER_CUBE_SHADOW: GLenum = 0x8DC5;
  #[doc = "`GL_SAMPLES: GLenum = 0x80A9`\n* **Groups:** GetFramebufferParameter, GetPName, InternalFormatPName"]
  pub const GL_SAMPLES: GLenum = 0x80A9;
  #[doc = "`GL_SAMPLES_PASSED: GLenum = 0x8914`\n* **Group:** QueryTarget"]
  pub const GL_SAMPLES_PASSED: GLenum = 0x8914;
  #[doc = "`GL_SAMPLE_ALPHA_TO_COVERAGE: GLenum = 0x809E`\n* **Group:** EnableCap"]
  pub const GL_SAMPLE_ALPHA_TO_COVERAGE: GLenum = 0x809E;
  #[doc = "`GL_SAMPLE_ALPHA_TO_ONE: GLenum = 0x809F`\n* **Group:** EnableCap"]
  pub const GL_SAMPLE_ALPHA_TO_ONE: GLenum = 0x809F;
  #[doc = "`GL_SAMPLE_BUFFERS: GLenum = 0x80A8`\n* **Groups:** GetFramebufferParameter, GetPName"]
  pub const GL_SAMPLE_BUFFERS: GLenum = 0x80A8;
  #[doc = "`GL_SAMPLE_COVERAGE: GLenum = 0x80A0`\n* **Group:** EnableCap"]
  pub const GL_SAMPLE_COVERAGE: GLenum = 0x80A0;
  #[doc = "`GL_SAMPLE_COVERAGE_INVERT: GLenum = 0x80AB`\n* **Group:** GetPName"]
  pub const GL_SAMPLE_COVERAGE_INVERT: GLenum = 0x80AB;
  #[doc = "`GL_SAMPLE_COVERAGE_VALUE: GLenum = 0x80AA`\n* **Group:** GetPName"]
  pub const GL_SAMPLE_COVERAGE_VALUE: GLenum = 0x80AA;
  #[doc = "`GL_SAMPLE_MASK: GLenum = 0x8E51`\n* **Group:** EnableCap"]
  pub const GL_SAMPLE_MASK: GLenum = 0x8E51;
  #[doc = "`GL_SAMPLE_MASK_VALUE: GLenum = 0x8E52`"]
  pub const GL_SAMPLE_MASK_VALUE: GLenum = 0x8E52;
  #[doc = "`GL_SAMPLE_POSITION: GLenum = 0x8E50`\n* **Group:** GetMultisamplePNameNV"]
  pub const GL_SAMPLE_POSITION: GLenum = 0x8E50;
  #[doc = "`GL_SAMPLE_SHADING: GLenum = 0x8C36`\n* **Group:** EnableCap"]
  pub const GL_SAMPLE_SHADING: GLenum = 0x8C36;
  #[doc = "`GL_SCISSOR_BOX: GLenum = 0x0C10`\n* **Group:** GetPName"]
  pub const GL_SCISSOR_BOX: GLenum = 0x0C10;
  #[doc = "`GL_SCISSOR_TEST: GLenum = 0x0C11`\n* **Groups:** GetPName, EnableCap"]
  pub const GL_SCISSOR_TEST: GLenum = 0x0C11;
  #[doc = "`GL_SEPARATE_ATTRIBS: GLenum = 0x8C8D`\n* **Group:** TransformFeedbackBufferMode"]
  pub const GL_SEPARATE_ATTRIBS: GLenum = 0x8C8D;
  #[doc = "`GL_SET: GLenum = 0x150F`\n* **Group:** LogicOp"]
  pub const GL_SET: GLenum = 0x150F;
  #[doc = "`GL_SHADER: GLenum = 0x82E1`\n* **Group:** ObjectIdentifier"]
  pub const GL_SHADER: GLenum = 0x82E1;
  #[doc = "`GL_SHADER_BINARY_FORMATS: GLenum = 0x8DF8`"]
  pub const GL_SHADER_BINARY_FORMATS: GLenum = 0x8DF8;
  #[doc = "`GL_SHADER_BINARY_FORMAT_SPIR_V: GLenum = 0x9551`"]
  pub const GL_SHADER_BINARY_FORMAT_SPIR_V: GLenum = 0x9551;
  #[doc = "`GL_SHADER_COMPILER: GLenum = 0x8DFA`\n* **Group:** GetPName"]
  pub const GL_SHADER_COMPILER: GLenum = 0x8DFA;
  #[doc = "`GL_SHADER_IMAGE_ACCESS_BARRIER_BIT: GLbitfield = 0x00000020`\n* **Group:** MemoryBarrierMask"]
  pub const GL_SHADER_IMAGE_ACCESS_BARRIER_BIT: GLbitfield = 0x00000020;
  #[doc = "`GL_SHADER_IMAGE_ATOMIC: GLenum = 0x82A6`\n* **Group:** InternalFormatPName"]
  pub const GL_SHADER_IMAGE_ATOMIC: GLenum = 0x82A6;
  #[doc = "`GL_SHADER_IMAGE_LOAD: GLenum = 0x82A4`\n* **Group:** InternalFormatPName"]
  pub const GL_SHADER_IMAGE_LOAD: GLenum = 0x82A4;
  #[doc = "`GL_SHADER_IMAGE_STORE: GLenum = 0x82A5`\n* **Group:** InternalFormatPName"]
  pub const GL_SHADER_IMAGE_STORE: GLenum = 0x82A5;
  #[doc = "`GL_SHADER_SOURCE_LENGTH: GLenum = 0x8B88`\n* **Group:** ShaderParameterName"]
  pub const GL_SHADER_SOURCE_LENGTH: GLenum = 0x8B88;
  #[doc = "`GL_SHADER_STORAGE_BARRIER_BIT: GLbitfield = 0x00002000`\n* **Group:** MemoryBarrierMask"]
  pub const GL_SHADER_STORAGE_BARRIER_BIT: GLbitfield = 0x00002000;
  #[doc = "`GL_SHADER_STORAGE_BLOCK: GLenum = 0x92E6`\n* **Group:** ProgramInterface"]
  pub const GL_SHADER_STORAGE_BLOCK: GLenum = 0x92E6;
  #[doc = "`GL_SHADER_STORAGE_BUFFER: GLenum = 0x90D2`\n* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_SHADER_STORAGE_BUFFER: GLenum = 0x90D2;
  #[doc = "`GL_SHADER_STORAGE_BUFFER_BINDING: GLenum = 0x90D3`\n* **Group:** GetPName"]
  pub const GL_SHADER_STORAGE_BUFFER_BINDING: GLenum = 0x90D3;
  #[doc = "`GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x90DF`\n* **Group:** GetPName"]
  pub const GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x90DF;
  #[doc = "`GL_SHADER_STORAGE_BUFFER_SIZE: GLenum = 0x90D5`\n* **Group:** GetPName"]
  pub const GL_SHADER_STORAGE_BUFFER_SIZE: GLenum = 0x90D5;
  #[doc = "`GL_SHADER_STORAGE_BUFFER_START: GLenum = 0x90D4`\n* **Group:** GetPName"]
  pub const GL_SHADER_STORAGE_BUFFER_START: GLenum = 0x90D4;
  #[doc = "`GL_SHADER_TYPE: GLenum = 0x8B4F`\n* **Group:** ShaderParameterName"]
  pub const GL_SHADER_TYPE: GLenum = 0x8B4F;
  #[doc = "`GL_SHADING_LANGUAGE_VERSION: GLenum = 0x8B8C`\n* **Group:** StringName"]
  pub const GL_SHADING_LANGUAGE_VERSION: GLenum = 0x8B8C;
  #[doc = "`GL_SHORT: GLenum = 0x1402`\n* **Groups:** VertexAttribIType, SecondaryColorPointerTypeIBM, WeightPointerTypeARB, TangentPointerTypeEXT, BinormalPointerTypeEXT, IndexPointerType, ListNameType, NormalPointerType, PixelType, TexCoordPointerType, VertexPointerType, VertexAttribType, VertexAttribPointerType"]
  pub const GL_SHORT: GLenum = 0x1402;
  #[doc = "`GL_SIGNALED: GLenum = 0x9119`"]
  pub const GL_SIGNALED: GLenum = 0x9119;
  #[doc = "`GL_SIGNED_NORMALIZED: GLenum = 0x8F9C`"]
  pub const GL_SIGNED_NORMALIZED: GLenum = 0x8F9C;
  #[doc = "`GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST: GLenum = 0x82AC`\n* **Group:** InternalFormatPName"]
  pub const GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST: GLenum = 0x82AC;
  #[doc = "`GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE: GLenum = 0x82AE`\n* **Group:** InternalFormatPName"]
  pub const GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE: GLenum = 0x82AE;
  #[doc = "`GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST: GLenum = 0x82AD`\n* **Group:** InternalFormatPName"]
  pub const GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST: GLenum = 0x82AD;
  #[doc = "`GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE: GLenum = 0x82AF`\n* **Group:** InternalFormatPName"]
  pub const GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE: GLenum = 0x82AF;
  #[doc = "`GL_SMOOTH_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23`\n* **Group:** GetPName\n* **Alias Of:** `GL_LINE_WIDTH_GRANULARITY`"]
  pub const GL_SMOOTH_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23;
  #[doc = "`GL_SMOOTH_LINE_WIDTH_RANGE: GLenum = 0x0B22`\n* **Group:** GetPName\n* **Alias Of:** `GL_LINE_WIDTH_RANGE`"]
  pub const GL_SMOOTH_LINE_WIDTH_RANGE: GLenum = 0x0B22;
  #[doc = "`GL_SMOOTH_POINT_SIZE_GRANULARITY: GLenum = 0x0B13`\n* **Group:** GetPName\n* **Alias Of:** `GL_POINT_SIZE_GRANULARITY`"]
  pub const GL_SMOOTH_POINT_SIZE_GRANULARITY: GLenum = 0x0B13;
  #[doc = "`GL_SMOOTH_POINT_SIZE_RANGE: GLenum = 0x0B12`\n* **Group:** GetPName\n* **Alias Of:** `GL_POINT_SIZE_RANGE`"]
  pub const GL_SMOOTH_POINT_SIZE_RANGE: GLenum = 0x0B12;
  #[doc = "`GL_SPIR_V_BINARY: GLenum = 0x9552`"]
  pub const GL_SPIR_V_BINARY: GLenum = 0x9552;
  #[doc = "`GL_SPIR_V_EXTENSIONS: GLenum = 0x9553`"]
  pub const GL_SPIR_V_EXTENSIONS: GLenum = 0x9553;
  #[doc = "`GL_SRC1_ALPHA: GLenum = 0x8589`\n* **Group:** BlendingFactor\n* **Alias Of:** `GL_SOURCE1_ALPHA`"]
  pub const GL_SRC1_ALPHA: GLenum = 0x8589;
  #[doc = "`GL_SRC1_COLOR: GLenum = 0x88F9`\n* **Group:** BlendingFactor"]
  pub const GL_SRC1_COLOR: GLenum = 0x88F9;
  #[doc = "`GL_SRC_ALPHA: GLenum = 0x0302`\n* **Group:** BlendingFactor"]
  pub const GL_SRC_ALPHA: GLenum = 0x0302;
  #[doc = "`GL_SRC_ALPHA_SATURATE: GLenum = 0x0308`\n* **Group:** BlendingFactor"]
  pub const GL_SRC_ALPHA_SATURATE: GLenum = 0x0308;
  #[doc = "`GL_SRC_COLOR: GLenum = 0x0300`\n* **Group:** BlendingFactor"]
  pub const GL_SRC_COLOR: GLenum = 0x0300;
  #[doc = "`GL_SRGB: GLenum = 0x8C40`\n* **Group:** InternalFormat"]
  pub const GL_SRGB: GLenum = 0x8C40;
  #[doc = "`GL_SRGB8: GLenum = 0x8C41`\n* **Group:** InternalFormat"]
  pub const GL_SRGB8: GLenum = 0x8C41;
  #[doc = "`GL_SRGB8_ALPHA8: GLenum = 0x8C43`\n* **Group:** InternalFormat"]
  pub const GL_SRGB8_ALPHA8: GLenum = 0x8C43;
  #[doc = "`GL_SRGB_ALPHA: GLenum = 0x8C42`\n* **Group:** InternalFormat"]
  pub const GL_SRGB_ALPHA: GLenum = 0x8C42;
  #[doc = "`GL_SRGB_READ: GLenum = 0x8297`\n* **Group:** InternalFormatPName"]
  pub const GL_SRGB_READ: GLenum = 0x8297;
  #[doc = "`GL_SRGB_WRITE: GLenum = 0x8298`\n* **Group:** InternalFormatPName"]
  pub const GL_SRGB_WRITE: GLenum = 0x8298;
  #[doc = "`GL_STACK_OVERFLOW: GLenum = 0x0503`\n* **Group:** ErrorCode"]
  pub const GL_STACK_OVERFLOW: GLenum = 0x0503;
  #[doc = "`GL_STACK_UNDERFLOW: GLenum = 0x0504`\n* **Group:** ErrorCode"]
  pub const GL_STACK_UNDERFLOW: GLenum = 0x0504;
  #[doc = "`GL_STATIC_COPY: GLenum = 0x88E6`\n* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_STATIC_COPY: GLenum = 0x88E6;
  #[doc = "`GL_STATIC_DRAW: GLenum = 0x88E4`\n* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_STATIC_DRAW: GLenum = 0x88E4;
  #[doc = "`GL_STATIC_READ: GLenum = 0x88E5`\n* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_STATIC_READ: GLenum = 0x88E5;
  #[doc = "`GL_STENCIL: GLenum = 0x1802`\n* **Groups:** Buffer, PixelCopyType, InvalidateFramebufferAttachment"]
  pub const GL_STENCIL: GLenum = 0x1802;
  #[doc = "`GL_STENCIL_ATTACHMENT: GLenum = 0x8D20`\n* **Group:** FramebufferAttachment"]
  pub const GL_STENCIL_ATTACHMENT: GLenum = 0x8D20;
  #[doc = "`GL_STENCIL_BACK_FAIL: GLenum = 0x8801`\n* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_FAIL: GLenum = 0x8801;
  #[doc = "`GL_STENCIL_BACK_FUNC: GLenum = 0x8800`\n* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_FUNC: GLenum = 0x8800;
  #[doc = "`GL_STENCIL_BACK_PASS_DEPTH_FAIL: GLenum = 0x8802`\n* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_PASS_DEPTH_FAIL: GLenum = 0x8802;
  #[doc = "`GL_STENCIL_BACK_PASS_DEPTH_PASS: GLenum = 0x8803`\n* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_PASS_DEPTH_PASS: GLenum = 0x8803;
  #[doc = "`GL_STENCIL_BACK_REF: GLenum = 0x8CA3`\n* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_REF: GLenum = 0x8CA3;
  #[doc = "`GL_STENCIL_BACK_VALUE_MASK: GLenum = 0x8CA4`\n* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_VALUE_MASK: GLenum = 0x8CA4;
  #[doc = "`GL_STENCIL_BACK_WRITEMASK: GLenum = 0x8CA5`\n* **Group:** GetPName"]
  pub const GL_STENCIL_BACK_WRITEMASK: GLenum = 0x8CA5;
  #[doc = "`GL_STENCIL_BUFFER_BIT: GLbitfield = 0x00000400`\n* **Groups:** ClearBufferMask, AttribMask"]
  pub const GL_STENCIL_BUFFER_BIT: GLbitfield = 0x00000400;
  #[doc = "`GL_STENCIL_CLEAR_VALUE: GLenum = 0x0B91`\n* **Group:** GetPName"]
  pub const GL_STENCIL_CLEAR_VALUE: GLenum = 0x0B91;
  #[doc = "`GL_STENCIL_COMPONENTS: GLenum = 0x8285`"]
  pub const GL_STENCIL_COMPONENTS: GLenum = 0x8285;
  #[doc = "`GL_STENCIL_FAIL: GLenum = 0x0B94`\n* **Group:** GetPName"]
  pub const GL_STENCIL_FAIL: GLenum = 0x0B94;
  #[doc = "`GL_STENCIL_FUNC: GLenum = 0x0B92`\n* **Group:** GetPName"]
  pub const GL_STENCIL_FUNC: GLenum = 0x0B92;
  #[doc = "`GL_STENCIL_INDEX: GLenum = 0x1901`\n* **Groups:** InternalFormat, PixelFormat"]
  pub const GL_STENCIL_INDEX: GLenum = 0x1901;
  #[doc = "`GL_STENCIL_INDEX1: GLenum = 0x8D46`\n* **Group:** InternalFormat"]
  pub const GL_STENCIL_INDEX1: GLenum = 0x8D46;
  #[doc = "`GL_STENCIL_INDEX16: GLenum = 0x8D49`\n* **Group:** InternalFormat"]
  pub const GL_STENCIL_INDEX16: GLenum = 0x8D49;
  #[doc = "`GL_STENCIL_INDEX4: GLenum = 0x8D47`\n* **Group:** InternalFormat"]
  pub const GL_STENCIL_INDEX4: GLenum = 0x8D47;
  #[doc = "`GL_STENCIL_INDEX8: GLenum = 0x8D48`\n* **Group:** InternalFormat"]
  pub const GL_STENCIL_INDEX8: GLenum = 0x8D48;
  #[doc = "`GL_STENCIL_PASS_DEPTH_FAIL: GLenum = 0x0B95`\n* **Group:** GetPName"]
  pub const GL_STENCIL_PASS_DEPTH_FAIL: GLenum = 0x0B95;
  #[doc = "`GL_STENCIL_PASS_DEPTH_PASS: GLenum = 0x0B96`\n* **Group:** GetPName"]
  pub const GL_STENCIL_PASS_DEPTH_PASS: GLenum = 0x0B96;
  #[doc = "`GL_STENCIL_REF: GLenum = 0x0B97`\n* **Group:** GetPName"]
  pub const GL_STENCIL_REF: GLenum = 0x0B97;
  #[doc = "`GL_STENCIL_RENDERABLE: GLenum = 0x8288`\n* **Group:** InternalFormatPName"]
  pub const GL_STENCIL_RENDERABLE: GLenum = 0x8288;
  #[doc = "`GL_STENCIL_TEST: GLenum = 0x0B90`\n* **Groups:** GetPName, EnableCap"]
  pub const GL_STENCIL_TEST: GLenum = 0x0B90;
  #[doc = "`GL_STENCIL_VALUE_MASK: GLenum = 0x0B93`\n* **Group:** GetPName"]
  pub const GL_STENCIL_VALUE_MASK: GLenum = 0x0B93;
  #[doc = "`GL_STENCIL_WRITEMASK: GLenum = 0x0B98`\n* **Group:** GetPName"]
  pub const GL_STENCIL_WRITEMASK: GLenum = 0x0B98;
  #[doc = "`GL_STEREO: GLenum = 0x0C33`\n* **Groups:** GetFramebufferParameter, GetPName"]
  pub const GL_STEREO: GLenum = 0x0C33;
  #[doc = "`GL_STREAM_COPY: GLenum = 0x88E2`\n* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_STREAM_COPY: GLenum = 0x88E2;
  #[doc = "`GL_STREAM_DRAW: GLenum = 0x88E0`\n* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_STREAM_DRAW: GLenum = 0x88E0;
  #[doc = "`GL_STREAM_READ: GLenum = 0x88E1`\n* **Groups:** VertexBufferObjectUsage, BufferUsageARB"]
  pub const GL_STREAM_READ: GLenum = 0x88E1;
  #[doc = "`GL_SUBPIXEL_BITS: GLenum = 0x0D50`\n* **Group:** GetPName"]
  pub const GL_SUBPIXEL_BITS: GLenum = 0x0D50;
  #[doc = "`GL_SYNC_CONDITION: GLenum = 0x9113`\n* **Group:** SyncParameterName"]
  pub const GL_SYNC_CONDITION: GLenum = 0x9113;
  #[doc = "`GL_SYNC_FENCE: GLenum = 0x9116`"]
  pub const GL_SYNC_FENCE: GLenum = 0x9116;
  #[doc = "`GL_SYNC_FLAGS: GLenum = 0x9115`\n* **Group:** SyncParameterName"]
  pub const GL_SYNC_FLAGS: GLenum = 0x9115;
  #[doc = "`GL_SYNC_FLUSH_COMMANDS_BIT: GLbitfield = 0x00000001`\n* **Group:** SyncObjectMask"]
  pub const GL_SYNC_FLUSH_COMMANDS_BIT: GLbitfield = 0x00000001;
  #[doc = "`GL_SYNC_GPU_COMMANDS_COMPLETE: GLenum = 0x9117`\n* **Group:** SyncCondition"]
  pub const GL_SYNC_GPU_COMMANDS_COMPLETE: GLenum = 0x9117;
  #[doc = "`GL_SYNC_STATUS: GLenum = 0x9114`\n* **Group:** SyncParameterName"]
  pub const GL_SYNC_STATUS: GLenum = 0x9114;
  #[doc = "`GL_TESS_CONTROL_OUTPUT_VERTICES: GLenum = 0x8E75`"]
  pub const GL_TESS_CONTROL_OUTPUT_VERTICES: GLenum = 0x8E75;
  #[doc = "`GL_TESS_CONTROL_SHADER: GLenum = 0x8E88`\n* **Groups:** PipelineParameterName, ShaderType"]
  pub const GL_TESS_CONTROL_SHADER: GLenum = 0x8E88;
  #[doc = "`GL_TESS_CONTROL_SHADER_BIT: GLbitfield = 0x00000008`\n* **Group:** UseProgramStageMask"]
  pub const GL_TESS_CONTROL_SHADER_BIT: GLbitfield = 0x00000008;
  #[doc = "`GL_TESS_CONTROL_SHADER_PATCHES: GLenum = 0x82F1`"]
  pub const GL_TESS_CONTROL_SHADER_PATCHES: GLenum = 0x82F1;
  #[doc = "`GL_TESS_CONTROL_SUBROUTINE: GLenum = 0x92E9`\n* **Group:** ProgramInterface"]
  pub const GL_TESS_CONTROL_SUBROUTINE: GLenum = 0x92E9;
  #[doc = "`GL_TESS_CONTROL_SUBROUTINE_UNIFORM: GLenum = 0x92EF`\n* **Group:** ProgramInterface"]
  pub const GL_TESS_CONTROL_SUBROUTINE_UNIFORM: GLenum = 0x92EF;
  #[doc = "`GL_TESS_CONTROL_TEXTURE: GLenum = 0x829C`\n* **Group:** InternalFormatPName"]
  pub const GL_TESS_CONTROL_TEXTURE: GLenum = 0x829C;
  #[doc = "`GL_TESS_EVALUATION_SHADER: GLenum = 0x8E87`\n* **Groups:** PipelineParameterName, ShaderType"]
  pub const GL_TESS_EVALUATION_SHADER: GLenum = 0x8E87;
  #[doc = "`GL_TESS_EVALUATION_SHADER_BIT: GLbitfield = 0x00000010`\n* **Group:** UseProgramStageMask"]
  pub const GL_TESS_EVALUATION_SHADER_BIT: GLbitfield = 0x00000010;
  #[doc = "`GL_TESS_EVALUATION_SHADER_INVOCATIONS: GLenum = 0x82F2`"]
  pub const GL_TESS_EVALUATION_SHADER_INVOCATIONS: GLenum = 0x82F2;
  #[doc = "`GL_TESS_EVALUATION_SUBROUTINE: GLenum = 0x92EA`\n* **Group:** ProgramInterface"]
  pub const GL_TESS_EVALUATION_SUBROUTINE: GLenum = 0x92EA;
  #[doc = "`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM: GLenum = 0x92F0`\n* **Group:** ProgramInterface"]
  pub const GL_TESS_EVALUATION_SUBROUTINE_UNIFORM: GLenum = 0x92F0;
  #[doc = "`GL_TESS_EVALUATION_TEXTURE: GLenum = 0x829D`\n* **Group:** InternalFormatPName"]
  pub const GL_TESS_EVALUATION_TEXTURE: GLenum = 0x829D;
  #[doc = "`GL_TESS_GEN_MODE: GLenum = 0x8E76`"]
  pub const GL_TESS_GEN_MODE: GLenum = 0x8E76;
  #[doc = "`GL_TESS_GEN_POINT_MODE: GLenum = 0x8E79`"]
  pub const GL_TESS_GEN_POINT_MODE: GLenum = 0x8E79;
  #[doc = "`GL_TESS_GEN_SPACING: GLenum = 0x8E77`"]
  pub const GL_TESS_GEN_SPACING: GLenum = 0x8E77;
  #[doc = "`GL_TESS_GEN_VERTEX_ORDER: GLenum = 0x8E78`"]
  pub const GL_TESS_GEN_VERTEX_ORDER: GLenum = 0x8E78;
  #[doc = "`GL_TEXTURE: GLenum = 0x1702`\n* **Groups:** ObjectIdentifier, MatrixMode"]
  pub const GL_TEXTURE: GLenum = 0x1702;
  #[doc = "`GL_TEXTURE0: GLenum = 0x84C0`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE0: GLenum = 0x84C0;
  #[doc = "`GL_TEXTURE1: GLenum = 0x84C1`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE1: GLenum = 0x84C1;
  #[doc = "`GL_TEXTURE10: GLenum = 0x84CA`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE10: GLenum = 0x84CA;
  #[doc = "`GL_TEXTURE11: GLenum = 0x84CB`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE11: GLenum = 0x84CB;
  #[doc = "`GL_TEXTURE12: GLenum = 0x84CC`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE12: GLenum = 0x84CC;
  #[doc = "`GL_TEXTURE13: GLenum = 0x84CD`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE13: GLenum = 0x84CD;
  #[doc = "`GL_TEXTURE14: GLenum = 0x84CE`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE14: GLenum = 0x84CE;
  #[doc = "`GL_TEXTURE15: GLenum = 0x84CF`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE15: GLenum = 0x84CF;
  #[doc = "`GL_TEXTURE16: GLenum = 0x84D0`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE16: GLenum = 0x84D0;
  #[doc = "`GL_TEXTURE17: GLenum = 0x84D1`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE17: GLenum = 0x84D1;
  #[doc = "`GL_TEXTURE18: GLenum = 0x84D2`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE18: GLenum = 0x84D2;
  #[doc = "`GL_TEXTURE19: GLenum = 0x84D3`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE19: GLenum = 0x84D3;
  #[doc = "`GL_TEXTURE2: GLenum = 0x84C2`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE2: GLenum = 0x84C2;
  #[doc = "`GL_TEXTURE20: GLenum = 0x84D4`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE20: GLenum = 0x84D4;
  #[doc = "`GL_TEXTURE21: GLenum = 0x84D5`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE21: GLenum = 0x84D5;
  #[doc = "`GL_TEXTURE22: GLenum = 0x84D6`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE22: GLenum = 0x84D6;
  #[doc = "`GL_TEXTURE23: GLenum = 0x84D7`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE23: GLenum = 0x84D7;
  #[doc = "`GL_TEXTURE24: GLenum = 0x84D8`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE24: GLenum = 0x84D8;
  #[doc = "`GL_TEXTURE25: GLenum = 0x84D9`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE25: GLenum = 0x84D9;
  #[doc = "`GL_TEXTURE26: GLenum = 0x84DA`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE26: GLenum = 0x84DA;
  #[doc = "`GL_TEXTURE27: GLenum = 0x84DB`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE27: GLenum = 0x84DB;
  #[doc = "`GL_TEXTURE28: GLenum = 0x84DC`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE28: GLenum = 0x84DC;
  #[doc = "`GL_TEXTURE29: GLenum = 0x84DD`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE29: GLenum = 0x84DD;
  #[doc = "`GL_TEXTURE3: GLenum = 0x84C3`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE3: GLenum = 0x84C3;
  #[doc = "`GL_TEXTURE30: GLenum = 0x84DE`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE30: GLenum = 0x84DE;
  #[doc = "`GL_TEXTURE31: GLenum = 0x84DF`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE31: GLenum = 0x84DF;
  #[doc = "`GL_TEXTURE4: GLenum = 0x84C4`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE4: GLenum = 0x84C4;
  #[doc = "`GL_TEXTURE5: GLenum = 0x84C5`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE5: GLenum = 0x84C5;
  #[doc = "`GL_TEXTURE6: GLenum = 0x84C6`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE6: GLenum = 0x84C6;
  #[doc = "`GL_TEXTURE7: GLenum = 0x84C7`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE7: GLenum = 0x84C7;
  #[doc = "`GL_TEXTURE8: GLenum = 0x84C8`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE8: GLenum = 0x84C8;
  #[doc = "`GL_TEXTURE9: GLenum = 0x84C9`\n* **Group:** TextureUnit"]
  pub const GL_TEXTURE9: GLenum = 0x84C9;
  #[doc = "`GL_TEXTURE_1D: GLenum = 0x0DE0`\n* **Groups:** CopyImageSubDataTarget, EnableCap, GetPName, TextureTarget"]
  pub const GL_TEXTURE_1D: GLenum = 0x0DE0;
  #[doc = "`GL_TEXTURE_1D_ARRAY: GLenum = 0x8C18`\n* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_1D_ARRAY: GLenum = 0x8C18;
  #[doc = "`GL_TEXTURE_2D: GLenum = 0x0DE1`\n* **Groups:** CopyImageSubDataTarget, EnableCap, GetPName, TextureTarget"]
  pub const GL_TEXTURE_2D: GLenum = 0x0DE1;
  #[doc = "`GL_TEXTURE_2D_ARRAY: GLenum = 0x8C1A`\n* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_2D_ARRAY: GLenum = 0x8C1A;
  #[doc = "`GL_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9100`\n* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9100;
  #[doc = "`GL_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9102`\n* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9102;
  #[doc = "`GL_TEXTURE_3D: GLenum = 0x806F`\n* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_3D: GLenum = 0x806F;
  #[doc = "`GL_TEXTURE_ALPHA_SIZE: GLenum = 0x805F`\n* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_ALPHA_SIZE: GLenum = 0x805F;
  #[doc = "`GL_TEXTURE_ALPHA_TYPE: GLenum = 0x8C13`"]
  pub const GL_TEXTURE_ALPHA_TYPE: GLenum = 0x8C13;
  #[doc = "`GL_TEXTURE_BASE_LEVEL: GLenum = 0x813C`\n* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_BASE_LEVEL: GLenum = 0x813C;
  #[doc = "`GL_TEXTURE_BINDING_1D: GLenum = 0x8068`\n* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_1D: GLenum = 0x8068;
  #[doc = "`GL_TEXTURE_BINDING_1D_ARRAY: GLenum = 0x8C1C`\n* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_1D_ARRAY: GLenum = 0x8C1C;
  #[doc = "`GL_TEXTURE_BINDING_2D: GLenum = 0x8069`\n* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_2D: GLenum = 0x8069;
  #[doc = "`GL_TEXTURE_BINDING_2D_ARRAY: GLenum = 0x8C1D`\n* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_2D_ARRAY: GLenum = 0x8C1D;
  #[doc = "`GL_TEXTURE_BINDING_2D_MULTISAMPLE: GLenum = 0x9104`\n* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE: GLenum = 0x9104;
  #[doc = "`GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: GLenum = 0x9105`\n* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: GLenum = 0x9105;
  #[doc = "`GL_TEXTURE_BINDING_3D: GLenum = 0x806A`\n* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_3D: GLenum = 0x806A;
  #[doc = "`GL_TEXTURE_BINDING_BUFFER: GLenum = 0x8C2C`\n* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_BUFFER: GLenum = 0x8C2C;
  #[doc = "`GL_TEXTURE_BINDING_CUBE_MAP: GLenum = 0x8514`\n* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_CUBE_MAP: GLenum = 0x8514;
  #[doc = "`GL_TEXTURE_BINDING_CUBE_MAP_ARRAY: GLenum = 0x900A`"]
  pub const GL_TEXTURE_BINDING_CUBE_MAP_ARRAY: GLenum = 0x900A;
  #[doc = "`GL_TEXTURE_BINDING_RECTANGLE: GLenum = 0x84F6`\n* **Group:** GetPName"]
  pub const GL_TEXTURE_BINDING_RECTANGLE: GLenum = 0x84F6;
  #[doc = "`GL_TEXTURE_BLUE_SIZE: GLenum = 0x805E`\n* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_BLUE_SIZE: GLenum = 0x805E;
  #[doc = "`GL_TEXTURE_BLUE_TYPE: GLenum = 0x8C12`"]
  pub const GL_TEXTURE_BLUE_TYPE: GLenum = 0x8C12;
  #[doc = "`GL_TEXTURE_BORDER_COLOR: GLenum = 0x1004`\n* **Groups:** SamplerParameterF, GetTextureParameter, TextureParameterName"]
  pub const GL_TEXTURE_BORDER_COLOR: GLenum = 0x1004;
  #[doc = "`GL_TEXTURE_BUFFER: GLenum = 0x8C2A`\n* **Groups:** TextureTarget, CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_TEXTURE_BUFFER: GLenum = 0x8C2A;
  #[doc = "`GL_TEXTURE_BUFFER_BINDING: GLenum = 0x8C2A`"]
  pub const GL_TEXTURE_BUFFER_BINDING: GLenum = 0x8C2A;
  #[doc = "`GL_TEXTURE_BUFFER_DATA_STORE_BINDING: GLenum = 0x8C2D`"]
  pub const GL_TEXTURE_BUFFER_DATA_STORE_BINDING: GLenum = 0x8C2D;
  #[doc = "`GL_TEXTURE_BUFFER_OFFSET: GLenum = 0x919D`"]
  pub const GL_TEXTURE_BUFFER_OFFSET: GLenum = 0x919D;
  #[doc = "`GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x919F`\n* **Group:** GetPName"]
  pub const GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x919F;
  #[doc = "`GL_TEXTURE_BUFFER_SIZE: GLenum = 0x919E`"]
  pub const GL_TEXTURE_BUFFER_SIZE: GLenum = 0x919E;
  #[doc = "`GL_TEXTURE_COMPARE_FUNC: GLenum = 0x884D`\n* **Groups:** SamplerParameterI, TextureParameterName"]
  pub const GL_TEXTURE_COMPARE_FUNC: GLenum = 0x884D;
  #[doc = "`GL_TEXTURE_COMPARE_MODE: GLenum = 0x884C`\n* **Groups:** SamplerParameterI, TextureParameterName"]
  pub const GL_TEXTURE_COMPARE_MODE: GLenum = 0x884C;
  #[doc = "`GL_TEXTURE_COMPRESSED: GLenum = 0x86A1`\n* **Group:** InternalFormatPName"]
  pub const GL_TEXTURE_COMPRESSED: GLenum = 0x86A1;
  #[doc = "`GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x82B2`\n* **Group:** InternalFormatPName"]
  pub const GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x82B2;
  #[doc = "`GL_TEXTURE_COMPRESSED_BLOCK_SIZE: GLenum = 0x82B3`\n* **Group:** InternalFormatPName"]
  pub const GL_TEXTURE_COMPRESSED_BLOCK_SIZE: GLenum = 0x82B3;
  #[doc = "`GL_TEXTURE_COMPRESSED_BLOCK_WIDTH: GLenum = 0x82B1`\n* **Group:** InternalFormatPName"]
  pub const GL_TEXTURE_COMPRESSED_BLOCK_WIDTH: GLenum = 0x82B1;
  #[doc = "`GL_TEXTURE_COMPRESSED_IMAGE_SIZE: GLenum = 0x86A0`"]
  pub const GL_TEXTURE_COMPRESSED_IMAGE_SIZE: GLenum = 0x86A0;
  #[doc = "`GL_TEXTURE_COMPRESSION_HINT: GLenum = 0x84EF`\n* **Groups:** HintTarget, GetPName"]
  pub const GL_TEXTURE_COMPRESSION_HINT: GLenum = 0x84EF;
  #[doc = "`GL_TEXTURE_CUBE_MAP: GLenum = 0x8513`\n* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP: GLenum = 0x8513;
  #[doc = "`GL_TEXTURE_CUBE_MAP_ARRAY: GLenum = 0x9009`\n* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_ARRAY: GLenum = 0x9009;
  #[doc = "`GL_TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum = 0x8516`\n* **Group:** TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum = 0x8516;
  #[doc = "`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum = 0x8518`\n* **Group:** TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum = 0x8518;
  #[doc = "`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum = 0x851A`\n* **Group:** TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum = 0x851A;
  #[doc = "`GL_TEXTURE_CUBE_MAP_POSITIVE_X: GLenum = 0x8515`\n* **Group:** TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_POSITIVE_X: GLenum = 0x8515;
  #[doc = "`GL_TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum = 0x8517`\n* **Group:** TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum = 0x8517;
  #[doc = "`GL_TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum = 0x8519`\n* **Group:** TextureTarget"]
  pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum = 0x8519;
  #[doc = "`GL_TEXTURE_CUBE_MAP_SEAMLESS: GLenum = 0x884F`\n* **Group:** EnableCap"]
  pub const GL_TEXTURE_CUBE_MAP_SEAMLESS: GLenum = 0x884F;
  #[doc = "`GL_TEXTURE_DEPTH: GLenum = 0x8071`"]
  pub const GL_TEXTURE_DEPTH: GLenum = 0x8071;
  #[doc = "`GL_TEXTURE_DEPTH_SIZE: GLenum = 0x884A`"]
  pub const GL_TEXTURE_DEPTH_SIZE: GLenum = 0x884A;
  #[doc = "`GL_TEXTURE_DEPTH_TYPE: GLenum = 0x8C16`"]
  pub const GL_TEXTURE_DEPTH_TYPE: GLenum = 0x8C16;
  #[doc = "`GL_TEXTURE_FETCH_BARRIER_BIT: GLbitfield = 0x00000008`\n* **Group:** MemoryBarrierMask"]
  pub const GL_TEXTURE_FETCH_BARRIER_BIT: GLbitfield = 0x00000008;
  #[doc = "`GL_TEXTURE_FIXED_SAMPLE_LOCATIONS: GLenum = 0x9107`"]
  pub const GL_TEXTURE_FIXED_SAMPLE_LOCATIONS: GLenum = 0x9107;
  #[doc = "`GL_TEXTURE_GATHER: GLenum = 0x82A2`\n* **Group:** InternalFormatPName"]
  pub const GL_TEXTURE_GATHER: GLenum = 0x82A2;
  #[doc = "`GL_TEXTURE_GATHER_SHADOW: GLenum = 0x82A3`\n* **Group:** InternalFormatPName"]
  pub const GL_TEXTURE_GATHER_SHADOW: GLenum = 0x82A3;
  #[doc = "`GL_TEXTURE_GREEN_SIZE: GLenum = 0x805D`\n* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_GREEN_SIZE: GLenum = 0x805D;
  #[doc = "`GL_TEXTURE_GREEN_TYPE: GLenum = 0x8C11`"]
  pub const GL_TEXTURE_GREEN_TYPE: GLenum = 0x8C11;
  #[doc = "`GL_TEXTURE_HEIGHT: GLenum = 0x1001`\n* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_HEIGHT: GLenum = 0x1001;
  #[doc = "`GL_TEXTURE_IMAGE_FORMAT: GLenum = 0x828F`\n* **Group:** InternalFormatPName"]
  pub const GL_TEXTURE_IMAGE_FORMAT: GLenum = 0x828F;
  #[doc = "`GL_TEXTURE_IMAGE_TYPE: GLenum = 0x8290`\n* **Group:** InternalFormatPName"]
  pub const GL_TEXTURE_IMAGE_TYPE: GLenum = 0x8290;
  #[doc = "`GL_TEXTURE_IMMUTABLE_FORMAT: GLenum = 0x912F`"]
  pub const GL_TEXTURE_IMMUTABLE_FORMAT: GLenum = 0x912F;
  #[doc = "`GL_TEXTURE_IMMUTABLE_LEVELS: GLenum = 0x82DF`"]
  pub const GL_TEXTURE_IMMUTABLE_LEVELS: GLenum = 0x82DF;
  #[doc = "`GL_TEXTURE_INTERNAL_FORMAT: GLenum = 0x1003`\n* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_INTERNAL_FORMAT: GLenum = 0x1003;
  #[doc = "`GL_TEXTURE_LOD_BIAS: GLenum = 0x8501`\n* **Groups:** TextureParameterName, SamplerParameterF"]
  pub const GL_TEXTURE_LOD_BIAS: GLenum = 0x8501;
  #[doc = "`GL_TEXTURE_MAG_FILTER: GLenum = 0x2800`\n* **Groups:** SamplerParameterI, GetTextureParameter, TextureParameterName"]
  pub const GL_TEXTURE_MAG_FILTER: GLenum = 0x2800;
  #[doc = "`GL_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FE`\n* **Group:** SamplerParameterF"]
  pub const GL_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FE;
  #[doc = "`GL_TEXTURE_MAX_ANISOTROPY_EXT: GLenum = 0x84FE`\n* **Alias Of:** `GL_TEXTURE_MAX_ANISOTROPY`"]
  pub const GL_TEXTURE_MAX_ANISOTROPY_EXT: GLenum = 0x84FE;
  #[doc = "`GL_TEXTURE_MAX_LEVEL: GLenum = 0x813D`\n* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_MAX_LEVEL: GLenum = 0x813D;
  #[doc = "`GL_TEXTURE_MAX_LOD: GLenum = 0x813B`\n* **Groups:** SamplerParameterF, TextureParameterName"]
  pub const GL_TEXTURE_MAX_LOD: GLenum = 0x813B;
  #[doc = "`GL_TEXTURE_MIN_FILTER: GLenum = 0x2801`\n* **Groups:** SamplerParameterI, GetTextureParameter, TextureParameterName"]
  pub const GL_TEXTURE_MIN_FILTER: GLenum = 0x2801;
  #[doc = "`GL_TEXTURE_MIN_LOD: GLenum = 0x813A`\n* **Groups:** SamplerParameterF, TextureParameterName"]
  pub const GL_TEXTURE_MIN_LOD: GLenum = 0x813A;
  #[doc = "`GL_TEXTURE_RECTANGLE: GLenum = 0x84F5`\n* **Groups:** CopyImageSubDataTarget, TextureTarget"]
  pub const GL_TEXTURE_RECTANGLE: GLenum = 0x84F5;
  #[doc = "`GL_TEXTURE_RED_SIZE: GLenum = 0x805C`\n* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_RED_SIZE: GLenum = 0x805C;
  #[doc = "`GL_TEXTURE_RED_TYPE: GLenum = 0x8C10`"]
  pub const GL_TEXTURE_RED_TYPE: GLenum = 0x8C10;
  #[doc = "`GL_TEXTURE_SAMPLES: GLenum = 0x9106`"]
  pub const GL_TEXTURE_SAMPLES: GLenum = 0x9106;
  #[doc = "`GL_TEXTURE_SHADOW: GLenum = 0x82A1`\n* **Group:** InternalFormatPName"]
  pub const GL_TEXTURE_SHADOW: GLenum = 0x82A1;
  #[doc = "`GL_TEXTURE_SHARED_SIZE: GLenum = 0x8C3F`"]
  pub const GL_TEXTURE_SHARED_SIZE: GLenum = 0x8C3F;
  #[doc = "`GL_TEXTURE_STENCIL_SIZE: GLenum = 0x88F1`"]
  pub const GL_TEXTURE_STENCIL_SIZE: GLenum = 0x88F1;
  #[doc = "`GL_TEXTURE_SWIZZLE_A: GLenum = 0x8E45`\n* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_SWIZZLE_A: GLenum = 0x8E45;
  #[doc = "`GL_TEXTURE_SWIZZLE_B: GLenum = 0x8E44`\n* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_SWIZZLE_B: GLenum = 0x8E44;
  #[doc = "`GL_TEXTURE_SWIZZLE_G: GLenum = 0x8E43`\n* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_SWIZZLE_G: GLenum = 0x8E43;
  #[doc = "`GL_TEXTURE_SWIZZLE_R: GLenum = 0x8E42`\n* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_SWIZZLE_R: GLenum = 0x8E42;
  #[doc = "`GL_TEXTURE_SWIZZLE_RGBA: GLenum = 0x8E46`\n* **Group:** TextureParameterName"]
  pub const GL_TEXTURE_SWIZZLE_RGBA: GLenum = 0x8E46;
  #[doc = "`GL_TEXTURE_TARGET: GLenum = 0x1006`"]
  pub const GL_TEXTURE_TARGET: GLenum = 0x1006;
  #[doc = "`GL_TEXTURE_UPDATE_BARRIER_BIT: GLbitfield = 0x00000100`\n* **Group:** MemoryBarrierMask"]
  pub const GL_TEXTURE_UPDATE_BARRIER_BIT: GLbitfield = 0x00000100;
  #[doc = "`GL_TEXTURE_VIEW: GLenum = 0x82B5`\n* **Group:** InternalFormatPName"]
  pub const GL_TEXTURE_VIEW: GLenum = 0x82B5;
  #[doc = "`GL_TEXTURE_VIEW_MIN_LAYER: GLenum = 0x82DD`"]
  pub const GL_TEXTURE_VIEW_MIN_LAYER: GLenum = 0x82DD;
  #[doc = "`GL_TEXTURE_VIEW_MIN_LEVEL: GLenum = 0x82DB`"]
  pub const GL_TEXTURE_VIEW_MIN_LEVEL: GLenum = 0x82DB;
  #[doc = "`GL_TEXTURE_VIEW_NUM_LAYERS: GLenum = 0x82DE`"]
  pub const GL_TEXTURE_VIEW_NUM_LAYERS: GLenum = 0x82DE;
  #[doc = "`GL_TEXTURE_VIEW_NUM_LEVELS: GLenum = 0x82DC`"]
  pub const GL_TEXTURE_VIEW_NUM_LEVELS: GLenum = 0x82DC;
  #[doc = "`GL_TEXTURE_WIDTH: GLenum = 0x1000`\n* **Groups:** TextureParameterName, GetTextureParameter"]
  pub const GL_TEXTURE_WIDTH: GLenum = 0x1000;
  #[doc = "`GL_TEXTURE_WRAP_R: GLenum = 0x8072`\n* **Groups:** SamplerParameterI, TextureParameterName"]
  pub const GL_TEXTURE_WRAP_R: GLenum = 0x8072;
  #[doc = "`GL_TEXTURE_WRAP_S: GLenum = 0x2802`\n* **Groups:** SamplerParameterI, GetTextureParameter, TextureParameterName"]
  pub const GL_TEXTURE_WRAP_S: GLenum = 0x2802;
  #[doc = "`GL_TEXTURE_WRAP_T: GLenum = 0x2803`\n* **Groups:** SamplerParameterI, GetTextureParameter, TextureParameterName"]
  pub const GL_TEXTURE_WRAP_T: GLenum = 0x2803;
  #[doc = "`GL_TIMEOUT_EXPIRED: GLenum = 0x911B`\n* **Group:** SyncStatus"]
  pub const GL_TIMEOUT_EXPIRED: GLenum = 0x911B;
  #[doc = "`GL_TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF`"]
  pub const GL_TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF;
  #[doc = "`GL_TIMESTAMP: GLenum = 0x8E28`\n* **Groups:** QueryCounterTarget, GetPName"]
  pub const GL_TIMESTAMP: GLenum = 0x8E28;
  #[doc = "`GL_TIME_ELAPSED: GLenum = 0x88BF`\n* **Group:** QueryTarget"]
  pub const GL_TIME_ELAPSED: GLenum = 0x88BF;
  #[doc = "`GL_TOP_LEVEL_ARRAY_SIZE: GLenum = 0x930C`\n* **Group:** ProgramResourceProperty"]
  pub const GL_TOP_LEVEL_ARRAY_SIZE: GLenum = 0x930C;
  #[doc = "`GL_TOP_LEVEL_ARRAY_STRIDE: GLenum = 0x930D`\n* **Group:** ProgramResourceProperty"]
  pub const GL_TOP_LEVEL_ARRAY_STRIDE: GLenum = 0x930D;
  #[doc = "`GL_TRANSFORM_FEEDBACK: GLenum = 0x8E22`\n* **Groups:** ObjectIdentifier, BindTransformFeedbackTarget"]
  pub const GL_TRANSFORM_FEEDBACK: GLenum = 0x8E22;
  #[doc = "`GL_TRANSFORM_FEEDBACK_ACTIVE: GLenum = 0x8E24`\n* **Group:** TransformFeedbackPName\n* **Alias Of:** `GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE`"]
  pub const GL_TRANSFORM_FEEDBACK_ACTIVE: GLenum = 0x8E24;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BARRIER_BIT: GLbitfield = 0x00000800`\n* **Group:** MemoryBarrierMask"]
  pub const GL_TRANSFORM_FEEDBACK_BARRIER_BIT: GLbitfield = 0x00000800;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BINDING: GLenum = 0x8E25`"]
  pub const GL_TRANSFORM_FEEDBACK_BINDING: GLenum = 0x8E25;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER: GLenum = 0x8C8E`\n* **Groups:** ProgramInterface, BufferTargetARB, BufferStorageTarget, CopyBufferSubDataTarget"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER: GLenum = 0x8C8E;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE: GLenum = 0x8E24`"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE: GLenum = 0x8E24;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING: GLenum = 0x8C8F`\n* **Groups:** TransformFeedbackPName, GetPName"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER_BINDING: GLenum = 0x8C8F;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER_INDEX: GLenum = 0x934B`\n* **Group:** ProgramResourceProperty"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER_INDEX: GLenum = 0x934B;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER_MODE: GLenum = 0x8C7F`\n* **Group:** ProgramPropertyARB"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER_MODE: GLenum = 0x8C7F;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED: GLenum = 0x8E23`"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED: GLenum = 0x8E23;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER_SIZE: GLenum = 0x8C85`\n* **Groups:** TransformFeedbackPName, GetPName"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER_SIZE: GLenum = 0x8C85;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER_START: GLenum = 0x8C84`\n* **Groups:** TransformFeedbackPName, GetPName"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER_START: GLenum = 0x8C84;
  #[doc = "`GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE: GLenum = 0x934C`\n* **Group:** ProgramResourceProperty"]
  pub const GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE: GLenum = 0x934C;
  #[doc = "`GL_TRANSFORM_FEEDBACK_OVERFLOW: GLenum = 0x82EC`\n* **Group:** QueryTarget"]
  pub const GL_TRANSFORM_FEEDBACK_OVERFLOW: GLenum = 0x82EC;
  #[doc = "`GL_TRANSFORM_FEEDBACK_PAUSED: GLenum = 0x8E23`\n* **Group:** TransformFeedbackPName\n* **Alias Of:** `GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED`"]
  pub const GL_TRANSFORM_FEEDBACK_PAUSED: GLenum = 0x8E23;
  #[doc = "`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: GLenum = 0x8C88`\n* **Group:** QueryTarget"]
  pub const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: GLenum = 0x8C88;
  #[doc = "`GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW: GLenum = 0x82ED`"]
  pub const GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW: GLenum = 0x82ED;
  #[doc = "`GL_TRANSFORM_FEEDBACK_VARYING: GLenum = 0x92F4`\n* **Group:** ProgramInterface"]
  pub const GL_TRANSFORM_FEEDBACK_VARYING: GLenum = 0x92F4;
  #[doc = "`GL_TRANSFORM_FEEDBACK_VARYINGS: GLenum = 0x8C83`\n* **Group:** ProgramPropertyARB"]
  pub const GL_TRANSFORM_FEEDBACK_VARYINGS: GLenum = 0x8C83;
  #[doc = "`GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: GLenum = 0x8C76`\n* **Group:** ProgramPropertyARB"]
  pub const GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: GLenum = 0x8C76;
  #[doc = "`GL_TRIANGLES: GLenum = 0x0004`\n* **Group:** PrimitiveType"]
  pub const GL_TRIANGLES: GLenum = 0x0004;
  #[doc = "`GL_TRIANGLES_ADJACENCY: GLenum = 0x000C`\n* **Group:** PrimitiveType"]
  pub const GL_TRIANGLES_ADJACENCY: GLenum = 0x000C;
  #[doc = "`GL_TRIANGLE_FAN: GLenum = 0x0006`\n* **Group:** PrimitiveType"]
  pub const GL_TRIANGLE_FAN: GLenum = 0x0006;
  #[doc = "`GL_TRIANGLE_STRIP: GLenum = 0x0005`\n* **Group:** PrimitiveType"]
  pub const GL_TRIANGLE_STRIP: GLenum = 0x0005;
  #[doc = "`GL_TRIANGLE_STRIP_ADJACENCY: GLenum = 0x000D`\n* **Group:** PrimitiveType"]
  pub const GL_TRIANGLE_STRIP_ADJACENCY: GLenum = 0x000D;
  #[doc = "`GL_TRUE: GLenum = 1`\n* **Groups:** Boolean, VertexShaderWriteMaskEXT, ClampColorModeARB"]
  pub const GL_TRUE: GLenum = 1;
  #[doc = "`GL_TYPE: GLenum = 0x92FA`\n* **Group:** ProgramResourceProperty"]
  pub const GL_TYPE: GLenum = 0x92FA;
  #[doc = "`GL_UNDEFINED_VERTEX: GLenum = 0x8260`"]
  pub const GL_UNDEFINED_VERTEX: GLenum = 0x8260;
  #[doc = "`GL_UNIFORM: GLenum = 0x92E1`\n* **Groups:** ProgramResourceProperty, ProgramInterface"]
  pub const GL_UNIFORM: GLenum = 0x92E1;
  #[doc = "`GL_UNIFORM_ARRAY_STRIDE: GLenum = 0x8A3C`\n* **Group:** UniformPName"]
  pub const GL_UNIFORM_ARRAY_STRIDE: GLenum = 0x8A3C;
  #[doc = "`GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX: GLenum = 0x92DA`\n* **Group:** UniformPName"]
  pub const GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX: GLenum = 0x92DA;
  #[doc = "`GL_UNIFORM_BARRIER_BIT: GLbitfield = 0x00000004`\n* **Group:** MemoryBarrierMask"]
  pub const GL_UNIFORM_BARRIER_BIT: GLbitfield = 0x00000004;
  #[doc = "`GL_UNIFORM_BLOCK: GLenum = 0x92E2`\n* **Group:** ProgramInterface"]
  pub const GL_UNIFORM_BLOCK: GLenum = 0x92E2;
  #[doc = "`GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS: GLenum = 0x8A42`\n* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS: GLenum = 0x8A42;
  #[doc = "`GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: GLenum = 0x8A43`\n* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: GLenum = 0x8A43;
  #[doc = "`GL_UNIFORM_BLOCK_BINDING: GLenum = 0x8A3F`\n* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_BINDING: GLenum = 0x8A3F;
  #[doc = "`GL_UNIFORM_BLOCK_DATA_SIZE: GLenum = 0x8A40`\n* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_DATA_SIZE: GLenum = 0x8A40;
  #[doc = "`GL_UNIFORM_BLOCK_INDEX: GLenum = 0x8A3A`\n* **Group:** UniformPName"]
  pub const GL_UNIFORM_BLOCK_INDEX: GLenum = 0x8A3A;
  #[doc = "`GL_UNIFORM_BLOCK_NAME_LENGTH: GLenum = 0x8A41`\n* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_NAME_LENGTH: GLenum = 0x8A41;
  #[doc = "`GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x90EC`\n* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x90EC;
  #[doc = "`GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x8A46`\n* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x8A46;
  #[doc = "`GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x8A45`\n* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x8A45;
  #[doc = "`GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x84F0`\n* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x84F0;
  #[doc = "`GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x84F1`\n* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum =
    0x84F1;
  #[doc = "`GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x8A44`\n* **Group:** UniformBlockPName"]
  pub const GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x8A44;
  #[doc = "`GL_UNIFORM_BUFFER: GLenum = 0x8A11`\n* **Groups:** CopyBufferSubDataTarget, BufferTargetARB, BufferStorageTarget"]
  pub const GL_UNIFORM_BUFFER: GLenum = 0x8A11;
  #[doc = "`GL_UNIFORM_BUFFER_BINDING: GLenum = 0x8A28`\n* **Group:** GetPName"]
  pub const GL_UNIFORM_BUFFER_BINDING: GLenum = 0x8A28;
  #[doc = "`GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x8A34`\n* **Group:** GetPName"]
  pub const GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x8A34;
  #[doc = "`GL_UNIFORM_BUFFER_SIZE: GLenum = 0x8A2A`\n* **Group:** GetPName"]
  pub const GL_UNIFORM_BUFFER_SIZE: GLenum = 0x8A2A;
  #[doc = "`GL_UNIFORM_BUFFER_START: GLenum = 0x8A29`\n* **Group:** GetPName"]
  pub const GL_UNIFORM_BUFFER_START: GLenum = 0x8A29;
  #[doc = "`GL_UNIFORM_IS_ROW_MAJOR: GLenum = 0x8A3E`\n* **Group:** UniformPName"]
  pub const GL_UNIFORM_IS_ROW_MAJOR: GLenum = 0x8A3E;
  #[doc = "`GL_UNIFORM_MATRIX_STRIDE: GLenum = 0x8A3D`\n* **Group:** UniformPName"]
  pub const GL_UNIFORM_MATRIX_STRIDE: GLenum = 0x8A3D;
  #[doc = "`GL_UNIFORM_NAME_LENGTH: GLenum = 0x8A39`\n* **Groups:** SubroutineParameterName, UniformPName"]
  pub const GL_UNIFORM_NAME_LENGTH: GLenum = 0x8A39;
  #[doc = "`GL_UNIFORM_OFFSET: GLenum = 0x8A3B`\n* **Group:** UniformPName"]
  pub const GL_UNIFORM_OFFSET: GLenum = 0x8A3B;
  #[doc = "`GL_UNIFORM_SIZE: GLenum = 0x8A38`\n* **Groups:** SubroutineParameterName, UniformPName"]
  pub const GL_UNIFORM_SIZE: GLenum = 0x8A38;
  #[doc = "`GL_UNIFORM_TYPE: GLenum = 0x8A37`\n* **Group:** UniformPName"]
  pub const GL_UNIFORM_TYPE: GLenum = 0x8A37;
  #[doc = "`GL_UNKNOWN_CONTEXT_RESET: GLenum = 0x8255`\n* **Group:** GraphicsResetStatus"]
  pub const GL_UNKNOWN_CONTEXT_RESET: GLenum = 0x8255;
  #[doc = "`GL_UNPACK_ALIGNMENT: GLenum = 0x0CF5`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_ALIGNMENT: GLenum = 0x0CF5;
  #[doc = "`GL_UNPACK_COMPRESSED_BLOCK_DEPTH: GLenum = 0x9129`"]
  pub const GL_UNPACK_COMPRESSED_BLOCK_DEPTH: GLenum = 0x9129;
  #[doc = "`GL_UNPACK_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x9128`"]
  pub const GL_UNPACK_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x9128;
  #[doc = "`GL_UNPACK_COMPRESSED_BLOCK_SIZE: GLenum = 0x912A`"]
  pub const GL_UNPACK_COMPRESSED_BLOCK_SIZE: GLenum = 0x912A;
  #[doc = "`GL_UNPACK_COMPRESSED_BLOCK_WIDTH: GLenum = 0x9127`"]
  pub const GL_UNPACK_COMPRESSED_BLOCK_WIDTH: GLenum = 0x9127;
  #[doc = "`GL_UNPACK_IMAGE_HEIGHT: GLenum = 0x806E`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_IMAGE_HEIGHT: GLenum = 0x806E;
  #[doc = "`GL_UNPACK_LSB_FIRST: GLenum = 0x0CF1`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_LSB_FIRST: GLenum = 0x0CF1;
  #[doc = "`GL_UNPACK_ROW_LENGTH: GLenum = 0x0CF2`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_ROW_LENGTH: GLenum = 0x0CF2;
  #[doc = "`GL_UNPACK_SKIP_IMAGES: GLenum = 0x806D`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_SKIP_IMAGES: GLenum = 0x806D;
  #[doc = "`GL_UNPACK_SKIP_PIXELS: GLenum = 0x0CF4`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_SKIP_PIXELS: GLenum = 0x0CF4;
  #[doc = "`GL_UNPACK_SKIP_ROWS: GLenum = 0x0CF3`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_SKIP_ROWS: GLenum = 0x0CF3;
  #[doc = "`GL_UNPACK_SWAP_BYTES: GLenum = 0x0CF0`\n* **Groups:** PixelStoreParameter, GetPName"]
  pub const GL_UNPACK_SWAP_BYTES: GLenum = 0x0CF0;
  #[doc = "`GL_UNSIGNALED: GLenum = 0x9118`"]
  pub const GL_UNSIGNALED: GLenum = 0x9118;
  #[doc = "`GL_UNSIGNED_BYTE: GLenum = 0x1401`\n* **Groups:** VertexAttribIType, ScalarType, ReplacementCodeTypeSUN, ElementPointerTypeATI, MatrixIndexPointerTypeARB, WeightPointerTypeARB, ColorPointerType, DrawElementsType, ListNameType, PixelType, VertexAttribType, VertexAttribPointerType"]
  pub const GL_UNSIGNED_BYTE: GLenum = 0x1401;
  #[doc = "`GL_UNSIGNED_BYTE_2_3_3_REV: GLenum = 0x8362`"]
  pub const GL_UNSIGNED_BYTE_2_3_3_REV: GLenum = 0x8362;
  #[doc = "`GL_UNSIGNED_BYTE_3_3_2: GLenum = 0x8032`\n* **Group:** PixelType"]
  pub const GL_UNSIGNED_BYTE_3_3_2: GLenum = 0x8032;
  #[doc = "`GL_UNSIGNED_INT: GLenum = 0x1405`\n* **Groups:** VertexAttribIType, ScalarType, ReplacementCodeTypeSUN, ElementPointerTypeATI, MatrixIndexPointerTypeARB, WeightPointerTypeARB, ColorPointerType, DrawElementsType, ListNameType, PixelFormat, PixelType, VertexAttribType, AttributeType, UniformType, VertexAttribPointerType, GlslTypeToken"]
  pub const GL_UNSIGNED_INT: GLenum = 0x1405;
  #[doc = "`GL_UNSIGNED_INT_10F_11F_11F_REV: GLenum = 0x8C3B`\n* **Groups:** VertexAttribPointerType, VertexAttribType"]
  pub const GL_UNSIGNED_INT_10F_11F_11F_REV: GLenum = 0x8C3B;
  #[doc = "`GL_UNSIGNED_INT_10_10_10_2: GLenum = 0x8036`\n* **Group:** PixelType"]
  pub const GL_UNSIGNED_INT_10_10_10_2: GLenum = 0x8036;
  #[doc = "`GL_UNSIGNED_INT_24_8: GLenum = 0x84FA`"]
  pub const GL_UNSIGNED_INT_24_8: GLenum = 0x84FA;
  #[doc = "`GL_UNSIGNED_INT_2_10_10_10_REV: GLenum = 0x8368`\n* **Groups:** VertexAttribPointerType, VertexAttribType"]
  pub const GL_UNSIGNED_INT_2_10_10_10_REV: GLenum = 0x8368;
  #[doc = "`GL_UNSIGNED_INT_5_9_9_9_REV: GLenum = 0x8C3E`"]
  pub const GL_UNSIGNED_INT_5_9_9_9_REV: GLenum = 0x8C3E;
  #[doc = "`GL_UNSIGNED_INT_8_8_8_8: GLenum = 0x8035`\n* **Group:** PixelType"]
  pub const GL_UNSIGNED_INT_8_8_8_8: GLenum = 0x8035;
  #[doc = "`GL_UNSIGNED_INT_8_8_8_8_REV: GLenum = 0x8367`"]
  pub const GL_UNSIGNED_INT_8_8_8_8_REV: GLenum = 0x8367;
  #[doc = "`GL_UNSIGNED_INT_ATOMIC_COUNTER: GLenum = 0x92DB`\n* **Group:** GlslTypeToken"]
  pub const GL_UNSIGNED_INT_ATOMIC_COUNTER: GLenum = 0x92DB;
  #[doc = "`GL_UNSIGNED_INT_IMAGE_1D: GLenum = 0x9062`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_UNSIGNED_INT_IMAGE_1D: GLenum = 0x9062;
  #[doc = "`GL_UNSIGNED_INT_IMAGE_1D_ARRAY: GLenum = 0x9068`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_UNSIGNED_INT_IMAGE_1D_ARRAY: GLenum = 0x9068;
  #[doc = "`GL_UNSIGNED_INT_IMAGE_2D: GLenum = 0x9063`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_UNSIGNED_INT_IMAGE_2D: GLenum = 0x9063;
  #[doc = "`GL_UNSIGNED_INT_IMAGE_2D_ARRAY: GLenum = 0x9069`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_UNSIGNED_INT_IMAGE_2D_ARRAY: GLenum = 0x9069;
  #[doc = "`GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE: GLenum = 0x906B`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE: GLenum = 0x906B;
  #[doc = "`GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x906C`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x906C;
  #[doc = "`GL_UNSIGNED_INT_IMAGE_2D_RECT: GLenum = 0x9065`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_UNSIGNED_INT_IMAGE_2D_RECT: GLenum = 0x9065;
  #[doc = "`GL_UNSIGNED_INT_IMAGE_3D: GLenum = 0x9064`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_UNSIGNED_INT_IMAGE_3D: GLenum = 0x9064;
  #[doc = "`GL_UNSIGNED_INT_IMAGE_BUFFER: GLenum = 0x9067`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_UNSIGNED_INT_IMAGE_BUFFER: GLenum = 0x9067;
  #[doc = "`GL_UNSIGNED_INT_IMAGE_CUBE: GLenum = 0x9066`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_UNSIGNED_INT_IMAGE_CUBE: GLenum = 0x9066;
  #[doc = "`GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x906A`\n* **Groups:** GlslTypeToken, AttributeType"]
  pub const GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x906A;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_1D: GLenum = 0x8DD1`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_1D: GLenum = 0x8DD1;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DD6`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DD6;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_2D: GLenum = 0x8DD2`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_2D: GLenum = 0x8DD2;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DD7`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DD7;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x910A`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x910A;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910D`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910D;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_2D_RECT: GLenum = 0x8DD5`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_2D_RECT: GLenum = 0x8DD5;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_3D: GLenum = 0x8DD3`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_3D: GLenum = 0x8DD3;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_BUFFER: GLenum = 0x8DD8`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_BUFFER: GLenum = 0x8DD8;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_CUBE: GLenum = 0x8DD4`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_CUBE: GLenum = 0x8DD4;
  #[doc = "`GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900F`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900F;
  #[doc = "`GL_UNSIGNED_INT_VEC2: GLenum = 0x8DC6`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_VEC2: GLenum = 0x8DC6;
  #[doc = "`GL_UNSIGNED_INT_VEC3: GLenum = 0x8DC7`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_VEC3: GLenum = 0x8DC7;
  #[doc = "`GL_UNSIGNED_INT_VEC4: GLenum = 0x8DC8`\n* **Groups:** GlslTypeToken, AttributeType, UniformType"]
  pub const GL_UNSIGNED_INT_VEC4: GLenum = 0x8DC8;
  #[doc = "`GL_UNSIGNED_NORMALIZED: GLenum = 0x8C17`"]
  pub const GL_UNSIGNED_NORMALIZED: GLenum = 0x8C17;
  #[doc = "`GL_UNSIGNED_SHORT: GLenum = 0x1403`\n* **Groups:** VertexAttribIType, ScalarType, ReplacementCodeTypeSUN, ElementPointerTypeATI, MatrixIndexPointerTypeARB, WeightPointerTypeARB, ColorPointerType, DrawElementsType, ListNameType, PixelFormat, PixelType, VertexAttribType, VertexAttribPointerType"]
  pub const GL_UNSIGNED_SHORT: GLenum = 0x1403;
  #[doc = "`GL_UNSIGNED_SHORT_1_5_5_5_REV: GLenum = 0x8366`"]
  pub const GL_UNSIGNED_SHORT_1_5_5_5_REV: GLenum = 0x8366;
  #[doc = "`GL_UNSIGNED_SHORT_4_4_4_4: GLenum = 0x8033`\n* **Group:** PixelType"]
  pub const GL_UNSIGNED_SHORT_4_4_4_4: GLenum = 0x8033;
  #[doc = "`GL_UNSIGNED_SHORT_4_4_4_4_REV: GLenum = 0x8365`"]
  pub const GL_UNSIGNED_SHORT_4_4_4_4_REV: GLenum = 0x8365;
  #[doc = "`GL_UNSIGNED_SHORT_5_5_5_1: GLenum = 0x8034`\n* **Group:** PixelType"]
  pub const GL_UNSIGNED_SHORT_5_5_5_1: GLenum = 0x8034;
  #[doc = "`GL_UNSIGNED_SHORT_5_6_5: GLenum = 0x8363`"]
  pub const GL_UNSIGNED_SHORT_5_6_5: GLenum = 0x8363;
  #[doc = "`GL_UNSIGNED_SHORT_5_6_5_REV: GLenum = 0x8364`"]
  pub const GL_UNSIGNED_SHORT_5_6_5_REV: GLenum = 0x8364;
  #[doc = "`GL_UPPER_LEFT: GLenum = 0x8CA2`\n* **Group:** ClipControlOrigin"]
  pub const GL_UPPER_LEFT: GLenum = 0x8CA2;
  #[doc = "`GL_VALIDATE_STATUS: GLenum = 0x8B83`\n* **Group:** ProgramPropertyARB"]
  pub const GL_VALIDATE_STATUS: GLenum = 0x8B83;
  #[doc = "`GL_VENDOR: GLenum = 0x1F00`\n* **Group:** StringName"]
  pub const GL_VENDOR: GLenum = 0x1F00;
  #[doc = "`GL_VERSION: GLenum = 0x1F02`\n* **Group:** StringName"]
  pub const GL_VERSION: GLenum = 0x1F02;
  #[doc = "`GL_VERTEX_ARRAY: GLenum = 0x8074`\n* **Groups:** ObjectIdentifier, EnableCap, GetPName"]
  pub const GL_VERTEX_ARRAY: GLenum = 0x8074;
  #[doc = "`GL_VERTEX_ARRAY_BINDING: GLenum = 0x85B5`\n* **Group:** GetPName"]
  pub const GL_VERTEX_ARRAY_BINDING: GLenum = 0x85B5;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT: GLbitfield = 0x00000001`\n* **Group:** MemoryBarrierMask"]
  pub const GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT: GLbitfield = 0x00000001;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum = 0x889F`\n* **Groups:** VertexAttribEnum, VertexAttribPropertyARB"]
  pub const GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum = 0x889F;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_DIVISOR: GLenum = 0x88FE`\n* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_DIVISOR: GLenum = 0x88FE;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_ENABLED: GLenum = 0x8622`\n* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_ENABLED: GLenum = 0x8622;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_INTEGER: GLenum = 0x88FD`\n* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_INTEGER: GLenum = 0x88FD;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_LONG: GLenum = 0x874E`\n* **Groups:** VertexArrayPName, VertexAttribPropertyARB"]
  pub const GL_VERTEX_ATTRIB_ARRAY_LONG: GLenum = 0x874E;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum = 0x886A`\n* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum = 0x886A;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_POINTER: GLenum = 0x8645`\n* **Group:** VertexAttribPointerPropertyARB"]
  pub const GL_VERTEX_ATTRIB_ARRAY_POINTER: GLenum = 0x8645;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_SIZE: GLenum = 0x8623`\n* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_SIZE: GLenum = 0x8623;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_STRIDE: GLenum = 0x8624`\n* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_STRIDE: GLenum = 0x8624;
  #[doc = "`GL_VERTEX_ATTRIB_ARRAY_TYPE: GLenum = 0x8625`\n* **Groups:** VertexAttribEnum, VertexAttribPropertyARB, VertexArrayPName"]
  pub const GL_VERTEX_ATTRIB_ARRAY_TYPE: GLenum = 0x8625;
  #[doc = "`GL_VERTEX_ATTRIB_BINDING: GLenum = 0x82D4`\n* **Group:** VertexAttribPropertyARB"]
  pub const GL_VERTEX_ATTRIB_BINDING: GLenum = 0x82D4;
  #[doc = "`GL_VERTEX_ATTRIB_RELATIVE_OFFSET: GLenum = 0x82D5`\n* **Groups:** VertexArrayPName, VertexAttribPropertyARB"]
  pub const GL_VERTEX_ATTRIB_RELATIVE_OFFSET: GLenum = 0x82D5;
  #[doc = "`GL_VERTEX_BINDING_BUFFER: GLenum = 0x8F4F`"]
  pub const GL_VERTEX_BINDING_BUFFER: GLenum = 0x8F4F;
  #[doc = "`GL_VERTEX_BINDING_DIVISOR: GLenum = 0x82D6`\n* **Group:** GetPName"]
  pub const GL_VERTEX_BINDING_DIVISOR: GLenum = 0x82D6;
  #[doc = "`GL_VERTEX_BINDING_OFFSET: GLenum = 0x82D7`\n* **Group:** GetPName"]
  pub const GL_VERTEX_BINDING_OFFSET: GLenum = 0x82D7;
  #[doc = "`GL_VERTEX_BINDING_STRIDE: GLenum = 0x82D8`\n* **Group:** GetPName"]
  pub const GL_VERTEX_BINDING_STRIDE: GLenum = 0x82D8;
  #[doc = "`GL_VERTEX_PROGRAM_POINT_SIZE: GLenum = 0x8642`"]
  pub const GL_VERTEX_PROGRAM_POINT_SIZE: GLenum = 0x8642;
  #[doc = "`GL_VERTEX_SHADER: GLenum = 0x8B31`\n* **Groups:** PipelineParameterName, ShaderType"]
  pub const GL_VERTEX_SHADER: GLenum = 0x8B31;
  #[doc = "`GL_VERTEX_SHADER_BIT: GLbitfield = 0x00000001`\n* **Group:** UseProgramStageMask"]
  pub const GL_VERTEX_SHADER_BIT: GLbitfield = 0x00000001;
  #[doc = "`GL_VERTEX_SHADER_INVOCATIONS: GLenum = 0x82F0`\n* **Group:** QueryTarget"]
  pub const GL_VERTEX_SHADER_INVOCATIONS: GLenum = 0x82F0;
  #[doc = "`GL_VERTEX_SUBROUTINE: GLenum = 0x92E8`\n* **Group:** ProgramInterface"]
  pub const GL_VERTEX_SUBROUTINE: GLenum = 0x92E8;
  #[doc = "`GL_VERTEX_SUBROUTINE_UNIFORM: GLenum = 0x92EE`\n* **Group:** ProgramInterface"]
  pub const GL_VERTEX_SUBROUTINE_UNIFORM: GLenum = 0x92EE;
  #[doc = "`GL_VERTEX_TEXTURE: GLenum = 0x829B`\n* **Group:** InternalFormatPName"]
  pub const GL_VERTEX_TEXTURE: GLenum = 0x829B;
  #[doc = "`GL_VERTICES_SUBMITTED: GLenum = 0x82EE`\n* **Group:** QueryTarget"]
  pub const GL_VERTICES_SUBMITTED: GLenum = 0x82EE;
  #[doc = "`GL_VIEWPORT: GLenum = 0x0BA2`\n* **Group:** GetPName"]
  pub const GL_VIEWPORT: GLenum = 0x0BA2;
  #[doc = "`GL_VIEWPORT_BOUNDS_RANGE: GLenum = 0x825D`\n* **Group:** GetPName"]
  pub const GL_VIEWPORT_BOUNDS_RANGE: GLenum = 0x825D;
  #[doc = "`GL_VIEWPORT_INDEX_PROVOKING_VERTEX: GLenum = 0x825F`\n* **Group:** GetPName"]
  pub const GL_VIEWPORT_INDEX_PROVOKING_VERTEX: GLenum = 0x825F;
  #[doc = "`GL_VIEWPORT_SUBPIXEL_BITS: GLenum = 0x825C`\n* **Group:** GetPName"]
  pub const GL_VIEWPORT_SUBPIXEL_BITS: GLenum = 0x825C;
  #[doc = "`GL_VIEW_CLASS_128_BITS: GLenum = 0x82C4`"]
  pub const GL_VIEW_CLASS_128_BITS: GLenum = 0x82C4;
  #[doc = "`GL_VIEW_CLASS_16_BITS: GLenum = 0x82CA`"]
  pub const GL_VIEW_CLASS_16_BITS: GLenum = 0x82CA;
  #[doc = "`GL_VIEW_CLASS_24_BITS: GLenum = 0x82C9`"]
  pub const GL_VIEW_CLASS_24_BITS: GLenum = 0x82C9;
  #[doc = "`GL_VIEW_CLASS_32_BITS: GLenum = 0x82C8`"]
  pub const GL_VIEW_CLASS_32_BITS: GLenum = 0x82C8;
  #[doc = "`GL_VIEW_CLASS_48_BITS: GLenum = 0x82C7`"]
  pub const GL_VIEW_CLASS_48_BITS: GLenum = 0x82C7;
  #[doc = "`GL_VIEW_CLASS_64_BITS: GLenum = 0x82C6`"]
  pub const GL_VIEW_CLASS_64_BITS: GLenum = 0x82C6;
  #[doc = "`GL_VIEW_CLASS_8_BITS: GLenum = 0x82CB`"]
  pub const GL_VIEW_CLASS_8_BITS: GLenum = 0x82CB;
  #[doc = "`GL_VIEW_CLASS_96_BITS: GLenum = 0x82C5`"]
  pub const GL_VIEW_CLASS_96_BITS: GLenum = 0x82C5;
  #[doc = "`GL_VIEW_CLASS_BPTC_FLOAT: GLenum = 0x82D3`"]
  pub const GL_VIEW_CLASS_BPTC_FLOAT: GLenum = 0x82D3;
  #[doc = "`GL_VIEW_CLASS_BPTC_UNORM: GLenum = 0x82D2`"]
  pub const GL_VIEW_CLASS_BPTC_UNORM: GLenum = 0x82D2;
  #[doc = "`GL_VIEW_CLASS_RGTC1_RED: GLenum = 0x82D0`"]
  pub const GL_VIEW_CLASS_RGTC1_RED: GLenum = 0x82D0;
  #[doc = "`GL_VIEW_CLASS_RGTC2_RG: GLenum = 0x82D1`"]
  pub const GL_VIEW_CLASS_RGTC2_RG: GLenum = 0x82D1;
  #[doc = "`GL_VIEW_CLASS_S3TC_DXT1_RGB: GLenum = 0x82CC`"]
  pub const GL_VIEW_CLASS_S3TC_DXT1_RGB: GLenum = 0x82CC;
  #[doc = "`GL_VIEW_CLASS_S3TC_DXT1_RGBA: GLenum = 0x82CD`"]
  pub const GL_VIEW_CLASS_S3TC_DXT1_RGBA: GLenum = 0x82CD;
  #[doc = "`GL_VIEW_CLASS_S3TC_DXT3_RGBA: GLenum = 0x82CE`"]
  pub const GL_VIEW_CLASS_S3TC_DXT3_RGBA: GLenum = 0x82CE;
  #[doc = "`GL_VIEW_CLASS_S3TC_DXT5_RGBA: GLenum = 0x82CF`"]
  pub const GL_VIEW_CLASS_S3TC_DXT5_RGBA: GLenum = 0x82CF;
  #[doc = "`GL_VIEW_COMPATIBILITY_CLASS: GLenum = 0x82B6`\n* **Group:** InternalFormatPName"]
  pub const GL_VIEW_COMPATIBILITY_CLASS: GLenum = 0x82B6;
  #[doc = "`GL_WAIT_FAILED: GLenum = 0x911D`\n* **Group:** SyncStatus"]
  pub const GL_WAIT_FAILED: GLenum = 0x911D;
  #[doc = "`GL_WRITE_ONLY: GLenum = 0x88B9`\n* **Group:** BufferAccessARB"]
  pub const GL_WRITE_ONLY: GLenum = 0x88B9;
  #[doc = "`GL_XOR: GLenum = 0x1506`\n* **Group:** LogicOp"]
  pub const GL_XOR: GLenum = 0x1506;
  #[doc = "`GL_ZERO: GLenum = 0`\n* **Groups:** TextureSwizzle, StencilOp, BlendingFactor"]
  pub const GL_ZERO: GLenum = 0;
  #[doc = "`GL_ZERO_TO_ONE: GLenum = 0x935F`\n* **Group:** ClipControlDepth"]
  pub const GL_ZERO_TO_ONE: GLenum = 0x935F;
}

/// This is called to panic when a not-loaded function is attempted.
///
/// Placing the panic mechanism in this cold function generally helps code
/// generation for the hot path. Or so the sages say, at least.
#[cold]
#[inline(never)]
fn go_panic_because_fn_not_loaded(name: &str) -> ! {
  panic!("called {name} but it was not loaded.", name = name)
}

/// Loads a function pointer.
/// Rejects suggested pointer addresses which are likely to be lies.
/// Returns the loaded pointer, or null if we rejected the proposed pointers.
/// This function is used by both the global loader and struct loader.
/// We mark it as `inline(never)` to favor a small binary over initialization
/// speed.
#[inline(never)]
fn do_the_load(get_proc_address: &mut GPA, fn_name: &[u8]) -> *mut c_void {
  // if this fails the code generator itself royally screwed up somehow,
  // and so it's only a debug assert.
  debug_assert_eq!(*fn_name.last().unwrap(), 0);
  let p: *mut c_void = get_proc_address(fn_name.as_ptr().cast());
  let p_usize = p as usize;
  // You *should* get null for failed lookups, but some systems have been
  // reported to give "error code" values such as -1 or small non-null values.
  // To help guard against this silliness, we consider these values to also
  // just be a result of null.
  if p_usize == usize::MAX || p_usize < 8 {
    null_mut()
  } else {
    p
  }
}

#[inline(never)]
#[cfg(feature = "debug_automatic_glGetError")]
fn report_error_as_necessary_from(name: &str, err: GLenum) {
  match err {
    GL_NO_ERROR => (),
    GL_INVALID_ENUM => error!("Invalid Enum to {name}.", name = name),
    GL_INVALID_VALUE => error!("Invalid Value to {name}.", name = name),
    GL_INVALID_OPERATION => error!("Invalid Operation to {name}.", name = name),
    GL_INVALID_FRAMEBUFFER_OPERATION => {
      error!("Invalid Framebuffer Operation to {name}.", name = name)
    }
    GL_OUT_OF_MEMORY => error!("Out of Memory in {name}.", name = name),
    GL_STACK_UNDERFLOW => error!("Stack Underflow in {name}.", name = name),
    GL_STACK_OVERFLOW => error!("Stack Overflow in {name}.", name = name),
    unknown => error!(
      "Unknown error code {unknown} to {name}.",
      name = name,
      unknown = unknown
    ),
  }
}

#[cfg(feature = "global_loader")]
pub use global_commands::*;
#[cfg(feature = "global_loader")]
mod global_commands {
  use super::*;

  /// Loads all global functions using the `get_proc_address` given.
  ///
  /// The closure should, when given a null-terminated name of a function,
  /// return a pointer to that function. If the function isn't available, then
  /// a null pointer should be returned instead.
  ///
  /// This allows you to call [SDL_GL_GetProcAddress](https://wiki.libsdl.org/SDL_GL_GetProcAddress),
  /// [wglGetProcAddress](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-wglgetprocaddress),
  /// or similar function, depending on your OS.
  #[inline(never)]
  pub fn global_load_with(get_proc_address: &mut GPA) -> usize {
    let mut count = 0;
    count += glActiveShaderProgram_load_with(get_proc_address) as usize;
    count += glActiveTexture_load_with(get_proc_address) as usize;
    count += glAttachShader_load_with(get_proc_address) as usize;
    count += glBeginConditionalRender_load_with(get_proc_address) as usize;
    count += glBeginQuery_load_with(get_proc_address) as usize;
    count += glBeginQueryIndexed_load_with(get_proc_address) as usize;
    count += glBeginTransformFeedback_load_with(get_proc_address) as usize;
    count += glBindAttribLocation_load_with(get_proc_address) as usize;
    count += glBindBuffer_load_with(get_proc_address) as usize;
    count += glBindBufferBase_load_with(get_proc_address) as usize;
    count += glBindBufferRange_load_with(get_proc_address) as usize;
    count += glBindBuffersBase_load_with(get_proc_address) as usize;
    count += glBindBuffersRange_load_with(get_proc_address) as usize;
    count += glBindFragDataLocation_load_with(get_proc_address) as usize;
    count += glBindFragDataLocationIndexed_load_with(get_proc_address) as usize;
    count += glBindFramebuffer_load_with(get_proc_address) as usize;
    count += glBindImageTexture_load_with(get_proc_address) as usize;
    count += glBindImageTextures_load_with(get_proc_address) as usize;
    count += glBindProgramPipeline_load_with(get_proc_address) as usize;
    count += glBindRenderbuffer_load_with(get_proc_address) as usize;
    count += glBindSampler_load_with(get_proc_address) as usize;
    count += glBindSamplers_load_with(get_proc_address) as usize;
    count += glBindTexture_load_with(get_proc_address) as usize;
    count += glBindTextureUnit_load_with(get_proc_address) as usize;
    count += glBindTextures_load_with(get_proc_address) as usize;
    count += glBindTransformFeedback_load_with(get_proc_address) as usize;
    count += glBindVertexArray_load_with(get_proc_address) as usize;
    count += glBindVertexBuffer_load_with(get_proc_address) as usize;
    count += glBindVertexBuffers_load_with(get_proc_address) as usize;
    count += glBlendColor_load_with(get_proc_address) as usize;
    count += glBlendEquation_load_with(get_proc_address) as usize;
    count += glBlendEquationSeparate_load_with(get_proc_address) as usize;
    count += glBlendEquationSeparatei_load_with(get_proc_address) as usize;
    count += glBlendEquationSeparateiARB_load_with(get_proc_address) as usize;
    count += glBlendEquationi_load_with(get_proc_address) as usize;
    count += glBlendEquationiARB_load_with(get_proc_address) as usize;
    count += glBlendFunc_load_with(get_proc_address) as usize;
    count += glBlendFuncSeparate_load_with(get_proc_address) as usize;
    count += glBlendFuncSeparatei_load_with(get_proc_address) as usize;
    count += glBlendFuncSeparateiARB_load_with(get_proc_address) as usize;
    count += glBlendFunci_load_with(get_proc_address) as usize;
    count += glBlendFunciARB_load_with(get_proc_address) as usize;
    count += glBlitFramebuffer_load_with(get_proc_address) as usize;
    count += glBlitNamedFramebuffer_load_with(get_proc_address) as usize;
    count += glBufferData_load_with(get_proc_address) as usize;
    count += glBufferStorage_load_with(get_proc_address) as usize;
    count += glBufferSubData_load_with(get_proc_address) as usize;
    count += glCheckFramebufferStatus_load_with(get_proc_address) as usize;
    count += glCheckNamedFramebufferStatus_load_with(get_proc_address) as usize;
    count += glClampColor_load_with(get_proc_address) as usize;
    count += glClear_load_with(get_proc_address) as usize;
    count += glClearBufferData_load_with(get_proc_address) as usize;
    count += glClearBufferSubData_load_with(get_proc_address) as usize;
    count += glClearBufferfi_load_with(get_proc_address) as usize;
    count += glClearBufferfv_load_with(get_proc_address) as usize;
    count += glClearBufferiv_load_with(get_proc_address) as usize;
    count += glClearBufferuiv_load_with(get_proc_address) as usize;
    count += glClearColor_load_with(get_proc_address) as usize;
    count += glClearDepth_load_with(get_proc_address) as usize;
    count += glClearDepthf_load_with(get_proc_address) as usize;
    count += glClearNamedBufferData_load_with(get_proc_address) as usize;
    count += glClearNamedBufferSubData_load_with(get_proc_address) as usize;
    count += glClearNamedFramebufferfi_load_with(get_proc_address) as usize;
    count += glClearNamedFramebufferfv_load_with(get_proc_address) as usize;
    count += glClearNamedFramebufferiv_load_with(get_proc_address) as usize;
    count += glClearNamedFramebufferuiv_load_with(get_proc_address) as usize;
    count += glClearStencil_load_with(get_proc_address) as usize;
    count += glClearTexImage_load_with(get_proc_address) as usize;
    count += glClearTexSubImage_load_with(get_proc_address) as usize;
    count += glClientWaitSync_load_with(get_proc_address) as usize;
    count += glClipControl_load_with(get_proc_address) as usize;
    count += glColorMask_load_with(get_proc_address) as usize;
    count += glColorMaski_load_with(get_proc_address) as usize;
    count += glCompileShader_load_with(get_proc_address) as usize;
    count += glCompressedTexImage1D_load_with(get_proc_address) as usize;
    count += glCompressedTexImage2D_load_with(get_proc_address) as usize;
    count += glCompressedTexImage3D_load_with(get_proc_address) as usize;
    count += glCompressedTexSubImage1D_load_with(get_proc_address) as usize;
    count += glCompressedTexSubImage2D_load_with(get_proc_address) as usize;
    count += glCompressedTexSubImage3D_load_with(get_proc_address) as usize;
    count += glCompressedTextureSubImage1D_load_with(get_proc_address) as usize;
    count += glCompressedTextureSubImage2D_load_with(get_proc_address) as usize;
    count += glCompressedTextureSubImage3D_load_with(get_proc_address) as usize;
    count += glCopyBufferSubData_load_with(get_proc_address) as usize;
    count += glCopyImageSubData_load_with(get_proc_address) as usize;
    count += glCopyNamedBufferSubData_load_with(get_proc_address) as usize;
    count += glCopyTexImage1D_load_with(get_proc_address) as usize;
    count += glCopyTexImage2D_load_with(get_proc_address) as usize;
    count += glCopyTexSubImage1D_load_with(get_proc_address) as usize;
    count += glCopyTexSubImage2D_load_with(get_proc_address) as usize;
    count += glCopyTexSubImage3D_load_with(get_proc_address) as usize;
    count += glCopyTextureSubImage1D_load_with(get_proc_address) as usize;
    count += glCopyTextureSubImage2D_load_with(get_proc_address) as usize;
    count += glCopyTextureSubImage3D_load_with(get_proc_address) as usize;
    count += glCreateBuffers_load_with(get_proc_address) as usize;
    count += glCreateFramebuffers_load_with(get_proc_address) as usize;
    count += glCreateProgram_load_with(get_proc_address) as usize;
    count += glCreateProgramPipelines_load_with(get_proc_address) as usize;
    count += glCreateQueries_load_with(get_proc_address) as usize;
    count += glCreateRenderbuffers_load_with(get_proc_address) as usize;
    count += glCreateSamplers_load_with(get_proc_address) as usize;
    count += glCreateShader_load_with(get_proc_address) as usize;
    count += glCreateShaderProgramv_load_with(get_proc_address) as usize;
    count += glCreateTextures_load_with(get_proc_address) as usize;
    count += glCreateTransformFeedbacks_load_with(get_proc_address) as usize;
    count += glCreateVertexArrays_load_with(get_proc_address) as usize;
    count += glCullFace_load_with(get_proc_address) as usize;
    count += glDebugMessageCallback_load_with(get_proc_address) as usize;
    count += glDebugMessageControl_load_with(get_proc_address) as usize;
    count += glDebugMessageInsert_load_with(get_proc_address) as usize;
    count += glDeleteBuffers_load_with(get_proc_address) as usize;
    count += glDeleteFramebuffers_load_with(get_proc_address) as usize;
    count += glDeleteProgram_load_with(get_proc_address) as usize;
    count += glDeleteProgramPipelines_load_with(get_proc_address) as usize;
    count += glDeleteQueries_load_with(get_proc_address) as usize;
    count += glDeleteRenderbuffers_load_with(get_proc_address) as usize;
    count += glDeleteSamplers_load_with(get_proc_address) as usize;
    count += glDeleteShader_load_with(get_proc_address) as usize;
    count += glDeleteSync_load_with(get_proc_address) as usize;
    count += glDeleteTextures_load_with(get_proc_address) as usize;
    count += glDeleteTransformFeedbacks_load_with(get_proc_address) as usize;
    count += glDeleteVertexArrays_load_with(get_proc_address) as usize;
    count += glDepthFunc_load_with(get_proc_address) as usize;
    count += glDepthMask_load_with(get_proc_address) as usize;
    count += glDepthRange_load_with(get_proc_address) as usize;
    count += glDepthRangeArrayv_load_with(get_proc_address) as usize;
    count += glDepthRangeIndexed_load_with(get_proc_address) as usize;
    count += glDepthRangef_load_with(get_proc_address) as usize;
    count += glDetachShader_load_with(get_proc_address) as usize;
    count += glDisable_load_with(get_proc_address) as usize;
    count += glDisableVertexArrayAttrib_load_with(get_proc_address) as usize;
    count += glDisableVertexAttribArray_load_with(get_proc_address) as usize;
    count += glDisablei_load_with(get_proc_address) as usize;
    count += glDispatchCompute_load_with(get_proc_address) as usize;
    count += glDispatchComputeIndirect_load_with(get_proc_address) as usize;
    count += glDrawArrays_load_with(get_proc_address) as usize;
    count += glDrawArraysIndirect_load_with(get_proc_address) as usize;
    count += glDrawArraysInstanced_load_with(get_proc_address) as usize;
    count +=
      glDrawArraysInstancedBaseInstance_load_with(get_proc_address) as usize;
    count += glDrawBuffer_load_with(get_proc_address) as usize;
    count += glDrawBuffers_load_with(get_proc_address) as usize;
    count += glDrawElements_load_with(get_proc_address) as usize;
    count += glDrawElementsBaseVertex_load_with(get_proc_address) as usize;
    count += glDrawElementsIndirect_load_with(get_proc_address) as usize;
    count += glDrawElementsInstanced_load_with(get_proc_address) as usize;
    count +=
      glDrawElementsInstancedBaseInstance_load_with(get_proc_address) as usize;
    count +=
      glDrawElementsInstancedBaseVertex_load_with(get_proc_address) as usize;
    count +=
      glDrawElementsInstancedBaseVertexBaseInstance_load_with(get_proc_address)
        as usize;
    count += glDrawRangeElements_load_with(get_proc_address) as usize;
    count += glDrawRangeElementsBaseVertex_load_with(get_proc_address) as usize;
    count += glDrawTransformFeedback_load_with(get_proc_address) as usize;
    count +=
      glDrawTransformFeedbackInstanced_load_with(get_proc_address) as usize;
    count += glDrawTransformFeedbackStream_load_with(get_proc_address) as usize;
    count += glDrawTransformFeedbackStreamInstanced_load_with(get_proc_address)
      as usize;
    count += glEnable_load_with(get_proc_address) as usize;
    count += glEnableVertexArrayAttrib_load_with(get_proc_address) as usize;
    count += glEnableVertexAttribArray_load_with(get_proc_address) as usize;
    count += glEnablei_load_with(get_proc_address) as usize;
    count += glEndConditionalRender_load_with(get_proc_address) as usize;
    count += glEndQuery_load_with(get_proc_address) as usize;
    count += glEndQueryIndexed_load_with(get_proc_address) as usize;
    count += glEndTransformFeedback_load_with(get_proc_address) as usize;
    count += glFenceSync_load_with(get_proc_address) as usize;
    count += glFinish_load_with(get_proc_address) as usize;
    count += glFlush_load_with(get_proc_address) as usize;
    count += glFlushMappedBufferRange_load_with(get_proc_address) as usize;
    count += glFlushMappedNamedBufferRange_load_with(get_proc_address) as usize;
    count += glFramebufferParameteri_load_with(get_proc_address) as usize;
    count += glFramebufferRenderbuffer_load_with(get_proc_address) as usize;
    count += glFramebufferTexture_load_with(get_proc_address) as usize;
    count += glFramebufferTexture1D_load_with(get_proc_address) as usize;
    count += glFramebufferTexture2D_load_with(get_proc_address) as usize;
    count += glFramebufferTexture3D_load_with(get_proc_address) as usize;
    count += glFramebufferTextureLayer_load_with(get_proc_address) as usize;
    count += glFrontFace_load_with(get_proc_address) as usize;
    count += glGenBuffers_load_with(get_proc_address) as usize;
    count += glGenFramebuffers_load_with(get_proc_address) as usize;
    count += glGenProgramPipelines_load_with(get_proc_address) as usize;
    count += glGenQueries_load_with(get_proc_address) as usize;
    count += glGenRenderbuffers_load_with(get_proc_address) as usize;
    count += glGenSamplers_load_with(get_proc_address) as usize;
    count += glGenTextures_load_with(get_proc_address) as usize;
    count += glGenTransformFeedbacks_load_with(get_proc_address) as usize;
    count += glGenVertexArrays_load_with(get_proc_address) as usize;
    count += glGenerateMipmap_load_with(get_proc_address) as usize;
    count += glGenerateTextureMipmap_load_with(get_proc_address) as usize;
    count +=
      glGetActiveAtomicCounterBufferiv_load_with(get_proc_address) as usize;
    count += glGetActiveAttrib_load_with(get_proc_address) as usize;
    count += glGetActiveSubroutineName_load_with(get_proc_address) as usize;
    count +=
      glGetActiveSubroutineUniformName_load_with(get_proc_address) as usize;
    count +=
      glGetActiveSubroutineUniformiv_load_with(get_proc_address) as usize;
    count += glGetActiveUniform_load_with(get_proc_address) as usize;
    count += glGetActiveUniformBlockName_load_with(get_proc_address) as usize;
    count += glGetActiveUniformBlockiv_load_with(get_proc_address) as usize;
    count += glGetActiveUniformName_load_with(get_proc_address) as usize;
    count += glGetActiveUniformsiv_load_with(get_proc_address) as usize;
    count += glGetAttachedShaders_load_with(get_proc_address) as usize;
    count += glGetAttribLocation_load_with(get_proc_address) as usize;
    count += glGetBooleani_v_load_with(get_proc_address) as usize;
    count += glGetBooleanv_load_with(get_proc_address) as usize;
    count += glGetBufferParameteri64v_load_with(get_proc_address) as usize;
    count += glGetBufferParameteriv_load_with(get_proc_address) as usize;
    count += glGetBufferPointerv_load_with(get_proc_address) as usize;
    count += glGetBufferSubData_load_with(get_proc_address) as usize;
    count += glGetCompressedTexImage_load_with(get_proc_address) as usize;
    count += glGetCompressedTextureImage_load_with(get_proc_address) as usize;
    count +=
      glGetCompressedTextureSubImage_load_with(get_proc_address) as usize;
    count += glGetDebugMessageLog_load_with(get_proc_address) as usize;
    count += glGetDoublei_v_load_with(get_proc_address) as usize;
    count += glGetDoublev_load_with(get_proc_address) as usize;
    count += glGetError_load_with(get_proc_address) as usize;
    count += glGetFloati_v_load_with(get_proc_address) as usize;
    count += glGetFloatv_load_with(get_proc_address) as usize;
    count += glGetFragDataIndex_load_with(get_proc_address) as usize;
    count += glGetFragDataLocation_load_with(get_proc_address) as usize;
    count += glGetFramebufferAttachmentParameteriv_load_with(get_proc_address)
      as usize;
    count += glGetFramebufferParameteriv_load_with(get_proc_address) as usize;
    count += glGetGraphicsResetStatus_load_with(get_proc_address) as usize;
    count += glGetInteger64i_v_load_with(get_proc_address) as usize;
    count += glGetInteger64v_load_with(get_proc_address) as usize;
    count += glGetIntegeri_v_load_with(get_proc_address) as usize;
    count += glGetIntegerv_load_with(get_proc_address) as usize;
    count += glGetInternalformati64v_load_with(get_proc_address) as usize;
    count += glGetInternalformativ_load_with(get_proc_address) as usize;
    count += glGetMultisamplefv_load_with(get_proc_address) as usize;
    count += glGetNamedBufferParameteri64v_load_with(get_proc_address) as usize;
    count += glGetNamedBufferParameteriv_load_with(get_proc_address) as usize;
    count += glGetNamedBufferPointerv_load_with(get_proc_address) as usize;
    count += glGetNamedBufferSubData_load_with(get_proc_address) as usize;
    count +=
      glGetNamedFramebufferAttachmentParameteriv_load_with(get_proc_address)
        as usize;
    count +=
      glGetNamedFramebufferParameteriv_load_with(get_proc_address) as usize;
    count +=
      glGetNamedRenderbufferParameteriv_load_with(get_proc_address) as usize;
    count += glGetObjectLabel_load_with(get_proc_address) as usize;
    count += glGetObjectPtrLabel_load_with(get_proc_address) as usize;
    count += glGetPointerv_load_with(get_proc_address) as usize;
    count += glGetProgramBinary_load_with(get_proc_address) as usize;
    count += glGetProgramInfoLog_load_with(get_proc_address) as usize;
    count += glGetProgramInterfaceiv_load_with(get_proc_address) as usize;
    count += glGetProgramPipelineInfoLog_load_with(get_proc_address) as usize;
    count += glGetProgramPipelineiv_load_with(get_proc_address) as usize;
    count += glGetProgramResourceIndex_load_with(get_proc_address) as usize;
    count += glGetProgramResourceLocation_load_with(get_proc_address) as usize;
    count +=
      glGetProgramResourceLocationIndex_load_with(get_proc_address) as usize;
    count += glGetProgramResourceName_load_with(get_proc_address) as usize;
    count += glGetProgramResourceiv_load_with(get_proc_address) as usize;
    count += glGetProgramStageiv_load_with(get_proc_address) as usize;
    count += glGetProgramiv_load_with(get_proc_address) as usize;
    count += glGetQueryBufferObjecti64v_load_with(get_proc_address) as usize;
    count += glGetQueryBufferObjectiv_load_with(get_proc_address) as usize;
    count += glGetQueryBufferObjectui64v_load_with(get_proc_address) as usize;
    count += glGetQueryBufferObjectuiv_load_with(get_proc_address) as usize;
    count += glGetQueryIndexediv_load_with(get_proc_address) as usize;
    count += glGetQueryObjecti64v_load_with(get_proc_address) as usize;
    count += glGetQueryObjectiv_load_with(get_proc_address) as usize;
    count += glGetQueryObjectui64v_load_with(get_proc_address) as usize;
    count += glGetQueryObjectuiv_load_with(get_proc_address) as usize;
    count += glGetQueryiv_load_with(get_proc_address) as usize;
    count += glGetRenderbufferParameteriv_load_with(get_proc_address) as usize;
    count += glGetSamplerParameterIiv_load_with(get_proc_address) as usize;
    count += glGetSamplerParameterIuiv_load_with(get_proc_address) as usize;
    count += glGetSamplerParameterfv_load_with(get_proc_address) as usize;
    count += glGetSamplerParameteriv_load_with(get_proc_address) as usize;
    count += glGetShaderInfoLog_load_with(get_proc_address) as usize;
    count += glGetShaderPrecisionFormat_load_with(get_proc_address) as usize;
    count += glGetShaderSource_load_with(get_proc_address) as usize;
    count += glGetShaderiv_load_with(get_proc_address) as usize;
    count += glGetString_load_with(get_proc_address) as usize;
    count += glGetStringi_load_with(get_proc_address) as usize;
    count += glGetSubroutineIndex_load_with(get_proc_address) as usize;
    count +=
      glGetSubroutineUniformLocation_load_with(get_proc_address) as usize;
    count += glGetSynciv_load_with(get_proc_address) as usize;
    count += glGetTexImage_load_with(get_proc_address) as usize;
    count += glGetTexLevelParameterfv_load_with(get_proc_address) as usize;
    count += glGetTexLevelParameteriv_load_with(get_proc_address) as usize;
    count += glGetTexParameterIiv_load_with(get_proc_address) as usize;
    count += glGetTexParameterIuiv_load_with(get_proc_address) as usize;
    count += glGetTexParameterfv_load_with(get_proc_address) as usize;
    count += glGetTexParameteriv_load_with(get_proc_address) as usize;
    count += glGetTextureImage_load_with(get_proc_address) as usize;
    count += glGetTextureLevelParameterfv_load_with(get_proc_address) as usize;
    count += glGetTextureLevelParameteriv_load_with(get_proc_address) as usize;
    count += glGetTextureParameterIiv_load_with(get_proc_address) as usize;
    count += glGetTextureParameterIuiv_load_with(get_proc_address) as usize;
    count += glGetTextureParameterfv_load_with(get_proc_address) as usize;
    count += glGetTextureParameteriv_load_with(get_proc_address) as usize;
    count += glGetTextureSubImage_load_with(get_proc_address) as usize;
    count += glGetTransformFeedbackVarying_load_with(get_proc_address) as usize;
    count += glGetTransformFeedbacki64_v_load_with(get_proc_address) as usize;
    count += glGetTransformFeedbacki_v_load_with(get_proc_address) as usize;
    count += glGetTransformFeedbackiv_load_with(get_proc_address) as usize;
    count += glGetUniformBlockIndex_load_with(get_proc_address) as usize;
    count += glGetUniformIndices_load_with(get_proc_address) as usize;
    count += glGetUniformLocation_load_with(get_proc_address) as usize;
    count += glGetUniformSubroutineuiv_load_with(get_proc_address) as usize;
    count += glGetUniformdv_load_with(get_proc_address) as usize;
    count += glGetUniformfv_load_with(get_proc_address) as usize;
    count += glGetUniformiv_load_with(get_proc_address) as usize;
    count += glGetUniformuiv_load_with(get_proc_address) as usize;
    count += glGetVertexArrayIndexed64iv_load_with(get_proc_address) as usize;
    count += glGetVertexArrayIndexediv_load_with(get_proc_address) as usize;
    count += glGetVertexArrayiv_load_with(get_proc_address) as usize;
    count += glGetVertexAttribIiv_load_with(get_proc_address) as usize;
    count += glGetVertexAttribIuiv_load_with(get_proc_address) as usize;
    count += glGetVertexAttribLdv_load_with(get_proc_address) as usize;
    count += glGetVertexAttribPointerv_load_with(get_proc_address) as usize;
    count += glGetVertexAttribdv_load_with(get_proc_address) as usize;
    count += glGetVertexAttribfv_load_with(get_proc_address) as usize;
    count += glGetVertexAttribiv_load_with(get_proc_address) as usize;
    count += glGetnCompressedTexImage_load_with(get_proc_address) as usize;
    count += glGetnTexImage_load_with(get_proc_address) as usize;
    count += glGetnUniformdv_load_with(get_proc_address) as usize;
    count += glGetnUniformfv_load_with(get_proc_address) as usize;
    count += glGetnUniformiv_load_with(get_proc_address) as usize;
    count += glGetnUniformuiv_load_with(get_proc_address) as usize;
    count += glHint_load_with(get_proc_address) as usize;
    count += glInvalidateBufferData_load_with(get_proc_address) as usize;
    count += glInvalidateBufferSubData_load_with(get_proc_address) as usize;
    count += glInvalidateFramebuffer_load_with(get_proc_address) as usize;
    count +=
      glInvalidateNamedFramebufferData_load_with(get_proc_address) as usize;
    count +=
      glInvalidateNamedFramebufferSubData_load_with(get_proc_address) as usize;
    count += glInvalidateSubFramebuffer_load_with(get_proc_address) as usize;
    count += glInvalidateTexImage_load_with(get_proc_address) as usize;
    count += glInvalidateTexSubImage_load_with(get_proc_address) as usize;
    count += glIsBuffer_load_with(get_proc_address) as usize;
    count += glIsEnabled_load_with(get_proc_address) as usize;
    count += glIsEnabledi_load_with(get_proc_address) as usize;
    count += glIsFramebuffer_load_with(get_proc_address) as usize;
    count += glIsProgram_load_with(get_proc_address) as usize;
    count += glIsProgramPipeline_load_with(get_proc_address) as usize;
    count += glIsQuery_load_with(get_proc_address) as usize;
    count += glIsRenderbuffer_load_with(get_proc_address) as usize;
    count += glIsSampler_load_with(get_proc_address) as usize;
    count += glIsShader_load_with(get_proc_address) as usize;
    count += glIsSync_load_with(get_proc_address) as usize;
    count += glIsTexture_load_with(get_proc_address) as usize;
    count += glIsTransformFeedback_load_with(get_proc_address) as usize;
    count += glIsVertexArray_load_with(get_proc_address) as usize;
    count += glLineWidth_load_with(get_proc_address) as usize;
    count += glLinkProgram_load_with(get_proc_address) as usize;
    count += glLogicOp_load_with(get_proc_address) as usize;
    count += glMapBuffer_load_with(get_proc_address) as usize;
    count += glMapBufferRange_load_with(get_proc_address) as usize;
    count += glMapNamedBuffer_load_with(get_proc_address) as usize;
    count += glMapNamedBufferRange_load_with(get_proc_address) as usize;
    count += glMemoryBarrier_load_with(get_proc_address) as usize;
    count += glMemoryBarrierByRegion_load_with(get_proc_address) as usize;
    count += glMinSampleShading_load_with(get_proc_address) as usize;
    count += glMultiDrawArrays_load_with(get_proc_address) as usize;
    count += glMultiDrawArraysIndirect_load_with(get_proc_address) as usize;
    count +=
      glMultiDrawArraysIndirectCount_load_with(get_proc_address) as usize;
    count += glMultiDrawElements_load_with(get_proc_address) as usize;
    count += glMultiDrawElementsBaseVertex_load_with(get_proc_address) as usize;
    count += glMultiDrawElementsIndirect_load_with(get_proc_address) as usize;
    count +=
      glMultiDrawElementsIndirectCount_load_with(get_proc_address) as usize;
    count += glNamedBufferData_load_with(get_proc_address) as usize;
    count += glNamedBufferStorage_load_with(get_proc_address) as usize;
    count += glNamedBufferSubData_load_with(get_proc_address) as usize;
    count += glNamedFramebufferDrawBuffer_load_with(get_proc_address) as usize;
    count += glNamedFramebufferDrawBuffers_load_with(get_proc_address) as usize;
    count += glNamedFramebufferParameteri_load_with(get_proc_address) as usize;
    count += glNamedFramebufferReadBuffer_load_with(get_proc_address) as usize;
    count +=
      glNamedFramebufferRenderbuffer_load_with(get_proc_address) as usize;
    count += glNamedFramebufferTexture_load_with(get_proc_address) as usize;
    count +=
      glNamedFramebufferTextureLayer_load_with(get_proc_address) as usize;
    count += glNamedRenderbufferStorage_load_with(get_proc_address) as usize;
    count += glNamedRenderbufferStorageMultisample_load_with(get_proc_address)
      as usize;
    count += glObjectLabel_load_with(get_proc_address) as usize;
    count += glObjectPtrLabel_load_with(get_proc_address) as usize;
    count += glPatchParameterfv_load_with(get_proc_address) as usize;
    count += glPatchParameteri_load_with(get_proc_address) as usize;
    count += glPauseTransformFeedback_load_with(get_proc_address) as usize;
    count += glPixelStoref_load_with(get_proc_address) as usize;
    count += glPixelStorei_load_with(get_proc_address) as usize;
    count += glPointParameterf_load_with(get_proc_address) as usize;
    count += glPointParameterfv_load_with(get_proc_address) as usize;
    count += glPointParameteri_load_with(get_proc_address) as usize;
    count += glPointParameteriv_load_with(get_proc_address) as usize;
    count += glPointSize_load_with(get_proc_address) as usize;
    count += glPolygonMode_load_with(get_proc_address) as usize;
    count += glPolygonOffset_load_with(get_proc_address) as usize;
    count += glPolygonOffsetClamp_load_with(get_proc_address) as usize;
    count += glPopDebugGroup_load_with(get_proc_address) as usize;
    count += glPrimitiveRestartIndex_load_with(get_proc_address) as usize;
    count += glProgramBinary_load_with(get_proc_address) as usize;
    count += glProgramParameteri_load_with(get_proc_address) as usize;
    count += glProgramUniform1d_load_with(get_proc_address) as usize;
    count += glProgramUniform1dv_load_with(get_proc_address) as usize;
    count += glProgramUniform1f_load_with(get_proc_address) as usize;
    count += glProgramUniform1fv_load_with(get_proc_address) as usize;
    count += glProgramUniform1i_load_with(get_proc_address) as usize;
    count += glProgramUniform1iv_load_with(get_proc_address) as usize;
    count += glProgramUniform1ui_load_with(get_proc_address) as usize;
    count += glProgramUniform1uiv_load_with(get_proc_address) as usize;
    count += glProgramUniform2d_load_with(get_proc_address) as usize;
    count += glProgramUniform2dv_load_with(get_proc_address) as usize;
    count += glProgramUniform2f_load_with(get_proc_address) as usize;
    count += glProgramUniform2fv_load_with(get_proc_address) as usize;
    count += glProgramUniform2i_load_with(get_proc_address) as usize;
    count += glProgramUniform2iv_load_with(get_proc_address) as usize;
    count += glProgramUniform2ui_load_with(get_proc_address) as usize;
    count += glProgramUniform2uiv_load_with(get_proc_address) as usize;
    count += glProgramUniform3d_load_with(get_proc_address) as usize;
    count += glProgramUniform3dv_load_with(get_proc_address) as usize;
    count += glProgramUniform3f_load_with(get_proc_address) as usize;
    count += glProgramUniform3fv_load_with(get_proc_address) as usize;
    count += glProgramUniform3i_load_with(get_proc_address) as usize;
    count += glProgramUniform3iv_load_with(get_proc_address) as usize;
    count += glProgramUniform3ui_load_with(get_proc_address) as usize;
    count += glProgramUniform3uiv_load_with(get_proc_address) as usize;
    count += glProgramUniform4d_load_with(get_proc_address) as usize;
    count += glProgramUniform4dv_load_with(get_proc_address) as usize;
    count += glProgramUniform4f_load_with(get_proc_address) as usize;
    count += glProgramUniform4fv_load_with(get_proc_address) as usize;
    count += glProgramUniform4i_load_with(get_proc_address) as usize;
    count += glProgramUniform4iv_load_with(get_proc_address) as usize;
    count += glProgramUniform4ui_load_with(get_proc_address) as usize;
    count += glProgramUniform4uiv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix2dv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix2fv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix2x3dv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix2x3fv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix2x4dv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix2x4fv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix3dv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix3fv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix3x2dv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix3x2fv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix3x4dv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix3x4fv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix4dv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix4fv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix4x2dv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix4x2fv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix4x3dv_load_with(get_proc_address) as usize;
    count += glProgramUniformMatrix4x3fv_load_with(get_proc_address) as usize;
    count += glProvokingVertex_load_with(get_proc_address) as usize;
    count += glPushDebugGroup_load_with(get_proc_address) as usize;
    count += glQueryCounter_load_with(get_proc_address) as usize;
    count += glReadBuffer_load_with(get_proc_address) as usize;
    count += glReadPixels_load_with(get_proc_address) as usize;
    count += glReadnPixels_load_with(get_proc_address) as usize;
    count += glReleaseShaderCompiler_load_with(get_proc_address) as usize;
    count += glRenderbufferStorage_load_with(get_proc_address) as usize;
    count +=
      glRenderbufferStorageMultisample_load_with(get_proc_address) as usize;
    count += glResumeTransformFeedback_load_with(get_proc_address) as usize;
    count += glSampleCoverage_load_with(get_proc_address) as usize;
    count += glSampleMaski_load_with(get_proc_address) as usize;
    count += glSamplerParameterIiv_load_with(get_proc_address) as usize;
    count += glSamplerParameterIuiv_load_with(get_proc_address) as usize;
    count += glSamplerParameterf_load_with(get_proc_address) as usize;
    count += glSamplerParameterfv_load_with(get_proc_address) as usize;
    count += glSamplerParameteri_load_with(get_proc_address) as usize;
    count += glSamplerParameteriv_load_with(get_proc_address) as usize;
    count += glScissor_load_with(get_proc_address) as usize;
    count += glScissorArrayv_load_with(get_proc_address) as usize;
    count += glScissorIndexed_load_with(get_proc_address) as usize;
    count += glScissorIndexedv_load_with(get_proc_address) as usize;
    count += glShaderBinary_load_with(get_proc_address) as usize;
    count += glShaderSource_load_with(get_proc_address) as usize;
    count += glShaderStorageBlockBinding_load_with(get_proc_address) as usize;
    count += glSpecializeShader_load_with(get_proc_address) as usize;
    count += glStencilFunc_load_with(get_proc_address) as usize;
    count += glStencilFuncSeparate_load_with(get_proc_address) as usize;
    count += glStencilMask_load_with(get_proc_address) as usize;
    count += glStencilMaskSeparate_load_with(get_proc_address) as usize;
    count += glStencilOp_load_with(get_proc_address) as usize;
    count += glStencilOpSeparate_load_with(get_proc_address) as usize;
    count += glTexBuffer_load_with(get_proc_address) as usize;
    count += glTexBufferRange_load_with(get_proc_address) as usize;
    count += glTexImage1D_load_with(get_proc_address) as usize;
    count += glTexImage2D_load_with(get_proc_address) as usize;
    count += glTexImage2DMultisample_load_with(get_proc_address) as usize;
    count += glTexImage3D_load_with(get_proc_address) as usize;
    count += glTexImage3DMultisample_load_with(get_proc_address) as usize;
    count += glTexParameterIiv_load_with(get_proc_address) as usize;
    count += glTexParameterIuiv_load_with(get_proc_address) as usize;
    count += glTexParameterf_load_with(get_proc_address) as usize;
    count += glTexParameterfv_load_with(get_proc_address) as usize;
    count += glTexParameteri_load_with(get_proc_address) as usize;
    count += glTexParameteriv_load_with(get_proc_address) as usize;
    count += glTexStorage1D_load_with(get_proc_address) as usize;
    count += glTexStorage2D_load_with(get_proc_address) as usize;
    count += glTexStorage2DMultisample_load_with(get_proc_address) as usize;
    count += glTexStorage3D_load_with(get_proc_address) as usize;
    count += glTexStorage3DMultisample_load_with(get_proc_address) as usize;
    count += glTexSubImage1D_load_with(get_proc_address) as usize;
    count += glTexSubImage2D_load_with(get_proc_address) as usize;
    count += glTexSubImage3D_load_with(get_proc_address) as usize;
    count += glTextureBarrier_load_with(get_proc_address) as usize;
    count += glTextureBuffer_load_with(get_proc_address) as usize;
    count += glTextureBufferRange_load_with(get_proc_address) as usize;
    count += glTextureParameterIiv_load_with(get_proc_address) as usize;
    count += glTextureParameterIuiv_load_with(get_proc_address) as usize;
    count += glTextureParameterf_load_with(get_proc_address) as usize;
    count += glTextureParameterfv_load_with(get_proc_address) as usize;
    count += glTextureParameteri_load_with(get_proc_address) as usize;
    count += glTextureParameteriv_load_with(get_proc_address) as usize;
    count += glTextureStorage1D_load_with(get_proc_address) as usize;
    count += glTextureStorage2D_load_with(get_proc_address) as usize;
    count += glTextureStorage2DMultisample_load_with(get_proc_address) as usize;
    count += glTextureStorage3D_load_with(get_proc_address) as usize;
    count += glTextureStorage3DMultisample_load_with(get_proc_address) as usize;
    count += glTextureSubImage1D_load_with(get_proc_address) as usize;
    count += glTextureSubImage2D_load_with(get_proc_address) as usize;
    count += glTextureSubImage3D_load_with(get_proc_address) as usize;
    count += glTextureView_load_with(get_proc_address) as usize;
    count += glTransformFeedbackBufferBase_load_with(get_proc_address) as usize;
    count +=
      glTransformFeedbackBufferRange_load_with(get_proc_address) as usize;
    count += glTransformFeedbackVaryings_load_with(get_proc_address) as usize;
    count += glUniform1d_load_with(get_proc_address) as usize;
    count += glUniform1dv_load_with(get_proc_address) as usize;
    count += glUniform1f_load_with(get_proc_address) as usize;
    count += glUniform1fv_load_with(get_proc_address) as usize;
    count += glUniform1i_load_with(get_proc_address) as usize;
    count += glUniform1iv_load_with(get_proc_address) as usize;
    count += glUniform1ui_load_with(get_proc_address) as usize;
    count += glUniform1uiv_load_with(get_proc_address) as usize;
    count += glUniform2d_load_with(get_proc_address) as usize;
    count += glUniform2dv_load_with(get_proc_address) as usize;
    count += glUniform2f_load_with(get_proc_address) as usize;
    count += glUniform2fv_load_with(get_proc_address) as usize;
    count += glUniform2i_load_with(get_proc_address) as usize;
    count += glUniform2iv_load_with(get_proc_address) as usize;
    count += glUniform2ui_load_with(get_proc_address) as usize;
    count += glUniform2uiv_load_with(get_proc_address) as usize;
    count += glUniform3d_load_with(get_proc_address) as usize;
    count += glUniform3dv_load_with(get_proc_address) as usize;
    count += glUniform3f_load_with(get_proc_address) as usize;
    count += glUniform3fv_load_with(get_proc_address) as usize;
    count += glUniform3i_load_with(get_proc_address) as usize;
    count += glUniform3iv_load_with(get_proc_address) as usize;
    count += glUniform3ui_load_with(get_proc_address) as usize;
    count += glUniform3uiv_load_with(get_proc_address) as usize;
    count += glUniform4d_load_with(get_proc_address) as usize;
    count += glUniform4dv_load_with(get_proc_address) as usize;
    count += glUniform4f_load_with(get_proc_address) as usize;
    count += glUniform4fv_load_with(get_proc_address) as usize;
    count += glUniform4i_load_with(get_proc_address) as usize;
    count += glUniform4iv_load_with(get_proc_address) as usize;
    count += glUniform4ui_load_with(get_proc_address) as usize;
    count += glUniform4uiv_load_with(get_proc_address) as usize;
    count += glUniformBlockBinding_load_with(get_proc_address) as usize;
    count += glUniformMatrix2dv_load_with(get_proc_address) as usize;
    count += glUniformMatrix2fv_load_with(get_proc_address) as usize;
    count += glUniformMatrix2x3dv_load_with(get_proc_address) as usize;
    count += glUniformMatrix2x3fv_load_with(get_proc_address) as usize;
    count += glUniformMatrix2x4dv_load_with(get_proc_address) as usize;
    count += glUniformMatrix2x4fv_load_with(get_proc_address) as usize;
    count += glUniformMatrix3dv_load_with(get_proc_address) as usize;
    count += glUniformMatrix3fv_load_with(get_proc_address) as usize;
    count += glUniformMatrix3x2dv_load_with(get_proc_address) as usize;
    count += glUniformMatrix3x2fv_load_with(get_proc_address) as usize;
    count += glUniformMatrix3x4dv_load_with(get_proc_address) as usize;
    count += glUniformMatrix3x4fv_load_with(get_proc_address) as usize;
    count += glUniformMatrix4dv_load_with(get_proc_address) as usize;
    count += glUniformMatrix4fv_load_with(get_proc_address) as usize;
    count += glUniformMatrix4x2dv_load_with(get_proc_address) as usize;
    count += glUniformMatrix4x2fv_load_with(get_proc_address) as usize;
    count += glUniformMatrix4x3dv_load_with(get_proc_address) as usize;
    count += glUniformMatrix4x3fv_load_with(get_proc_address) as usize;
    count += glUniformSubroutinesuiv_load_with(get_proc_address) as usize;
    count += glUnmapBuffer_load_with(get_proc_address) as usize;
    count += glUnmapNamedBuffer_load_with(get_proc_address) as usize;
    count += glUseProgram_load_with(get_proc_address) as usize;
    count += glUseProgramStages_load_with(get_proc_address) as usize;
    count += glValidateProgram_load_with(get_proc_address) as usize;
    count += glValidateProgramPipeline_load_with(get_proc_address) as usize;
    count += glVertexArrayAttribBinding_load_with(get_proc_address) as usize;
    count += glVertexArrayAttribFormat_load_with(get_proc_address) as usize;
    count += glVertexArrayAttribIFormat_load_with(get_proc_address) as usize;
    count += glVertexArrayAttribLFormat_load_with(get_proc_address) as usize;
    count += glVertexArrayBindingDivisor_load_with(get_proc_address) as usize;
    count += glVertexArrayElementBuffer_load_with(get_proc_address) as usize;
    count += glVertexArrayVertexBuffer_load_with(get_proc_address) as usize;
    count += glVertexArrayVertexBuffers_load_with(get_proc_address) as usize;
    count += glVertexAttrib1d_load_with(get_proc_address) as usize;
    count += glVertexAttrib1dv_load_with(get_proc_address) as usize;
    count += glVertexAttrib1f_load_with(get_proc_address) as usize;
    count += glVertexAttrib1fv_load_with(get_proc_address) as usize;
    count += glVertexAttrib1s_load_with(get_proc_address) as usize;
    count += glVertexAttrib1sv_load_with(get_proc_address) as usize;
    count += glVertexAttrib2d_load_with(get_proc_address) as usize;
    count += glVertexAttrib2dv_load_with(get_proc_address) as usize;
    count += glVertexAttrib2f_load_with(get_proc_address) as usize;
    count += glVertexAttrib2fv_load_with(get_proc_address) as usize;
    count += glVertexAttrib2s_load_with(get_proc_address) as usize;
    count += glVertexAttrib2sv_load_with(get_proc_address) as usize;
    count += glVertexAttrib3d_load_with(get_proc_address) as usize;
    count += glVertexAttrib3dv_load_with(get_proc_address) as usize;
    count += glVertexAttrib3f_load_with(get_proc_address) as usize;
    count += glVertexAttrib3fv_load_with(get_proc_address) as usize;
    count += glVertexAttrib3s_load_with(get_proc_address) as usize;
    count += glVertexAttrib3sv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4Nbv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4Niv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4Nsv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4Nub_load_with(get_proc_address) as usize;
    count += glVertexAttrib4Nubv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4Nuiv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4Nusv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4bv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4d_load_with(get_proc_address) as usize;
    count += glVertexAttrib4dv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4f_load_with(get_proc_address) as usize;
    count += glVertexAttrib4fv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4iv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4s_load_with(get_proc_address) as usize;
    count += glVertexAttrib4sv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4ubv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4uiv_load_with(get_proc_address) as usize;
    count += glVertexAttrib4usv_load_with(get_proc_address) as usize;
    count += glVertexAttribBinding_load_with(get_proc_address) as usize;
    count += glVertexAttribDivisor_load_with(get_proc_address) as usize;
    count += glVertexAttribFormat_load_with(get_proc_address) as usize;
    count += glVertexAttribI1i_load_with(get_proc_address) as usize;
    count += glVertexAttribI1iv_load_with(get_proc_address) as usize;
    count += glVertexAttribI1ui_load_with(get_proc_address) as usize;
    count += glVertexAttribI1uiv_load_with(get_proc_address) as usize;
    count += glVertexAttribI2i_load_with(get_proc_address) as usize;
    count += glVertexAttribI2iv_load_with(get_proc_address) as usize;
    count += glVertexAttribI2ui_load_with(get_proc_address) as usize;
    count += glVertexAttribI2uiv_load_with(get_proc_address) as usize;
    count += glVertexAttribI3i_load_with(get_proc_address) as usize;
    count += glVertexAttribI3iv_load_with(get_proc_address) as usize;
    count += glVertexAttribI3ui_load_with(get_proc_address) as usize;
    count += glVertexAttribI3uiv_load_with(get_proc_address) as usize;
    count += glVertexAttribI4bv_load_with(get_proc_address) as usize;
    count += glVertexAttribI4i_load_with(get_proc_address) as usize;
    count += glVertexAttribI4iv_load_with(get_proc_address) as usize;
    count += glVertexAttribI4sv_load_with(get_proc_address) as usize;
    count += glVertexAttribI4ubv_load_with(get_proc_address) as usize;
    count += glVertexAttribI4ui_load_with(get_proc_address) as usize;
    count += glVertexAttribI4uiv_load_with(get_proc_address) as usize;
    count += glVertexAttribI4usv_load_with(get_proc_address) as usize;
    count += glVertexAttribIFormat_load_with(get_proc_address) as usize;
    count += glVertexAttribIPointer_load_with(get_proc_address) as usize;
    count += glVertexAttribL1d_load_with(get_proc_address) as usize;
    count += glVertexAttribL1dv_load_with(get_proc_address) as usize;
    count += glVertexAttribL2d_load_with(get_proc_address) as usize;
    count += glVertexAttribL2dv_load_with(get_proc_address) as usize;
    count += glVertexAttribL3d_load_with(get_proc_address) as usize;
    count += glVertexAttribL3dv_load_with(get_proc_address) as usize;
    count += glVertexAttribL4d_load_with(get_proc_address) as usize;
    count += glVertexAttribL4dv_load_with(get_proc_address) as usize;
    count += glVertexAttribLFormat_load_with(get_proc_address) as usize;
    count += glVertexAttribLPointer_load_with(get_proc_address) as usize;
    count += glVertexAttribP1ui_load_with(get_proc_address) as usize;
    count += glVertexAttribP1uiv_load_with(get_proc_address) as usize;
    count += glVertexAttribP2ui_load_with(get_proc_address) as usize;
    count += glVertexAttribP2uiv_load_with(get_proc_address) as usize;
    count += glVertexAttribP3ui_load_with(get_proc_address) as usize;
    count += glVertexAttribP3uiv_load_with(get_proc_address) as usize;
    count += glVertexAttribP4ui_load_with(get_proc_address) as usize;
    count += glVertexAttribP4uiv_load_with(get_proc_address) as usize;
    count += glVertexAttribPointer_load_with(get_proc_address) as usize;
    count += glVertexBindingDivisor_load_with(get_proc_address) as usize;
    count += glViewport_load_with(get_proc_address) as usize;
    count += glViewportArrayv_load_with(get_proc_address) as usize;
    count += glViewportIndexedf_load_with(get_proc_address) as usize;
    count += glViewportIndexedfv_load_with(get_proc_address) as usize;
    count += glWaitSync_load_with(get_proc_address) as usize;
    count
  }

  /// [glActiveShaderProgram](http://docs.gl/gl4/glActiveShaderProgram)(pipeline, program)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glActiveShaderProgram(pipeline: GLuint, program: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glActiveShaderProgram({:?}, {:?});", pipeline, program);
    }
    let p = glActiveShaderProgram_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(pipeline, program),
      None => go_panic_because_fn_not_loaded("glActiveShaderProgram"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glActiveShaderProgram" != "glGetError" {
        report_error_as_necessary_from("glActiveShaderProgram", glGetError());
      }
    }
    out
  }
  static glActiveShaderProgram_p: APcv = ap_null();
  /// Tries to load [`glActiveShaderProgram`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glActiveShaderProgram_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glActiveShaderProgram\0");
    glActiveShaderProgram_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glActiveShaderProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glActiveShaderProgram_is_loaded() -> bool {
    !glActiveShaderProgram_p.load(RELAX).is_null()
  }

  /// [glActiveTexture](http://docs.gl/gl4/glActiveTexture)(texture)
  /// * `texture` group: TextureUnit
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glActiveTexture(texture: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glActiveTexture({:#X});", texture);
    }
    let p = glActiveTexture_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(texture),
      None => go_panic_because_fn_not_loaded("glActiveTexture"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glActiveTexture" != "glGetError" {
        report_error_as_necessary_from("glActiveTexture", glGetError());
      }
    }
    out
  }
  static glActiveTexture_p: APcv = ap_null();
  /// Tries to load [`glActiveTexture`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glActiveTexture_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glActiveTexture\0");
    glActiveTexture_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glActiveTexture`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glActiveTexture_is_loaded() -> bool {
    !glActiveTexture_p.load(RELAX).is_null()
  }

  /// [glAttachShader](http://docs.gl/gl4/glAttachShader)(program, shader)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glAttachShader(program: GLuint, shader: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glAttachShader({:?}, {:?});", program, shader);
    }
    let p = glAttachShader_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(program, shader),
      None => go_panic_because_fn_not_loaded("glAttachShader"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glAttachShader" != "glGetError" {
        report_error_as_necessary_from("glAttachShader", glGetError());
      }
    }
    out
  }
  static glAttachShader_p: APcv = ap_null();
  /// Tries to load [`glAttachShader`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glAttachShader_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glAttachShader\0");
    glAttachShader_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glAttachShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glAttachShader_is_loaded() -> bool {
    !glAttachShader_p.load(RELAX).is_null()
  }

  /// [glBeginConditionalRender](http://docs.gl/gl4/glBeginConditionalRender)(id, mode)
  /// * `mode` group: ConditionalRenderMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBeginConditionalRender(id: GLuint, mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBeginConditionalRender({:?}, {:#X});", id, mode);
    }
    let p = glBeginConditionalRender_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum)>>(p) {
      Some(fn_p) => fn_p(id, mode),
      None => go_panic_because_fn_not_loaded("glBeginConditionalRender"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBeginConditionalRender" != "glGetError" {
        report_error_as_necessary_from(
          "glBeginConditionalRender",
          glGetError(),
        );
      }
    }
    out
  }
  static glBeginConditionalRender_p: APcv = ap_null();
  /// Tries to load [`glBeginConditionalRender`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBeginConditionalRender_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glBeginConditionalRender\0");
    glBeginConditionalRender_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBeginConditionalRender`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBeginConditionalRender_is_loaded() -> bool {
    !glBeginConditionalRender_p.load(RELAX).is_null()
  }

  /// [glBeginQuery](http://docs.gl/gl4/glBeginQuery)(target, id)
  /// * `target` group: QueryTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBeginQuery(target: GLenum, id: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBeginQuery({:#X}, {:?});", target, id);
    }
    let p = glBeginQuery_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(target, id),
      None => go_panic_because_fn_not_loaded("glBeginQuery"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBeginQuery" != "glGetError" {
        report_error_as_necessary_from("glBeginQuery", glGetError());
      }
    }
    out
  }
  static glBeginQuery_p: APcv = ap_null();
  /// Tries to load [`glBeginQuery`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBeginQuery_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBeginQuery\0");
    glBeginQuery_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBeginQuery`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBeginQuery_is_loaded() -> bool {
    !glBeginQuery_p.load(RELAX).is_null()
  }

  /// [glBeginQueryIndexed](http://docs.gl/gl4/glBeginQueryIndexed)(target, index, id)
  /// * `target` group: QueryTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBeginQueryIndexed(target: GLenum, index: GLuint, id: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBeginQueryIndexed({:#X}, {:?}, {:?});",
        target,
        index,
        id
      );
    }
    let p = glBeginQueryIndexed_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(target, index, id),
      None => go_panic_because_fn_not_loaded("glBeginQueryIndexed"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBeginQueryIndexed" != "glGetError" {
        report_error_as_necessary_from("glBeginQueryIndexed", glGetError());
      }
    }
    out
  }
  static glBeginQueryIndexed_p: APcv = ap_null();
  /// Tries to load [`glBeginQueryIndexed`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBeginQueryIndexed_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBeginQueryIndexed\0");
    glBeginQueryIndexed_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBeginQueryIndexed`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBeginQueryIndexed_is_loaded() -> bool {
    !glBeginQueryIndexed_p.load(RELAX).is_null()
  }

  /// [glBeginTransformFeedback](http://docs.gl/gl4/glBeginTransformFeedback)(primitiveMode)
  /// * `primitiveMode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBeginTransformFeedback(primitiveMode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBeginTransformFeedback({:#X});", primitiveMode);
    }
    let p = glBeginTransformFeedback_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(primitiveMode),
      None => go_panic_because_fn_not_loaded("glBeginTransformFeedback"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBeginTransformFeedback" != "glGetError" {
        report_error_as_necessary_from(
          "glBeginTransformFeedback",
          glGetError(),
        );
      }
    }
    out
  }
  static glBeginTransformFeedback_p: APcv = ap_null();
  /// Tries to load [`glBeginTransformFeedback`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBeginTransformFeedback_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glBeginTransformFeedback\0");
    glBeginTransformFeedback_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBeginTransformFeedback`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBeginTransformFeedback_is_loaded() -> bool {
    !glBeginTransformFeedback_p.load(RELAX).is_null()
  }

  /// [glBindAttribLocation](http://docs.gl/gl4/glBindAttribLocation)(program, index, name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindAttribLocation(
    program: GLuint,
    index: GLuint,
    name: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindAttribLocation({:?}, {:?}, {:p});",
        program,
        index,
        name
      );
    }
    let p = glBindAttribLocation_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLuint, *const GLchar)>>(p) {
        Some(fn_p) => fn_p(program, index, name),
        None => go_panic_because_fn_not_loaded("glBindAttribLocation"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindAttribLocation" != "glGetError" {
        report_error_as_necessary_from("glBindAttribLocation", glGetError());
      }
    }
    out
  }
  static glBindAttribLocation_p: APcv = ap_null();
  /// Tries to load [`glBindAttribLocation`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindAttribLocation_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindAttribLocation\0");
    glBindAttribLocation_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindAttribLocation`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindAttribLocation_is_loaded() -> bool {
    !glBindAttribLocation_p.load(RELAX).is_null()
  }

  /// [glBindBuffer](http://docs.gl/gl4/glBindBuffer)(target, buffer)
  /// * `target` group: BufferTargetARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindBuffer(target: GLenum, buffer: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindBuffer({:#X}, {:?});", target, buffer);
    }
    let p = glBindBuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(target, buffer),
      None => go_panic_because_fn_not_loaded("glBindBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindBuffer" != "glGetError" {
        report_error_as_necessary_from("glBindBuffer", glGetError());
      }
    }
    out
  }
  static glBindBuffer_p: APcv = ap_null();
  /// Tries to load [`glBindBuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindBuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindBuffer\0");
    glBindBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindBuffer_is_loaded() -> bool {
    !glBindBuffer_p.load(RELAX).is_null()
  }

  /// [glBindBufferBase](http://docs.gl/gl4/glBindBufferBase)(target, index, buffer)
  /// * `target` group: BufferTargetARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindBufferBase(
    target: GLenum,
    index: GLuint,
    buffer: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindBufferBase({:#X}, {:?}, {:?});",
        target,
        index,
        buffer
      );
    }
    let p = glBindBufferBase_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(target, index, buffer),
      None => go_panic_because_fn_not_loaded("glBindBufferBase"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindBufferBase" != "glGetError" {
        report_error_as_necessary_from("glBindBufferBase", glGetError());
      }
    }
    out
  }
  static glBindBufferBase_p: APcv = ap_null();
  /// Tries to load [`glBindBufferBase`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindBufferBase_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindBufferBase\0");
    glBindBufferBase_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindBufferBase`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindBufferBase_is_loaded() -> bool {
    !glBindBufferBase_p.load(RELAX).is_null()
  }

  /// [glBindBufferRange](http://docs.gl/gl4/glBindBufferRange)(target, index, buffer, offset, size)
  /// * `target` group: BufferTargetARB
  /// * `offset` group: BufferOffset
  /// * `size` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindBufferRange(
    target: GLenum,
    index: GLuint,
    buffer: GLuint,
    offset: GLintptr,
    size: GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindBufferRange({:#X}, {:?}, {:?}, {:?}, {:?});",
        target,
        index,
        buffer,
        offset,
        size
      );
    }
    let p = glBindBufferRange_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLuint, GLuint, GLintptr, GLsizeiptr)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, index, buffer, offset, size),
      None => go_panic_because_fn_not_loaded("glBindBufferRange"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindBufferRange" != "glGetError" {
        report_error_as_necessary_from("glBindBufferRange", glGetError());
      }
    }
    out
  }
  static glBindBufferRange_p: APcv = ap_null();
  /// Tries to load [`glBindBufferRange`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindBufferRange_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindBufferRange\0");
    glBindBufferRange_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindBufferRange`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindBufferRange_is_loaded() -> bool {
    !glBindBufferRange_p.load(RELAX).is_null()
  }

  /// [glBindBuffersBase](http://docs.gl/gl4/glBindBuffersBase)(target, first, count, buffers)
  /// * `target` group: BufferTargetARB
  /// * `buffers` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindBuffersBase(
    target: GLenum,
    first: GLuint,
    count: GLsizei,
    buffers: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindBuffersBase({:#X}, {:?}, {:?}, {:p});",
        target,
        first,
        count,
        buffers
      );
    }
    let p = glBindBuffersBase_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLuint, GLsizei, *const GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, first, count, buffers),
      None => go_panic_because_fn_not_loaded("glBindBuffersBase"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindBuffersBase" != "glGetError" {
        report_error_as_necessary_from("glBindBuffersBase", glGetError());
      }
    }
    out
  }
  static glBindBuffersBase_p: APcv = ap_null();
  /// Tries to load [`glBindBuffersBase`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindBuffersBase_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindBuffersBase\0");
    glBindBuffersBase_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindBuffersBase`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindBuffersBase_is_loaded() -> bool {
    !glBindBuffersBase_p.load(RELAX).is_null()
  }

  /// [glBindBuffersRange](http://docs.gl/gl4/glBindBuffersRange)(target, first, count, buffers, offsets, sizes)
  /// * `target` group: BufferTargetARB
  /// * `buffers` len: count
  /// * `offsets` len: count
  /// * `sizes` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindBuffersRange(
    target: GLenum,
    first: GLuint,
    count: GLsizei,
    buffers: *const GLuint,
    offsets: *const GLintptr,
    sizes: *const GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindBuffersRange({:#X}, {:?}, {:?}, {:p}, {:p}, {:p});",
        target,
        first,
        count,
        buffers,
        offsets,
        sizes
      );
    }
    let p = glBindBuffersRange_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLuint,
          GLsizei,
          *const GLuint,
          *const GLintptr,
          *const GLsizeiptr,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(target, first, count, buffers, offsets, sizes),
      None => go_panic_because_fn_not_loaded("glBindBuffersRange"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindBuffersRange" != "glGetError" {
        report_error_as_necessary_from("glBindBuffersRange", glGetError());
      }
    }
    out
  }
  static glBindBuffersRange_p: APcv = ap_null();
  /// Tries to load [`glBindBuffersRange`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindBuffersRange_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindBuffersRange\0");
    glBindBuffersRange_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindBuffersRange`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindBuffersRange_is_loaded() -> bool {
    !glBindBuffersRange_p.load(RELAX).is_null()
  }

  /// [glBindFragDataLocation](http://docs.gl/gl4/glBindFragDataLocation)(program, color, name)
  /// * `name` len: COMPSIZE(name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindFragDataLocation(
    program: GLuint,
    color: GLuint,
    name: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindFragDataLocation({:?}, {:?}, {:p});",
        program,
        color,
        name
      );
    }
    let p = glBindFragDataLocation_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLuint, *const GLchar)>>(p) {
        Some(fn_p) => fn_p(program, color, name),
        None => go_panic_because_fn_not_loaded("glBindFragDataLocation"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindFragDataLocation" != "glGetError" {
        report_error_as_necessary_from("glBindFragDataLocation", glGetError());
      }
    }
    out
  }
  static glBindFragDataLocation_p: APcv = ap_null();
  /// Tries to load [`glBindFragDataLocation`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindFragDataLocation_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindFragDataLocation\0");
    glBindFragDataLocation_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindFragDataLocation`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindFragDataLocation_is_loaded() -> bool {
    !glBindFragDataLocation_p.load(RELAX).is_null()
  }

  /// [glBindFragDataLocationIndexed](http://docs.gl/gl4/glBindFragDataLocationIndexed)(program, colorNumber, index, name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindFragDataLocationIndexed(
    program: GLuint,
    colorNumber: GLuint,
    index: GLuint,
    name: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindFragDataLocationIndexed({:?}, {:?}, {:?}, {:p});",
        program,
        colorNumber,
        index,
        name
      );
    }
    let p = glBindFragDataLocationIndexed_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLuint, GLuint, *const GLchar)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, colorNumber, index, name),
      None => go_panic_because_fn_not_loaded("glBindFragDataLocationIndexed"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindFragDataLocationIndexed" != "glGetError" {
        report_error_as_necessary_from(
          "glBindFragDataLocationIndexed",
          glGetError(),
        );
      }
    }
    out
  }
  static glBindFragDataLocationIndexed_p: APcv = ap_null();
  /// Tries to load [`glBindFragDataLocationIndexed`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindFragDataLocationIndexed_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glBindFragDataLocationIndexed\0");
    glBindFragDataLocationIndexed_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindFragDataLocationIndexed`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindFragDataLocationIndexed_is_loaded() -> bool {
    !glBindFragDataLocationIndexed_p.load(RELAX).is_null()
  }

  /// [glBindFramebuffer](http://docs.gl/gl4/glBindFramebuffer)(target, framebuffer)
  /// * `target` group: FramebufferTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindFramebuffer(target: GLenum, framebuffer: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindFramebuffer({:#X}, {:?});", target, framebuffer);
    }
    let p = glBindFramebuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(target, framebuffer),
      None => go_panic_because_fn_not_loaded("glBindFramebuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindFramebuffer" != "glGetError" {
        report_error_as_necessary_from("glBindFramebuffer", glGetError());
      }
    }
    out
  }
  static glBindFramebuffer_p: APcv = ap_null();
  /// Tries to load [`glBindFramebuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindFramebuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindFramebuffer\0");
    glBindFramebuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindFramebuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindFramebuffer_is_loaded() -> bool {
    !glBindFramebuffer_p.load(RELAX).is_null()
  }

  /// [glBindImageTexture](http://docs.gl/gl4/glBindImageTexture)(unit, texture, level, layered, layer, access, format)
  /// * `access` group: BufferAccessARB
  /// * `format` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindImageTexture(
    unit: GLuint,
    texture: GLuint,
    level: GLint,
    layered: GLboolean,
    layer: GLint,
    access: GLenum,
    format: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindImageTexture({:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X});", unit, texture, level, layered, layer, access, format);
    }
    let p = glBindImageTexture_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLuint,
          GLint,
          GLboolean,
          GLint,
          GLenum,
          GLenum,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(unit, texture, level, layered, layer, access, format),
      None => go_panic_because_fn_not_loaded("glBindImageTexture"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindImageTexture" != "glGetError" {
        report_error_as_necessary_from("glBindImageTexture", glGetError());
      }
    }
    out
  }
  static glBindImageTexture_p: APcv = ap_null();
  /// Tries to load [`glBindImageTexture`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindImageTexture_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindImageTexture\0");
    glBindImageTexture_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindImageTexture`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindImageTexture_is_loaded() -> bool {
    !glBindImageTexture_p.load(RELAX).is_null()
  }

  /// [glBindImageTextures](http://docs.gl/gl4/glBindImageTextures)(first, count, textures)
  /// * `textures` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindImageTextures(
    first: GLuint,
    count: GLsizei,
    textures: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindImageTextures({:?}, {:?}, {:p});",
        first,
        count,
        textures
      );
    }
    let p = glBindImageTextures_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLsizei, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(first, count, textures),
        None => go_panic_because_fn_not_loaded("glBindImageTextures"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindImageTextures" != "glGetError" {
        report_error_as_necessary_from("glBindImageTextures", glGetError());
      }
    }
    out
  }
  static glBindImageTextures_p: APcv = ap_null();
  /// Tries to load [`glBindImageTextures`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindImageTextures_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindImageTextures\0");
    glBindImageTextures_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindImageTextures`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindImageTextures_is_loaded() -> bool {
    !glBindImageTextures_p.load(RELAX).is_null()
  }

  /// [glBindProgramPipeline](http://docs.gl/gl4/glBindProgramPipeline)(pipeline)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindProgramPipeline(pipeline: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindProgramPipeline({:?});", pipeline);
    }
    let p = glBindProgramPipeline_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(pipeline),
      None => go_panic_because_fn_not_loaded("glBindProgramPipeline"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindProgramPipeline" != "glGetError" {
        report_error_as_necessary_from("glBindProgramPipeline", glGetError());
      }
    }
    out
  }
  static glBindProgramPipeline_p: APcv = ap_null();
  /// Tries to load [`glBindProgramPipeline`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindProgramPipeline_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindProgramPipeline\0");
    glBindProgramPipeline_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindProgramPipeline`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindProgramPipeline_is_loaded() -> bool {
    !glBindProgramPipeline_p.load(RELAX).is_null()
  }

  /// [glBindRenderbuffer](http://docs.gl/gl4/glBindRenderbuffer)(target, renderbuffer)
  /// * `target` group: RenderbufferTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindRenderbuffer(target: GLenum, renderbuffer: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindRenderbuffer({:#X}, {:?});", target, renderbuffer);
    }
    let p = glBindRenderbuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(target, renderbuffer),
      None => go_panic_because_fn_not_loaded("glBindRenderbuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindRenderbuffer" != "glGetError" {
        report_error_as_necessary_from("glBindRenderbuffer", glGetError());
      }
    }
    out
  }
  static glBindRenderbuffer_p: APcv = ap_null();
  /// Tries to load [`glBindRenderbuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindRenderbuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindRenderbuffer\0");
    glBindRenderbuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindRenderbuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindRenderbuffer_is_loaded() -> bool {
    !glBindRenderbuffer_p.load(RELAX).is_null()
  }

  /// [glBindSampler](http://docs.gl/gl4/glBindSampler)(unit, sampler)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindSampler(unit: GLuint, sampler: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindSampler({:?}, {:?});", unit, sampler);
    }
    let p = glBindSampler_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(unit, sampler),
      None => go_panic_because_fn_not_loaded("glBindSampler"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindSampler" != "glGetError" {
        report_error_as_necessary_from("glBindSampler", glGetError());
      }
    }
    out
  }
  static glBindSampler_p: APcv = ap_null();
  /// Tries to load [`glBindSampler`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindSampler_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindSampler\0");
    glBindSampler_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindSampler`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindSampler_is_loaded() -> bool {
    !glBindSampler_p.load(RELAX).is_null()
  }

  /// [glBindSamplers](http://docs.gl/gl4/glBindSamplers)(first, count, samplers)
  /// * `samplers` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindSamplers(
    first: GLuint,
    count: GLsizei,
    samplers: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindSamplers({:?}, {:?}, {:p});",
        first,
        count,
        samplers
      );
    }
    let p = glBindSamplers_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLsizei, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(first, count, samplers),
        None => go_panic_because_fn_not_loaded("glBindSamplers"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindSamplers" != "glGetError" {
        report_error_as_necessary_from("glBindSamplers", glGetError());
      }
    }
    out
  }
  static glBindSamplers_p: APcv = ap_null();
  /// Tries to load [`glBindSamplers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindSamplers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindSamplers\0");
    glBindSamplers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindSamplers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindSamplers_is_loaded() -> bool {
    !glBindSamplers_p.load(RELAX).is_null()
  }

  /// [glBindTexture](http://docs.gl/gl4/glBindTexture)(target, texture)
  /// * `target` group: TextureTarget
  /// * `texture` group: Texture
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindTexture(target: GLenum, texture: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindTexture({:#X}, {:?});", target, texture);
    }
    let p = glBindTexture_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(target, texture),
      None => go_panic_because_fn_not_loaded("glBindTexture"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindTexture" != "glGetError" {
        report_error_as_necessary_from("glBindTexture", glGetError());
      }
    }
    out
  }
  static glBindTexture_p: APcv = ap_null();
  /// Tries to load [`glBindTexture`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindTexture_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindTexture\0");
    glBindTexture_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindTexture`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindTexture_is_loaded() -> bool {
    !glBindTexture_p.load(RELAX).is_null()
  }

  /// [glBindTextureUnit](http://docs.gl/gl4/glBindTextureUnit)(unit, texture)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindTextureUnit(unit: GLuint, texture: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindTextureUnit({:?}, {:?});", unit, texture);
    }
    let p = glBindTextureUnit_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(unit, texture),
      None => go_panic_because_fn_not_loaded("glBindTextureUnit"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindTextureUnit" != "glGetError" {
        report_error_as_necessary_from("glBindTextureUnit", glGetError());
      }
    }
    out
  }
  static glBindTextureUnit_p: APcv = ap_null();
  /// Tries to load [`glBindTextureUnit`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindTextureUnit_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindTextureUnit\0");
    glBindTextureUnit_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindTextureUnit`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindTextureUnit_is_loaded() -> bool {
    !glBindTextureUnit_p.load(RELAX).is_null()
  }

  /// [glBindTextures](http://docs.gl/gl4/glBindTextures)(first, count, textures)
  /// * `textures` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindTextures(
    first: GLuint,
    count: GLsizei,
    textures: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindTextures({:?}, {:?}, {:p});",
        first,
        count,
        textures
      );
    }
    let p = glBindTextures_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLsizei, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(first, count, textures),
        None => go_panic_because_fn_not_loaded("glBindTextures"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindTextures" != "glGetError" {
        report_error_as_necessary_from("glBindTextures", glGetError());
      }
    }
    out
  }
  static glBindTextures_p: APcv = ap_null();
  /// Tries to load [`glBindTextures`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindTextures_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindTextures\0");
    glBindTextures_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindTextures`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindTextures_is_loaded() -> bool {
    !glBindTextures_p.load(RELAX).is_null()
  }

  /// [glBindTransformFeedback](http://docs.gl/gl4/glBindTransformFeedback)(target, id)
  /// * `target` group: BindTransformFeedbackTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindTransformFeedback(target: GLenum, id: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindTransformFeedback({:#X}, {:?});", target, id);
    }
    let p = glBindTransformFeedback_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(target, id),
      None => go_panic_because_fn_not_loaded("glBindTransformFeedback"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindTransformFeedback" != "glGetError" {
        report_error_as_necessary_from("glBindTransformFeedback", glGetError());
      }
    }
    out
  }
  static glBindTransformFeedback_p: APcv = ap_null();
  /// Tries to load [`glBindTransformFeedback`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindTransformFeedback_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindTransformFeedback\0");
    glBindTransformFeedback_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindTransformFeedback`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindTransformFeedback_is_loaded() -> bool {
    !glBindTransformFeedback_p.load(RELAX).is_null()
  }

  /// [glBindVertexArray](http://docs.gl/gl4/glBindVertexArray)(array)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindVertexArray(array: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBindVertexArray({:?});", array);
    }
    let p = glBindVertexArray_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(array),
      None => go_panic_because_fn_not_loaded("glBindVertexArray"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindVertexArray" != "glGetError" {
        report_error_as_necessary_from("glBindVertexArray", glGetError());
      }
    }
    out
  }
  static glBindVertexArray_p: APcv = ap_null();
  /// Tries to load [`glBindVertexArray`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindVertexArray_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindVertexArray\0");
    glBindVertexArray_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindVertexArray`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindVertexArray_is_loaded() -> bool {
    !glBindVertexArray_p.load(RELAX).is_null()
  }

  /// [glBindVertexBuffer](http://docs.gl/gl4/glBindVertexBuffer)(bindingindex, buffer, offset, stride)
  /// * `offset` group: BufferOffset
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindVertexBuffer(
    bindingindex: GLuint,
    buffer: GLuint,
    offset: GLintptr,
    stride: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindVertexBuffer({:?}, {:?}, {:?}, {:?});",
        bindingindex,
        buffer,
        offset,
        stride
      );
    }
    let p = glBindVertexBuffer_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLuint, GLintptr, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(bindingindex, buffer, offset, stride),
      None => go_panic_because_fn_not_loaded("glBindVertexBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindVertexBuffer" != "glGetError" {
        report_error_as_necessary_from("glBindVertexBuffer", glGetError());
      }
    }
    out
  }
  static glBindVertexBuffer_p: APcv = ap_null();
  /// Tries to load [`glBindVertexBuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindVertexBuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindVertexBuffer\0");
    glBindVertexBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindVertexBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindVertexBuffer_is_loaded() -> bool {
    !glBindVertexBuffer_p.load(RELAX).is_null()
  }

  /// [glBindVertexBuffers](http://docs.gl/gl4/glBindVertexBuffers)(first, count, buffers, offsets, strides)
  /// * `buffers` len: count
  /// * `offsets` len: count
  /// * `strides` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBindVertexBuffers(
    first: GLuint,
    count: GLsizei,
    buffers: *const GLuint,
    offsets: *const GLintptr,
    strides: *const GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBindVertexBuffers({:?}, {:?}, {:p}, {:p}, {:p});",
        first,
        count,
        buffers,
        offsets,
        strides
      );
    }
    let p = glBindVertexBuffers_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLsizei,
          *const GLuint,
          *const GLintptr,
          *const GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(first, count, buffers, offsets, strides),
      None => go_panic_because_fn_not_loaded("glBindVertexBuffers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBindVertexBuffers" != "glGetError" {
        report_error_as_necessary_from("glBindVertexBuffers", glGetError());
      }
    }
    out
  }
  static glBindVertexBuffers_p: APcv = ap_null();
  /// Tries to load [`glBindVertexBuffers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBindVertexBuffers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBindVertexBuffers\0");
    glBindVertexBuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBindVertexBuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBindVertexBuffers_is_loaded() -> bool {
    !glBindVertexBuffers_p.load(RELAX).is_null()
  }

  /// [glBlendColor](http://docs.gl/gl4/glBlendColor)(red, green, blue, alpha)
  /// * `red` group: ColorF
  /// * `green` group: ColorF
  /// * `blue` group: ColorF
  /// * `alpha` group: ColorF
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendColor(
    red: GLfloat,
    green: GLfloat,
    blue: GLfloat,
    alpha: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBlendColor({:?}, {:?}, {:?}, {:?});",
        red,
        green,
        blue,
        alpha
      );
    }
    let p = glBlendColor_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLfloat, GLfloat, GLfloat, GLfloat)>>(
        p,
      ) {
        Some(fn_p) => fn_p(red, green, blue, alpha),
        None => go_panic_because_fn_not_loaded("glBlendColor"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendColor" != "glGetError" {
        report_error_as_necessary_from("glBlendColor", glGetError());
      }
    }
    out
  }
  static glBlendColor_p: APcv = ap_null();
  /// Tries to load [`glBlendColor`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendColor_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendColor\0");
    glBlendColor_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendColor`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendColor_is_loaded() -> bool {
    !glBlendColor_p.load(RELAX).is_null()
  }

  /// [glBlendEquation](http://docs.gl/gl4/glBlendEquation)(mode)
  /// * `mode` group: BlendEquationModeEXT
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendEquation(mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBlendEquation({:#X});", mode);
    }
    let p = glBlendEquation_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(mode),
      None => go_panic_because_fn_not_loaded("glBlendEquation"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendEquation" != "glGetError" {
        report_error_as_necessary_from("glBlendEquation", glGetError());
      }
    }
    out
  }
  static glBlendEquation_p: APcv = ap_null();
  /// Tries to load [`glBlendEquation`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendEquation_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendEquation\0");
    glBlendEquation_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendEquation`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendEquation_is_loaded() -> bool {
    !glBlendEquation_p.load(RELAX).is_null()
  }

  /// [glBlendEquationSeparate](http://docs.gl/gl4/glBlendEquationSeparate)(modeRGB, modeAlpha)
  /// * `modeRGB` group: BlendEquationModeEXT
  /// * `modeAlpha` group: BlendEquationModeEXT
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBlendEquationSeparate({:#X}, {:#X});",
        modeRGB,
        modeAlpha
      );
    }
    let p = glBlendEquationSeparate_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLenum)>>(p) {
      Some(fn_p) => fn_p(modeRGB, modeAlpha),
      None => go_panic_because_fn_not_loaded("glBlendEquationSeparate"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendEquationSeparate" != "glGetError" {
        report_error_as_necessary_from("glBlendEquationSeparate", glGetError());
      }
    }
    out
  }
  static glBlendEquationSeparate_p: APcv = ap_null();
  /// Tries to load [`glBlendEquationSeparate`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendEquationSeparate_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendEquationSeparate\0");
    glBlendEquationSeparate_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendEquationSeparate`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendEquationSeparate_is_loaded() -> bool {
    !glBlendEquationSeparate_p.load(RELAX).is_null()
  }

  /// [glBlendEquationSeparatei](http://docs.gl/gl4/glBlendEquationSeparatei)(buf, modeRGB, modeAlpha)
  /// * `modeRGB` group: BlendEquationModeEXT
  /// * `modeAlpha` group: BlendEquationModeEXT
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendEquationSeparatei(
    buf: GLuint,
    modeRGB: GLenum,
    modeAlpha: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBlendEquationSeparatei({:?}, {:#X}, {:#X});",
        buf,
        modeRGB,
        modeAlpha
      );
    }
    let p = glBlendEquationSeparatei_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum)>>(p) {
      Some(fn_p) => fn_p(buf, modeRGB, modeAlpha),
      None => go_panic_because_fn_not_loaded("glBlendEquationSeparatei"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendEquationSeparatei" != "glGetError" {
        report_error_as_necessary_from(
          "glBlendEquationSeparatei",
          glGetError(),
        );
      }
    }
    out
  }
  static glBlendEquationSeparatei_p: APcv = ap_null();
  /// Tries to load [`glBlendEquationSeparatei`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendEquationSeparatei_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendEquationSeparatei\0");
    glBlendEquationSeparatei_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendEquationSeparatei`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendEquationSeparatei_is_loaded() -> bool {
    !glBlendEquationSeparatei_p.load(RELAX).is_null()
  }

  /// [glBlendEquationSeparateiARB](http://docs.gl/gl4/glBlendEquationSeparateiARB)(buf, modeRGB, modeAlpha)
  /// * `modeRGB` group: BlendEquationModeEXT
  /// * `modeAlpha` group: BlendEquationModeEXT
  /// * alias of: [`glBlendEquationSeparatei`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendEquationSeparateiARB(
    buf: GLuint,
    modeRGB: GLenum,
    modeAlpha: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBlendEquationSeparateiARB({:?}, {:#X}, {:#X});",
        buf,
        modeRGB,
        modeAlpha
      );
    }
    let p = glBlendEquationSeparateiARB_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum)>>(p) {
      Some(fn_p) => fn_p(buf, modeRGB, modeAlpha),
      None => go_panic_because_fn_not_loaded("glBlendEquationSeparateiARB"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendEquationSeparateiARB" != "glGetError" {
        report_error_as_necessary_from(
          "glBlendEquationSeparateiARB",
          glGetError(),
        );
      }
    }
    out
  }
  static glBlendEquationSeparateiARB_p: APcv = ap_null();
  /// Tries to load [`glBlendEquationSeparateiARB`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendEquationSeparateiARB_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendEquationSeparateiARB\0");
    glBlendEquationSeparateiARB_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendEquationSeparateiARB`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendEquationSeparateiARB_is_loaded() -> bool {
    !glBlendEquationSeparateiARB_p.load(RELAX).is_null()
  }

  /// [glBlendEquationi](http://docs.gl/gl4/glBlendEquationi)(buf, mode)
  /// * `mode` group: BlendEquationModeEXT
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendEquationi(buf: GLuint, mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBlendEquationi({:?}, {:#X});", buf, mode);
    }
    let p = glBlendEquationi_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum)>>(p) {
      Some(fn_p) => fn_p(buf, mode),
      None => go_panic_because_fn_not_loaded("glBlendEquationi"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendEquationi" != "glGetError" {
        report_error_as_necessary_from("glBlendEquationi", glGetError());
      }
    }
    out
  }
  static glBlendEquationi_p: APcv = ap_null();
  /// Tries to load [`glBlendEquationi`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendEquationi_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendEquationi\0");
    glBlendEquationi_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendEquationi`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendEquationi_is_loaded() -> bool {
    !glBlendEquationi_p.load(RELAX).is_null()
  }

  /// [glBlendEquationiARB](http://docs.gl/gl4/glBlendEquationiARB)(buf, mode)
  /// * `mode` group: BlendEquationModeEXT
  /// * alias of: [`glBlendEquationi`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendEquationiARB(buf: GLuint, mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBlendEquationiARB({:?}, {:#X});", buf, mode);
    }
    let p = glBlendEquationiARB_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum)>>(p) {
      Some(fn_p) => fn_p(buf, mode),
      None => go_panic_because_fn_not_loaded("glBlendEquationiARB"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendEquationiARB" != "glGetError" {
        report_error_as_necessary_from("glBlendEquationiARB", glGetError());
      }
    }
    out
  }
  static glBlendEquationiARB_p: APcv = ap_null();
  /// Tries to load [`glBlendEquationiARB`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendEquationiARB_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendEquationiARB\0");
    glBlendEquationiARB_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendEquationiARB`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendEquationiARB_is_loaded() -> bool {
    !glBlendEquationiARB_p.load(RELAX).is_null()
  }

  /// [glBlendFunc](http://docs.gl/gl4/glBlendFunc)(sfactor, dfactor)
  /// * `sfactor` group: BlendingFactor
  /// * `dfactor` group: BlendingFactor
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendFunc(sfactor: GLenum, dfactor: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBlendFunc({:#X}, {:#X});", sfactor, dfactor);
    }
    let p = glBlendFunc_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLenum)>>(p) {
      Some(fn_p) => fn_p(sfactor, dfactor),
      None => go_panic_because_fn_not_loaded("glBlendFunc"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendFunc" != "glGetError" {
        report_error_as_necessary_from("glBlendFunc", glGetError());
      }
    }
    out
  }
  static glBlendFunc_p: APcv = ap_null();
  /// Tries to load [`glBlendFunc`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendFunc_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendFunc\0");
    glBlendFunc_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendFunc`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendFunc_is_loaded() -> bool {
    !glBlendFunc_p.load(RELAX).is_null()
  }

  /// [glBlendFuncSeparate](http://docs.gl/gl4/glBlendFuncSeparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)
  /// * `sfactorRGB` group: BlendingFactor
  /// * `dfactorRGB` group: BlendingFactor
  /// * `sfactorAlpha` group: BlendingFactor
  /// * `dfactorAlpha` group: BlendingFactor
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendFuncSeparate(
    sfactorRGB: GLenum,
    dfactorRGB: GLenum,
    sfactorAlpha: GLenum,
    dfactorAlpha: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBlendFuncSeparate({:#X}, {:#X}, {:#X}, {:#X});",
        sfactorRGB,
        dfactorRGB,
        sfactorAlpha,
        dfactorAlpha
      );
    }
    let p = glBlendFuncSeparate_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, GLenum, GLenum)>>(p) {
        Some(fn_p) => fn_p(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha),
        None => go_panic_because_fn_not_loaded("glBlendFuncSeparate"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendFuncSeparate" != "glGetError" {
        report_error_as_necessary_from("glBlendFuncSeparate", glGetError());
      }
    }
    out
  }
  static glBlendFuncSeparate_p: APcv = ap_null();
  /// Tries to load [`glBlendFuncSeparate`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendFuncSeparate_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendFuncSeparate\0");
    glBlendFuncSeparate_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendFuncSeparate`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendFuncSeparate_is_loaded() -> bool {
    !glBlendFuncSeparate_p.load(RELAX).is_null()
  }

  /// [glBlendFuncSeparatei](http://docs.gl/gl4/glBlendFuncSeparatei)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)
  /// * `srcRGB` group: BlendingFactor
  /// * `dstRGB` group: BlendingFactor
  /// * `srcAlpha` group: BlendingFactor
  /// * `dstAlpha` group: BlendingFactor
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendFuncSeparatei(
    buf: GLuint,
    srcRGB: GLenum,
    dstRGB: GLenum,
    srcAlpha: GLenum,
    dstAlpha: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBlendFuncSeparatei({:?}, {:#X}, {:#X}, {:#X}, {:#X});",
        buf,
        srcRGB,
        dstRGB,
        srcAlpha,
        dstAlpha
      );
    }
    let p = glBlendFuncSeparatei_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLenum, GLenum, GLenum)>,
    >(p)
    {
      Some(fn_p) => fn_p(buf, srcRGB, dstRGB, srcAlpha, dstAlpha),
      None => go_panic_because_fn_not_loaded("glBlendFuncSeparatei"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendFuncSeparatei" != "glGetError" {
        report_error_as_necessary_from("glBlendFuncSeparatei", glGetError());
      }
    }
    out
  }
  static glBlendFuncSeparatei_p: APcv = ap_null();
  /// Tries to load [`glBlendFuncSeparatei`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendFuncSeparatei_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendFuncSeparatei\0");
    glBlendFuncSeparatei_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendFuncSeparatei`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendFuncSeparatei_is_loaded() -> bool {
    !glBlendFuncSeparatei_p.load(RELAX).is_null()
  }

  /// [glBlendFuncSeparateiARB](http://docs.gl/gl4/glBlendFuncSeparateiARB)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)
  /// * `srcRGB` group: BlendingFactor
  /// * `dstRGB` group: BlendingFactor
  /// * `srcAlpha` group: BlendingFactor
  /// * `dstAlpha` group: BlendingFactor
  /// * alias of: [`glBlendFuncSeparatei`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendFuncSeparateiARB(
    buf: GLuint,
    srcRGB: GLenum,
    dstRGB: GLenum,
    srcAlpha: GLenum,
    dstAlpha: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBlendFuncSeparateiARB({:?}, {:#X}, {:#X}, {:#X}, {:#X});",
        buf,
        srcRGB,
        dstRGB,
        srcAlpha,
        dstAlpha
      );
    }
    let p = glBlendFuncSeparateiARB_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLenum, GLenum, GLenum)>,
    >(p)
    {
      Some(fn_p) => fn_p(buf, srcRGB, dstRGB, srcAlpha, dstAlpha),
      None => go_panic_because_fn_not_loaded("glBlendFuncSeparateiARB"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendFuncSeparateiARB" != "glGetError" {
        report_error_as_necessary_from("glBlendFuncSeparateiARB", glGetError());
      }
    }
    out
  }
  static glBlendFuncSeparateiARB_p: APcv = ap_null();
  /// Tries to load [`glBlendFuncSeparateiARB`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendFuncSeparateiARB_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendFuncSeparateiARB\0");
    glBlendFuncSeparateiARB_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendFuncSeparateiARB`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendFuncSeparateiARB_is_loaded() -> bool {
    !glBlendFuncSeparateiARB_p.load(RELAX).is_null()
  }

  /// [glBlendFunci](http://docs.gl/gl4/glBlendFunci)(buf, src, dst)
  /// * `src` group: BlendingFactor
  /// * `dst` group: BlendingFactor
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendFunci(buf: GLuint, src: GLenum, dst: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBlendFunci({:?}, {:#X}, {:#X});", buf, src, dst);
    }
    let p = glBlendFunci_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum)>>(p) {
      Some(fn_p) => fn_p(buf, src, dst),
      None => go_panic_because_fn_not_loaded("glBlendFunci"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendFunci" != "glGetError" {
        report_error_as_necessary_from("glBlendFunci", glGetError());
      }
    }
    out
  }
  static glBlendFunci_p: APcv = ap_null();
  /// Tries to load [`glBlendFunci`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendFunci_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendFunci\0");
    glBlendFunci_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendFunci`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendFunci_is_loaded() -> bool {
    !glBlendFunci_p.load(RELAX).is_null()
  }

  /// [glBlendFunciARB](http://docs.gl/gl4/glBlendFunciARB)(buf, src, dst)
  /// * `src` group: BlendingFactor
  /// * `dst` group: BlendingFactor
  /// * alias of: [`glBlendFunci`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlendFunciARB(buf: GLuint, src: GLenum, dst: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBlendFunciARB({:?}, {:#X}, {:#X});", buf, src, dst);
    }
    let p = glBlendFunciARB_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum)>>(p) {
      Some(fn_p) => fn_p(buf, src, dst),
      None => go_panic_because_fn_not_loaded("glBlendFunciARB"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlendFunciARB" != "glGetError" {
        report_error_as_necessary_from("glBlendFunciARB", glGetError());
      }
    }
    out
  }
  static glBlendFunciARB_p: APcv = ap_null();
  /// Tries to load [`glBlendFunciARB`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlendFunciARB_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlendFunciARB\0");
    glBlendFunciARB_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlendFunciARB`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlendFunciARB_is_loaded() -> bool {
    !glBlendFunciARB_p.load(RELAX).is_null()
  }

  /// [glBlitFramebuffer](http://docs.gl/gl4/glBlitFramebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
  /// * `mask` group: ClearBufferMask
  /// * `filter` group: BlitFramebufferFilter
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlitFramebuffer(
    srcX0: GLint,
    srcY0: GLint,
    srcX1: GLint,
    srcY1: GLint,
    dstX0: GLint,
    dstY0: GLint,
    dstX1: GLint,
    dstY1: GLint,
    mask: GLbitfield,
    filter: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBlitFramebuffer({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X});", srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    }
    let p = glBlitFramebuffer_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLbitfield,
          GLenum,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter,
      ),
      None => go_panic_because_fn_not_loaded("glBlitFramebuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlitFramebuffer" != "glGetError" {
        report_error_as_necessary_from("glBlitFramebuffer", glGetError());
      }
    }
    out
  }
  static glBlitFramebuffer_p: APcv = ap_null();
  /// Tries to load [`glBlitFramebuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlitFramebuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlitFramebuffer\0");
    glBlitFramebuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlitFramebuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlitFramebuffer_is_loaded() -> bool {
    !glBlitFramebuffer_p.load(RELAX).is_null()
  }

  /// [glBlitNamedFramebuffer](http://docs.gl/gl4/glBlitNamedFramebuffer)(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
  /// * `mask` group: ClearBufferMask
  /// * `filter` group: BlitFramebufferFilter
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBlitNamedFramebuffer(
    readFramebuffer: GLuint,
    drawFramebuffer: GLuint,
    srcX0: GLint,
    srcY0: GLint,
    srcX1: GLint,
    srcY1: GLint,
    dstX0: GLint,
    dstY0: GLint,
    dstX1: GLint,
    dstY1: GLint,
    mask: GLbitfield,
    filter: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glBlitNamedFramebuffer({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X});", readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    }
    let p = glBlitNamedFramebuffer_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLuint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLbitfield,
          GLenum,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        readFramebuffer,
        drawFramebuffer,
        srcX0,
        srcY0,
        srcX1,
        srcY1,
        dstX0,
        dstY0,
        dstX1,
        dstY1,
        mask,
        filter,
      ),
      None => go_panic_because_fn_not_loaded("glBlitNamedFramebuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBlitNamedFramebuffer" != "glGetError" {
        report_error_as_necessary_from("glBlitNamedFramebuffer", glGetError());
      }
    }
    out
  }
  static glBlitNamedFramebuffer_p: APcv = ap_null();
  /// Tries to load [`glBlitNamedFramebuffer`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBlitNamedFramebuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBlitNamedFramebuffer\0");
    glBlitNamedFramebuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBlitNamedFramebuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBlitNamedFramebuffer_is_loaded() -> bool {
    !glBlitNamedFramebuffer_p.load(RELAX).is_null()
  }

  /// [glBufferData](http://docs.gl/gl4/glBufferData)(target, size, data, usage)
  /// * `target` group: BufferTargetARB
  /// * `size` group: BufferSize
  /// * `data` len: size
  /// * `usage` group: BufferUsageARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBufferData(
    target: GLenum,
    size: GLsizeiptr,
    data: *const c_void,
    usage: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBufferData({:#X}, {:?}, {:p}, {:#X});",
        target,
        size,
        data,
        usage
      );
    }
    let p = glBufferData_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLsizeiptr, *const c_void, GLenum)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, size, data, usage),
      None => go_panic_because_fn_not_loaded("glBufferData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBufferData" != "glGetError" {
        report_error_as_necessary_from("glBufferData", glGetError());
      }
    }
    out
  }
  static glBufferData_p: APcv = ap_null();
  /// Tries to load [`glBufferData`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBufferData_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBufferData\0");
    glBufferData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBufferData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBufferData_is_loaded() -> bool {
    !glBufferData_p.load(RELAX).is_null()
  }

  /// [glBufferStorage](http://docs.gl/gl4/glBufferStorage)(target, size, data, flags)
  /// * `target` group: BufferStorageTarget
  /// * `data` len: size
  /// * `flags` group: BufferStorageMask
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBufferStorage(
    target: GLenum,
    size: GLsizeiptr,
    data: *const c_void,
    flags: GLbitfield,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBufferStorage({:#X}, {:?}, {:p}, {:?});",
        target,
        size,
        data,
        flags
      );
    }
    let p = glBufferStorage_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLsizeiptr, *const c_void, GLbitfield)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, size, data, flags),
      None => go_panic_because_fn_not_loaded("glBufferStorage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBufferStorage" != "glGetError" {
        report_error_as_necessary_from("glBufferStorage", glGetError());
      }
    }
    out
  }
  static glBufferStorage_p: APcv = ap_null();
  /// Tries to load [`glBufferStorage`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBufferStorage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBufferStorage\0");
    glBufferStorage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBufferStorage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBufferStorage_is_loaded() -> bool {
    !glBufferStorage_p.load(RELAX).is_null()
  }

  /// [glBufferSubData](http://docs.gl/gl4/glBufferSubData)(target, offset, size, data)
  /// * `target` group: BufferTargetARB
  /// * `offset` group: BufferOffset
  /// * `size` group: BufferSize
  /// * `data` len: size
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glBufferSubData(
    target: GLenum,
    offset: GLintptr,
    size: GLsizeiptr,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glBufferSubData({:#X}, {:?}, {:?}, {:p});",
        target,
        offset,
        size,
        data
      );
    }
    let p = glBufferSubData_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLintptr, GLsizeiptr, *const c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, offset, size, data),
      None => go_panic_because_fn_not_loaded("glBufferSubData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glBufferSubData" != "glGetError" {
        report_error_as_necessary_from("glBufferSubData", glGetError());
      }
    }
    out
  }
  static glBufferSubData_p: APcv = ap_null();
  /// Tries to load [`glBufferSubData`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glBufferSubData_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glBufferSubData\0");
    glBufferSubData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glBufferSubData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glBufferSubData_is_loaded() -> bool {
    !glBufferSubData_p.load(RELAX).is_null()
  }

  /// [glCheckFramebufferStatus](http://docs.gl/gl4/glCheckFramebufferStatus)(target)
  /// * `target` group: FramebufferTarget
  /// * return value group: FramebufferStatus
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCheckFramebufferStatus(target: GLenum) -> GLenum {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCheckFramebufferStatus({:#X});", target);
    }
    let p = glCheckFramebufferStatus_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum) -> GLenum>>(p) {
      Some(fn_p) => fn_p(target),
      None => go_panic_because_fn_not_loaded("glCheckFramebufferStatus"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCheckFramebufferStatus" != "glGetError" {
        report_error_as_necessary_from(
          "glCheckFramebufferStatus",
          glGetError(),
        );
      }
    }
    out
  }
  static glCheckFramebufferStatus_p: APcv = ap_null();
  /// Tries to load [`glCheckFramebufferStatus`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCheckFramebufferStatus_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glCheckFramebufferStatus\0");
    glCheckFramebufferStatus_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCheckFramebufferStatus`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCheckFramebufferStatus_is_loaded() -> bool {
    !glCheckFramebufferStatus_p.load(RELAX).is_null()
  }

  /// [glCheckNamedFramebufferStatus](http://docs.gl/gl4/glCheckNamedFramebufferStatus)(framebuffer, target)
  /// * `target` group: FramebufferTarget
  /// * return value group: FramebufferStatus
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCheckNamedFramebufferStatus(
    framebuffer: GLuint,
    target: GLenum,
  ) -> GLenum {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glCheckNamedFramebufferStatus({:?}, {:#X});",
        framebuffer,
        target
      );
    }
    let p = glCheckNamedFramebufferStatus_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum) -> GLenum>>(p)
    {
      Some(fn_p) => fn_p(framebuffer, target),
      None => go_panic_because_fn_not_loaded("glCheckNamedFramebufferStatus"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCheckNamedFramebufferStatus" != "glGetError" {
        report_error_as_necessary_from(
          "glCheckNamedFramebufferStatus",
          glGetError(),
        );
      }
    }
    out
  }
  static glCheckNamedFramebufferStatus_p: APcv = ap_null();
  /// Tries to load [`glCheckNamedFramebufferStatus`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCheckNamedFramebufferStatus_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glCheckNamedFramebufferStatus\0");
    glCheckNamedFramebufferStatus_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCheckNamedFramebufferStatus`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCheckNamedFramebufferStatus_is_loaded() -> bool {
    !glCheckNamedFramebufferStatus_p.load(RELAX).is_null()
  }

  /// [glClampColor](http://docs.gl/gl4/glClampColor)(target, clamp)
  /// * `target` group: ClampColorTargetARB
  /// * `clamp` group: ClampColorModeARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClampColor(target: GLenum, clamp: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClampColor({:#X}, {:#X});", target, clamp);
    }
    let p = glClampColor_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLenum)>>(p) {
      Some(fn_p) => fn_p(target, clamp),
      None => go_panic_because_fn_not_loaded("glClampColor"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClampColor" != "glGetError" {
        report_error_as_necessary_from("glClampColor", glGetError());
      }
    }
    out
  }
  static glClampColor_p: APcv = ap_null();
  /// Tries to load [`glClampColor`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClampColor_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClampColor\0");
    glClampColor_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClampColor`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClampColor_is_loaded() -> bool {
    !glClampColor_p.load(RELAX).is_null()
  }

  /// [glClear](http://docs.gl/gl4/glClear)(mask)
  /// * `mask` group: ClearBufferMask
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClear(mask: GLbitfield) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClear({:?});", mask);
    }
    let p = glClear_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLbitfield)>>(p) {
      Some(fn_p) => fn_p(mask),
      None => go_panic_because_fn_not_loaded("glClear"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClear" != "glGetError" {
        report_error_as_necessary_from("glClear", glGetError());
      }
    }
    out
  }
  static glClear_p: APcv = ap_null();
  /// Tries to load [`glClear`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClear_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClear\0");
    glClear_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClear`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClear_is_loaded() -> bool {
    !glClear_p.load(RELAX).is_null()
  }

  /// [glClearBufferData](http://docs.gl/gl4/glClearBufferData)(target, internalformat, format, type_, data)
  /// * `target` group: BufferStorageTarget
  /// * `internalformat` group: InternalFormat
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `data` len: COMPSIZE(format,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearBufferData(
    target: GLenum,
    internalformat: GLenum,
    format: GLenum,
    type_: GLenum,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearBufferData({:#X}, {:#X}, {:#X}, {:#X}, {:p});",
        target,
        internalformat,
        format,
        type_,
        data
      );
    }
    let p = glClearBufferData_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLenum, GLenum, GLenum, *const c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, internalformat, format, type_, data),
      None => go_panic_because_fn_not_loaded("glClearBufferData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearBufferData" != "glGetError" {
        report_error_as_necessary_from("glClearBufferData", glGetError());
      }
    }
    out
  }
  static glClearBufferData_p: APcv = ap_null();
  /// Tries to load [`glClearBufferData`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearBufferData_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearBufferData\0");
    glClearBufferData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearBufferData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearBufferData_is_loaded() -> bool {
    !glClearBufferData_p.load(RELAX).is_null()
  }

  /// [glClearBufferSubData](http://docs.gl/gl4/glClearBufferSubData)(target, internalformat, offset, size, format, type_, data)
  /// * `target` group: BufferTargetARB
  /// * `internalformat` group: InternalFormat
  /// * `offset` group: BufferOffset
  /// * `size` group: BufferSize
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `data` len: COMPSIZE(format,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearBufferSubData(
    target: GLenum,
    internalformat: GLenum,
    offset: GLintptr,
    size: GLsizeiptr,
    format: GLenum,
    type_: GLenum,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClearBufferSubData({:#X}, {:#X}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, internalformat, offset, size, format, type_, data);
    }
    let p = glClearBufferSubData_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLenum,
          GLintptr,
          GLsizeiptr,
          GLenum,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(target, internalformat, offset, size, format, type_, data)
      }
      None => go_panic_because_fn_not_loaded("glClearBufferSubData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearBufferSubData" != "glGetError" {
        report_error_as_necessary_from("glClearBufferSubData", glGetError());
      }
    }
    out
  }
  static glClearBufferSubData_p: APcv = ap_null();
  /// Tries to load [`glClearBufferSubData`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearBufferSubData_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearBufferSubData\0");
    glClearBufferSubData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearBufferSubData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearBufferSubData_is_loaded() -> bool {
    !glClearBufferSubData_p.load(RELAX).is_null()
  }

  /// [glClearBufferfi](http://docs.gl/gl4/glClearBufferfi)(buffer, drawbuffer, depth, stencil)
  /// * `buffer` group: Buffer
  /// * `drawbuffer` group: DrawBufferName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearBufferfi(
    buffer: GLenum,
    drawbuffer: GLint,
    depth: GLfloat,
    stencil: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearBufferfi({:#X}, {:?}, {:?}, {:?});",
        buffer,
        drawbuffer,
        depth,
        stencil
      );
    }
    let p = glClearBufferfi_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLint, GLfloat, GLint)>>(p) {
        Some(fn_p) => fn_p(buffer, drawbuffer, depth, stencil),
        None => go_panic_because_fn_not_loaded("glClearBufferfi"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearBufferfi" != "glGetError" {
        report_error_as_necessary_from("glClearBufferfi", glGetError());
      }
    }
    out
  }
  static glClearBufferfi_p: APcv = ap_null();
  /// Tries to load [`glClearBufferfi`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearBufferfi_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearBufferfi\0");
    glClearBufferfi_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearBufferfi`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearBufferfi_is_loaded() -> bool {
    !glClearBufferfi_p.load(RELAX).is_null()
  }

  /// [glClearBufferfv](http://docs.gl/gl4/glClearBufferfv)(buffer, drawbuffer, value)
  /// * `buffer` group: Buffer
  /// * `drawbuffer` group: DrawBufferName
  /// * `value` len: COMPSIZE(buffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearBufferfv(
    buffer: GLenum,
    drawbuffer: GLint,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearBufferfv({:#X}, {:?}, {:p});",
        buffer,
        drawbuffer,
        value
      );
    }
    let p = glClearBufferfv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLint, *const GLfloat)>>(p) {
        Some(fn_p) => fn_p(buffer, drawbuffer, value),
        None => go_panic_because_fn_not_loaded("glClearBufferfv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearBufferfv" != "glGetError" {
        report_error_as_necessary_from("glClearBufferfv", glGetError());
      }
    }
    out
  }
  static glClearBufferfv_p: APcv = ap_null();
  /// Tries to load [`glClearBufferfv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearBufferfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearBufferfv\0");
    glClearBufferfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearBufferfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearBufferfv_is_loaded() -> bool {
    !glClearBufferfv_p.load(RELAX).is_null()
  }

  /// [glClearBufferiv](http://docs.gl/gl4/glClearBufferiv)(buffer, drawbuffer, value)
  /// * `buffer` group: Buffer
  /// * `drawbuffer` group: DrawBufferName
  /// * `value` len: COMPSIZE(buffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearBufferiv(
    buffer: GLenum,
    drawbuffer: GLint,
    value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearBufferiv({:#X}, {:?}, {:p});",
        buffer,
        drawbuffer,
        value
      );
    }
    let p = glClearBufferiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLint, *const GLint)>>(p) {
        Some(fn_p) => fn_p(buffer, drawbuffer, value),
        None => go_panic_because_fn_not_loaded("glClearBufferiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearBufferiv" != "glGetError" {
        report_error_as_necessary_from("glClearBufferiv", glGetError());
      }
    }
    out
  }
  static glClearBufferiv_p: APcv = ap_null();
  /// Tries to load [`glClearBufferiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearBufferiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearBufferiv\0");
    glClearBufferiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearBufferiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearBufferiv_is_loaded() -> bool {
    !glClearBufferiv_p.load(RELAX).is_null()
  }

  /// [glClearBufferuiv](http://docs.gl/gl4/glClearBufferuiv)(buffer, drawbuffer, value)
  /// * `buffer` group: Buffer
  /// * `drawbuffer` group: DrawBufferName
  /// * `value` len: COMPSIZE(buffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearBufferuiv(
    buffer: GLenum,
    drawbuffer: GLint,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearBufferuiv({:#X}, {:?}, {:p});",
        buffer,
        drawbuffer,
        value
      );
    }
    let p = glClearBufferuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLint, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(buffer, drawbuffer, value),
        None => go_panic_because_fn_not_loaded("glClearBufferuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearBufferuiv" != "glGetError" {
        report_error_as_necessary_from("glClearBufferuiv", glGetError());
      }
    }
    out
  }
  static glClearBufferuiv_p: APcv = ap_null();
  /// Tries to load [`glClearBufferuiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearBufferuiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearBufferuiv\0");
    glClearBufferuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearBufferuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearBufferuiv_is_loaded() -> bool {
    !glClearBufferuiv_p.load(RELAX).is_null()
  }

  /// [glClearColor](http://docs.gl/gl4/glClearColor)(red, green, blue, alpha)
  /// * `red` group: ColorF
  /// * `green` group: ColorF
  /// * `blue` group: ColorF
  /// * `alpha` group: ColorF
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearColor(
    red: GLfloat,
    green: GLfloat,
    blue: GLfloat,
    alpha: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearColor({:?}, {:?}, {:?}, {:?});",
        red,
        green,
        blue,
        alpha
      );
    }
    let p = glClearColor_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLfloat, GLfloat, GLfloat, GLfloat)>>(
        p,
      ) {
        Some(fn_p) => fn_p(red, green, blue, alpha),
        None => go_panic_because_fn_not_loaded("glClearColor"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearColor" != "glGetError" {
        report_error_as_necessary_from("glClearColor", glGetError());
      }
    }
    out
  }
  static glClearColor_p: APcv = ap_null();
  /// Tries to load [`glClearColor`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearColor_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearColor\0");
    glClearColor_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearColor`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearColor_is_loaded() -> bool {
    !glClearColor_p.load(RELAX).is_null()
  }

  /// [glClearDepth](http://docs.gl/gl4/glClearDepth)(depth)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearDepth(depth: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClearDepth({:?});", depth);
    }
    let p = glClearDepth_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLdouble)>>(p) {
      Some(fn_p) => fn_p(depth),
      None => go_panic_because_fn_not_loaded("glClearDepth"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearDepth" != "glGetError" {
        report_error_as_necessary_from("glClearDepth", glGetError());
      }
    }
    out
  }
  static glClearDepth_p: APcv = ap_null();
  /// Tries to load [`glClearDepth`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearDepth_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearDepth\0");
    glClearDepth_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearDepth`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearDepth_is_loaded() -> bool {
    !glClearDepth_p.load(RELAX).is_null()
  }

  /// [glClearDepthf](http://docs.gl/gl4/glClearDepthf)(d)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearDepthf(d: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClearDepthf({:?});", d);
    }
    let p = glClearDepthf_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLfloat)>>(p) {
      Some(fn_p) => fn_p(d),
      None => go_panic_because_fn_not_loaded("glClearDepthf"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearDepthf" != "glGetError" {
        report_error_as_necessary_from("glClearDepthf", glGetError());
      }
    }
    out
  }
  static glClearDepthf_p: APcv = ap_null();
  /// Tries to load [`glClearDepthf`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearDepthf_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearDepthf\0");
    glClearDepthf_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearDepthf`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearDepthf_is_loaded() -> bool {
    !glClearDepthf_p.load(RELAX).is_null()
  }

  /// [glClearNamedBufferData](http://docs.gl/gl4/glClearNamedBufferData)(buffer, internalformat, format, type_, data)
  /// * `internalformat` group: InternalFormat
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearNamedBufferData(
    buffer: GLuint,
    internalformat: GLenum,
    format: GLenum,
    type_: GLenum,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearNamedBufferData({:?}, {:#X}, {:#X}, {:#X}, {:p});",
        buffer,
        internalformat,
        format,
        type_,
        data
      );
    }
    let p = glClearNamedBufferData_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLenum, GLenum, *const c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(buffer, internalformat, format, type_, data),
      None => go_panic_because_fn_not_loaded("glClearNamedBufferData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearNamedBufferData" != "glGetError" {
        report_error_as_necessary_from("glClearNamedBufferData", glGetError());
      }
    }
    out
  }
  static glClearNamedBufferData_p: APcv = ap_null();
  /// Tries to load [`glClearNamedBufferData`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearNamedBufferData_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearNamedBufferData\0");
    glClearNamedBufferData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearNamedBufferData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearNamedBufferData_is_loaded() -> bool {
    !glClearNamedBufferData_p.load(RELAX).is_null()
  }

  /// [glClearNamedBufferSubData](http://docs.gl/gl4/glClearNamedBufferSubData)(buffer, internalformat, offset, size, format, type_, data)
  /// * `internalformat` group: InternalFormat
  /// * `size` group: BufferSize
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearNamedBufferSubData(
    buffer: GLuint,
    internalformat: GLenum,
    offset: GLintptr,
    size: GLsizeiptr,
    format: GLenum,
    type_: GLenum,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClearNamedBufferSubData({:?}, {:#X}, {:?}, {:?}, {:#X}, {:#X}, {:p});", buffer, internalformat, offset, size, format, type_, data);
    }
    let p = glClearNamedBufferSubData_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLenum,
          GLintptr,
          GLsizeiptr,
          GLenum,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(buffer, internalformat, offset, size, format, type_, data)
      }
      None => go_panic_because_fn_not_loaded("glClearNamedBufferSubData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearNamedBufferSubData" != "glGetError" {
        report_error_as_necessary_from(
          "glClearNamedBufferSubData",
          glGetError(),
        );
      }
    }
    out
  }
  static glClearNamedBufferSubData_p: APcv = ap_null();
  /// Tries to load [`glClearNamedBufferSubData`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearNamedBufferSubData_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glClearNamedBufferSubData\0");
    glClearNamedBufferSubData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearNamedBufferSubData`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearNamedBufferSubData_is_loaded() -> bool {
    !glClearNamedBufferSubData_p.load(RELAX).is_null()
  }

  /// [glClearNamedFramebufferfi](http://docs.gl/gl4/glClearNamedFramebufferfi)(framebuffer, buffer, drawbuffer, depth, stencil)
  /// * `buffer` group: Buffer
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearNamedFramebufferfi(
    framebuffer: GLuint,
    buffer: GLenum,
    drawbuffer: GLint,
    depth: GLfloat,
    stencil: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearNamedFramebufferfi({:?}, {:#X}, {:?}, {:?}, {:?});",
        framebuffer,
        buffer,
        drawbuffer,
        depth,
        stencil
      );
    }
    let p = glClearNamedFramebufferfi_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLint, GLfloat, GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(framebuffer, buffer, drawbuffer, depth, stencil),
      None => go_panic_because_fn_not_loaded("glClearNamedFramebufferfi"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearNamedFramebufferfi" != "glGetError" {
        report_error_as_necessary_from(
          "glClearNamedFramebufferfi",
          glGetError(),
        );
      }
    }
    out
  }
  static glClearNamedFramebufferfi_p: APcv = ap_null();
  /// Tries to load [`glClearNamedFramebufferfi`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearNamedFramebufferfi_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glClearNamedFramebufferfi\0");
    glClearNamedFramebufferfi_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearNamedFramebufferfi`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearNamedFramebufferfi_is_loaded() -> bool {
    !glClearNamedFramebufferfi_p.load(RELAX).is_null()
  }

  /// [glClearNamedFramebufferfv](http://docs.gl/gl4/glClearNamedFramebufferfv)(framebuffer, buffer, drawbuffer, value)
  /// * `buffer` group: Buffer
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearNamedFramebufferfv(
    framebuffer: GLuint,
    buffer: GLenum,
    drawbuffer: GLint,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearNamedFramebufferfv({:?}, {:#X}, {:?}, {:p});",
        framebuffer,
        buffer,
        drawbuffer,
        value
      );
    }
    let p = glClearNamedFramebufferfv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLint, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(framebuffer, buffer, drawbuffer, value),
      None => go_panic_because_fn_not_loaded("glClearNamedFramebufferfv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearNamedFramebufferfv" != "glGetError" {
        report_error_as_necessary_from(
          "glClearNamedFramebufferfv",
          glGetError(),
        );
      }
    }
    out
  }
  static glClearNamedFramebufferfv_p: APcv = ap_null();
  /// Tries to load [`glClearNamedFramebufferfv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearNamedFramebufferfv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glClearNamedFramebufferfv\0");
    glClearNamedFramebufferfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearNamedFramebufferfv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearNamedFramebufferfv_is_loaded() -> bool {
    !glClearNamedFramebufferfv_p.load(RELAX).is_null()
  }

  /// [glClearNamedFramebufferiv](http://docs.gl/gl4/glClearNamedFramebufferiv)(framebuffer, buffer, drawbuffer, value)
  /// * `buffer` group: Buffer
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearNamedFramebufferiv(
    framebuffer: GLuint,
    buffer: GLenum,
    drawbuffer: GLint,
    value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearNamedFramebufferiv({:?}, {:#X}, {:?}, {:p});",
        framebuffer,
        buffer,
        drawbuffer,
        value
      );
    }
    let p = glClearNamedFramebufferiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLint, *const GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(framebuffer, buffer, drawbuffer, value),
      None => go_panic_because_fn_not_loaded("glClearNamedFramebufferiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearNamedFramebufferiv" != "glGetError" {
        report_error_as_necessary_from(
          "glClearNamedFramebufferiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glClearNamedFramebufferiv_p: APcv = ap_null();
  /// Tries to load [`glClearNamedFramebufferiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearNamedFramebufferiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glClearNamedFramebufferiv\0");
    glClearNamedFramebufferiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearNamedFramebufferiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearNamedFramebufferiv_is_loaded() -> bool {
    !glClearNamedFramebufferiv_p.load(RELAX).is_null()
  }

  /// [glClearNamedFramebufferuiv](http://docs.gl/gl4/glClearNamedFramebufferuiv)(framebuffer, buffer, drawbuffer, value)
  /// * `buffer` group: Buffer
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearNamedFramebufferuiv(
    framebuffer: GLuint,
    buffer: GLenum,
    drawbuffer: GLint,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearNamedFramebufferuiv({:?}, {:#X}, {:?}, {:p});",
        framebuffer,
        buffer,
        drawbuffer,
        value
      );
    }
    let p = glClearNamedFramebufferuiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLint, *const GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(framebuffer, buffer, drawbuffer, value),
      None => go_panic_because_fn_not_loaded("glClearNamedFramebufferuiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearNamedFramebufferuiv" != "glGetError" {
        report_error_as_necessary_from(
          "glClearNamedFramebufferuiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glClearNamedFramebufferuiv_p: APcv = ap_null();
  /// Tries to load [`glClearNamedFramebufferuiv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearNamedFramebufferuiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glClearNamedFramebufferuiv\0");
    glClearNamedFramebufferuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearNamedFramebufferuiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearNamedFramebufferuiv_is_loaded() -> bool {
    !glClearNamedFramebufferuiv_p.load(RELAX).is_null()
  }

  /// [glClearStencil](http://docs.gl/gl4/glClearStencil)(s)
  /// * `s` group: StencilValue
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearStencil(s: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClearStencil({:?});", s);
    }
    let p = glClearStencil_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLint)>>(p) {
      Some(fn_p) => fn_p(s),
      None => go_panic_because_fn_not_loaded("glClearStencil"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearStencil" != "glGetError" {
        report_error_as_necessary_from("glClearStencil", glGetError());
      }
    }
    out
  }
  static glClearStencil_p: APcv = ap_null();
  /// Tries to load [`glClearStencil`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearStencil_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearStencil\0");
    glClearStencil_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearStencil`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearStencil_is_loaded() -> bool {
    !glClearStencil_p.load(RELAX).is_null()
  }

  /// [glClearTexImage](http://docs.gl/gl4/glClearTexImage)(texture, level, format, type_, data)
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `data` len: COMPSIZE(format,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearTexImage(
    texture: GLuint,
    level: GLint,
    format: GLenum,
    type_: GLenum,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClearTexImage({:?}, {:?}, {:#X}, {:#X}, {:p});",
        texture,
        level,
        format,
        type_,
        data
      );
    }
    let p = glClearTexImage_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLenum, GLenum, *const c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(texture, level, format, type_, data),
      None => go_panic_because_fn_not_loaded("glClearTexImage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearTexImage" != "glGetError" {
        report_error_as_necessary_from("glClearTexImage", glGetError());
      }
    }
    out
  }
  static glClearTexImage_p: APcv = ap_null();
  /// Tries to load [`glClearTexImage`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearTexImage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearTexImage\0");
    glClearTexImage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearTexImage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearTexImage_is_loaded() -> bool {
    !glClearTexImage_p.load(RELAX).is_null()
  }

  /// [glClearTexSubImage](http://docs.gl/gl4/glClearTexSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, data)
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `data` len: COMPSIZE(format,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClearTexSubImage(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    zoffset: GLint,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
    format: GLenum,
    type_: GLenum,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClearTexSubImage({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, data);
    }
    let p = glClearTexSubImage_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLsizei,
          GLenum,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        texture, level, xoffset, yoffset, zoffset, width, height, depth,
        format, type_, data,
      ),
      None => go_panic_because_fn_not_loaded("glClearTexSubImage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClearTexSubImage" != "glGetError" {
        report_error_as_necessary_from("glClearTexSubImage", glGetError());
      }
    }
    out
  }
  static glClearTexSubImage_p: APcv = ap_null();
  /// Tries to load [`glClearTexSubImage`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClearTexSubImage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClearTexSubImage\0");
    glClearTexSubImage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClearTexSubImage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClearTexSubImage_is_loaded() -> bool {
    !glClearTexSubImage_p.load(RELAX).is_null()
  }

  /// [glClientWaitSync](http://docs.gl/gl4/glClientWaitSync)(sync, flags, timeout)
  /// * `sync` group: sync
  /// * `flags` group: SyncObjectMask
  /// * return value group: SyncStatus
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClientWaitSync(
    sync: GLsync,
    flags: GLbitfield,
    timeout: GLuint64,
  ) -> GLenum {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glClientWaitSync({:p}, {:?}, {:?});",
        sync,
        flags,
        timeout
      );
    }
    let p = glClientWaitSync_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLsync, GLbitfield, GLuint64) -> GLenum>,
    >(p)
    {
      Some(fn_p) => fn_p(sync, flags, timeout),
      None => go_panic_because_fn_not_loaded("glClientWaitSync"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClientWaitSync" != "glGetError" {
        report_error_as_necessary_from("glClientWaitSync", glGetError());
      }
    }
    out
  }
  static glClientWaitSync_p: APcv = ap_null();
  /// Tries to load [`glClientWaitSync`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClientWaitSync_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClientWaitSync\0");
    glClientWaitSync_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClientWaitSync`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClientWaitSync_is_loaded() -> bool {
    !glClientWaitSync_p.load(RELAX).is_null()
  }

  /// [glClipControl](http://docs.gl/gl4/glClipControl)(origin, depth)
  /// * `origin` group: ClipControlOrigin
  /// * `depth` group: ClipControlDepth
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glClipControl(origin: GLenum, depth: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glClipControl({:#X}, {:#X});", origin, depth);
    }
    let p = glClipControl_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLenum)>>(p) {
      Some(fn_p) => fn_p(origin, depth),
      None => go_panic_because_fn_not_loaded("glClipControl"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glClipControl" != "glGetError" {
        report_error_as_necessary_from("glClipControl", glGetError());
      }
    }
    out
  }
  static glClipControl_p: APcv = ap_null();
  /// Tries to load [`glClipControl`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glClipControl_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glClipControl\0");
    glClipControl_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glClipControl`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glClipControl_is_loaded() -> bool {
    !glClipControl_p.load(RELAX).is_null()
  }

  /// [glColorMask](http://docs.gl/gl4/glColorMask)(red, green, blue, alpha)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glColorMask(
    red: GLboolean,
    green: GLboolean,
    blue: GLboolean,
    alpha: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glColorMask({:?}, {:?}, {:?}, {:?});",
        red,
        green,
        blue,
        alpha
      );
    }
    let p = glColorMask_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLboolean, GLboolean, GLboolean, GLboolean)>,
    >(p)
    {
      Some(fn_p) => fn_p(red, green, blue, alpha),
      None => go_panic_because_fn_not_loaded("glColorMask"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glColorMask" != "glGetError" {
        report_error_as_necessary_from("glColorMask", glGetError());
      }
    }
    out
  }
  static glColorMask_p: APcv = ap_null();
  /// Tries to load [`glColorMask`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glColorMask_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glColorMask\0");
    glColorMask_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glColorMask`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glColorMask_is_loaded() -> bool {
    !glColorMask_p.load(RELAX).is_null()
  }

  /// [glColorMaski](http://docs.gl/gl4/glColorMaski)(index, r, g, b, a)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glColorMaski(
    index: GLuint,
    r: GLboolean,
    g: GLboolean,
    b: GLboolean,
    a: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glColorMaski({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        r,
        g,
        b,
        a
      );
    }
    let p = glColorMaski_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLboolean, GLboolean, GLboolean, GLboolean)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, r, g, b, a),
      None => go_panic_because_fn_not_loaded("glColorMaski"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glColorMaski" != "glGetError" {
        report_error_as_necessary_from("glColorMaski", glGetError());
      }
    }
    out
  }
  static glColorMaski_p: APcv = ap_null();
  /// Tries to load [`glColorMaski`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glColorMaski_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glColorMaski\0");
    glColorMaski_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glColorMaski`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glColorMaski_is_loaded() -> bool {
    !glColorMaski_p.load(RELAX).is_null()
  }

  /// [glCompileShader](http://docs.gl/gl4/glCompileShader)(shader)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompileShader(shader: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompileShader({:?});", shader);
    }
    let p = glCompileShader_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(shader),
      None => go_panic_because_fn_not_loaded("glCompileShader"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCompileShader" != "glGetError" {
        report_error_as_necessary_from("glCompileShader", glGetError());
      }
    }
    out
  }
  static glCompileShader_p: APcv = ap_null();
  /// Tries to load [`glCompileShader`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCompileShader_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCompileShader\0");
    glCompileShader_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCompileShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompileShader_is_loaded() -> bool {
    !glCompileShader_p.load(RELAX).is_null()
  }

  /// [glCompressedTexImage1D](http://docs.gl/gl4/glCompressedTexImage1D)(target, level, internalformat, width, border, imageSize, data)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `border` group: CheckedInt32
  /// * `data` group: CompressedTextureARB
  /// * `data` len: imageSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTexImage1D(
    target: GLenum,
    level: GLint,
    internalformat: GLenum,
    width: GLsizei,
    border: GLint,
    imageSize: GLsizei,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTexImage1D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, border, imageSize, data);
    }
    let p = glCompressedTexImage1D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLenum,
          GLsizei,
          GLint,
          GLsizei,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(target, level, internalformat, width, border, imageSize, data)
      }
      None => go_panic_because_fn_not_loaded("glCompressedTexImage1D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCompressedTexImage1D" != "glGetError" {
        report_error_as_necessary_from("glCompressedTexImage1D", glGetError());
      }
    }
    out
  }
  static glCompressedTexImage1D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTexImage1D`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCompressedTexImage1D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCompressedTexImage1D\0");
    glCompressedTexImage1D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCompressedTexImage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTexImage1D_is_loaded() -> bool {
    !glCompressedTexImage1D_p.load(RELAX).is_null()
  }

  /// [glCompressedTexImage2D](http://docs.gl/gl4/glCompressedTexImage2D)(target, level, internalformat, width, height, border, imageSize, data)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `border` group: CheckedInt32
  /// * `data` group: CompressedTextureARB
  /// * `data` len: imageSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTexImage2D(
    target: GLenum,
    level: GLint,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
    border: GLint,
    imageSize: GLsizei,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTexImage2D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, height, border, imageSize, data);
    }
    let p = glCompressedTexImage2D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLenum,
          GLsizei,
          GLsizei,
          GLint,
          GLsizei,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target,
        level,
        internalformat,
        width,
        height,
        border,
        imageSize,
        data,
      ),
      None => go_panic_because_fn_not_loaded("glCompressedTexImage2D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCompressedTexImage2D" != "glGetError" {
        report_error_as_necessary_from("glCompressedTexImage2D", glGetError());
      }
    }
    out
  }
  static glCompressedTexImage2D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTexImage2D`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCompressedTexImage2D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCompressedTexImage2D\0");
    glCompressedTexImage2D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCompressedTexImage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTexImage2D_is_loaded() -> bool {
    !glCompressedTexImage2D_p.load(RELAX).is_null()
  }

  /// [glCompressedTexImage3D](http://docs.gl/gl4/glCompressedTexImage3D)(target, level, internalformat, width, height, depth, border, imageSize, data)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `border` group: CheckedInt32
  /// * `data` group: CompressedTextureARB
  /// * `data` len: imageSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTexImage3D(
    target: GLenum,
    level: GLint,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
    border: GLint,
    imageSize: GLsizei,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTexImage3D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, height, depth, border, imageSize, data);
    }
    let p = glCompressedTexImage3D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLenum,
          GLsizei,
          GLsizei,
          GLsizei,
          GLint,
          GLsizei,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        imageSize,
        data,
      ),
      None => go_panic_because_fn_not_loaded("glCompressedTexImage3D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCompressedTexImage3D" != "glGetError" {
        report_error_as_necessary_from("glCompressedTexImage3D", glGetError());
      }
    }
    out
  }
  static glCompressedTexImage3D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTexImage3D`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCompressedTexImage3D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCompressedTexImage3D\0");
    glCompressedTexImage3D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCompressedTexImage3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTexImage3D_is_loaded() -> bool {
    !glCompressedTexImage3D_p.load(RELAX).is_null()
  }

  /// [glCompressedTexSubImage1D](http://docs.gl/gl4/glCompressedTexSubImage1D)(target, level, xoffset, width, format, imageSize, data)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `data` group: CompressedTextureARB
  /// * `data` len: imageSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTexSubImage1D(
    target: GLenum,
    level: GLint,
    xoffset: GLint,
    width: GLsizei,
    format: GLenum,
    imageSize: GLsizei,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, width, format, imageSize, data);
    }
    let p = glCompressedTexSubImage1D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLint,
          GLsizei,
          GLenum,
          GLsizei,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(target, level, xoffset, width, format, imageSize, data)
      }
      None => go_panic_because_fn_not_loaded("glCompressedTexSubImage1D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCompressedTexSubImage1D" != "glGetError" {
        report_error_as_necessary_from(
          "glCompressedTexSubImage1D",
          glGetError(),
        );
      }
    }
    out
  }
  static glCompressedTexSubImage1D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTexSubImage1D`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCompressedTexSubImage1D_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glCompressedTexSubImage1D\0");
    glCompressedTexSubImage1D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCompressedTexSubImage1D`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTexSubImage1D_is_loaded() -> bool {
    !glCompressedTexSubImage1D_p.load(RELAX).is_null()
  }

  /// [glCompressedTexSubImage2D](http://docs.gl/gl4/glCompressedTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, imageSize, data)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `yoffset` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `data` group: CompressedTextureARB
  /// * `data` len: imageSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTexSubImage2D(
    target: GLenum,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    width: GLsizei,
    height: GLsizei,
    format: GLenum,
    imageSize: GLsizei,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, yoffset, width, height, format, imageSize, data);
    }
    let p = glCompressedTexSubImage2D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLenum,
          GLsizei,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target, level, xoffset, yoffset, width, height, format, imageSize, data,
      ),
      None => go_panic_because_fn_not_loaded("glCompressedTexSubImage2D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCompressedTexSubImage2D" != "glGetError" {
        report_error_as_necessary_from(
          "glCompressedTexSubImage2D",
          glGetError(),
        );
      }
    }
    out
  }
  static glCompressedTexSubImage2D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTexSubImage2D`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCompressedTexSubImage2D_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glCompressedTexSubImage2D\0");
    glCompressedTexSubImage2D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCompressedTexSubImage2D`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTexSubImage2D_is_loaded() -> bool {
    !glCompressedTexSubImage2D_p.load(RELAX).is_null()
  }

  /// [glCompressedTexSubImage3D](http://docs.gl/gl4/glCompressedTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `yoffset` group: CheckedInt32
  /// * `zoffset` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `data` group: CompressedTextureARB
  /// * `data` len: imageSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTexSubImage3D(
    target: GLenum,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    zoffset: GLint,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
    format: GLenum,
    imageSize: GLsizei,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    }
    let p = glCompressedTexSubImage3D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLsizei,
          GLenum,
          GLsizei,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target, level, xoffset, yoffset, zoffset, width, height, depth, format,
        imageSize, data,
      ),
      None => go_panic_because_fn_not_loaded("glCompressedTexSubImage3D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCompressedTexSubImage3D" != "glGetError" {
        report_error_as_necessary_from(
          "glCompressedTexSubImage3D",
          glGetError(),
        );
      }
    }
    out
  }
  static glCompressedTexSubImage3D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTexSubImage3D`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCompressedTexSubImage3D_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glCompressedTexSubImage3D\0");
    glCompressedTexSubImage3D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCompressedTexSubImage3D`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTexSubImage3D_is_loaded() -> bool {
    !glCompressedTexSubImage3D_p.load(RELAX).is_null()
  }

  /// [glCompressedTextureSubImage1D](http://docs.gl/gl4/glCompressedTextureSubImage1D)(texture, level, xoffset, width, format, imageSize, data)
  /// * `format` group: PixelFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTextureSubImage1D(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    width: GLsizei,
    format: GLenum,
    imageSize: GLsizei,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTextureSubImage1D({:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", texture, level, xoffset, width, format, imageSize, data);
    }
    let p = glCompressedTextureSubImage1D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLint,
          GLsizei,
          GLenum,
          GLsizei,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(texture, level, xoffset, width, format, imageSize, data)
      }
      None => go_panic_because_fn_not_loaded("glCompressedTextureSubImage1D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCompressedTextureSubImage1D" != "glGetError" {
        report_error_as_necessary_from(
          "glCompressedTextureSubImage1D",
          glGetError(),
        );
      }
    }
    out
  }
  static glCompressedTextureSubImage1D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTextureSubImage1D`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCompressedTextureSubImage1D_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glCompressedTextureSubImage1D\0");
    glCompressedTextureSubImage1D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCompressedTextureSubImage1D`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTextureSubImage1D_is_loaded() -> bool {
    !glCompressedTextureSubImage1D_p.load(RELAX).is_null()
  }

  /// [glCompressedTextureSubImage2D](http://docs.gl/gl4/glCompressedTextureSubImage2D)(texture, level, xoffset, yoffset, width, height, format, imageSize, data)
  /// * `format` group: PixelFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTextureSubImage2D(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    width: GLsizei,
    height: GLsizei,
    format: GLenum,
    imageSize: GLsizei,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTextureSubImage2D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", texture, level, xoffset, yoffset, width, height, format, imageSize, data);
    }
    let p = glCompressedTextureSubImage2D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLenum,
          GLsizei,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        texture, level, xoffset, yoffset, width, height, format, imageSize,
        data,
      ),
      None => go_panic_because_fn_not_loaded("glCompressedTextureSubImage2D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCompressedTextureSubImage2D" != "glGetError" {
        report_error_as_necessary_from(
          "glCompressedTextureSubImage2D",
          glGetError(),
        );
      }
    }
    out
  }
  static glCompressedTextureSubImage2D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTextureSubImage2D`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCompressedTextureSubImage2D_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glCompressedTextureSubImage2D\0");
    glCompressedTextureSubImage2D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCompressedTextureSubImage2D`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTextureSubImage2D_is_loaded() -> bool {
    !glCompressedTextureSubImage2D_p.load(RELAX).is_null()
  }

  /// [glCompressedTextureSubImage3D](http://docs.gl/gl4/glCompressedTextureSubImage3D)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)
  /// * `format` group: PixelFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCompressedTextureSubImage3D(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    zoffset: GLint,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
    format: GLenum,
    imageSize: GLsizei,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCompressedTextureSubImage3D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    }
    let p = glCompressedTextureSubImage3D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLsizei,
          GLenum,
          GLsizei,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        texture, level, xoffset, yoffset, zoffset, width, height, depth,
        format, imageSize, data,
      ),
      None => go_panic_because_fn_not_loaded("glCompressedTextureSubImage3D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCompressedTextureSubImage3D" != "glGetError" {
        report_error_as_necessary_from(
          "glCompressedTextureSubImage3D",
          glGetError(),
        );
      }
    }
    out
  }
  static glCompressedTextureSubImage3D_p: APcv = ap_null();
  /// Tries to load [`glCompressedTextureSubImage3D`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCompressedTextureSubImage3D_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glCompressedTextureSubImage3D\0");
    glCompressedTextureSubImage3D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCompressedTextureSubImage3D`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCompressedTextureSubImage3D_is_loaded() -> bool {
    !glCompressedTextureSubImage3D_p.load(RELAX).is_null()
  }

  /// [glCopyBufferSubData](http://docs.gl/gl4/glCopyBufferSubData)(readTarget, writeTarget, readOffset, writeOffset, size)
  /// * `readTarget` group: CopyBufferSubDataTarget
  /// * `writeTarget` group: CopyBufferSubDataTarget
  /// * `readOffset` group: BufferOffset
  /// * `writeOffset` group: BufferOffset
  /// * `size` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyBufferSubData(
    readTarget: GLenum,
    writeTarget: GLenum,
    readOffset: GLintptr,
    writeOffset: GLintptr,
    size: GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glCopyBufferSubData({:#X}, {:#X}, {:?}, {:?}, {:?});",
        readTarget,
        writeTarget,
        readOffset,
        writeOffset,
        size
      );
    }
    let p = glCopyBufferSubData_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr)>,
    >(p)
    {
      Some(fn_p) => {
        fn_p(readTarget, writeTarget, readOffset, writeOffset, size)
      }
      None => go_panic_because_fn_not_loaded("glCopyBufferSubData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCopyBufferSubData" != "glGetError" {
        report_error_as_necessary_from("glCopyBufferSubData", glGetError());
      }
    }
    out
  }
  static glCopyBufferSubData_p: APcv = ap_null();
  /// Tries to load [`glCopyBufferSubData`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCopyBufferSubData_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCopyBufferSubData\0");
    glCopyBufferSubData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCopyBufferSubData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyBufferSubData_is_loaded() -> bool {
    !glCopyBufferSubData_p.load(RELAX).is_null()
  }

  /// [glCopyImageSubData](http://docs.gl/gl4/glCopyImageSubData)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)
  /// * `srcTarget` group: CopyImageSubDataTarget
  /// * `dstTarget` group: CopyImageSubDataTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyImageSubData(
    srcName: GLuint,
    srcTarget: GLenum,
    srcLevel: GLint,
    srcX: GLint,
    srcY: GLint,
    srcZ: GLint,
    dstName: GLuint,
    dstTarget: GLenum,
    dstLevel: GLint,
    dstX: GLint,
    dstY: GLint,
    dstZ: GLint,
    srcWidth: GLsizei,
    srcHeight: GLsizei,
    srcDepth: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCopyImageSubData({:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    }
    let p = glCopyImageSubData_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLenum,
          GLint,
          GLint,
          GLint,
          GLint,
          GLuint,
          GLenum,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget,
        dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth,
      ),
      None => go_panic_because_fn_not_loaded("glCopyImageSubData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCopyImageSubData" != "glGetError" {
        report_error_as_necessary_from("glCopyImageSubData", glGetError());
      }
    }
    out
  }
  static glCopyImageSubData_p: APcv = ap_null();
  /// Tries to load [`glCopyImageSubData`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCopyImageSubData_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCopyImageSubData\0");
    glCopyImageSubData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCopyImageSubData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyImageSubData_is_loaded() -> bool {
    !glCopyImageSubData_p.load(RELAX).is_null()
  }

  /// [glCopyNamedBufferSubData](http://docs.gl/gl4/glCopyNamedBufferSubData)(readBuffer, writeBuffer, readOffset, writeOffset, size)
  /// * `size` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyNamedBufferSubData(
    readBuffer: GLuint,
    writeBuffer: GLuint,
    readOffset: GLintptr,
    writeOffset: GLintptr,
    size: GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glCopyNamedBufferSubData({:?}, {:?}, {:?}, {:?}, {:?});",
        readBuffer,
        writeBuffer,
        readOffset,
        writeOffset,
        size
      );
    }
    let p = glCopyNamedBufferSubData_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLuint, GLintptr, GLintptr, GLsizeiptr)>,
    >(p)
    {
      Some(fn_p) => {
        fn_p(readBuffer, writeBuffer, readOffset, writeOffset, size)
      }
      None => go_panic_because_fn_not_loaded("glCopyNamedBufferSubData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCopyNamedBufferSubData" != "glGetError" {
        report_error_as_necessary_from(
          "glCopyNamedBufferSubData",
          glGetError(),
        );
      }
    }
    out
  }
  static glCopyNamedBufferSubData_p: APcv = ap_null();
  /// Tries to load [`glCopyNamedBufferSubData`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCopyNamedBufferSubData_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glCopyNamedBufferSubData\0");
    glCopyNamedBufferSubData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCopyNamedBufferSubData`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyNamedBufferSubData_is_loaded() -> bool {
    !glCopyNamedBufferSubData_p.load(RELAX).is_null()
  }

  /// [glCopyTexImage1D](http://docs.gl/gl4/glCopyTexImage1D)(target, level, internalformat, x, y, width, border)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  /// * `border` group: CheckedInt32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTexImage1D(
    target: GLenum,
    level: GLint,
    internalformat: GLenum,
    x: GLint,
    y: GLint,
    width: GLsizei,
    border: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glCopyTexImage1D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});",
        target,
        level,
        internalformat,
        x,
        y,
        width,
        border
      );
    }
    let p = glCopyTexImage1D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(target, level, internalformat, x, y, width, border),
      None => go_panic_because_fn_not_loaded("glCopyTexImage1D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCopyTexImage1D" != "glGetError" {
        report_error_as_necessary_from("glCopyTexImage1D", glGetError());
      }
    }
    out
  }
  static glCopyTexImage1D_p: APcv = ap_null();
  /// Tries to load [`glCopyTexImage1D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCopyTexImage1D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCopyTexImage1D\0");
    glCopyTexImage1D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCopyTexImage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTexImage1D_is_loaded() -> bool {
    !glCopyTexImage1D_p.load(RELAX).is_null()
  }

  /// [glCopyTexImage2D](http://docs.gl/gl4/glCopyTexImage2D)(target, level, internalformat, x, y, width, height, border)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  /// * `border` group: CheckedInt32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTexImage2D(
    target: GLenum,
    level: GLint,
    internalformat: GLenum,
    x: GLint,
    y: GLint,
    width: GLsizei,
    height: GLsizei,
    border: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCopyTexImage2D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, internalformat, x, y, width, height, border);
    }
    let p = glCopyTexImage2D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLenum,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLint,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(target, level, internalformat, x, y, width, height, border)
      }
      None => go_panic_because_fn_not_loaded("glCopyTexImage2D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCopyTexImage2D" != "glGetError" {
        report_error_as_necessary_from("glCopyTexImage2D", glGetError());
      }
    }
    out
  }
  static glCopyTexImage2D_p: APcv = ap_null();
  /// Tries to load [`glCopyTexImage2D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCopyTexImage2D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCopyTexImage2D\0");
    glCopyTexImage2D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCopyTexImage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTexImage2D_is_loaded() -> bool {
    !glCopyTexImage2D_p.load(RELAX).is_null()
  }

  /// [glCopyTexSubImage1D](http://docs.gl/gl4/glCopyTexSubImage1D)(target, level, xoffset, x, y, width)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTexSubImage1D(
    target: GLenum,
    level: GLint,
    xoffset: GLint,
    x: GLint,
    y: GLint,
    width: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glCopyTexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
        target,
        level,
        xoffset,
        x,
        y,
        width
      );
    }
    let p = glCopyTexSubImage1D_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, level, xoffset, x, y, width),
      None => go_panic_because_fn_not_loaded("glCopyTexSubImage1D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCopyTexSubImage1D" != "glGetError" {
        report_error_as_necessary_from("glCopyTexSubImage1D", glGetError());
      }
    }
    out
  }
  static glCopyTexSubImage1D_p: APcv = ap_null();
  /// Tries to load [`glCopyTexSubImage1D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCopyTexSubImage1D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCopyTexSubImage1D\0");
    glCopyTexSubImage1D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCopyTexSubImage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTexSubImage1D_is_loaded() -> bool {
    !glCopyTexSubImage1D_p.load(RELAX).is_null()
  }

  /// [glCopyTexSubImage2D](http://docs.gl/gl4/glCopyTexSubImage2D)(target, level, xoffset, yoffset, x, y, width, height)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `yoffset` group: CheckedInt32
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTexSubImage2D(
    target: GLenum,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    x: GLint,
    y: GLint,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCopyTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, xoffset, yoffset, x, y, width, height);
    }
    let p = glCopyTexSubImage2D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(target, level, xoffset, yoffset, x, y, width, height),
      None => go_panic_because_fn_not_loaded("glCopyTexSubImage2D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCopyTexSubImage2D" != "glGetError" {
        report_error_as_necessary_from("glCopyTexSubImage2D", glGetError());
      }
    }
    out
  }
  static glCopyTexSubImage2D_p: APcv = ap_null();
  /// Tries to load [`glCopyTexSubImage2D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCopyTexSubImage2D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCopyTexSubImage2D\0");
    glCopyTexSubImage2D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCopyTexSubImage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTexSubImage2D_is_loaded() -> bool {
    !glCopyTexSubImage2D_p.load(RELAX).is_null()
  }

  /// [glCopyTexSubImage3D](http://docs.gl/gl4/glCopyTexSubImage3D)(target, level, xoffset, yoffset, zoffset, x, y, width, height)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `yoffset` group: CheckedInt32
  /// * `zoffset` group: CheckedInt32
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTexSubImage3D(
    target: GLenum,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    zoffset: GLint,
    x: GLint,
    y: GLint,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCopyTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, xoffset, yoffset, zoffset, x, y, width, height);
    }
    let p = glCopyTexSubImage3D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(target, level, xoffset, yoffset, zoffset, x, y, width, height)
      }
      None => go_panic_because_fn_not_loaded("glCopyTexSubImage3D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCopyTexSubImage3D" != "glGetError" {
        report_error_as_necessary_from("glCopyTexSubImage3D", glGetError());
      }
    }
    out
  }
  static glCopyTexSubImage3D_p: APcv = ap_null();
  /// Tries to load [`glCopyTexSubImage3D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCopyTexSubImage3D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCopyTexSubImage3D\0");
    glCopyTexSubImage3D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCopyTexSubImage3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTexSubImage3D_is_loaded() -> bool {
    !glCopyTexSubImage3D_p.load(RELAX).is_null()
  }

  /// [glCopyTextureSubImage1D](http://docs.gl/gl4/glCopyTextureSubImage1D)(texture, level, xoffset, x, y, width)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTextureSubImage1D(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    x: GLint,
    y: GLint,
    width: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glCopyTextureSubImage1D({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
        texture,
        level,
        xoffset,
        x,
        y,
        width
      );
    }
    let p = glCopyTextureSubImage1D_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(texture, level, xoffset, x, y, width),
      None => go_panic_because_fn_not_loaded("glCopyTextureSubImage1D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCopyTextureSubImage1D" != "glGetError" {
        report_error_as_necessary_from("glCopyTextureSubImage1D", glGetError());
      }
    }
    out
  }
  static glCopyTextureSubImage1D_p: APcv = ap_null();
  /// Tries to load [`glCopyTextureSubImage1D`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCopyTextureSubImage1D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCopyTextureSubImage1D\0");
    glCopyTextureSubImage1D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCopyTextureSubImage1D`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTextureSubImage1D_is_loaded() -> bool {
    !glCopyTextureSubImage1D_p.load(RELAX).is_null()
  }

  /// [glCopyTextureSubImage2D](http://docs.gl/gl4/glCopyTextureSubImage2D)(texture, level, xoffset, yoffset, x, y, width, height)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTextureSubImage2D(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    x: GLint,
    y: GLint,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCopyTextureSubImage2D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", texture, level, xoffset, yoffset, x, y, width, height);
    }
    let p = glCopyTextureSubImage2D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(texture, level, xoffset, yoffset, x, y, width, height),
      None => go_panic_because_fn_not_loaded("glCopyTextureSubImage2D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCopyTextureSubImage2D" != "glGetError" {
        report_error_as_necessary_from("glCopyTextureSubImage2D", glGetError());
      }
    }
    out
  }
  static glCopyTextureSubImage2D_p: APcv = ap_null();
  /// Tries to load [`glCopyTextureSubImage2D`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCopyTextureSubImage2D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCopyTextureSubImage2D\0");
    glCopyTextureSubImage2D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCopyTextureSubImage2D`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTextureSubImage2D_is_loaded() -> bool {
    !glCopyTextureSubImage2D_p.load(RELAX).is_null()
  }

  /// [glCopyTextureSubImage3D](http://docs.gl/gl4/glCopyTextureSubImage3D)(texture, level, xoffset, yoffset, zoffset, x, y, width, height)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCopyTextureSubImage3D(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    zoffset: GLint,
    x: GLint,
    y: GLint,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCopyTextureSubImage3D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", texture, level, xoffset, yoffset, zoffset, x, y, width, height);
    }
    let p = glCopyTextureSubImage3D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(texture, level, xoffset, yoffset, zoffset, x, y, width, height)
      }
      None => go_panic_because_fn_not_loaded("glCopyTextureSubImage3D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCopyTextureSubImage3D" != "glGetError" {
        report_error_as_necessary_from("glCopyTextureSubImage3D", glGetError());
      }
    }
    out
  }
  static glCopyTextureSubImage3D_p: APcv = ap_null();
  /// Tries to load [`glCopyTextureSubImage3D`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCopyTextureSubImage3D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCopyTextureSubImage3D\0");
    glCopyTextureSubImage3D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCopyTextureSubImage3D`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCopyTextureSubImage3D_is_loaded() -> bool {
    !glCopyTextureSubImage3D_p.load(RELAX).is_null()
  }

  /// [glCreateBuffers](http://docs.gl/gl4/glCreateBuffers)(n, buffers)
  /// * `buffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateBuffers(n: GLsizei, buffers: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCreateBuffers({:?}, {:p});", n, buffers);
    }
    let p = glCreateBuffers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, buffers),
      None => go_panic_because_fn_not_loaded("glCreateBuffers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCreateBuffers" != "glGetError" {
        report_error_as_necessary_from("glCreateBuffers", glGetError());
      }
    }
    out
  }
  static glCreateBuffers_p: APcv = ap_null();
  /// Tries to load [`glCreateBuffers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCreateBuffers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCreateBuffers\0");
    glCreateBuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCreateBuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateBuffers_is_loaded() -> bool {
    !glCreateBuffers_p.load(RELAX).is_null()
  }

  /// [glCreateFramebuffers](http://docs.gl/gl4/glCreateFramebuffers)(n, framebuffers)
  /// * `framebuffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateFramebuffers(n: GLsizei, framebuffers: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCreateFramebuffers({:?}, {:p});", n, framebuffers);
    }
    let p = glCreateFramebuffers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, framebuffers),
      None => go_panic_because_fn_not_loaded("glCreateFramebuffers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCreateFramebuffers" != "glGetError" {
        report_error_as_necessary_from("glCreateFramebuffers", glGetError());
      }
    }
    out
  }
  static glCreateFramebuffers_p: APcv = ap_null();
  /// Tries to load [`glCreateFramebuffers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCreateFramebuffers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCreateFramebuffers\0");
    glCreateFramebuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCreateFramebuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateFramebuffers_is_loaded() -> bool {
    !glCreateFramebuffers_p.load(RELAX).is_null()
  }

  /// [glCreateProgram](http://docs.gl/gl4/glCreateProgram)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateProgram() -> GLuint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCreateProgram();",);
    }
    let p = glCreateProgram_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn() -> GLuint>>(p) {
      Some(fn_p) => fn_p(),
      None => go_panic_because_fn_not_loaded("glCreateProgram"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCreateProgram" != "glGetError" {
        report_error_as_necessary_from("glCreateProgram", glGetError());
      }
    }
    out
  }
  static glCreateProgram_p: APcv = ap_null();
  /// Tries to load [`glCreateProgram`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCreateProgram_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCreateProgram\0");
    glCreateProgram_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCreateProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateProgram_is_loaded() -> bool {
    !glCreateProgram_p.load(RELAX).is_null()
  }

  /// [glCreateProgramPipelines](http://docs.gl/gl4/glCreateProgramPipelines)(n, pipelines)
  /// * `pipelines` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateProgramPipelines(n: GLsizei, pipelines: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCreateProgramPipelines({:?}, {:p});", n, pipelines);
    }
    let p = glCreateProgramPipelines_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, pipelines),
      None => go_panic_because_fn_not_loaded("glCreateProgramPipelines"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCreateProgramPipelines" != "glGetError" {
        report_error_as_necessary_from(
          "glCreateProgramPipelines",
          glGetError(),
        );
      }
    }
    out
  }
  static glCreateProgramPipelines_p: APcv = ap_null();
  /// Tries to load [`glCreateProgramPipelines`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCreateProgramPipelines_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glCreateProgramPipelines\0");
    glCreateProgramPipelines_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCreateProgramPipelines`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateProgramPipelines_is_loaded() -> bool {
    !glCreateProgramPipelines_p.load(RELAX).is_null()
  }

  /// [glCreateQueries](http://docs.gl/gl4/glCreateQueries)(target, n, ids)
  /// * `target` group: QueryTarget
  /// * `ids` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateQueries(target: GLenum, n: GLsizei, ids: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCreateQueries({:#X}, {:?}, {:p});", target, n, ids);
    }
    let p = glCreateQueries_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(target, n, ids),
        None => go_panic_because_fn_not_loaded("glCreateQueries"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCreateQueries" != "glGetError" {
        report_error_as_necessary_from("glCreateQueries", glGetError());
      }
    }
    out
  }
  static glCreateQueries_p: APcv = ap_null();
  /// Tries to load [`glCreateQueries`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCreateQueries_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCreateQueries\0");
    glCreateQueries_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCreateQueries`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateQueries_is_loaded() -> bool {
    !glCreateQueries_p.load(RELAX).is_null()
  }

  /// [glCreateRenderbuffers](http://docs.gl/gl4/glCreateRenderbuffers)(n, renderbuffers)
  /// * `renderbuffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateRenderbuffers(n: GLsizei, renderbuffers: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCreateRenderbuffers({:?}, {:p});", n, renderbuffers);
    }
    let p = glCreateRenderbuffers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, renderbuffers),
      None => go_panic_because_fn_not_loaded("glCreateRenderbuffers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCreateRenderbuffers" != "glGetError" {
        report_error_as_necessary_from("glCreateRenderbuffers", glGetError());
      }
    }
    out
  }
  static glCreateRenderbuffers_p: APcv = ap_null();
  /// Tries to load [`glCreateRenderbuffers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCreateRenderbuffers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCreateRenderbuffers\0");
    glCreateRenderbuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCreateRenderbuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateRenderbuffers_is_loaded() -> bool {
    !glCreateRenderbuffers_p.load(RELAX).is_null()
  }

  /// [glCreateSamplers](http://docs.gl/gl4/glCreateSamplers)(n, samplers)
  /// * `samplers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateSamplers(n: GLsizei, samplers: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCreateSamplers({:?}, {:p});", n, samplers);
    }
    let p = glCreateSamplers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, samplers),
      None => go_panic_because_fn_not_loaded("glCreateSamplers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCreateSamplers" != "glGetError" {
        report_error_as_necessary_from("glCreateSamplers", glGetError());
      }
    }
    out
  }
  static glCreateSamplers_p: APcv = ap_null();
  /// Tries to load [`glCreateSamplers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCreateSamplers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCreateSamplers\0");
    glCreateSamplers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCreateSamplers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateSamplers_is_loaded() -> bool {
    !glCreateSamplers_p.load(RELAX).is_null()
  }

  /// [glCreateShader](http://docs.gl/gl4/glCreateShader)(type_)
  /// * `type_` group: ShaderType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateShader(type_: GLenum) -> GLuint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCreateShader({:#X});", type_);
    }
    let p = glCreateShader_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum) -> GLuint>>(p) {
      Some(fn_p) => fn_p(type_),
      None => go_panic_because_fn_not_loaded("glCreateShader"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCreateShader" != "glGetError" {
        report_error_as_necessary_from("glCreateShader", glGetError());
      }
    }
    out
  }
  static glCreateShader_p: APcv = ap_null();
  /// Tries to load [`glCreateShader`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCreateShader_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCreateShader\0");
    glCreateShader_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCreateShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateShader_is_loaded() -> bool {
    !glCreateShader_p.load(RELAX).is_null()
  }

  /// [glCreateShaderProgramv](http://docs.gl/gl4/glCreateShaderProgramv)(type_, count, strings)
  /// * `type_` group: ShaderType
  /// * `strings` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateShaderProgramv(
    type_: GLenum,
    count: GLsizei,
    strings: *const *const GLchar,
  ) -> GLuint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glCreateShaderProgramv({:#X}, {:?}, {:p});",
        type_,
        count,
        strings
      );
    }
    let p = glCreateShaderProgramv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLsizei, *const *const GLchar) -> GLuint>,
    >(p)
    {
      Some(fn_p) => fn_p(type_, count, strings),
      None => go_panic_because_fn_not_loaded("glCreateShaderProgramv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCreateShaderProgramv" != "glGetError" {
        report_error_as_necessary_from("glCreateShaderProgramv", glGetError());
      }
    }
    out
  }
  static glCreateShaderProgramv_p: APcv = ap_null();
  /// Tries to load [`glCreateShaderProgramv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCreateShaderProgramv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCreateShaderProgramv\0");
    glCreateShaderProgramv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCreateShaderProgramv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateShaderProgramv_is_loaded() -> bool {
    !glCreateShaderProgramv_p.load(RELAX).is_null()
  }

  /// [glCreateTextures](http://docs.gl/gl4/glCreateTextures)(target, n, textures)
  /// * `target` group: TextureTarget
  /// * `textures` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateTextures(
    target: GLenum,
    n: GLsizei,
    textures: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glCreateTextures({:#X}, {:?}, {:p});",
        target,
        n,
        textures
      );
    }
    let p = glCreateTextures_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(target, n, textures),
        None => go_panic_because_fn_not_loaded("glCreateTextures"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCreateTextures" != "glGetError" {
        report_error_as_necessary_from("glCreateTextures", glGetError());
      }
    }
    out
  }
  static glCreateTextures_p: APcv = ap_null();
  /// Tries to load [`glCreateTextures`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCreateTextures_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCreateTextures\0");
    glCreateTextures_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCreateTextures`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateTextures_is_loaded() -> bool {
    !glCreateTextures_p.load(RELAX).is_null()
  }

  /// [glCreateTransformFeedbacks](http://docs.gl/gl4/glCreateTransformFeedbacks)(n, ids)
  /// * `ids` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateTransformFeedbacks(n: GLsizei, ids: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCreateTransformFeedbacks({:?}, {:p});", n, ids);
    }
    let p = glCreateTransformFeedbacks_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, ids),
      None => go_panic_because_fn_not_loaded("glCreateTransformFeedbacks"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCreateTransformFeedbacks" != "glGetError" {
        report_error_as_necessary_from(
          "glCreateTransformFeedbacks",
          glGetError(),
        );
      }
    }
    out
  }
  static glCreateTransformFeedbacks_p: APcv = ap_null();
  /// Tries to load [`glCreateTransformFeedbacks`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCreateTransformFeedbacks_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glCreateTransformFeedbacks\0");
    glCreateTransformFeedbacks_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCreateTransformFeedbacks`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateTransformFeedbacks_is_loaded() -> bool {
    !glCreateTransformFeedbacks_p.load(RELAX).is_null()
  }

  /// [glCreateVertexArrays](http://docs.gl/gl4/glCreateVertexArrays)(n, arrays)
  /// * `arrays` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCreateVertexArrays(n: GLsizei, arrays: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCreateVertexArrays({:?}, {:p});", n, arrays);
    }
    let p = glCreateVertexArrays_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, arrays),
      None => go_panic_because_fn_not_loaded("glCreateVertexArrays"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCreateVertexArrays" != "glGetError" {
        report_error_as_necessary_from("glCreateVertexArrays", glGetError());
      }
    }
    out
  }
  static glCreateVertexArrays_p: APcv = ap_null();
  /// Tries to load [`glCreateVertexArrays`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCreateVertexArrays_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCreateVertexArrays\0");
    glCreateVertexArrays_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCreateVertexArrays`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCreateVertexArrays_is_loaded() -> bool {
    !glCreateVertexArrays_p.load(RELAX).is_null()
  }

  /// [glCullFace](http://docs.gl/gl4/glCullFace)(mode)
  /// * `mode` group: CullFaceMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glCullFace(mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glCullFace({:#X});", mode);
    }
    let p = glCullFace_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(mode),
      None => go_panic_because_fn_not_loaded("glCullFace"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glCullFace" != "glGetError" {
        report_error_as_necessary_from("glCullFace", glGetError());
      }
    }
    out
  }
  static glCullFace_p: APcv = ap_null();
  /// Tries to load [`glCullFace`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glCullFace_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glCullFace\0");
    glCullFace_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glCullFace`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glCullFace_is_loaded() -> bool {
    !glCullFace_p.load(RELAX).is_null()
  }

  /// [glDebugMessageCallback](http://docs.gl/gl4/glDebugMessageCallback)(callback, userParam)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDebugMessageCallback(
    callback: GLDEBUGPROC,
    userParam: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDebugMessageCallback({:?}, {:p});",
        t_::<_, O<fn()>>(callback),
        userParam
      );
    }
    let p = glDebugMessageCallback_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLDEBUGPROC, *const c_void)>>(p) {
        Some(fn_p) => fn_p(callback, userParam),
        None => go_panic_because_fn_not_loaded("glDebugMessageCallback"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDebugMessageCallback" != "glGetError" {
        report_error_as_necessary_from("glDebugMessageCallback", glGetError());
      }
    }
    out
  }
  static glDebugMessageCallback_p: APcv = ap_null();
  /// Tries to load [`glDebugMessageCallback`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDebugMessageCallback_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDebugMessageCallback\0");
    glDebugMessageCallback_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDebugMessageCallback`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDebugMessageCallback_is_loaded() -> bool {
    !glDebugMessageCallback_p.load(RELAX).is_null()
  }

  /// [glDebugMessageControl](http://docs.gl/gl4/glDebugMessageControl)(source, type_, severity, count, ids, enabled)
  /// * `source` group: DebugSource
  /// * `type_` group: DebugType
  /// * `severity` group: DebugSeverity
  /// * `ids` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDebugMessageControl(
    source: GLenum,
    type_: GLenum,
    severity: GLenum,
    count: GLsizei,
    ids: *const GLuint,
    enabled: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDebugMessageControl({:#X}, {:#X}, {:#X}, {:?}, {:p}, {:?});",
        source,
        type_,
        severity,
        count,
        ids,
        enabled
      );
    }
    let p = glDebugMessageControl_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLenum,
          GLenum,
          GLsizei,
          *const GLuint,
          GLboolean,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(source, type_, severity, count, ids, enabled),
      None => go_panic_because_fn_not_loaded("glDebugMessageControl"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDebugMessageControl" != "glGetError" {
        report_error_as_necessary_from("glDebugMessageControl", glGetError());
      }
    }
    out
  }
  static glDebugMessageControl_p: APcv = ap_null();
  /// Tries to load [`glDebugMessageControl`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDebugMessageControl_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDebugMessageControl\0");
    glDebugMessageControl_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDebugMessageControl`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDebugMessageControl_is_loaded() -> bool {
    !glDebugMessageControl_p.load(RELAX).is_null()
  }

  /// [glDebugMessageInsert](http://docs.gl/gl4/glDebugMessageInsert)(source, type_, id, severity, length, buf)
  /// * `source` group: DebugSource
  /// * `type_` group: DebugType
  /// * `severity` group: DebugSeverity
  /// * `buf` len: COMPSIZE(buf,length)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDebugMessageInsert(
    source: GLenum,
    type_: GLenum,
    id: GLuint,
    severity: GLenum,
    length: GLsizei,
    buf: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDebugMessageInsert({:#X}, {:#X}, {:?}, {:#X}, {:?}, {:p});",
        source,
        type_,
        id,
        severity,
        length,
        buf
      );
    }
    let p = glDebugMessageInsert_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLenum,
          GLuint,
          GLenum,
          GLsizei,
          *const GLchar,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(source, type_, id, severity, length, buf),
      None => go_panic_because_fn_not_loaded("glDebugMessageInsert"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDebugMessageInsert" != "glGetError" {
        report_error_as_necessary_from("glDebugMessageInsert", glGetError());
      }
    }
    out
  }
  static glDebugMessageInsert_p: APcv = ap_null();
  /// Tries to load [`glDebugMessageInsert`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDebugMessageInsert_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDebugMessageInsert\0");
    glDebugMessageInsert_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDebugMessageInsert`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDebugMessageInsert_is_loaded() -> bool {
    !glDebugMessageInsert_p.load(RELAX).is_null()
  }

  /// [glDeleteBuffers](http://docs.gl/gl4/glDeleteBuffers)(n, buffers)
  /// * `buffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteBuffers(n: GLsizei, buffers: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteBuffers({:?}, {:p});", n, buffers);
    }
    let p = glDeleteBuffers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(n, buffers),
      None => go_panic_because_fn_not_loaded("glDeleteBuffers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDeleteBuffers" != "glGetError" {
        report_error_as_necessary_from("glDeleteBuffers", glGetError());
      }
    }
    out
  }
  static glDeleteBuffers_p: APcv = ap_null();
  /// Tries to load [`glDeleteBuffers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDeleteBuffers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDeleteBuffers\0");
    glDeleteBuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDeleteBuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteBuffers_is_loaded() -> bool {
    !glDeleteBuffers_p.load(RELAX).is_null()
  }

  /// [glDeleteFramebuffers](http://docs.gl/gl4/glDeleteFramebuffers)(n, framebuffers)
  /// * `framebuffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteFramebuffers(n: GLsizei, framebuffers: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteFramebuffers({:?}, {:p});", n, framebuffers);
    }
    let p = glDeleteFramebuffers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(n, framebuffers),
      None => go_panic_because_fn_not_loaded("glDeleteFramebuffers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDeleteFramebuffers" != "glGetError" {
        report_error_as_necessary_from("glDeleteFramebuffers", glGetError());
      }
    }
    out
  }
  static glDeleteFramebuffers_p: APcv = ap_null();
  /// Tries to load [`glDeleteFramebuffers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDeleteFramebuffers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDeleteFramebuffers\0");
    glDeleteFramebuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDeleteFramebuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteFramebuffers_is_loaded() -> bool {
    !glDeleteFramebuffers_p.load(RELAX).is_null()
  }

  /// [glDeleteProgram](http://docs.gl/gl4/glDeleteProgram)(program)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteProgram(program: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteProgram({:?});", program);
    }
    let p = glDeleteProgram_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(program),
      None => go_panic_because_fn_not_loaded("glDeleteProgram"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDeleteProgram" != "glGetError" {
        report_error_as_necessary_from("glDeleteProgram", glGetError());
      }
    }
    out
  }
  static glDeleteProgram_p: APcv = ap_null();
  /// Tries to load [`glDeleteProgram`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDeleteProgram_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDeleteProgram\0");
    glDeleteProgram_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDeleteProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteProgram_is_loaded() -> bool {
    !glDeleteProgram_p.load(RELAX).is_null()
  }

  /// [glDeleteProgramPipelines](http://docs.gl/gl4/glDeleteProgramPipelines)(n, pipelines)
  /// * `pipelines` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteProgramPipelines(n: GLsizei, pipelines: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteProgramPipelines({:?}, {:p});", n, pipelines);
    }
    let p = glDeleteProgramPipelines_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(n, pipelines),
      None => go_panic_because_fn_not_loaded("glDeleteProgramPipelines"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDeleteProgramPipelines" != "glGetError" {
        report_error_as_necessary_from(
          "glDeleteProgramPipelines",
          glGetError(),
        );
      }
    }
    out
  }
  static glDeleteProgramPipelines_p: APcv = ap_null();
  /// Tries to load [`glDeleteProgramPipelines`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDeleteProgramPipelines_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glDeleteProgramPipelines\0");
    glDeleteProgramPipelines_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDeleteProgramPipelines`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteProgramPipelines_is_loaded() -> bool {
    !glDeleteProgramPipelines_p.load(RELAX).is_null()
  }

  /// [glDeleteQueries](http://docs.gl/gl4/glDeleteQueries)(n, ids)
  /// * `ids` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteQueries(n: GLsizei, ids: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteQueries({:?}, {:p});", n, ids);
    }
    let p = glDeleteQueries_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(n, ids),
      None => go_panic_because_fn_not_loaded("glDeleteQueries"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDeleteQueries" != "glGetError" {
        report_error_as_necessary_from("glDeleteQueries", glGetError());
      }
    }
    out
  }
  static glDeleteQueries_p: APcv = ap_null();
  /// Tries to load [`glDeleteQueries`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDeleteQueries_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDeleteQueries\0");
    glDeleteQueries_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDeleteQueries`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteQueries_is_loaded() -> bool {
    !glDeleteQueries_p.load(RELAX).is_null()
  }

  /// [glDeleteRenderbuffers](http://docs.gl/gl4/glDeleteRenderbuffers)(n, renderbuffers)
  /// * `renderbuffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteRenderbuffers(
    n: GLsizei,
    renderbuffers: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteRenderbuffers({:?}, {:p});", n, renderbuffers);
    }
    let p = glDeleteRenderbuffers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(n, renderbuffers),
      None => go_panic_because_fn_not_loaded("glDeleteRenderbuffers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDeleteRenderbuffers" != "glGetError" {
        report_error_as_necessary_from("glDeleteRenderbuffers", glGetError());
      }
    }
    out
  }
  static glDeleteRenderbuffers_p: APcv = ap_null();
  /// Tries to load [`glDeleteRenderbuffers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDeleteRenderbuffers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDeleteRenderbuffers\0");
    glDeleteRenderbuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDeleteRenderbuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteRenderbuffers_is_loaded() -> bool {
    !glDeleteRenderbuffers_p.load(RELAX).is_null()
  }

  /// [glDeleteSamplers](http://docs.gl/gl4/glDeleteSamplers)(count, samplers)
  /// * `samplers` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteSamplers(count: GLsizei, samplers: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteSamplers({:?}, {:p});", count, samplers);
    }
    let p = glDeleteSamplers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(count, samplers),
      None => go_panic_because_fn_not_loaded("glDeleteSamplers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDeleteSamplers" != "glGetError" {
        report_error_as_necessary_from("glDeleteSamplers", glGetError());
      }
    }
    out
  }
  static glDeleteSamplers_p: APcv = ap_null();
  /// Tries to load [`glDeleteSamplers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDeleteSamplers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDeleteSamplers\0");
    glDeleteSamplers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDeleteSamplers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteSamplers_is_loaded() -> bool {
    !glDeleteSamplers_p.load(RELAX).is_null()
  }

  /// [glDeleteShader](http://docs.gl/gl4/glDeleteShader)(shader)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteShader(shader: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteShader({:?});", shader);
    }
    let p = glDeleteShader_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(shader),
      None => go_panic_because_fn_not_loaded("glDeleteShader"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDeleteShader" != "glGetError" {
        report_error_as_necessary_from("glDeleteShader", glGetError());
      }
    }
    out
  }
  static glDeleteShader_p: APcv = ap_null();
  /// Tries to load [`glDeleteShader`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDeleteShader_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDeleteShader\0");
    glDeleteShader_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDeleteShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteShader_is_loaded() -> bool {
    !glDeleteShader_p.load(RELAX).is_null()
  }

  /// [glDeleteSync](http://docs.gl/gl4/glDeleteSync)(sync)
  /// * `sync` group: sync
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteSync(sync: GLsync) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteSync({:p});", sync);
    }
    let p = glDeleteSync_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsync)>>(p) {
      Some(fn_p) => fn_p(sync),
      None => go_panic_because_fn_not_loaded("glDeleteSync"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDeleteSync" != "glGetError" {
        report_error_as_necessary_from("glDeleteSync", glGetError());
      }
    }
    out
  }
  static glDeleteSync_p: APcv = ap_null();
  /// Tries to load [`glDeleteSync`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDeleteSync_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDeleteSync\0");
    glDeleteSync_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDeleteSync`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteSync_is_loaded() -> bool {
    !glDeleteSync_p.load(RELAX).is_null()
  }

  /// [glDeleteTextures](http://docs.gl/gl4/glDeleteTextures)(n, textures)
  /// * `textures` group: Texture
  /// * `textures` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteTextures(n: GLsizei, textures: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteTextures({:?}, {:p});", n, textures);
    }
    let p = glDeleteTextures_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(n, textures),
      None => go_panic_because_fn_not_loaded("glDeleteTextures"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDeleteTextures" != "glGetError" {
        report_error_as_necessary_from("glDeleteTextures", glGetError());
      }
    }
    out
  }
  static glDeleteTextures_p: APcv = ap_null();
  /// Tries to load [`glDeleteTextures`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDeleteTextures_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDeleteTextures\0");
    glDeleteTextures_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDeleteTextures`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteTextures_is_loaded() -> bool {
    !glDeleteTextures_p.load(RELAX).is_null()
  }

  /// [glDeleteTransformFeedbacks](http://docs.gl/gl4/glDeleteTransformFeedbacks)(n, ids)
  /// * `ids` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteTransformFeedbacks(n: GLsizei, ids: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteTransformFeedbacks({:?}, {:p});", n, ids);
    }
    let p = glDeleteTransformFeedbacks_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(n, ids),
      None => go_panic_because_fn_not_loaded("glDeleteTransformFeedbacks"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDeleteTransformFeedbacks" != "glGetError" {
        report_error_as_necessary_from(
          "glDeleteTransformFeedbacks",
          glGetError(),
        );
      }
    }
    out
  }
  static glDeleteTransformFeedbacks_p: APcv = ap_null();
  /// Tries to load [`glDeleteTransformFeedbacks`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDeleteTransformFeedbacks_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glDeleteTransformFeedbacks\0");
    glDeleteTransformFeedbacks_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDeleteTransformFeedbacks`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteTransformFeedbacks_is_loaded() -> bool {
    !glDeleteTransformFeedbacks_p.load(RELAX).is_null()
  }

  /// [glDeleteVertexArrays](http://docs.gl/gl4/glDeleteVertexArrays)(n, arrays)
  /// * `arrays` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDeleteVertexArrays(n: GLsizei, arrays: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDeleteVertexArrays({:?}, {:p});", n, arrays);
    }
    let p = glDeleteVertexArrays_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(n, arrays),
      None => go_panic_because_fn_not_loaded("glDeleteVertexArrays"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDeleteVertexArrays" != "glGetError" {
        report_error_as_necessary_from("glDeleteVertexArrays", glGetError());
      }
    }
    out
  }
  static glDeleteVertexArrays_p: APcv = ap_null();
  /// Tries to load [`glDeleteVertexArrays`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDeleteVertexArrays_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDeleteVertexArrays\0");
    glDeleteVertexArrays_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDeleteVertexArrays`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDeleteVertexArrays_is_loaded() -> bool {
    !glDeleteVertexArrays_p.load(RELAX).is_null()
  }

  /// [glDepthFunc](http://docs.gl/gl4/glDepthFunc)(func)
  /// * `func` group: DepthFunction
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDepthFunc(func: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDepthFunc({:#X});", func);
    }
    let p = glDepthFunc_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(func),
      None => go_panic_because_fn_not_loaded("glDepthFunc"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDepthFunc" != "glGetError" {
        report_error_as_necessary_from("glDepthFunc", glGetError());
      }
    }
    out
  }
  static glDepthFunc_p: APcv = ap_null();
  /// Tries to load [`glDepthFunc`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDepthFunc_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDepthFunc\0");
    glDepthFunc_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDepthFunc`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDepthFunc_is_loaded() -> bool {
    !glDepthFunc_p.load(RELAX).is_null()
  }

  /// [glDepthMask](http://docs.gl/gl4/glDepthMask)(flag)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDepthMask(flag: GLboolean) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDepthMask({:?});", flag);
    }
    let p = glDepthMask_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLboolean)>>(p) {
      Some(fn_p) => fn_p(flag),
      None => go_panic_because_fn_not_loaded("glDepthMask"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDepthMask" != "glGetError" {
        report_error_as_necessary_from("glDepthMask", glGetError());
      }
    }
    out
  }
  static glDepthMask_p: APcv = ap_null();
  /// Tries to load [`glDepthMask`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDepthMask_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDepthMask\0");
    glDepthMask_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDepthMask`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDepthMask_is_loaded() -> bool {
    !glDepthMask_p.load(RELAX).is_null()
  }

  /// [glDepthRange](http://docs.gl/gl4/glDepthRange)(n, f)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDepthRange(n: GLdouble, f: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDepthRange({:?}, {:?});", n, f);
    }
    let p = glDepthRange_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLdouble, GLdouble)>>(p) {
      Some(fn_p) => fn_p(n, f),
      None => go_panic_because_fn_not_loaded("glDepthRange"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDepthRange" != "glGetError" {
        report_error_as_necessary_from("glDepthRange", glGetError());
      }
    }
    out
  }
  static glDepthRange_p: APcv = ap_null();
  /// Tries to load [`glDepthRange`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDepthRange_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDepthRange\0");
    glDepthRange_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDepthRange`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDepthRange_is_loaded() -> bool {
    !glDepthRange_p.load(RELAX).is_null()
  }

  /// [glDepthRangeArrayv](http://docs.gl/gl4/glDepthRangeArrayv)(first, count, v)
  /// * `v` len: COMPSIZE(count)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDepthRangeArrayv(
    first: GLuint,
    count: GLsizei,
    v: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDepthRangeArrayv({:?}, {:?}, {:p});", first, count, v);
    }
    let p = glDepthRangeArrayv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLsizei, *const GLdouble)>>(p)
      {
        Some(fn_p) => fn_p(first, count, v),
        None => go_panic_because_fn_not_loaded("glDepthRangeArrayv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDepthRangeArrayv" != "glGetError" {
        report_error_as_necessary_from("glDepthRangeArrayv", glGetError());
      }
    }
    out
  }
  static glDepthRangeArrayv_p: APcv = ap_null();
  /// Tries to load [`glDepthRangeArrayv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDepthRangeArrayv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDepthRangeArrayv\0");
    glDepthRangeArrayv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDepthRangeArrayv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDepthRangeArrayv_is_loaded() -> bool {
    !glDepthRangeArrayv_p.load(RELAX).is_null()
  }

  /// [glDepthRangeIndexed](http://docs.gl/gl4/glDepthRangeIndexed)(index, n, f)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDepthRangeIndexed(index: GLuint, n: GLdouble, f: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDepthRangeIndexed({:?}, {:?}, {:?});", index, n, f);
    }
    let p = glDepthRangeIndexed_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLdouble, GLdouble)>>(p) {
        Some(fn_p) => fn_p(index, n, f),
        None => go_panic_because_fn_not_loaded("glDepthRangeIndexed"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDepthRangeIndexed" != "glGetError" {
        report_error_as_necessary_from("glDepthRangeIndexed", glGetError());
      }
    }
    out
  }
  static glDepthRangeIndexed_p: APcv = ap_null();
  /// Tries to load [`glDepthRangeIndexed`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDepthRangeIndexed_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDepthRangeIndexed\0");
    glDepthRangeIndexed_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDepthRangeIndexed`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDepthRangeIndexed_is_loaded() -> bool {
    !glDepthRangeIndexed_p.load(RELAX).is_null()
  }

  /// [glDepthRangef](http://docs.gl/gl4/glDepthRangef)(n, f)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDepthRangef(n: GLfloat, f: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDepthRangef({:?}, {:?});", n, f);
    }
    let p = glDepthRangef_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLfloat, GLfloat)>>(p) {
      Some(fn_p) => fn_p(n, f),
      None => go_panic_because_fn_not_loaded("glDepthRangef"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDepthRangef" != "glGetError" {
        report_error_as_necessary_from("glDepthRangef", glGetError());
      }
    }
    out
  }
  static glDepthRangef_p: APcv = ap_null();
  /// Tries to load [`glDepthRangef`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDepthRangef_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDepthRangef\0");
    glDepthRangef_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDepthRangef`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDepthRangef_is_loaded() -> bool {
    !glDepthRangef_p.load(RELAX).is_null()
  }

  /// [glDetachShader](http://docs.gl/gl4/glDetachShader)(program, shader)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDetachShader(program: GLuint, shader: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDetachShader({:?}, {:?});", program, shader);
    }
    let p = glDetachShader_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(program, shader),
      None => go_panic_because_fn_not_loaded("glDetachShader"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDetachShader" != "glGetError" {
        report_error_as_necessary_from("glDetachShader", glGetError());
      }
    }
    out
  }
  static glDetachShader_p: APcv = ap_null();
  /// Tries to load [`glDetachShader`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDetachShader_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDetachShader\0");
    glDetachShader_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDetachShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDetachShader_is_loaded() -> bool {
    !glDetachShader_p.load(RELAX).is_null()
  }

  /// [glDisable](http://docs.gl/gl4/glDisable)(cap)
  /// * `cap` group: EnableCap
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDisable(cap: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDisable({:#X});", cap);
    }
    let p = glDisable_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(cap),
      None => go_panic_because_fn_not_loaded("glDisable"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDisable" != "glGetError" {
        report_error_as_necessary_from("glDisable", glGetError());
      }
    }
    out
  }
  static glDisable_p: APcv = ap_null();
  /// Tries to load [`glDisable`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDisable_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDisable\0");
    glDisable_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDisable`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDisable_is_loaded() -> bool {
    !glDisable_p.load(RELAX).is_null()
  }

  /// [glDisableVertexArrayAttrib](http://docs.gl/gl4/glDisableVertexArrayAttrib)(vaobj, index)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDisableVertexArrayAttrib(vaobj: GLuint, index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDisableVertexArrayAttrib({:?}, {:?});", vaobj, index);
    }
    let p = glDisableVertexArrayAttrib_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(vaobj, index),
      None => go_panic_because_fn_not_loaded("glDisableVertexArrayAttrib"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDisableVertexArrayAttrib" != "glGetError" {
        report_error_as_necessary_from(
          "glDisableVertexArrayAttrib",
          glGetError(),
        );
      }
    }
    out
  }
  static glDisableVertexArrayAttrib_p: APcv = ap_null();
  /// Tries to load [`glDisableVertexArrayAttrib`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDisableVertexArrayAttrib_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glDisableVertexArrayAttrib\0");
    glDisableVertexArrayAttrib_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDisableVertexArrayAttrib`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDisableVertexArrayAttrib_is_loaded() -> bool {
    !glDisableVertexArrayAttrib_p.load(RELAX).is_null()
  }

  /// [glDisableVertexAttribArray](http://docs.gl/gl4/glDisableVertexAttribArray)(index)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDisableVertexAttribArray(index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDisableVertexAttribArray({:?});", index);
    }
    let p = glDisableVertexAttribArray_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(index),
      None => go_panic_because_fn_not_loaded("glDisableVertexAttribArray"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDisableVertexAttribArray" != "glGetError" {
        report_error_as_necessary_from(
          "glDisableVertexAttribArray",
          glGetError(),
        );
      }
    }
    out
  }
  static glDisableVertexAttribArray_p: APcv = ap_null();
  /// Tries to load [`glDisableVertexAttribArray`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDisableVertexAttribArray_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glDisableVertexAttribArray\0");
    glDisableVertexAttribArray_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDisableVertexAttribArray`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDisableVertexAttribArray_is_loaded() -> bool {
    !glDisableVertexAttribArray_p.load(RELAX).is_null()
  }

  /// [glDisablei](http://docs.gl/gl4/glDisablei)(target, index)
  /// * `target` group: EnableCap
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDisablei(target: GLenum, index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDisablei({:#X}, {:?});", target, index);
    }
    let p = glDisablei_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(target, index),
      None => go_panic_because_fn_not_loaded("glDisablei"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDisablei" != "glGetError" {
        report_error_as_necessary_from("glDisablei", glGetError());
      }
    }
    out
  }
  static glDisablei_p: APcv = ap_null();
  /// Tries to load [`glDisablei`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDisablei_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDisablei\0");
    glDisablei_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDisablei`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDisablei_is_loaded() -> bool {
    !glDisablei_p.load(RELAX).is_null()
  }

  /// [glDispatchCompute](http://docs.gl/gl4/glDispatchCompute)(num_groups_x, num_groups_y, num_groups_z)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDispatchCompute(
    num_groups_x: GLuint,
    num_groups_y: GLuint,
    num_groups_z: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDispatchCompute({:?}, {:?}, {:?});",
        num_groups_x,
        num_groups_y,
        num_groups_z
      );
    }
    let p = glDispatchCompute_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(num_groups_x, num_groups_y, num_groups_z),
      None => go_panic_because_fn_not_loaded("glDispatchCompute"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDispatchCompute" != "glGetError" {
        report_error_as_necessary_from("glDispatchCompute", glGetError());
      }
    }
    out
  }
  static glDispatchCompute_p: APcv = ap_null();
  /// Tries to load [`glDispatchCompute`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDispatchCompute_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDispatchCompute\0");
    glDispatchCompute_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDispatchCompute`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDispatchCompute_is_loaded() -> bool {
    !glDispatchCompute_p.load(RELAX).is_null()
  }

  /// [glDispatchComputeIndirect](http://docs.gl/gl4/glDispatchComputeIndirect)(indirect)
  /// * `indirect` group: BufferOffset
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDispatchComputeIndirect(indirect: GLintptr) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDispatchComputeIndirect({:?});", indirect);
    }
    let p = glDispatchComputeIndirect_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLintptr)>>(p) {
      Some(fn_p) => fn_p(indirect),
      None => go_panic_because_fn_not_loaded("glDispatchComputeIndirect"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDispatchComputeIndirect" != "glGetError" {
        report_error_as_necessary_from(
          "glDispatchComputeIndirect",
          glGetError(),
        );
      }
    }
    out
  }
  static glDispatchComputeIndirect_p: APcv = ap_null();
  /// Tries to load [`glDispatchComputeIndirect`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDispatchComputeIndirect_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glDispatchComputeIndirect\0");
    glDispatchComputeIndirect_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDispatchComputeIndirect`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDispatchComputeIndirect_is_loaded() -> bool {
    !glDispatchComputeIndirect_p.load(RELAX).is_null()
  }

  /// [glDrawArrays](http://docs.gl/gl4/glDrawArrays)(mode, first, count)
  /// * `mode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawArrays(mode: GLenum, first: GLint, count: GLsizei) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawArrays({:#X}, {:?}, {:?});", mode, first, count);
    }
    let p = glDrawArrays_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLint, GLsizei)>>(p) {
      Some(fn_p) => fn_p(mode, first, count),
      None => go_panic_because_fn_not_loaded("glDrawArrays"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawArrays" != "glGetError" {
        report_error_as_necessary_from("glDrawArrays", glGetError());
      }
    }
    out
  }
  static glDrawArrays_p: APcv = ap_null();
  /// Tries to load [`glDrawArrays`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawArrays_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawArrays\0");
    glDrawArrays_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawArrays`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawArrays_is_loaded() -> bool {
    !glDrawArrays_p.load(RELAX).is_null()
  }

  /// [glDrawArraysIndirect](http://docs.gl/gl4/glDrawArraysIndirect)(mode, indirect)
  /// * `mode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawArraysIndirect(mode: GLenum, indirect: *const c_void) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawArraysIndirect({:#X}, {:p});", mode, indirect);
    }
    let p = glDrawArraysIndirect_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, *const c_void)>>(p) {
      Some(fn_p) => fn_p(mode, indirect),
      None => go_panic_because_fn_not_loaded("glDrawArraysIndirect"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawArraysIndirect" != "glGetError" {
        report_error_as_necessary_from("glDrawArraysIndirect", glGetError());
      }
    }
    out
  }
  static glDrawArraysIndirect_p: APcv = ap_null();
  /// Tries to load [`glDrawArraysIndirect`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawArraysIndirect_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawArraysIndirect\0");
    glDrawArraysIndirect_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawArraysIndirect`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawArraysIndirect_is_loaded() -> bool {
    !glDrawArraysIndirect_p.load(RELAX).is_null()
  }

  /// [glDrawArraysInstanced](http://docs.gl/gl4/glDrawArraysInstanced)(mode, first, count, instancecount)
  /// * `mode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawArraysInstanced(
    mode: GLenum,
    first: GLint,
    count: GLsizei,
    instancecount: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawArraysInstanced({:#X}, {:?}, {:?}, {:?});",
        mode,
        first,
        count,
        instancecount
      );
    }
    let p = glDrawArraysInstanced_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLint, GLsizei, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(mode, first, count, instancecount),
      None => go_panic_because_fn_not_loaded("glDrawArraysInstanced"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawArraysInstanced" != "glGetError" {
        report_error_as_necessary_from("glDrawArraysInstanced", glGetError());
      }
    }
    out
  }
  static glDrawArraysInstanced_p: APcv = ap_null();
  /// Tries to load [`glDrawArraysInstanced`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawArraysInstanced_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawArraysInstanced\0");
    glDrawArraysInstanced_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawArraysInstanced`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawArraysInstanced_is_loaded() -> bool {
    !glDrawArraysInstanced_p.load(RELAX).is_null()
  }

  /// [glDrawArraysInstancedBaseInstance](http://docs.gl/gl4/glDrawArraysInstancedBaseInstance)(mode, first, count, instancecount, baseinstance)
  /// * `mode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawArraysInstancedBaseInstance(
    mode: GLenum,
    first: GLint,
    count: GLsizei,
    instancecount: GLsizei,
    baseinstance: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawArraysInstancedBaseInstance({:#X}, {:?}, {:?}, {:?}, {:?});", mode, first, count, instancecount, baseinstance);
    }
    let p = glDrawArraysInstancedBaseInstance_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLint, GLsizei, GLsizei, GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(mode, first, count, instancecount, baseinstance),
      None => {
        go_panic_because_fn_not_loaded("glDrawArraysInstancedBaseInstance")
      }
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawArraysInstancedBaseInstance" != "glGetError" {
        report_error_as_necessary_from(
          "glDrawArraysInstancedBaseInstance",
          glGetError(),
        );
      }
    }
    out
  }
  static glDrawArraysInstancedBaseInstance_p: APcv = ap_null();
  /// Tries to load [`glDrawArraysInstancedBaseInstance`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawArraysInstancedBaseInstance_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glDrawArraysInstancedBaseInstance\0");
    glDrawArraysInstancedBaseInstance_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawArraysInstancedBaseInstance`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawArraysInstancedBaseInstance_is_loaded() -> bool {
    !glDrawArraysInstancedBaseInstance_p.load(RELAX).is_null()
  }

  /// [glDrawBuffer](http://docs.gl/gl4/glDrawBuffer)(buf)
  /// * `buf` group: DrawBufferMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawBuffer(buf: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawBuffer({:#X});", buf);
    }
    let p = glDrawBuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(buf),
      None => go_panic_because_fn_not_loaded("glDrawBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawBuffer" != "glGetError" {
        report_error_as_necessary_from("glDrawBuffer", glGetError());
      }
    }
    out
  }
  static glDrawBuffer_p: APcv = ap_null();
  /// Tries to load [`glDrawBuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawBuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawBuffer\0");
    glDrawBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawBuffer_is_loaded() -> bool {
    !glDrawBuffer_p.load(RELAX).is_null()
  }

  /// [glDrawBuffers](http://docs.gl/gl4/glDrawBuffers)(n, bufs)
  /// * `bufs` group: DrawBufferMode
  /// * `bufs` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawBuffers(n: GLsizei, bufs: *const GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawBuffers({:?}, {:p});", n, bufs);
    }
    let p = glDrawBuffers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLenum)>>(p) {
      Some(fn_p) => fn_p(n, bufs),
      None => go_panic_because_fn_not_loaded("glDrawBuffers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawBuffers" != "glGetError" {
        report_error_as_necessary_from("glDrawBuffers", glGetError());
      }
    }
    out
  }
  static glDrawBuffers_p: APcv = ap_null();
  /// Tries to load [`glDrawBuffers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawBuffers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawBuffers\0");
    glDrawBuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawBuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawBuffers_is_loaded() -> bool {
    !glDrawBuffers_p.load(RELAX).is_null()
  }

  /// [glDrawElements](http://docs.gl/gl4/glDrawElements)(mode, count, type_, indices)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(count,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawElements(
    mode: GLenum,
    count: GLsizei,
    type_: GLenum,
    indices: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawElements({:#X}, {:?}, {:#X}, {:p});",
        mode,
        count,
        type_,
        indices
      );
    }
    let p = glDrawElements_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLsizei, GLenum, *const c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(mode, count, type_, indices),
      None => go_panic_because_fn_not_loaded("glDrawElements"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawElements" != "glGetError" {
        report_error_as_necessary_from("glDrawElements", glGetError());
      }
    }
    out
  }
  static glDrawElements_p: APcv = ap_null();
  /// Tries to load [`glDrawElements`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawElements_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawElements\0");
    glDrawElements_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawElements`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawElements_is_loaded() -> bool {
    !glDrawElements_p.load(RELAX).is_null()
  }

  /// [glDrawElementsBaseVertex](http://docs.gl/gl4/glDrawElementsBaseVertex)(mode, count, type_, indices, basevertex)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(count,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawElementsBaseVertex(
    mode: GLenum,
    count: GLsizei,
    type_: GLenum,
    indices: *const c_void,
    basevertex: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawElementsBaseVertex({:#X}, {:?}, {:#X}, {:p}, {:?});",
        mode,
        count,
        type_,
        indices,
        basevertex
      );
    }
    let p = glDrawElementsBaseVertex_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(mode, count, type_, indices, basevertex),
      None => go_panic_because_fn_not_loaded("glDrawElementsBaseVertex"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawElementsBaseVertex" != "glGetError" {
        report_error_as_necessary_from(
          "glDrawElementsBaseVertex",
          glGetError(),
        );
      }
    }
    out
  }
  static glDrawElementsBaseVertex_p: APcv = ap_null();
  /// Tries to load [`glDrawElementsBaseVertex`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawElementsBaseVertex_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawElementsBaseVertex\0");
    glDrawElementsBaseVertex_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawElementsBaseVertex`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawElementsBaseVertex_is_loaded() -> bool {
    !glDrawElementsBaseVertex_p.load(RELAX).is_null()
  }

  /// [glDrawElementsIndirect](http://docs.gl/gl4/glDrawElementsIndirect)(mode, type_, indirect)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawElementsIndirect(
    mode: GLenum,
    type_: GLenum,
    indirect: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawElementsIndirect({:#X}, {:#X}, {:p});",
        mode,
        type_,
        indirect
      );
    }
    let p = glDrawElementsIndirect_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *const c_void)>>(p) {
        Some(fn_p) => fn_p(mode, type_, indirect),
        None => go_panic_because_fn_not_loaded("glDrawElementsIndirect"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawElementsIndirect" != "glGetError" {
        report_error_as_necessary_from("glDrawElementsIndirect", glGetError());
      }
    }
    out
  }
  static glDrawElementsIndirect_p: APcv = ap_null();
  /// Tries to load [`glDrawElementsIndirect`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawElementsIndirect_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawElementsIndirect\0");
    glDrawElementsIndirect_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawElementsIndirect`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawElementsIndirect_is_loaded() -> bool {
    !glDrawElementsIndirect_p.load(RELAX).is_null()
  }

  /// [glDrawElementsInstanced](http://docs.gl/gl4/glDrawElementsInstanced)(mode, count, type_, indices, instancecount)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(count,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawElementsInstanced(
    mode: GLenum,
    count: GLsizei,
    type_: GLenum,
    indices: *const c_void,
    instancecount: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawElementsInstanced({:#X}, {:?}, {:#X}, {:p}, {:?});",
        mode,
        count,
        type_,
        indices,
        instancecount
      );
    }
    let p = glDrawElementsInstanced_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(mode, count, type_, indices, instancecount),
      None => go_panic_because_fn_not_loaded("glDrawElementsInstanced"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawElementsInstanced" != "glGetError" {
        report_error_as_necessary_from("glDrawElementsInstanced", glGetError());
      }
    }
    out
  }
  static glDrawElementsInstanced_p: APcv = ap_null();
  /// Tries to load [`glDrawElementsInstanced`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawElementsInstanced_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawElementsInstanced\0");
    glDrawElementsInstanced_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawElementsInstanced`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawElementsInstanced_is_loaded() -> bool {
    !glDrawElementsInstanced_p.load(RELAX).is_null()
  }

  /// [glDrawElementsInstancedBaseInstance](http://docs.gl/gl4/glDrawElementsInstancedBaseInstance)(mode, count, type_, indices, instancecount, baseinstance)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: PrimitiveType
  /// * `indices` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawElementsInstancedBaseInstance(
    mode: GLenum,
    count: GLsizei,
    type_: GLenum,
    indices: *const c_void,
    instancecount: GLsizei,
    baseinstance: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawElementsInstancedBaseInstance({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?});", mode, count, type_, indices, instancecount, baseinstance);
    }
    let p = glDrawElementsInstancedBaseInstance_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLsizei,
          GLenum,
          *const c_void,
          GLsizei,
          GLuint,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(mode, count, type_, indices, instancecount, baseinstance)
      }
      None => {
        go_panic_because_fn_not_loaded("glDrawElementsInstancedBaseInstance")
      }
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawElementsInstancedBaseInstance" != "glGetError" {
        report_error_as_necessary_from(
          "glDrawElementsInstancedBaseInstance",
          glGetError(),
        );
      }
    }
    out
  }
  static glDrawElementsInstancedBaseInstance_p: APcv = ap_null();
  /// Tries to load [`glDrawElementsInstancedBaseInstance`], returns if a
  /// non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawElementsInstancedBaseInstance_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glDrawElementsInstancedBaseInstance\0");
    glDrawElementsInstancedBaseInstance_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawElementsInstancedBaseInstance`] is
  /// loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawElementsInstancedBaseInstance_is_loaded() -> bool {
    !glDrawElementsInstancedBaseInstance_p.load(RELAX).is_null()
  }

  /// [glDrawElementsInstancedBaseVertex](http://docs.gl/gl4/glDrawElementsInstancedBaseVertex)(mode, count, type_, indices, instancecount, basevertex)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(count,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawElementsInstancedBaseVertex(
    mode: GLenum,
    count: GLsizei,
    type_: GLenum,
    indices: *const c_void,
    instancecount: GLsizei,
    basevertex: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawElementsInstancedBaseVertex({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?});", mode, count, type_, indices, instancecount, basevertex);
    }
    let p = glDrawElementsInstancedBaseVertex_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLsizei,
          GLenum,
          *const c_void,
          GLsizei,
          GLint,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(mode, count, type_, indices, instancecount, basevertex)
      }
      None => {
        go_panic_because_fn_not_loaded("glDrawElementsInstancedBaseVertex")
      }
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawElementsInstancedBaseVertex" != "glGetError" {
        report_error_as_necessary_from(
          "glDrawElementsInstancedBaseVertex",
          glGetError(),
        );
      }
    }
    out
  }
  static glDrawElementsInstancedBaseVertex_p: APcv = ap_null();
  /// Tries to load [`glDrawElementsInstancedBaseVertex`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawElementsInstancedBaseVertex_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glDrawElementsInstancedBaseVertex\0");
    glDrawElementsInstancedBaseVertex_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawElementsInstancedBaseVertex`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawElementsInstancedBaseVertex_is_loaded() -> bool {
    !glDrawElementsInstancedBaseVertex_p.load(RELAX).is_null()
  }

  /// [glDrawElementsInstancedBaseVertexBaseInstance](http://docs.gl/gl4/glDrawElementsInstancedBaseVertexBaseInstance)(mode, count, type_, indices, instancecount, basevertex, baseinstance)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawElementsInstancedBaseVertexBaseInstance(
    mode: GLenum,
    count: GLsizei,
    type_: GLenum,
    indices: *const c_void,
    instancecount: GLsizei,
    basevertex: GLint,
    baseinstance: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawElementsInstancedBaseVertexBaseInstance({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?}, {:?});", mode, count, type_, indices, instancecount, basevertex, baseinstance);
    }
    let p = glDrawElementsInstancedBaseVertexBaseInstance_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLsizei,
          GLenum,
          *const c_void,
          GLsizei,
          GLint,
          GLuint,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        mode,
        count,
        type_,
        indices,
        instancecount,
        basevertex,
        baseinstance,
      ),
      None => go_panic_because_fn_not_loaded(
        "glDrawElementsInstancedBaseVertexBaseInstance",
      ),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawElementsInstancedBaseVertexBaseInstance" != "glGetError" {
        report_error_as_necessary_from(
          "glDrawElementsInstancedBaseVertexBaseInstance",
          glGetError(),
        );
      }
    }
    out
  }
  static glDrawElementsInstancedBaseVertexBaseInstance_p: APcv = ap_null();
  /// Tries to load [`glDrawElementsInstancedBaseVertexBaseInstance`], returns
  /// if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawElementsInstancedBaseVertexBaseInstance_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(
      get_proc_address,
      b"glDrawElementsInstancedBaseVertexBaseInstance\0",
    );
    glDrawElementsInstancedBaseVertexBaseInstance_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for
  /// [`glDrawElementsInstancedBaseVertexBaseInstance`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawElementsInstancedBaseVertexBaseInstance_is_loaded() -> bool {
    !glDrawElementsInstancedBaseVertexBaseInstance_p.load(RELAX).is_null()
  }

  /// [glDrawRangeElements](http://docs.gl/gl4/glDrawRangeElements)(mode, start, end, count, type_, indices)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(count,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawRangeElements(
    mode: GLenum,
    start: GLuint,
    end: GLuint,
    count: GLsizei,
    type_: GLenum,
    indices: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawRangeElements({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p});",
        mode,
        start,
        end,
        count,
        type_,
        indices
      );
    }
    let p = glDrawRangeElements_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLuint,
          GLuint,
          GLsizei,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(mode, start, end, count, type_, indices),
      None => go_panic_because_fn_not_loaded("glDrawRangeElements"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawRangeElements" != "glGetError" {
        report_error_as_necessary_from("glDrawRangeElements", glGetError());
      }
    }
    out
  }
  static glDrawRangeElements_p: APcv = ap_null();
  /// Tries to load [`glDrawRangeElements`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawRangeElements_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawRangeElements\0");
    glDrawRangeElements_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawRangeElements`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawRangeElements_is_loaded() -> bool {
    !glDrawRangeElements_p.load(RELAX).is_null()
  }

  /// [glDrawRangeElementsBaseVertex](http://docs.gl/gl4/glDrawRangeElementsBaseVertex)(mode, start, end, count, type_, indices, basevertex)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(count,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawRangeElementsBaseVertex(
    mode: GLenum,
    start: GLuint,
    end: GLuint,
    count: GLsizei,
    type_: GLenum,
    indices: *const c_void,
    basevertex: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawRangeElementsBaseVertex({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p}, {:?});", mode, start, end, count, type_, indices, basevertex);
    }
    let p = glDrawRangeElementsBaseVertex_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLuint,
          GLuint,
          GLsizei,
          GLenum,
          *const c_void,
          GLint,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(mode, start, end, count, type_, indices, basevertex),
      None => go_panic_because_fn_not_loaded("glDrawRangeElementsBaseVertex"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawRangeElementsBaseVertex" != "glGetError" {
        report_error_as_necessary_from(
          "glDrawRangeElementsBaseVertex",
          glGetError(),
        );
      }
    }
    out
  }
  static glDrawRangeElementsBaseVertex_p: APcv = ap_null();
  /// Tries to load [`glDrawRangeElementsBaseVertex`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawRangeElementsBaseVertex_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawRangeElementsBaseVertex\0");
    glDrawRangeElementsBaseVertex_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawRangeElementsBaseVertex`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawRangeElementsBaseVertex_is_loaded() -> bool {
    !glDrawRangeElementsBaseVertex_p.load(RELAX).is_null()
  }

  /// [glDrawTransformFeedback](http://docs.gl/gl4/glDrawTransformFeedback)(mode, id)
  /// * `mode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawTransformFeedback(mode: GLenum, id: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawTransformFeedback({:#X}, {:?});", mode, id);
    }
    let p = glDrawTransformFeedback_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(mode, id),
      None => go_panic_because_fn_not_loaded("glDrawTransformFeedback"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawTransformFeedback" != "glGetError" {
        report_error_as_necessary_from("glDrawTransformFeedback", glGetError());
      }
    }
    out
  }
  static glDrawTransformFeedback_p: APcv = ap_null();
  /// Tries to load [`glDrawTransformFeedback`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawTransformFeedback_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawTransformFeedback\0");
    glDrawTransformFeedback_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawTransformFeedback`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawTransformFeedback_is_loaded() -> bool {
    !glDrawTransformFeedback_p.load(RELAX).is_null()
  }

  /// [glDrawTransformFeedbackInstanced](http://docs.gl/gl4/glDrawTransformFeedbackInstanced)(mode, id, instancecount)
  /// * `mode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawTransformFeedbackInstanced(
    mode: GLenum,
    id: GLuint,
    instancecount: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawTransformFeedbackInstanced({:#X}, {:?}, {:?});",
        mode,
        id,
        instancecount
      );
    }
    let p = glDrawTransformFeedbackInstanced_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint, GLsizei)>>(p) {
      Some(fn_p) => fn_p(mode, id, instancecount),
      None => {
        go_panic_because_fn_not_loaded("glDrawTransformFeedbackInstanced")
      }
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawTransformFeedbackInstanced" != "glGetError" {
        report_error_as_necessary_from(
          "glDrawTransformFeedbackInstanced",
          glGetError(),
        );
      }
    }
    out
  }
  static glDrawTransformFeedbackInstanced_p: APcv = ap_null();
  /// Tries to load [`glDrawTransformFeedbackInstanced`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawTransformFeedbackInstanced_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glDrawTransformFeedbackInstanced\0");
    glDrawTransformFeedbackInstanced_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawTransformFeedbackInstanced`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawTransformFeedbackInstanced_is_loaded() -> bool {
    !glDrawTransformFeedbackInstanced_p.load(RELAX).is_null()
  }

  /// [glDrawTransformFeedbackStream](http://docs.gl/gl4/glDrawTransformFeedbackStream)(mode, id, stream)
  /// * `mode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawTransformFeedbackStream(
    mode: GLenum,
    id: GLuint,
    stream: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glDrawTransformFeedbackStream({:#X}, {:?}, {:?});",
        mode,
        id,
        stream
      );
    }
    let p = glDrawTransformFeedbackStream_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(mode, id, stream),
      None => go_panic_because_fn_not_loaded("glDrawTransformFeedbackStream"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawTransformFeedbackStream" != "glGetError" {
        report_error_as_necessary_from(
          "glDrawTransformFeedbackStream",
          glGetError(),
        );
      }
    }
    out
  }
  static glDrawTransformFeedbackStream_p: APcv = ap_null();
  /// Tries to load [`glDrawTransformFeedbackStream`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawTransformFeedbackStream_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glDrawTransformFeedbackStream\0");
    glDrawTransformFeedbackStream_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawTransformFeedbackStream`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawTransformFeedbackStream_is_loaded() -> bool {
    !glDrawTransformFeedbackStream_p.load(RELAX).is_null()
  }

  /// [glDrawTransformFeedbackStreamInstanced](http://docs.gl/gl4/glDrawTransformFeedbackStreamInstanced)(mode, id, stream, instancecount)
  /// * `mode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glDrawTransformFeedbackStreamInstanced(
    mode: GLenum,
    id: GLuint,
    stream: GLuint,
    instancecount: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glDrawTransformFeedbackStreamInstanced({:#X}, {:?}, {:?}, {:?});", mode, id, stream, instancecount);
    }
    let p = glDrawTransformFeedbackStreamInstanced_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLuint, GLuint, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(mode, id, stream, instancecount),
      None => {
        go_panic_because_fn_not_loaded("glDrawTransformFeedbackStreamInstanced")
      }
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glDrawTransformFeedbackStreamInstanced" != "glGetError" {
        report_error_as_necessary_from(
          "glDrawTransformFeedbackStreamInstanced",
          glGetError(),
        );
      }
    }
    out
  }
  static glDrawTransformFeedbackStreamInstanced_p: APcv = ap_null();
  /// Tries to load [`glDrawTransformFeedbackStreamInstanced`], returns if a
  /// non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glDrawTransformFeedbackStreamInstanced_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(
      get_proc_address,
      b"glDrawTransformFeedbackStreamInstanced\0",
    );
    glDrawTransformFeedbackStreamInstanced_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glDrawTransformFeedbackStreamInstanced`] is
  /// loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glDrawTransformFeedbackStreamInstanced_is_loaded() -> bool {
    !glDrawTransformFeedbackStreamInstanced_p.load(RELAX).is_null()
  }

  /// [glEnable](http://docs.gl/gl4/glEnable)(cap)
  /// * `cap` group: EnableCap
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEnable(cap: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEnable({:#X});", cap);
    }
    let p = glEnable_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(cap),
      None => go_panic_because_fn_not_loaded("glEnable"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glEnable" != "glGetError" {
        report_error_as_necessary_from("glEnable", glGetError());
      }
    }
    out
  }
  static glEnable_p: APcv = ap_null();
  /// Tries to load [`glEnable`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glEnable_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glEnable\0");
    glEnable_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glEnable`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEnable_is_loaded() -> bool {
    !glEnable_p.load(RELAX).is_null()
  }

  /// [glEnableVertexArrayAttrib](http://docs.gl/gl4/glEnableVertexArrayAttrib)(vaobj, index)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEnableVertexArrayAttrib(vaobj: GLuint, index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEnableVertexArrayAttrib({:?}, {:?});", vaobj, index);
    }
    let p = glEnableVertexArrayAttrib_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(vaobj, index),
      None => go_panic_because_fn_not_loaded("glEnableVertexArrayAttrib"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glEnableVertexArrayAttrib" != "glGetError" {
        report_error_as_necessary_from(
          "glEnableVertexArrayAttrib",
          glGetError(),
        );
      }
    }
    out
  }
  static glEnableVertexArrayAttrib_p: APcv = ap_null();
  /// Tries to load [`glEnableVertexArrayAttrib`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glEnableVertexArrayAttrib_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glEnableVertexArrayAttrib\0");
    glEnableVertexArrayAttrib_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glEnableVertexArrayAttrib`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEnableVertexArrayAttrib_is_loaded() -> bool {
    !glEnableVertexArrayAttrib_p.load(RELAX).is_null()
  }

  /// [glEnableVertexAttribArray](http://docs.gl/gl4/glEnableVertexAttribArray)(index)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEnableVertexAttribArray(index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEnableVertexAttribArray({:?});", index);
    }
    let p = glEnableVertexAttribArray_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(index),
      None => go_panic_because_fn_not_loaded("glEnableVertexAttribArray"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glEnableVertexAttribArray" != "glGetError" {
        report_error_as_necessary_from(
          "glEnableVertexAttribArray",
          glGetError(),
        );
      }
    }
    out
  }
  static glEnableVertexAttribArray_p: APcv = ap_null();
  /// Tries to load [`glEnableVertexAttribArray`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glEnableVertexAttribArray_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glEnableVertexAttribArray\0");
    glEnableVertexAttribArray_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glEnableVertexAttribArray`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEnableVertexAttribArray_is_loaded() -> bool {
    !glEnableVertexAttribArray_p.load(RELAX).is_null()
  }

  /// [glEnablei](http://docs.gl/gl4/glEnablei)(target, index)
  /// * `target` group: EnableCap
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEnablei(target: GLenum, index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEnablei({:#X}, {:?});", target, index);
    }
    let p = glEnablei_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(target, index),
      None => go_panic_because_fn_not_loaded("glEnablei"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glEnablei" != "glGetError" {
        report_error_as_necessary_from("glEnablei", glGetError());
      }
    }
    out
  }
  static glEnablei_p: APcv = ap_null();
  /// Tries to load [`glEnablei`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glEnablei_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glEnablei\0");
    glEnablei_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glEnablei`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEnablei_is_loaded() -> bool {
    !glEnablei_p.load(RELAX).is_null()
  }

  /// [glEndConditionalRender](http://docs.gl/gl4/glEndConditionalRender)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEndConditionalRender() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEndConditionalRender();",);
    }
    let p = glEndConditionalRender_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn()>>(p) {
      Some(fn_p) => fn_p(),
      None => go_panic_because_fn_not_loaded("glEndConditionalRender"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glEndConditionalRender" != "glGetError" {
        report_error_as_necessary_from("glEndConditionalRender", glGetError());
      }
    }
    out
  }
  static glEndConditionalRender_p: APcv = ap_null();
  /// Tries to load [`glEndConditionalRender`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glEndConditionalRender_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glEndConditionalRender\0");
    glEndConditionalRender_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glEndConditionalRender`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEndConditionalRender_is_loaded() -> bool {
    !glEndConditionalRender_p.load(RELAX).is_null()
  }

  /// [glEndQuery](http://docs.gl/gl4/glEndQuery)(target)
  /// * `target` group: QueryTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEndQuery(target: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEndQuery({:#X});", target);
    }
    let p = glEndQuery_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(target),
      None => go_panic_because_fn_not_loaded("glEndQuery"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glEndQuery" != "glGetError" {
        report_error_as_necessary_from("glEndQuery", glGetError());
      }
    }
    out
  }
  static glEndQuery_p: APcv = ap_null();
  /// Tries to load [`glEndQuery`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glEndQuery_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glEndQuery\0");
    glEndQuery_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glEndQuery`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEndQuery_is_loaded() -> bool {
    !glEndQuery_p.load(RELAX).is_null()
  }

  /// [glEndQueryIndexed](http://docs.gl/gl4/glEndQueryIndexed)(target, index)
  /// * `target` group: QueryTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEndQueryIndexed(target: GLenum, index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEndQueryIndexed({:#X}, {:?});", target, index);
    }
    let p = glEndQueryIndexed_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(target, index),
      None => go_panic_because_fn_not_loaded("glEndQueryIndexed"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glEndQueryIndexed" != "glGetError" {
        report_error_as_necessary_from("glEndQueryIndexed", glGetError());
      }
    }
    out
  }
  static glEndQueryIndexed_p: APcv = ap_null();
  /// Tries to load [`glEndQueryIndexed`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glEndQueryIndexed_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glEndQueryIndexed\0");
    glEndQueryIndexed_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glEndQueryIndexed`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEndQueryIndexed_is_loaded() -> bool {
    !glEndQueryIndexed_p.load(RELAX).is_null()
  }

  /// [glEndTransformFeedback](http://docs.gl/gl4/glEndTransformFeedback)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glEndTransformFeedback() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glEndTransformFeedback();",);
    }
    let p = glEndTransformFeedback_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn()>>(p) {
      Some(fn_p) => fn_p(),
      None => go_panic_because_fn_not_loaded("glEndTransformFeedback"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glEndTransformFeedback" != "glGetError" {
        report_error_as_necessary_from("glEndTransformFeedback", glGetError());
      }
    }
    out
  }
  static glEndTransformFeedback_p: APcv = ap_null();
  /// Tries to load [`glEndTransformFeedback`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glEndTransformFeedback_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glEndTransformFeedback\0");
    glEndTransformFeedback_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glEndTransformFeedback`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glEndTransformFeedback_is_loaded() -> bool {
    !glEndTransformFeedback_p.load(RELAX).is_null()
  }

  /// [glFenceSync](http://docs.gl/gl4/glFenceSync)(condition, flags)
  /// * `condition` group: SyncCondition
  /// * return value group: sync
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFenceSync(condition: GLenum, flags: GLbitfield) -> GLsync {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glFenceSync({:#X}, {:?});", condition, flags);
    }
    let p = glFenceSync_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLbitfield) -> GLsync>>(p) {
        Some(fn_p) => fn_p(condition, flags),
        None => go_panic_because_fn_not_loaded("glFenceSync"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFenceSync" != "glGetError" {
        report_error_as_necessary_from("glFenceSync", glGetError());
      }
    }
    out
  }
  static glFenceSync_p: APcv = ap_null();
  /// Tries to load [`glFenceSync`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFenceSync_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glFenceSync\0");
    glFenceSync_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFenceSync`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFenceSync_is_loaded() -> bool {
    !glFenceSync_p.load(RELAX).is_null()
  }

  /// [glFinish](http://docs.gl/gl4/glFinish)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFinish() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glFinish();",);
    }
    let p = glFinish_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn()>>(p) {
      Some(fn_p) => fn_p(),
      None => go_panic_because_fn_not_loaded("glFinish"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFinish" != "glGetError" {
        report_error_as_necessary_from("glFinish", glGetError());
      }
    }
    out
  }
  static glFinish_p: APcv = ap_null();
  /// Tries to load [`glFinish`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFinish_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glFinish\0");
    glFinish_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFinish`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFinish_is_loaded() -> bool {
    !glFinish_p.load(RELAX).is_null()
  }

  /// [glFlush](http://docs.gl/gl4/glFlush)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFlush() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glFlush();",);
    }
    let p = glFlush_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn()>>(p) {
      Some(fn_p) => fn_p(),
      None => go_panic_because_fn_not_loaded("glFlush"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFlush" != "glGetError" {
        report_error_as_necessary_from("glFlush", glGetError());
      }
    }
    out
  }
  static glFlush_p: APcv = ap_null();
  /// Tries to load [`glFlush`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFlush_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glFlush\0");
    glFlush_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFlush`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFlush_is_loaded() -> bool {
    !glFlush_p.load(RELAX).is_null()
  }

  /// [glFlushMappedBufferRange](http://docs.gl/gl4/glFlushMappedBufferRange)(target, offset, length)
  /// * `target` group: BufferTargetARB
  /// * `offset` group: BufferOffset
  /// * `length` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFlushMappedBufferRange(
    target: GLenum,
    offset: GLintptr,
    length: GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFlushMappedBufferRange({:#X}, {:?}, {:?});",
        target,
        offset,
        length
      );
    }
    let p = glFlushMappedBufferRange_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLintptr, GLsizeiptr)>>(p) {
        Some(fn_p) => fn_p(target, offset, length),
        None => go_panic_because_fn_not_loaded("glFlushMappedBufferRange"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFlushMappedBufferRange" != "glGetError" {
        report_error_as_necessary_from(
          "glFlushMappedBufferRange",
          glGetError(),
        );
      }
    }
    out
  }
  static glFlushMappedBufferRange_p: APcv = ap_null();
  /// Tries to load [`glFlushMappedBufferRange`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFlushMappedBufferRange_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glFlushMappedBufferRange\0");
    glFlushMappedBufferRange_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFlushMappedBufferRange`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFlushMappedBufferRange_is_loaded() -> bool {
    !glFlushMappedBufferRange_p.load(RELAX).is_null()
  }

  /// [glFlushMappedNamedBufferRange](http://docs.gl/gl4/glFlushMappedNamedBufferRange)(buffer, offset, length)
  /// * `length` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFlushMappedNamedBufferRange(
    buffer: GLuint,
    offset: GLintptr,
    length: GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFlushMappedNamedBufferRange({:?}, {:?}, {:?});",
        buffer,
        offset,
        length
      );
    }
    let p = glFlushMappedNamedBufferRange_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLintptr, GLsizeiptr)>>(p) {
        Some(fn_p) => fn_p(buffer, offset, length),
        None => go_panic_because_fn_not_loaded("glFlushMappedNamedBufferRange"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFlushMappedNamedBufferRange" != "glGetError" {
        report_error_as_necessary_from(
          "glFlushMappedNamedBufferRange",
          glGetError(),
        );
      }
    }
    out
  }
  static glFlushMappedNamedBufferRange_p: APcv = ap_null();
  /// Tries to load [`glFlushMappedNamedBufferRange`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFlushMappedNamedBufferRange_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glFlushMappedNamedBufferRange\0");
    glFlushMappedNamedBufferRange_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFlushMappedNamedBufferRange`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFlushMappedNamedBufferRange_is_loaded() -> bool {
    !glFlushMappedNamedBufferRange_p.load(RELAX).is_null()
  }

  /// [glFramebufferParameteri](http://docs.gl/gl4/glFramebufferParameteri)(target, pname, param)
  /// * `target` group: FramebufferTarget
  /// * `pname` group: FramebufferParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferParameteri(
    target: GLenum,
    pname: GLenum,
    param: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFramebufferParameteri({:#X}, {:#X}, {:?});",
        target,
        pname,
        param
      );
    }
    let p = glFramebufferParameteri_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLenum, GLint)>>(p) {
      Some(fn_p) => fn_p(target, pname, param),
      None => go_panic_because_fn_not_loaded("glFramebufferParameteri"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFramebufferParameteri" != "glGetError" {
        report_error_as_necessary_from("glFramebufferParameteri", glGetError());
      }
    }
    out
  }
  static glFramebufferParameteri_p: APcv = ap_null();
  /// Tries to load [`glFramebufferParameteri`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFramebufferParameteri_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glFramebufferParameteri\0");
    glFramebufferParameteri_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFramebufferParameteri`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferParameteri_is_loaded() -> bool {
    !glFramebufferParameteri_p.load(RELAX).is_null()
  }

  /// [glFramebufferRenderbuffer](http://docs.gl/gl4/glFramebufferRenderbuffer)(target, attachment, renderbuffertarget, renderbuffer)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  /// * `renderbuffertarget` group: RenderbufferTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferRenderbuffer(
    target: GLenum,
    attachment: GLenum,
    renderbuffertarget: GLenum,
    renderbuffer: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFramebufferRenderbuffer({:#X}, {:#X}, {:#X}, {:?});",
        target,
        attachment,
        renderbuffertarget,
        renderbuffer
      );
    }
    let p = glFramebufferRenderbuffer_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, GLenum, GLuint)>>(p) {
        Some(fn_p) => {
          fn_p(target, attachment, renderbuffertarget, renderbuffer)
        }
        None => go_panic_because_fn_not_loaded("glFramebufferRenderbuffer"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFramebufferRenderbuffer" != "glGetError" {
        report_error_as_necessary_from(
          "glFramebufferRenderbuffer",
          glGetError(),
        );
      }
    }
    out
  }
  static glFramebufferRenderbuffer_p: APcv = ap_null();
  /// Tries to load [`glFramebufferRenderbuffer`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFramebufferRenderbuffer_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glFramebufferRenderbuffer\0");
    glFramebufferRenderbuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFramebufferRenderbuffer`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferRenderbuffer_is_loaded() -> bool {
    !glFramebufferRenderbuffer_p.load(RELAX).is_null()
  }

  /// [glFramebufferTexture](http://docs.gl/gl4/glFramebufferTexture)(target, attachment, texture, level)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferTexture(
    target: GLenum,
    attachment: GLenum,
    texture: GLuint,
    level: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFramebufferTexture({:#X}, {:#X}, {:?}, {:?});",
        target,
        attachment,
        texture,
        level
      );
    }
    let p = glFramebufferTexture_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, GLuint, GLint)>>(p) {
        Some(fn_p) => fn_p(target, attachment, texture, level),
        None => go_panic_because_fn_not_loaded("glFramebufferTexture"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFramebufferTexture" != "glGetError" {
        report_error_as_necessary_from("glFramebufferTexture", glGetError());
      }
    }
    out
  }
  static glFramebufferTexture_p: APcv = ap_null();
  /// Tries to load [`glFramebufferTexture`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFramebufferTexture_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glFramebufferTexture\0");
    glFramebufferTexture_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFramebufferTexture`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferTexture_is_loaded() -> bool {
    !glFramebufferTexture_p.load(RELAX).is_null()
  }

  /// [glFramebufferTexture1D](http://docs.gl/gl4/glFramebufferTexture1D)(target, attachment, textarget, texture, level)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  /// * `textarget` group: TextureTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferTexture1D(
    target: GLenum,
    attachment: GLenum,
    textarget: GLenum,
    texture: GLuint,
    level: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFramebufferTexture1D({:#X}, {:#X}, {:#X}, {:?}, {:?});",
        target,
        attachment,
        textarget,
        texture,
        level
      );
    }
    let p = glFramebufferTexture1D_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, attachment, textarget, texture, level),
      None => go_panic_because_fn_not_loaded("glFramebufferTexture1D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFramebufferTexture1D" != "glGetError" {
        report_error_as_necessary_from("glFramebufferTexture1D", glGetError());
      }
    }
    out
  }
  static glFramebufferTexture1D_p: APcv = ap_null();
  /// Tries to load [`glFramebufferTexture1D`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFramebufferTexture1D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glFramebufferTexture1D\0");
    glFramebufferTexture1D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFramebufferTexture1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferTexture1D_is_loaded() -> bool {
    !glFramebufferTexture1D_p.load(RELAX).is_null()
  }

  /// [glFramebufferTexture2D](http://docs.gl/gl4/glFramebufferTexture2D)(target, attachment, textarget, texture, level)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  /// * `textarget` group: TextureTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferTexture2D(
    target: GLenum,
    attachment: GLenum,
    textarget: GLenum,
    texture: GLuint,
    level: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFramebufferTexture2D({:#X}, {:#X}, {:#X}, {:?}, {:?});",
        target,
        attachment,
        textarget,
        texture,
        level
      );
    }
    let p = glFramebufferTexture2D_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, attachment, textarget, texture, level),
      None => go_panic_because_fn_not_loaded("glFramebufferTexture2D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFramebufferTexture2D" != "glGetError" {
        report_error_as_necessary_from("glFramebufferTexture2D", glGetError());
      }
    }
    out
  }
  static glFramebufferTexture2D_p: APcv = ap_null();
  /// Tries to load [`glFramebufferTexture2D`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFramebufferTexture2D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glFramebufferTexture2D\0");
    glFramebufferTexture2D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFramebufferTexture2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferTexture2D_is_loaded() -> bool {
    !glFramebufferTexture2D_p.load(RELAX).is_null()
  }

  /// [glFramebufferTexture3D](http://docs.gl/gl4/glFramebufferTexture3D)(target, attachment, textarget, texture, level, zoffset)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  /// * `textarget` group: TextureTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferTexture3D(
    target: GLenum,
    attachment: GLenum,
    textarget: GLenum,
    texture: GLuint,
    level: GLint,
    zoffset: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glFramebufferTexture3D({:#X}, {:#X}, {:#X}, {:?}, {:?}, {:?});", target, attachment, textarget, texture, level, zoffset);
    }
    let p = glFramebufferTexture3D_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint, GLint)>,
    >(p)
    {
      Some(fn_p) => {
        fn_p(target, attachment, textarget, texture, level, zoffset)
      }
      None => go_panic_because_fn_not_loaded("glFramebufferTexture3D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFramebufferTexture3D" != "glGetError" {
        report_error_as_necessary_from("glFramebufferTexture3D", glGetError());
      }
    }
    out
  }
  static glFramebufferTexture3D_p: APcv = ap_null();
  /// Tries to load [`glFramebufferTexture3D`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFramebufferTexture3D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glFramebufferTexture3D\0");
    glFramebufferTexture3D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFramebufferTexture3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferTexture3D_is_loaded() -> bool {
    !glFramebufferTexture3D_p.load(RELAX).is_null()
  }

  /// [glFramebufferTextureLayer](http://docs.gl/gl4/glFramebufferTextureLayer)(target, attachment, texture, level, layer)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  /// * `texture` group: Texture
  /// * `level` group: CheckedInt32
  /// * `layer` group: CheckedInt32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFramebufferTextureLayer(
    target: GLenum,
    attachment: GLenum,
    texture: GLuint,
    level: GLint,
    layer: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glFramebufferTextureLayer({:#X}, {:#X}, {:?}, {:?}, {:?});",
        target,
        attachment,
        texture,
        level,
        layer
      );
    }
    let p = glFramebufferTextureLayer_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLenum, GLuint, GLint, GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, attachment, texture, level, layer),
      None => go_panic_because_fn_not_loaded("glFramebufferTextureLayer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFramebufferTextureLayer" != "glGetError" {
        report_error_as_necessary_from(
          "glFramebufferTextureLayer",
          glGetError(),
        );
      }
    }
    out
  }
  static glFramebufferTextureLayer_p: APcv = ap_null();
  /// Tries to load [`glFramebufferTextureLayer`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFramebufferTextureLayer_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glFramebufferTextureLayer\0");
    glFramebufferTextureLayer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFramebufferTextureLayer`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFramebufferTextureLayer_is_loaded() -> bool {
    !glFramebufferTextureLayer_p.load(RELAX).is_null()
  }

  /// [glFrontFace](http://docs.gl/gl4/glFrontFace)(mode)
  /// * `mode` group: FrontFaceDirection
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glFrontFace(mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glFrontFace({:#X});", mode);
    }
    let p = glFrontFace_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(mode),
      None => go_panic_because_fn_not_loaded("glFrontFace"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glFrontFace" != "glGetError" {
        report_error_as_necessary_from("glFrontFace", glGetError());
      }
    }
    out
  }
  static glFrontFace_p: APcv = ap_null();
  /// Tries to load [`glFrontFace`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glFrontFace_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glFrontFace\0");
    glFrontFace_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glFrontFace`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glFrontFace_is_loaded() -> bool {
    !glFrontFace_p.load(RELAX).is_null()
  }

  /// [glGenBuffers](http://docs.gl/gl4/glGenBuffers)(n, buffers)
  /// * `buffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenBuffers(n: GLsizei, buffers: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenBuffers({:?}, {:p});", n, buffers);
    }
    let p = glGenBuffers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, buffers),
      None => go_panic_because_fn_not_loaded("glGenBuffers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGenBuffers" != "glGetError" {
        report_error_as_necessary_from("glGenBuffers", glGetError());
      }
    }
    out
  }
  static glGenBuffers_p: APcv = ap_null();
  /// Tries to load [`glGenBuffers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGenBuffers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGenBuffers\0");
    glGenBuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGenBuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenBuffers_is_loaded() -> bool {
    !glGenBuffers_p.load(RELAX).is_null()
  }

  /// [glGenFramebuffers](http://docs.gl/gl4/glGenFramebuffers)(n, framebuffers)
  /// * `framebuffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenFramebuffers(n: GLsizei, framebuffers: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenFramebuffers({:?}, {:p});", n, framebuffers);
    }
    let p = glGenFramebuffers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, framebuffers),
      None => go_panic_because_fn_not_loaded("glGenFramebuffers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGenFramebuffers" != "glGetError" {
        report_error_as_necessary_from("glGenFramebuffers", glGetError());
      }
    }
    out
  }
  static glGenFramebuffers_p: APcv = ap_null();
  /// Tries to load [`glGenFramebuffers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGenFramebuffers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGenFramebuffers\0");
    glGenFramebuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGenFramebuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenFramebuffers_is_loaded() -> bool {
    !glGenFramebuffers_p.load(RELAX).is_null()
  }

  /// [glGenProgramPipelines](http://docs.gl/gl4/glGenProgramPipelines)(n, pipelines)
  /// * `pipelines` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenProgramPipelines(n: GLsizei, pipelines: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenProgramPipelines({:?}, {:p});", n, pipelines);
    }
    let p = glGenProgramPipelines_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, pipelines),
      None => go_panic_because_fn_not_loaded("glGenProgramPipelines"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGenProgramPipelines" != "glGetError" {
        report_error_as_necessary_from("glGenProgramPipelines", glGetError());
      }
    }
    out
  }
  static glGenProgramPipelines_p: APcv = ap_null();
  /// Tries to load [`glGenProgramPipelines`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGenProgramPipelines_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGenProgramPipelines\0");
    glGenProgramPipelines_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGenProgramPipelines`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenProgramPipelines_is_loaded() -> bool {
    !glGenProgramPipelines_p.load(RELAX).is_null()
  }

  /// [glGenQueries](http://docs.gl/gl4/glGenQueries)(n, ids)
  /// * `ids` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenQueries(n: GLsizei, ids: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenQueries({:?}, {:p});", n, ids);
    }
    let p = glGenQueries_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, ids),
      None => go_panic_because_fn_not_loaded("glGenQueries"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGenQueries" != "glGetError" {
        report_error_as_necessary_from("glGenQueries", glGetError());
      }
    }
    out
  }
  static glGenQueries_p: APcv = ap_null();
  /// Tries to load [`glGenQueries`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGenQueries_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGenQueries\0");
    glGenQueries_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGenQueries`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenQueries_is_loaded() -> bool {
    !glGenQueries_p.load(RELAX).is_null()
  }

  /// [glGenRenderbuffers](http://docs.gl/gl4/glGenRenderbuffers)(n, renderbuffers)
  /// * `renderbuffers` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenRenderbuffers(n: GLsizei, renderbuffers: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenRenderbuffers({:?}, {:p});", n, renderbuffers);
    }
    let p = glGenRenderbuffers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, renderbuffers),
      None => go_panic_because_fn_not_loaded("glGenRenderbuffers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGenRenderbuffers" != "glGetError" {
        report_error_as_necessary_from("glGenRenderbuffers", glGetError());
      }
    }
    out
  }
  static glGenRenderbuffers_p: APcv = ap_null();
  /// Tries to load [`glGenRenderbuffers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGenRenderbuffers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGenRenderbuffers\0");
    glGenRenderbuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGenRenderbuffers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenRenderbuffers_is_loaded() -> bool {
    !glGenRenderbuffers_p.load(RELAX).is_null()
  }

  /// [glGenSamplers](http://docs.gl/gl4/glGenSamplers)(count, samplers)
  /// * `samplers` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenSamplers(count: GLsizei, samplers: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenSamplers({:?}, {:p});", count, samplers);
    }
    let p = glGenSamplers_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(count, samplers),
      None => go_panic_because_fn_not_loaded("glGenSamplers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGenSamplers" != "glGetError" {
        report_error_as_necessary_from("glGenSamplers", glGetError());
      }
    }
    out
  }
  static glGenSamplers_p: APcv = ap_null();
  /// Tries to load [`glGenSamplers`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGenSamplers_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGenSamplers\0");
    glGenSamplers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGenSamplers`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenSamplers_is_loaded() -> bool {
    !glGenSamplers_p.load(RELAX).is_null()
  }

  /// [glGenTextures](http://docs.gl/gl4/glGenTextures)(n, textures)
  /// * `textures` group: Texture
  /// * `textures` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenTextures(n: GLsizei, textures: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenTextures({:?}, {:p});", n, textures);
    }
    let p = glGenTextures_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, textures),
      None => go_panic_because_fn_not_loaded("glGenTextures"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGenTextures" != "glGetError" {
        report_error_as_necessary_from("glGenTextures", glGetError());
      }
    }
    out
  }
  static glGenTextures_p: APcv = ap_null();
  /// Tries to load [`glGenTextures`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGenTextures_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGenTextures\0");
    glGenTextures_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGenTextures`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenTextures_is_loaded() -> bool {
    !glGenTextures_p.load(RELAX).is_null()
  }

  /// [glGenTransformFeedbacks](http://docs.gl/gl4/glGenTransformFeedbacks)(n, ids)
  /// * `ids` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenTransformFeedbacks(n: GLsizei, ids: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenTransformFeedbacks({:?}, {:p});", n, ids);
    }
    let p = glGenTransformFeedbacks_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, ids),
      None => go_panic_because_fn_not_loaded("glGenTransformFeedbacks"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGenTransformFeedbacks" != "glGetError" {
        report_error_as_necessary_from("glGenTransformFeedbacks", glGetError());
      }
    }
    out
  }
  static glGenTransformFeedbacks_p: APcv = ap_null();
  /// Tries to load [`glGenTransformFeedbacks`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGenTransformFeedbacks_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGenTransformFeedbacks\0");
    glGenTransformFeedbacks_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGenTransformFeedbacks`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenTransformFeedbacks_is_loaded() -> bool {
    !glGenTransformFeedbacks_p.load(RELAX).is_null()
  }

  /// [glGenVertexArrays](http://docs.gl/gl4/glGenVertexArrays)(n, arrays)
  /// * `arrays` len: n
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenVertexArrays(n: GLsizei, arrays: *mut GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenVertexArrays({:?}, {:p});", n, arrays);
    }
    let p = glGenVertexArrays_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
      Some(fn_p) => fn_p(n, arrays),
      None => go_panic_because_fn_not_loaded("glGenVertexArrays"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGenVertexArrays" != "glGetError" {
        report_error_as_necessary_from("glGenVertexArrays", glGetError());
      }
    }
    out
  }
  static glGenVertexArrays_p: APcv = ap_null();
  /// Tries to load [`glGenVertexArrays`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGenVertexArrays_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGenVertexArrays\0");
    glGenVertexArrays_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGenVertexArrays`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenVertexArrays_is_loaded() -> bool {
    !glGenVertexArrays_p.load(RELAX).is_null()
  }

  /// [glGenerateMipmap](http://docs.gl/gl4/glGenerateMipmap)(target)
  /// * `target` group: TextureTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenerateMipmap(target: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenerateMipmap({:#X});", target);
    }
    let p = glGenerateMipmap_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(target),
      None => go_panic_because_fn_not_loaded("glGenerateMipmap"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGenerateMipmap" != "glGetError" {
        report_error_as_necessary_from("glGenerateMipmap", glGetError());
      }
    }
    out
  }
  static glGenerateMipmap_p: APcv = ap_null();
  /// Tries to load [`glGenerateMipmap`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGenerateMipmap_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGenerateMipmap\0");
    glGenerateMipmap_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGenerateMipmap`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenerateMipmap_is_loaded() -> bool {
    !glGenerateMipmap_p.load(RELAX).is_null()
  }

  /// [glGenerateTextureMipmap](http://docs.gl/gl4/glGenerateTextureMipmap)(texture)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGenerateTextureMipmap(texture: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGenerateTextureMipmap({:?});", texture);
    }
    let p = glGenerateTextureMipmap_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(texture),
      None => go_panic_because_fn_not_loaded("glGenerateTextureMipmap"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGenerateTextureMipmap" != "glGetError" {
        report_error_as_necessary_from("glGenerateTextureMipmap", glGetError());
      }
    }
    out
  }
  static glGenerateTextureMipmap_p: APcv = ap_null();
  /// Tries to load [`glGenerateTextureMipmap`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGenerateTextureMipmap_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGenerateTextureMipmap\0");
    glGenerateTextureMipmap_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGenerateTextureMipmap`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGenerateTextureMipmap_is_loaded() -> bool {
    !glGenerateTextureMipmap_p.load(RELAX).is_null()
  }

  /// [glGetActiveAtomicCounterBufferiv](http://docs.gl/gl4/glGetActiveAtomicCounterBufferiv)(program, bufferIndex, pname, params)
  /// * `pname` group: AtomicCounterBufferPName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveAtomicCounterBufferiv(
    program: GLuint,
    bufferIndex: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveAtomicCounterBufferiv({:?}, {:?}, {:#X}, {:p});",
        program,
        bufferIndex,
        pname,
        params
      );
    }
    let p = glGetActiveAtomicCounterBufferiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLuint, GLenum, *mut GLint)>>(
        p,
      ) {
        Some(fn_p) => fn_p(program, bufferIndex, pname, params),
        None => {
          go_panic_because_fn_not_loaded("glGetActiveAtomicCounterBufferiv")
        }
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetActiveAtomicCounterBufferiv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetActiveAtomicCounterBufferiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetActiveAtomicCounterBufferiv_p: APcv = ap_null();
  /// Tries to load [`glGetActiveAtomicCounterBufferiv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetActiveAtomicCounterBufferiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glGetActiveAtomicCounterBufferiv\0");
    glGetActiveAtomicCounterBufferiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetActiveAtomicCounterBufferiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveAtomicCounterBufferiv_is_loaded() -> bool {
    !glGetActiveAtomicCounterBufferiv_p.load(RELAX).is_null()
  }

  /// [glGetActiveAttrib](http://docs.gl/gl4/glGetActiveAttrib)(program, index, bufSize, length, size, type_, name)
  /// * `length` len: 1
  /// * `size` len: 1
  /// * `type_` group: AttributeType
  /// * `type_` len: 1
  /// * `name` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveAttrib(
    program: GLuint,
    index: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    size: *mut GLint,
    type_: *mut GLenum,
    name: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveAttrib({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});",
        program,
        index,
        bufSize,
        length,
        size,
        type_,
        name
      );
    }
    let p = glGetActiveAttrib_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLuint,
          GLsizei,
          *mut GLsizei,
          *mut GLint,
          *mut GLenum,
          *mut GLchar,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(program, index, bufSize, length, size, type_, name),
      None => go_panic_because_fn_not_loaded("glGetActiveAttrib"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetActiveAttrib" != "glGetError" {
        report_error_as_necessary_from("glGetActiveAttrib", glGetError());
      }
    }
    out
  }
  static glGetActiveAttrib_p: APcv = ap_null();
  /// Tries to load [`glGetActiveAttrib`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetActiveAttrib_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetActiveAttrib\0");
    glGetActiveAttrib_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetActiveAttrib`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveAttrib_is_loaded() -> bool {
    !glGetActiveAttrib_p.load(RELAX).is_null()
  }

  /// [glGetActiveSubroutineName](http://docs.gl/gl4/glGetActiveSubroutineName)(program, shadertype, index, bufSize, length, name)
  /// * `shadertype` group: ShaderType
  /// * `length` len: 1
  /// * `name` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveSubroutineName(
    program: GLuint,
    shadertype: GLenum,
    index: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    name: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetActiveSubroutineName({:?}, {:#X}, {:?}, {:?}, {:p}, {:p});", program, shadertype, index, bufSize, length, name);
    }
    let p = glGetActiveSubroutineName_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLenum,
          GLuint,
          GLsizei,
          *mut GLsizei,
          *mut GLchar,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(program, shadertype, index, bufSize, length, name),
      None => go_panic_because_fn_not_loaded("glGetActiveSubroutineName"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetActiveSubroutineName" != "glGetError" {
        report_error_as_necessary_from(
          "glGetActiveSubroutineName",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetActiveSubroutineName_p: APcv = ap_null();
  /// Tries to load [`glGetActiveSubroutineName`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetActiveSubroutineName_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetActiveSubroutineName\0");
    glGetActiveSubroutineName_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetActiveSubroutineName`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveSubroutineName_is_loaded() -> bool {
    !glGetActiveSubroutineName_p.load(RELAX).is_null()
  }

  /// [glGetActiveSubroutineUniformName](http://docs.gl/gl4/glGetActiveSubroutineUniformName)(program, shadertype, index, bufSize, length, name)
  /// * `shadertype` group: ShaderType
  /// * `length` len: 1
  /// * `name` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveSubroutineUniformName(
    program: GLuint,
    shadertype: GLenum,
    index: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    name: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetActiveSubroutineUniformName({:?}, {:#X}, {:?}, {:?}, {:p}, {:p});", program, shadertype, index, bufSize, length, name);
    }
    let p = glGetActiveSubroutineUniformName_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLenum,
          GLuint,
          GLsizei,
          *mut GLsizei,
          *mut GLchar,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(program, shadertype, index, bufSize, length, name),
      None => {
        go_panic_because_fn_not_loaded("glGetActiveSubroutineUniformName")
      }
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetActiveSubroutineUniformName" != "glGetError" {
        report_error_as_necessary_from(
          "glGetActiveSubroutineUniformName",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetActiveSubroutineUniformName_p: APcv = ap_null();
  /// Tries to load [`glGetActiveSubroutineUniformName`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetActiveSubroutineUniformName_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glGetActiveSubroutineUniformName\0");
    glGetActiveSubroutineUniformName_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetActiveSubroutineUniformName`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveSubroutineUniformName_is_loaded() -> bool {
    !glGetActiveSubroutineUniformName_p.load(RELAX).is_null()
  }

  /// [glGetActiveSubroutineUniformiv](http://docs.gl/gl4/glGetActiveSubroutineUniformiv)(program, shadertype, index, pname, values)
  /// * `shadertype` group: ShaderType
  /// * `pname` group: SubroutineParameterName
  /// * `values` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveSubroutineUniformiv(
    program: GLuint,
    shadertype: GLenum,
    index: GLuint,
    pname: GLenum,
    values: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetActiveSubroutineUniformiv({:?}, {:#X}, {:?}, {:#X}, {:p});", program, shadertype, index, pname, values);
    }
    let p = glGetActiveSubroutineUniformiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLuint, GLenum, *mut GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, shadertype, index, pname, values),
      None => go_panic_because_fn_not_loaded("glGetActiveSubroutineUniformiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetActiveSubroutineUniformiv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetActiveSubroutineUniformiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetActiveSubroutineUniformiv_p: APcv = ap_null();
  /// Tries to load [`glGetActiveSubroutineUniformiv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetActiveSubroutineUniformiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetActiveSubroutineUniformiv\0");
    glGetActiveSubroutineUniformiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetActiveSubroutineUniformiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveSubroutineUniformiv_is_loaded() -> bool {
    !glGetActiveSubroutineUniformiv_p.load(RELAX).is_null()
  }

  /// [glGetActiveUniform](http://docs.gl/gl4/glGetActiveUniform)(program, index, bufSize, length, size, type_, name)
  /// * `length` len: 1
  /// * `size` len: 1
  /// * `type_` group: UniformType
  /// * `type_` len: 1
  /// * `name` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveUniform(
    program: GLuint,
    index: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    size: *mut GLint,
    type_: *mut GLenum,
    name: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveUniform({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});",
        program,
        index,
        bufSize,
        length,
        size,
        type_,
        name
      );
    }
    let p = glGetActiveUniform_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLuint,
          GLsizei,
          *mut GLsizei,
          *mut GLint,
          *mut GLenum,
          *mut GLchar,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(program, index, bufSize, length, size, type_, name),
      None => go_panic_because_fn_not_loaded("glGetActiveUniform"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetActiveUniform" != "glGetError" {
        report_error_as_necessary_from("glGetActiveUniform", glGetError());
      }
    }
    out
  }
  static glGetActiveUniform_p: APcv = ap_null();
  /// Tries to load [`glGetActiveUniform`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetActiveUniform_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetActiveUniform\0");
    glGetActiveUniform_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetActiveUniform`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveUniform_is_loaded() -> bool {
    !glGetActiveUniform_p.load(RELAX).is_null()
  }

  /// [glGetActiveUniformBlockName](http://docs.gl/gl4/glGetActiveUniformBlockName)(program, uniformBlockIndex, bufSize, length, uniformBlockName)
  /// * `length` len: 1
  /// * `uniformBlockName` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveUniformBlockName(
    program: GLuint,
    uniformBlockIndex: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    uniformBlockName: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveUniformBlockName({:?}, {:?}, {:?}, {:p}, {:p});",
        program,
        uniformBlockIndex,
        bufSize,
        length,
        uniformBlockName
      );
    }
    let p = glGetActiveUniformBlockName_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLchar)>,
    >(p)
    {
      Some(fn_p) => {
        fn_p(program, uniformBlockIndex, bufSize, length, uniformBlockName)
      }
      None => go_panic_because_fn_not_loaded("glGetActiveUniformBlockName"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetActiveUniformBlockName" != "glGetError" {
        report_error_as_necessary_from(
          "glGetActiveUniformBlockName",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetActiveUniformBlockName_p: APcv = ap_null();
  /// Tries to load [`glGetActiveUniformBlockName`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetActiveUniformBlockName_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetActiveUniformBlockName\0");
    glGetActiveUniformBlockName_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetActiveUniformBlockName`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveUniformBlockName_is_loaded() -> bool {
    !glGetActiveUniformBlockName_p.load(RELAX).is_null()
  }

  /// [glGetActiveUniformBlockiv](http://docs.gl/gl4/glGetActiveUniformBlockiv)(program, uniformBlockIndex, pname, params)
  /// * `pname` group: UniformBlockPName
  /// * `params` len: COMPSIZE(program,uniformBlockIndex,pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveUniformBlockiv(
    program: GLuint,
    uniformBlockIndex: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveUniformBlockiv({:?}, {:?}, {:#X}, {:p});",
        program,
        uniformBlockIndex,
        pname,
        params
      );
    }
    let p = glGetActiveUniformBlockiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLuint, GLenum, *mut GLint)>>(
        p,
      ) {
        Some(fn_p) => fn_p(program, uniformBlockIndex, pname, params),
        None => go_panic_because_fn_not_loaded("glGetActiveUniformBlockiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetActiveUniformBlockiv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetActiveUniformBlockiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetActiveUniformBlockiv_p: APcv = ap_null();
  /// Tries to load [`glGetActiveUniformBlockiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetActiveUniformBlockiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetActiveUniformBlockiv\0");
    glGetActiveUniformBlockiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetActiveUniformBlockiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveUniformBlockiv_is_loaded() -> bool {
    !glGetActiveUniformBlockiv_p.load(RELAX).is_null()
  }

  /// [glGetActiveUniformName](http://docs.gl/gl4/glGetActiveUniformName)(program, uniformIndex, bufSize, length, uniformName)
  /// * `length` len: 1
  /// * `uniformName` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveUniformName(
    program: GLuint,
    uniformIndex: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    uniformName: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveUniformName({:?}, {:?}, {:?}, {:p}, {:p});",
        program,
        uniformIndex,
        bufSize,
        length,
        uniformName
      );
    }
    let p = glGetActiveUniformName_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLchar)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, uniformIndex, bufSize, length, uniformName),
      None => go_panic_because_fn_not_loaded("glGetActiveUniformName"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetActiveUniformName" != "glGetError" {
        report_error_as_necessary_from("glGetActiveUniformName", glGetError());
      }
    }
    out
  }
  static glGetActiveUniformName_p: APcv = ap_null();
  /// Tries to load [`glGetActiveUniformName`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetActiveUniformName_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetActiveUniformName\0");
    glGetActiveUniformName_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetActiveUniformName`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveUniformName_is_loaded() -> bool {
    !glGetActiveUniformName_p.load(RELAX).is_null()
  }

  /// [glGetActiveUniformsiv](http://docs.gl/gl4/glGetActiveUniformsiv)(program, uniformCount, uniformIndices, pname, params)
  /// * `uniformIndices` len: uniformCount
  /// * `pname` group: UniformPName
  /// * `params` len: COMPSIZE(uniformCount,pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetActiveUniformsiv(
    program: GLuint,
    uniformCount: GLsizei,
    uniformIndices: *const GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetActiveUniformsiv({:?}, {:?}, {:p}, {:#X}, {:p});",
        program,
        uniformCount,
        uniformIndices,
        pname,
        params
      );
    }
    let p = glGetActiveUniformsiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizei, *const GLuint, GLenum, *mut GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, uniformCount, uniformIndices, pname, params),
      None => go_panic_because_fn_not_loaded("glGetActiveUniformsiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetActiveUniformsiv" != "glGetError" {
        report_error_as_necessary_from("glGetActiveUniformsiv", glGetError());
      }
    }
    out
  }
  static glGetActiveUniformsiv_p: APcv = ap_null();
  /// Tries to load [`glGetActiveUniformsiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetActiveUniformsiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetActiveUniformsiv\0");
    glGetActiveUniformsiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetActiveUniformsiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetActiveUniformsiv_is_loaded() -> bool {
    !glGetActiveUniformsiv_p.load(RELAX).is_null()
  }

  /// [glGetAttachedShaders](http://docs.gl/gl4/glGetAttachedShaders)(program, maxCount, count, shaders)
  /// * `count` len: 1
  /// * `shaders` len: maxCount
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetAttachedShaders(
    program: GLuint,
    maxCount: GLsizei,
    count: *mut GLsizei,
    shaders: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetAttachedShaders({:?}, {:?}, {:p}, {:p});",
        program,
        maxCount,
        count,
        shaders
      );
    }
    let p = glGetAttachedShaders_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, maxCount, count, shaders),
      None => go_panic_because_fn_not_loaded("glGetAttachedShaders"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetAttachedShaders" != "glGetError" {
        report_error_as_necessary_from("glGetAttachedShaders", glGetError());
      }
    }
    out
  }
  static glGetAttachedShaders_p: APcv = ap_null();
  /// Tries to load [`glGetAttachedShaders`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetAttachedShaders_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetAttachedShaders\0");
    glGetAttachedShaders_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetAttachedShaders`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetAttachedShaders_is_loaded() -> bool {
    !glGetAttachedShaders_p.load(RELAX).is_null()
  }

  /// [glGetAttribLocation](http://docs.gl/gl4/glGetAttribLocation)(program, name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetAttribLocation(
    program: GLuint,
    name: *const GLchar,
  ) -> GLint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetAttribLocation({:?}, {:p});", program, name);
    }
    let p = glGetAttribLocation_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, *const GLchar) -> GLint>>(p) {
        Some(fn_p) => fn_p(program, name),
        None => go_panic_because_fn_not_loaded("glGetAttribLocation"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetAttribLocation" != "glGetError" {
        report_error_as_necessary_from("glGetAttribLocation", glGetError());
      }
    }
    out
  }
  static glGetAttribLocation_p: APcv = ap_null();
  /// Tries to load [`glGetAttribLocation`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetAttribLocation_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetAttribLocation\0");
    glGetAttribLocation_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetAttribLocation`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetAttribLocation_is_loaded() -> bool {
    !glGetAttribLocation_p.load(RELAX).is_null()
  }

  /// [glGetBooleani_v](http://docs.gl/gl4/glGetBooleani_v)(target, index, data)
  /// * `target` group: BufferTargetARB
  /// * `data` len: COMPSIZE(target)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetBooleani_v(
    target: GLenum,
    index: GLuint,
    data: *mut GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetBooleani_v({:#X}, {:?}, {:p});",
        target,
        index,
        data
      );
    }
    let p = glGetBooleani_v_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLuint, *mut GLboolean)>>(p) {
        Some(fn_p) => fn_p(target, index, data),
        None => go_panic_because_fn_not_loaded("glGetBooleani_v"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetBooleani_v" != "glGetError" {
        report_error_as_necessary_from("glGetBooleani_v", glGetError());
      }
    }
    out
  }
  static glGetBooleani_v_p: APcv = ap_null();
  /// Tries to load [`glGetBooleani_v`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetBooleani_v_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetBooleani_v\0");
    glGetBooleani_v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetBooleani_v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetBooleani_v_is_loaded() -> bool {
    !glGetBooleani_v_p.load(RELAX).is_null()
  }

  /// [glGetBooleanv](http://docs.gl/gl4/glGetBooleanv)(pname, data)
  /// * `pname` group: GetPName
  /// * `data` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetBooleanv(pname: GLenum, data: *mut GLboolean) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetBooleanv({:#X}, {:p});", pname, data);
    }
    let p = glGetBooleanv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, *mut GLboolean)>>(p) {
      Some(fn_p) => fn_p(pname, data),
      None => go_panic_because_fn_not_loaded("glGetBooleanv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetBooleanv" != "glGetError" {
        report_error_as_necessary_from("glGetBooleanv", glGetError());
      }
    }
    out
  }
  static glGetBooleanv_p: APcv = ap_null();
  /// Tries to load [`glGetBooleanv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetBooleanv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetBooleanv\0");
    glGetBooleanv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetBooleanv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetBooleanv_is_loaded() -> bool {
    !glGetBooleanv_p.load(RELAX).is_null()
  }

  /// [glGetBufferParameteri64v](http://docs.gl/gl4/glGetBufferParameter)(target, pname, params)
  /// * `target` group: BufferTargetARB
  /// * `pname` group: BufferPNameARB
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetBufferParameteri64v(
    target: GLenum,
    pname: GLenum,
    params: *mut GLint64,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetBufferParameteri64v({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glGetBufferParameteri64v_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint64)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glGetBufferParameteri64v"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetBufferParameteri64v" != "glGetError" {
        report_error_as_necessary_from(
          "glGetBufferParameteri64v",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetBufferParameteri64v_p: APcv = ap_null();
  /// Tries to load [`glGetBufferParameteri64v`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetBufferParameteri64v_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetBufferParameteri64v\0");
    glGetBufferParameteri64v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetBufferParameteri64v`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetBufferParameteri64v_is_loaded() -> bool {
    !glGetBufferParameteri64v_p.load(RELAX).is_null()
  }

  /// [glGetBufferParameteriv](http://docs.gl/gl4/glGetBufferParameter)(target, pname, params)
  /// * `target` group: BufferTargetARB
  /// * `pname` group: BufferPNameARB
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetBufferParameteriv(
    target: GLenum,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetBufferParameteriv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glGetBufferParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glGetBufferParameteriv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetBufferParameteriv" != "glGetError" {
        report_error_as_necessary_from("glGetBufferParameteriv", glGetError());
      }
    }
    out
  }
  static glGetBufferParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetBufferParameteriv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetBufferParameteriv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetBufferParameteriv\0");
    glGetBufferParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetBufferParameteriv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetBufferParameteriv_is_loaded() -> bool {
    !glGetBufferParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetBufferPointerv](http://docs.gl/gl4/glGetBufferPointerv)(target, pname, params)
  /// * `target` group: BufferTargetARB
  /// * `pname` group: BufferPointerNameARB
  /// * `params` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetBufferPointerv(
    target: GLenum,
    pname: GLenum,
    params: *mut *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetBufferPointerv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glGetBufferPointerv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut *mut c_void)>>(p)
      {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glGetBufferPointerv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetBufferPointerv" != "glGetError" {
        report_error_as_necessary_from("glGetBufferPointerv", glGetError());
      }
    }
    out
  }
  static glGetBufferPointerv_p: APcv = ap_null();
  /// Tries to load [`glGetBufferPointerv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetBufferPointerv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetBufferPointerv\0");
    glGetBufferPointerv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetBufferPointerv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetBufferPointerv_is_loaded() -> bool {
    !glGetBufferPointerv_p.load(RELAX).is_null()
  }

  /// [glGetBufferSubData](http://docs.gl/gl4/glGetBufferSubData)(target, offset, size, data)
  /// * `target` group: BufferTargetARB
  /// * `offset` group: BufferOffset
  /// * `size` group: BufferSize
  /// * `data` len: size
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetBufferSubData(
    target: GLenum,
    offset: GLintptr,
    size: GLsizeiptr,
    data: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetBufferSubData({:#X}, {:?}, {:?}, {:p});",
        target,
        offset,
        size,
        data
      );
    }
    let p = glGetBufferSubData_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLintptr, GLsizeiptr, *mut c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, offset, size, data),
      None => go_panic_because_fn_not_loaded("glGetBufferSubData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetBufferSubData" != "glGetError" {
        report_error_as_necessary_from("glGetBufferSubData", glGetError());
      }
    }
    out
  }
  static glGetBufferSubData_p: APcv = ap_null();
  /// Tries to load [`glGetBufferSubData`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetBufferSubData_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetBufferSubData\0");
    glGetBufferSubData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetBufferSubData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetBufferSubData_is_loaded() -> bool {
    !glGetBufferSubData_p.load(RELAX).is_null()
  }

  /// [glGetCompressedTexImage](http://docs.gl/gl4/glGetCompressedTexImage)(target, level, img)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `img` group: CompressedTextureARB
  /// * `img` len: COMPSIZE(target,level)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetCompressedTexImage(
    target: GLenum,
    level: GLint,
    img: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetCompressedTexImage({:#X}, {:?}, {:p});",
        target,
        level,
        img
      );
    }
    let p = glGetCompressedTexImage_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLint, *mut c_void)>>(p) {
        Some(fn_p) => fn_p(target, level, img),
        None => go_panic_because_fn_not_loaded("glGetCompressedTexImage"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetCompressedTexImage" != "glGetError" {
        report_error_as_necessary_from("glGetCompressedTexImage", glGetError());
      }
    }
    out
  }
  static glGetCompressedTexImage_p: APcv = ap_null();
  /// Tries to load [`glGetCompressedTexImage`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetCompressedTexImage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetCompressedTexImage\0");
    glGetCompressedTexImage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetCompressedTexImage`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetCompressedTexImage_is_loaded() -> bool {
    !glGetCompressedTexImage_p.load(RELAX).is_null()
  }

  /// [glGetCompressedTextureImage](http://docs.gl/gl4/glGetCompressedTextureImage)(texture, level, bufSize, pixels)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetCompressedTextureImage(
    texture: GLuint,
    level: GLint,
    bufSize: GLsizei,
    pixels: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetCompressedTextureImage({:?}, {:?}, {:?}, {:p});",
        texture,
        level,
        bufSize,
        pixels
      );
    }
    let p = glGetCompressedTextureImage_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *mut c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(texture, level, bufSize, pixels),
      None => go_panic_because_fn_not_loaded("glGetCompressedTextureImage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetCompressedTextureImage" != "glGetError" {
        report_error_as_necessary_from(
          "glGetCompressedTextureImage",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetCompressedTextureImage_p: APcv = ap_null();
  /// Tries to load [`glGetCompressedTextureImage`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetCompressedTextureImage_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetCompressedTextureImage\0");
    glGetCompressedTextureImage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetCompressedTextureImage`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetCompressedTextureImage_is_loaded() -> bool {
    !glGetCompressedTextureImage_p.load(RELAX).is_null()
  }

  /// [glGetCompressedTextureSubImage](http://docs.gl/gl4/glGetCompressedTextureSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetCompressedTextureSubImage(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    zoffset: GLint,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
    bufSize: GLsizei,
    pixels: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetCompressedTextureSubImage({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
    }
    let p = glGetCompressedTextureSubImage_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLsizei,
          GLsizei,
          *mut c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        texture, level, xoffset, yoffset, zoffset, width, height, depth,
        bufSize, pixels,
      ),
      None => go_panic_because_fn_not_loaded("glGetCompressedTextureSubImage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetCompressedTextureSubImage" != "glGetError" {
        report_error_as_necessary_from(
          "glGetCompressedTextureSubImage",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetCompressedTextureSubImage_p: APcv = ap_null();
  /// Tries to load [`glGetCompressedTextureSubImage`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetCompressedTextureSubImage_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetCompressedTextureSubImage\0");
    glGetCompressedTextureSubImage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetCompressedTextureSubImage`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetCompressedTextureSubImage_is_loaded() -> bool {
    !glGetCompressedTextureSubImage_p.load(RELAX).is_null()
  }

  /// [glGetDebugMessageLog](http://docs.gl/gl4/glGetDebugMessageLog)(count, bufSize, sources, types, ids, severities, lengths, messageLog)
  /// * `sources` group: DebugSource
  /// * `sources` len: count
  /// * `types` group: DebugType
  /// * `types` len: count
  /// * `ids` len: count
  /// * `severities` group: DebugSeverity
  /// * `severities` len: count
  /// * `lengths` len: count
  /// * `messageLog` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetDebugMessageLog(
    count: GLuint,
    bufSize: GLsizei,
    sources: *mut GLenum,
    types: *mut GLenum,
    ids: *mut GLuint,
    severities: *mut GLenum,
    lengths: *mut GLsizei,
    messageLog: *mut GLchar,
  ) -> GLuint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetDebugMessageLog({:?}, {:?}, {:p}, {:p}, {:p}, {:p}, {:p}, {:p});", count, bufSize, sources, types, ids, severities, lengths, messageLog);
    }
    let p = glGetDebugMessageLog_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLsizei,
          *mut GLenum,
          *mut GLenum,
          *mut GLuint,
          *mut GLenum,
          *mut GLsizei,
          *mut GLchar,
        ) -> GLuint,
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        count, bufSize, sources, types, ids, severities, lengths, messageLog,
      ),
      None => go_panic_because_fn_not_loaded("glGetDebugMessageLog"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetDebugMessageLog" != "glGetError" {
        report_error_as_necessary_from("glGetDebugMessageLog", glGetError());
      }
    }
    out
  }
  static glGetDebugMessageLog_p: APcv = ap_null();
  /// Tries to load [`glGetDebugMessageLog`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetDebugMessageLog_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetDebugMessageLog\0");
    glGetDebugMessageLog_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetDebugMessageLog`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetDebugMessageLog_is_loaded() -> bool {
    !glGetDebugMessageLog_p.load(RELAX).is_null()
  }

  /// [glGetDoublei_v](http://docs.gl/gl4/glGetDoublei_v)(target, index, data)
  /// * `data` len: COMPSIZE(target)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetDoublei_v(
    target: GLenum,
    index: GLuint,
    data: *mut GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetDoublei_v({:#X}, {:?}, {:p});", target, index, data);
    }
    let p = glGetDoublei_v_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLuint, *mut GLdouble)>>(p) {
        Some(fn_p) => fn_p(target, index, data),
        None => go_panic_because_fn_not_loaded("glGetDoublei_v"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetDoublei_v" != "glGetError" {
        report_error_as_necessary_from("glGetDoublei_v", glGetError());
      }
    }
    out
  }
  static glGetDoublei_v_p: APcv = ap_null();
  /// Tries to load [`glGetDoublei_v`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetDoublei_v_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetDoublei_v\0");
    glGetDoublei_v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetDoublei_v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetDoublei_v_is_loaded() -> bool {
    !glGetDoublei_v_p.load(RELAX).is_null()
  }

  /// [glGetDoublev](http://docs.gl/gl4/glGetDoublev)(pname, data)
  /// * `pname` group: GetPName
  /// * `data` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetDoublev(pname: GLenum, data: *mut GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetDoublev({:#X}, {:p});", pname, data);
    }
    let p = glGetDoublev_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, *mut GLdouble)>>(p) {
      Some(fn_p) => fn_p(pname, data),
      None => go_panic_because_fn_not_loaded("glGetDoublev"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetDoublev" != "glGetError" {
        report_error_as_necessary_from("glGetDoublev", glGetError());
      }
    }
    out
  }
  static glGetDoublev_p: APcv = ap_null();
  /// Tries to load [`glGetDoublev`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetDoublev_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetDoublev\0");
    glGetDoublev_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetDoublev`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetDoublev_is_loaded() -> bool {
    !glGetDoublev_p.load(RELAX).is_null()
  }

  /// [glGetError](http://docs.gl/gl4/glGetError)()
  /// * return value group: ErrorCode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetError() -> GLenum {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetError();",);
    }
    let p = glGetError_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn() -> GLenum>>(p) {
      Some(fn_p) => fn_p(),
      None => go_panic_because_fn_not_loaded("glGetError"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetError" != "glGetError" {
        report_error_as_necessary_from("glGetError", glGetError());
      }
    }
    out
  }
  static glGetError_p: APcv = ap_null();
  /// Tries to load [`glGetError`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetError_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetError\0");
    glGetError_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetError`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetError_is_loaded() -> bool {
    !glGetError_p.load(RELAX).is_null()
  }

  /// [glGetFloati_v](http://docs.gl/gl4/glGetFloati_v)(target, index, data)
  /// * `data` len: COMPSIZE(target)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetFloati_v(
    target: GLenum,
    index: GLuint,
    data: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetFloati_v({:#X}, {:?}, {:p});", target, index, data);
    }
    let p = glGetFloati_v_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLuint, *mut GLfloat)>>(p) {
        Some(fn_p) => fn_p(target, index, data),
        None => go_panic_because_fn_not_loaded("glGetFloati_v"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetFloati_v" != "glGetError" {
        report_error_as_necessary_from("glGetFloati_v", glGetError());
      }
    }
    out
  }
  static glGetFloati_v_p: APcv = ap_null();
  /// Tries to load [`glGetFloati_v`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetFloati_v_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetFloati_v\0");
    glGetFloati_v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetFloati_v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetFloati_v_is_loaded() -> bool {
    !glGetFloati_v_p.load(RELAX).is_null()
  }

  /// [glGetFloatv](http://docs.gl/gl4/glGetFloatv)(pname, data)
  /// * `pname` group: GetPName
  /// * `data` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetFloatv(pname: GLenum, data: *mut GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetFloatv({:#X}, {:p});", pname, data);
    }
    let p = glGetFloatv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, *mut GLfloat)>>(p) {
      Some(fn_p) => fn_p(pname, data),
      None => go_panic_because_fn_not_loaded("glGetFloatv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetFloatv" != "glGetError" {
        report_error_as_necessary_from("glGetFloatv", glGetError());
      }
    }
    out
  }
  static glGetFloatv_p: APcv = ap_null();
  /// Tries to load [`glGetFloatv`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetFloatv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetFloatv\0");
    glGetFloatv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetFloatv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetFloatv_is_loaded() -> bool {
    !glGetFloatv_p.load(RELAX).is_null()
  }

  /// [glGetFragDataIndex](http://docs.gl/gl4/glGetFragDataIndex)(program, name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetFragDataIndex(
    program: GLuint,
    name: *const GLchar,
  ) -> GLint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetFragDataIndex({:?}, {:p});", program, name);
    }
    let p = glGetFragDataIndex_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, *const GLchar) -> GLint>>(p) {
        Some(fn_p) => fn_p(program, name),
        None => go_panic_because_fn_not_loaded("glGetFragDataIndex"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetFragDataIndex" != "glGetError" {
        report_error_as_necessary_from("glGetFragDataIndex", glGetError());
      }
    }
    out
  }
  static glGetFragDataIndex_p: APcv = ap_null();
  /// Tries to load [`glGetFragDataIndex`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetFragDataIndex_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetFragDataIndex\0");
    glGetFragDataIndex_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetFragDataIndex`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetFragDataIndex_is_loaded() -> bool {
    !glGetFragDataIndex_p.load(RELAX).is_null()
  }

  /// [glGetFragDataLocation](http://docs.gl/gl4/glGetFragDataLocation)(program, name)
  /// * `name` len: COMPSIZE(name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetFragDataLocation(
    program: GLuint,
    name: *const GLchar,
  ) -> GLint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetFragDataLocation({:?}, {:p});", program, name);
    }
    let p = glGetFragDataLocation_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, *const GLchar) -> GLint>>(p) {
        Some(fn_p) => fn_p(program, name),
        None => go_panic_because_fn_not_loaded("glGetFragDataLocation"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetFragDataLocation" != "glGetError" {
        report_error_as_necessary_from("glGetFragDataLocation", glGetError());
      }
    }
    out
  }
  static glGetFragDataLocation_p: APcv = ap_null();
  /// Tries to load [`glGetFragDataLocation`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetFragDataLocation_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetFragDataLocation\0");
    glGetFragDataLocation_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetFragDataLocation`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetFragDataLocation_is_loaded() -> bool {
    !glGetFragDataLocation_p.load(RELAX).is_null()
  }

  /// [glGetFramebufferAttachmentParameteriv](http://docs.gl/gl4/glGetFramebufferAttachmentParameteriv)(target, attachment, pname, params)
  /// * `target` group: FramebufferTarget
  /// * `attachment` group: FramebufferAttachment
  /// * `pname` group: FramebufferAttachmentParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetFramebufferAttachmentParameteriv(
    target: GLenum,
    attachment: GLenum,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetFramebufferAttachmentParameteriv({:#X}, {:#X}, {:#X}, {:p});", target, attachment, pname, params);
    }
    let p = glGetFramebufferAttachmentParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, GLenum, *mut GLint)>>(
        p,
      ) {
        Some(fn_p) => fn_p(target, attachment, pname, params),
        None => go_panic_because_fn_not_loaded(
          "glGetFramebufferAttachmentParameteriv",
        ),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetFramebufferAttachmentParameteriv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetFramebufferAttachmentParameteriv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetFramebufferAttachmentParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetFramebufferAttachmentParameteriv`], returns if a
  /// non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetFramebufferAttachmentParameteriv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glGetFramebufferAttachmentParameteriv\0");
    glGetFramebufferAttachmentParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetFramebufferAttachmentParameteriv`] is
  /// loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetFramebufferAttachmentParameteriv_is_loaded() -> bool {
    !glGetFramebufferAttachmentParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetFramebufferParameteriv](http://docs.gl/gl4/glGetFramebufferParameteriv)(target, pname, params)
  /// * `target` group: FramebufferTarget
  /// * `pname` group: FramebufferAttachmentParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetFramebufferParameteriv(
    target: GLenum,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetFramebufferParameteriv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glGetFramebufferParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glGetFramebufferParameteriv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetFramebufferParameteriv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetFramebufferParameteriv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetFramebufferParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetFramebufferParameteriv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetFramebufferParameteriv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetFramebufferParameteriv\0");
    glGetFramebufferParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetFramebufferParameteriv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetFramebufferParameteriv_is_loaded() -> bool {
    !glGetFramebufferParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetGraphicsResetStatus](http://docs.gl/gl4/glGetGraphicsResetStatus)()
  /// * return value group: GraphicsResetStatus
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetGraphicsResetStatus() -> GLenum {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetGraphicsResetStatus();",);
    }
    let p = glGetGraphicsResetStatus_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn() -> GLenum>>(p) {
      Some(fn_p) => fn_p(),
      None => go_panic_because_fn_not_loaded("glGetGraphicsResetStatus"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetGraphicsResetStatus" != "glGetError" {
        report_error_as_necessary_from(
          "glGetGraphicsResetStatus",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetGraphicsResetStatus_p: APcv = ap_null();
  /// Tries to load [`glGetGraphicsResetStatus`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetGraphicsResetStatus_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetGraphicsResetStatus\0");
    glGetGraphicsResetStatus_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetGraphicsResetStatus`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetGraphicsResetStatus_is_loaded() -> bool {
    !glGetGraphicsResetStatus_p.load(RELAX).is_null()
  }

  /// [glGetInteger64i_v](http://docs.gl/gl4/glGetInteger64i_v)(target, index, data)
  /// * `data` len: COMPSIZE(target)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetInteger64i_v(
    target: GLenum,
    index: GLuint,
    data: *mut GLint64,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetInteger64i_v({:#X}, {:?}, {:p});",
        target,
        index,
        data
      );
    }
    let p = glGetInteger64i_v_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLuint, *mut GLint64)>>(p) {
        Some(fn_p) => fn_p(target, index, data),
        None => go_panic_because_fn_not_loaded("glGetInteger64i_v"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetInteger64i_v" != "glGetError" {
        report_error_as_necessary_from("glGetInteger64i_v", glGetError());
      }
    }
    out
  }
  static glGetInteger64i_v_p: APcv = ap_null();
  /// Tries to load [`glGetInteger64i_v`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetInteger64i_v_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetInteger64i_v\0");
    glGetInteger64i_v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetInteger64i_v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetInteger64i_v_is_loaded() -> bool {
    !glGetInteger64i_v_p.load(RELAX).is_null()
  }

  /// [glGetInteger64v](http://docs.gl/gl4/glGetInteger64v)(pname, data)
  /// * `pname` group: GetPName
  /// * `data` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetInteger64v(pname: GLenum, data: *mut GLint64) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetInteger64v({:#X}, {:p});", pname, data);
    }
    let p = glGetInteger64v_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, *mut GLint64)>>(p) {
      Some(fn_p) => fn_p(pname, data),
      None => go_panic_because_fn_not_loaded("glGetInteger64v"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetInteger64v" != "glGetError" {
        report_error_as_necessary_from("glGetInteger64v", glGetError());
      }
    }
    out
  }
  static glGetInteger64v_p: APcv = ap_null();
  /// Tries to load [`glGetInteger64v`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetInteger64v_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetInteger64v\0");
    glGetInteger64v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetInteger64v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetInteger64v_is_loaded() -> bool {
    !glGetInteger64v_p.load(RELAX).is_null()
  }

  /// [glGetIntegeri_v](http://docs.gl/gl4/glGetIntegeri_v)(target, index, data)
  /// * `data` len: COMPSIZE(target)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetIntegeri_v(
    target: GLenum,
    index: GLuint,
    data: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetIntegeri_v({:#X}, {:?}, {:p});",
        target,
        index,
        data
      );
    }
    let p = glGetIntegeri_v_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLuint, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(target, index, data),
        None => go_panic_because_fn_not_loaded("glGetIntegeri_v"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetIntegeri_v" != "glGetError" {
        report_error_as_necessary_from("glGetIntegeri_v", glGetError());
      }
    }
    out
  }
  static glGetIntegeri_v_p: APcv = ap_null();
  /// Tries to load [`glGetIntegeri_v`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetIntegeri_v_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetIntegeri_v\0");
    glGetIntegeri_v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetIntegeri_v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetIntegeri_v_is_loaded() -> bool {
    !glGetIntegeri_v_p.load(RELAX).is_null()
  }

  /// [glGetIntegerv](http://docs.gl/gl4/glGetIntegerv)(pname, data)
  /// * `pname` group: GetPName
  /// * `data` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetIntegerv(pname: GLenum, data: *mut GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetIntegerv({:#X}, {:p});", pname, data);
    }
    let p = glGetIntegerv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, *mut GLint)>>(p) {
      Some(fn_p) => fn_p(pname, data),
      None => go_panic_because_fn_not_loaded("glGetIntegerv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetIntegerv" != "glGetError" {
        report_error_as_necessary_from("glGetIntegerv", glGetError());
      }
    }
    out
  }
  static glGetIntegerv_p: APcv = ap_null();
  /// Tries to load [`glGetIntegerv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetIntegerv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetIntegerv\0");
    glGetIntegerv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetIntegerv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetIntegerv_is_loaded() -> bool {
    !glGetIntegerv_p.load(RELAX).is_null()
  }

  /// [glGetInternalformati64v](http://docs.gl/gl4/glGetInternalformati64v)(target, internalformat, pname, count, params)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  /// * `pname` group: InternalFormatPName
  /// * `params` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetInternalformati64v(
    target: GLenum,
    internalformat: GLenum,
    pname: GLenum,
    count: GLsizei,
    params: *mut GLint64,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetInternalformati64v({:#X}, {:#X}, {:#X}, {:?}, {:p});",
        target,
        internalformat,
        pname,
        count,
        params
      );
    }
    let p = glGetInternalformati64v_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut GLint64)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, internalformat, pname, count, params),
      None => go_panic_because_fn_not_loaded("glGetInternalformati64v"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetInternalformati64v" != "glGetError" {
        report_error_as_necessary_from("glGetInternalformati64v", glGetError());
      }
    }
    out
  }
  static glGetInternalformati64v_p: APcv = ap_null();
  /// Tries to load [`glGetInternalformati64v`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetInternalformati64v_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetInternalformati64v\0");
    glGetInternalformati64v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetInternalformati64v`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetInternalformati64v_is_loaded() -> bool {
    !glGetInternalformati64v_p.load(RELAX).is_null()
  }

  /// [glGetInternalformativ](http://docs.gl/gl4/glGetInternalformativ)(target, internalformat, pname, count, params)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  /// * `pname` group: InternalFormatPName
  /// * `params` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetInternalformativ(
    target: GLenum,
    internalformat: GLenum,
    pname: GLenum,
    count: GLsizei,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetInternalformativ({:#X}, {:#X}, {:#X}, {:?}, {:p});",
        target,
        internalformat,
        pname,
        count,
        params
      );
    }
    let p = glGetInternalformativ_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, internalformat, pname, count, params),
      None => go_panic_because_fn_not_loaded("glGetInternalformativ"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetInternalformativ" != "glGetError" {
        report_error_as_necessary_from("glGetInternalformativ", glGetError());
      }
    }
    out
  }
  static glGetInternalformativ_p: APcv = ap_null();
  /// Tries to load [`glGetInternalformativ`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetInternalformativ_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetInternalformativ\0");
    glGetInternalformativ_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetInternalformativ`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetInternalformativ_is_loaded() -> bool {
    !glGetInternalformativ_p.load(RELAX).is_null()
  }

  /// [glGetMultisamplefv](http://docs.gl/gl4/glGetMultisamplefv)(pname, index, val)
  /// * `pname` group: GetMultisamplePNameNV
  /// * `val` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetMultisamplefv(
    pname: GLenum,
    index: GLuint,
    val: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetMultisamplefv({:#X}, {:?}, {:p});",
        pname,
        index,
        val
      );
    }
    let p = glGetMultisamplefv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLuint, *mut GLfloat)>>(p) {
        Some(fn_p) => fn_p(pname, index, val),
        None => go_panic_because_fn_not_loaded("glGetMultisamplefv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetMultisamplefv" != "glGetError" {
        report_error_as_necessary_from("glGetMultisamplefv", glGetError());
      }
    }
    out
  }
  static glGetMultisamplefv_p: APcv = ap_null();
  /// Tries to load [`glGetMultisamplefv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetMultisamplefv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetMultisamplefv\0");
    glGetMultisamplefv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetMultisamplefv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetMultisamplefv_is_loaded() -> bool {
    !glGetMultisamplefv_p.load(RELAX).is_null()
  }

  /// [glGetNamedBufferParameteri64v](http://docs.gl/gl4/glGetBufferParameter)(buffer, pname, params)
  /// * `pname` group: BufferPNameARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetNamedBufferParameteri64v(
    buffer: GLuint,
    pname: GLenum,
    params: *mut GLint64,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetNamedBufferParameteri64v({:?}, {:#X}, {:p});",
        buffer,
        pname,
        params
      );
    }
    let p = glGetNamedBufferParameteri64v_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint64)>>(p) {
        Some(fn_p) => fn_p(buffer, pname, params),
        None => go_panic_because_fn_not_loaded("glGetNamedBufferParameteri64v"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetNamedBufferParameteri64v" != "glGetError" {
        report_error_as_necessary_from(
          "glGetNamedBufferParameteri64v",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetNamedBufferParameteri64v_p: APcv = ap_null();
  /// Tries to load [`glGetNamedBufferParameteri64v`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetNamedBufferParameteri64v_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetNamedBufferParameteri64v\0");
    glGetNamedBufferParameteri64v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetNamedBufferParameteri64v`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetNamedBufferParameteri64v_is_loaded() -> bool {
    !glGetNamedBufferParameteri64v_p.load(RELAX).is_null()
  }

  /// [glGetNamedBufferParameteriv](http://docs.gl/gl4/glGetBufferParameter)(buffer, pname, params)
  /// * `pname` group: BufferPNameARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetNamedBufferParameteriv(
    buffer: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetNamedBufferParameteriv({:?}, {:#X}, {:p});",
        buffer,
        pname,
        params
      );
    }
    let p = glGetNamedBufferParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(buffer, pname, params),
        None => go_panic_because_fn_not_loaded("glGetNamedBufferParameteriv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetNamedBufferParameteriv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetNamedBufferParameteriv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetNamedBufferParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetNamedBufferParameteriv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetNamedBufferParameteriv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetNamedBufferParameteriv\0");
    glGetNamedBufferParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetNamedBufferParameteriv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetNamedBufferParameteriv_is_loaded() -> bool {
    !glGetNamedBufferParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetNamedBufferPointerv](http://docs.gl/gl4/glGetNamedBufferPointerv)(buffer, pname, params)
  /// * `pname` group: BufferPointerNameARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetNamedBufferPointerv(
    buffer: GLuint,
    pname: GLenum,
    params: *mut *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetNamedBufferPointerv({:?}, {:#X}, {:p});",
        buffer,
        pname,
        params
      );
    }
    let p = glGetNamedBufferPointerv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut *mut c_void)>>(p)
      {
        Some(fn_p) => fn_p(buffer, pname, params),
        None => go_panic_because_fn_not_loaded("glGetNamedBufferPointerv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetNamedBufferPointerv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetNamedBufferPointerv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetNamedBufferPointerv_p: APcv = ap_null();
  /// Tries to load [`glGetNamedBufferPointerv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetNamedBufferPointerv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetNamedBufferPointerv\0");
    glGetNamedBufferPointerv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetNamedBufferPointerv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetNamedBufferPointerv_is_loaded() -> bool {
    !glGetNamedBufferPointerv_p.load(RELAX).is_null()
  }

  /// [glGetNamedBufferSubData](http://docs.gl/gl4/glGetNamedBufferSubData)(buffer, offset, size, data)
  /// * `size` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetNamedBufferSubData(
    buffer: GLuint,
    offset: GLintptr,
    size: GLsizeiptr,
    data: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetNamedBufferSubData({:?}, {:?}, {:?}, {:p});",
        buffer,
        offset,
        size,
        data
      );
    }
    let p = glGetNamedBufferSubData_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLintptr, GLsizeiptr, *mut c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(buffer, offset, size, data),
      None => go_panic_because_fn_not_loaded("glGetNamedBufferSubData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetNamedBufferSubData" != "glGetError" {
        report_error_as_necessary_from("glGetNamedBufferSubData", glGetError());
      }
    }
    out
  }
  static glGetNamedBufferSubData_p: APcv = ap_null();
  /// Tries to load [`glGetNamedBufferSubData`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetNamedBufferSubData_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetNamedBufferSubData\0");
    glGetNamedBufferSubData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetNamedBufferSubData`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetNamedBufferSubData_is_loaded() -> bool {
    !glGetNamedBufferSubData_p.load(RELAX).is_null()
  }

  /// [glGetNamedFramebufferAttachmentParameteriv](http://docs.gl/gl4/glGetNamedFramebufferAttachmentParameteriv)(framebuffer, attachment, pname, params)
  /// * `attachment` group: FramebufferAttachment
  /// * `pname` group: FramebufferAttachmentParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetNamedFramebufferAttachmentParameteriv(
    framebuffer: GLuint,
    attachment: GLenum,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetNamedFramebufferAttachmentParameteriv({:?}, {:#X}, {:#X}, {:p});", framebuffer, attachment, pname, params);
    }
    let p = glGetNamedFramebufferAttachmentParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum, *mut GLint)>>(
        p,
      ) {
        Some(fn_p) => fn_p(framebuffer, attachment, pname, params),
        None => go_panic_because_fn_not_loaded(
          "glGetNamedFramebufferAttachmentParameteriv",
        ),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetNamedFramebufferAttachmentParameteriv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetNamedFramebufferAttachmentParameteriv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetNamedFramebufferAttachmentParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetNamedFramebufferAttachmentParameteriv`], returns if a
  /// non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetNamedFramebufferAttachmentParameteriv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(
      get_proc_address,
      b"glGetNamedFramebufferAttachmentParameteriv\0",
    );
    glGetNamedFramebufferAttachmentParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetNamedFramebufferAttachmentParameteriv`]
  /// is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetNamedFramebufferAttachmentParameteriv_is_loaded() -> bool {
    !glGetNamedFramebufferAttachmentParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetNamedFramebufferParameteriv](http://docs.gl/gl4/glGetNamedFramebufferParameteriv)(framebuffer, pname, param)
  /// * `pname` group: GetFramebufferParameter
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetNamedFramebufferParameteriv(
    framebuffer: GLuint,
    pname: GLenum,
    param: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetNamedFramebufferParameteriv({:?}, {:#X}, {:p});",
        framebuffer,
        pname,
        param
      );
    }
    let p = glGetNamedFramebufferParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(framebuffer, pname, param),
        None => {
          go_panic_because_fn_not_loaded("glGetNamedFramebufferParameteriv")
        }
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetNamedFramebufferParameteriv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetNamedFramebufferParameteriv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetNamedFramebufferParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetNamedFramebufferParameteriv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetNamedFramebufferParameteriv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glGetNamedFramebufferParameteriv\0");
    glGetNamedFramebufferParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetNamedFramebufferParameteriv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetNamedFramebufferParameteriv_is_loaded() -> bool {
    !glGetNamedFramebufferParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetNamedRenderbufferParameteriv](http://docs.gl/gl4/glGetNamedRenderbufferParameteriv)(renderbuffer, pname, params)
  /// * `pname` group: RenderbufferParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetNamedRenderbufferParameteriv(
    renderbuffer: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetNamedRenderbufferParameteriv({:?}, {:#X}, {:p});",
        renderbuffer,
        pname,
        params
      );
    }
    let p = glGetNamedRenderbufferParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(renderbuffer, pname, params),
        None => {
          go_panic_because_fn_not_loaded("glGetNamedRenderbufferParameteriv")
        }
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetNamedRenderbufferParameteriv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetNamedRenderbufferParameteriv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetNamedRenderbufferParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetNamedRenderbufferParameteriv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetNamedRenderbufferParameteriv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glGetNamedRenderbufferParameteriv\0");
    glGetNamedRenderbufferParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetNamedRenderbufferParameteriv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetNamedRenderbufferParameteriv_is_loaded() -> bool {
    !glGetNamedRenderbufferParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetObjectLabel](http://docs.gl/gl4/glGetObjectLabel)(identifier, name, bufSize, length, label)
  /// * `identifier` group: ObjectIdentifier
  /// * `length` len: 1
  /// * `label` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetObjectLabel(
    identifier: GLenum,
    name: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    label: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetObjectLabel({:#X}, {:?}, {:?}, {:p}, {:p});",
        identifier,
        name,
        bufSize,
        length,
        label
      );
    }
    let p = glGetObjectLabel_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLuint, GLsizei, *mut GLsizei, *mut GLchar)>,
    >(p)
    {
      Some(fn_p) => fn_p(identifier, name, bufSize, length, label),
      None => go_panic_because_fn_not_loaded("glGetObjectLabel"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetObjectLabel" != "glGetError" {
        report_error_as_necessary_from("glGetObjectLabel", glGetError());
      }
    }
    out
  }
  static glGetObjectLabel_p: APcv = ap_null();
  /// Tries to load [`glGetObjectLabel`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetObjectLabel_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetObjectLabel\0");
    glGetObjectLabel_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetObjectLabel`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetObjectLabel_is_loaded() -> bool {
    !glGetObjectLabel_p.load(RELAX).is_null()
  }

  /// [glGetObjectPtrLabel](http://docs.gl/gl4/glGetObjectPtrLabel)(ptr, bufSize, length, label)
  /// * `length` len: 1
  /// * `label` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetObjectPtrLabel(
    ptr: *const c_void,
    bufSize: GLsizei,
    length: *mut GLsizei,
    label: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetObjectPtrLabel({:p}, {:?}, {:p}, {:p});",
        ptr,
        bufSize,
        length,
        label
      );
    }
    let p = glGetObjectPtrLabel_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(*const c_void, GLsizei, *mut GLsizei, *mut GLchar)>,
    >(p)
    {
      Some(fn_p) => fn_p(ptr, bufSize, length, label),
      None => go_panic_because_fn_not_loaded("glGetObjectPtrLabel"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetObjectPtrLabel" != "glGetError" {
        report_error_as_necessary_from("glGetObjectPtrLabel", glGetError());
      }
    }
    out
  }
  static glGetObjectPtrLabel_p: APcv = ap_null();
  /// Tries to load [`glGetObjectPtrLabel`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetObjectPtrLabel_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetObjectPtrLabel\0");
    glGetObjectPtrLabel_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetObjectPtrLabel`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetObjectPtrLabel_is_loaded() -> bool {
    !glGetObjectPtrLabel_p.load(RELAX).is_null()
  }

  /// [glGetPointerv](http://docs.gl/gl4/glGetPointerv)(pname, params)
  /// * `pname` group: GetPointervPName
  /// * `params` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetPointerv(pname: GLenum, params: *mut *mut c_void) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetPointerv({:#X}, {:p});", pname, params);
    }
    let p = glGetPointerv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, *mut *mut c_void)>>(p)
    {
      Some(fn_p) => fn_p(pname, params),
      None => go_panic_because_fn_not_loaded("glGetPointerv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetPointerv" != "glGetError" {
        report_error_as_necessary_from("glGetPointerv", glGetError());
      }
    }
    out
  }
  static glGetPointerv_p: APcv = ap_null();
  /// Tries to load [`glGetPointerv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetPointerv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetPointerv\0");
    glGetPointerv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetPointerv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetPointerv_is_loaded() -> bool {
    !glGetPointerv_p.load(RELAX).is_null()
  }

  /// [glGetProgramBinary](http://docs.gl/gl4/glGetProgramBinary)(program, bufSize, length, binaryFormat, binary)
  /// * `length` len: 1
  /// * `binaryFormat` len: 1
  /// * `binary` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramBinary(
    program: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    binaryFormat: *mut GLenum,
    binary: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetProgramBinary({:?}, {:?}, {:p}, {:p}, {:p});",
        program,
        bufSize,
        length,
        binaryFormat,
        binary
      );
    }
    let p = glGetProgramBinary_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLsizei,
          *mut GLsizei,
          *mut GLenum,
          *mut c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(program, bufSize, length, binaryFormat, binary),
      None => go_panic_because_fn_not_loaded("glGetProgramBinary"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetProgramBinary" != "glGetError" {
        report_error_as_necessary_from("glGetProgramBinary", glGetError());
      }
    }
    out
  }
  static glGetProgramBinary_p: APcv = ap_null();
  /// Tries to load [`glGetProgramBinary`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetProgramBinary_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetProgramBinary\0");
    glGetProgramBinary_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetProgramBinary`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramBinary_is_loaded() -> bool {
    !glGetProgramBinary_p.load(RELAX).is_null()
  }

  /// [glGetProgramInfoLog](http://docs.gl/gl4/glGetProgramInfoLog)(program, bufSize, length, infoLog)
  /// * `length` len: 1
  /// * `infoLog` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramInfoLog(
    program: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    infoLog: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetProgramInfoLog({:?}, {:?}, {:p}, {:p});",
        program,
        bufSize,
        length,
        infoLog
      );
    }
    let p = glGetProgramInfoLog_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, bufSize, length, infoLog),
      None => go_panic_because_fn_not_loaded("glGetProgramInfoLog"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetProgramInfoLog" != "glGetError" {
        report_error_as_necessary_from("glGetProgramInfoLog", glGetError());
      }
    }
    out
  }
  static glGetProgramInfoLog_p: APcv = ap_null();
  /// Tries to load [`glGetProgramInfoLog`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetProgramInfoLog_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetProgramInfoLog\0");
    glGetProgramInfoLog_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetProgramInfoLog`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramInfoLog_is_loaded() -> bool {
    !glGetProgramInfoLog_p.load(RELAX).is_null()
  }

  /// [glGetProgramInterfaceiv](http://docs.gl/gl4/glGetProgramInterfaceiv)(program, programInterface, pname, params)
  /// * `programInterface` group: ProgramInterface
  /// * `pname` group: ProgramInterfacePName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramInterfaceiv(
    program: GLuint,
    programInterface: GLenum,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetProgramInterfaceiv({:?}, {:#X}, {:#X}, {:p});",
        program,
        programInterface,
        pname,
        params
      );
    }
    let p = glGetProgramInterfaceiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum, *mut GLint)>>(
        p,
      ) {
        Some(fn_p) => fn_p(program, programInterface, pname, params),
        None => go_panic_because_fn_not_loaded("glGetProgramInterfaceiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetProgramInterfaceiv" != "glGetError" {
        report_error_as_necessary_from("glGetProgramInterfaceiv", glGetError());
      }
    }
    out
  }
  static glGetProgramInterfaceiv_p: APcv = ap_null();
  /// Tries to load [`glGetProgramInterfaceiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetProgramInterfaceiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetProgramInterfaceiv\0");
    glGetProgramInterfaceiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetProgramInterfaceiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramInterfaceiv_is_loaded() -> bool {
    !glGetProgramInterfaceiv_p.load(RELAX).is_null()
  }

  /// [glGetProgramPipelineInfoLog](http://docs.gl/gl4/glGetProgramPipelineInfoLog)(pipeline, bufSize, length, infoLog)
  /// * `length` len: 1
  /// * `infoLog` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramPipelineInfoLog(
    pipeline: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    infoLog: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetProgramPipelineInfoLog({:?}, {:?}, {:p}, {:p});",
        pipeline,
        bufSize,
        length,
        infoLog
      );
    }
    let p = glGetProgramPipelineInfoLog_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar)>,
    >(p)
    {
      Some(fn_p) => fn_p(pipeline, bufSize, length, infoLog),
      None => go_panic_because_fn_not_loaded("glGetProgramPipelineInfoLog"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetProgramPipelineInfoLog" != "glGetError" {
        report_error_as_necessary_from(
          "glGetProgramPipelineInfoLog",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetProgramPipelineInfoLog_p: APcv = ap_null();
  /// Tries to load [`glGetProgramPipelineInfoLog`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetProgramPipelineInfoLog_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetProgramPipelineInfoLog\0");
    glGetProgramPipelineInfoLog_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetProgramPipelineInfoLog`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramPipelineInfoLog_is_loaded() -> bool {
    !glGetProgramPipelineInfoLog_p.load(RELAX).is_null()
  }

  /// [glGetProgramPipelineiv](http://docs.gl/gl4/glGetProgramPipelineiv)(pipeline, pname, params)
  /// * `pname` group: PipelineParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramPipelineiv(
    pipeline: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetProgramPipelineiv({:?}, {:#X}, {:p});",
        pipeline,
        pname,
        params
      );
    }
    let p = glGetProgramPipelineiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(pipeline, pname, params),
        None => go_panic_because_fn_not_loaded("glGetProgramPipelineiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetProgramPipelineiv" != "glGetError" {
        report_error_as_necessary_from("glGetProgramPipelineiv", glGetError());
      }
    }
    out
  }
  static glGetProgramPipelineiv_p: APcv = ap_null();
  /// Tries to load [`glGetProgramPipelineiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetProgramPipelineiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetProgramPipelineiv\0");
    glGetProgramPipelineiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetProgramPipelineiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramPipelineiv_is_loaded() -> bool {
    !glGetProgramPipelineiv_p.load(RELAX).is_null()
  }

  /// [glGetProgramResourceIndex](http://docs.gl/gl4/glGetProgramResourceIndex)(program, programInterface, name)
  /// * `programInterface` group: ProgramInterface
  /// * `name` len: COMPSIZE(name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramResourceIndex(
    program: GLuint,
    programInterface: GLenum,
    name: *const GLchar,
  ) -> GLuint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetProgramResourceIndex({:?}, {:#X}, {:p});",
        program,
        programInterface,
        name
      );
    }
    let p = glGetProgramResourceIndex_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, *const GLchar) -> GLuint>,
    >(p)
    {
      Some(fn_p) => fn_p(program, programInterface, name),
      None => go_panic_because_fn_not_loaded("glGetProgramResourceIndex"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetProgramResourceIndex" != "glGetError" {
        report_error_as_necessary_from(
          "glGetProgramResourceIndex",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetProgramResourceIndex_p: APcv = ap_null();
  /// Tries to load [`glGetProgramResourceIndex`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetProgramResourceIndex_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetProgramResourceIndex\0");
    glGetProgramResourceIndex_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetProgramResourceIndex`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramResourceIndex_is_loaded() -> bool {
    !glGetProgramResourceIndex_p.load(RELAX).is_null()
  }

  /// [glGetProgramResourceLocation](http://docs.gl/gl4/glGetProgramResourceLocation)(program, programInterface, name)
  /// * `programInterface` group: ProgramInterface
  /// * `name` len: COMPSIZE(name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramResourceLocation(
    program: GLuint,
    programInterface: GLenum,
    name: *const GLchar,
  ) -> GLint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetProgramResourceLocation({:?}, {:#X}, {:p});",
        program,
        programInterface,
        name
      );
    }
    let p = glGetProgramResourceLocation_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint>,
    >(p)
    {
      Some(fn_p) => fn_p(program, programInterface, name),
      None => go_panic_because_fn_not_loaded("glGetProgramResourceLocation"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetProgramResourceLocation" != "glGetError" {
        report_error_as_necessary_from(
          "glGetProgramResourceLocation",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetProgramResourceLocation_p: APcv = ap_null();
  /// Tries to load [`glGetProgramResourceLocation`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetProgramResourceLocation_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetProgramResourceLocation\0");
    glGetProgramResourceLocation_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetProgramResourceLocation`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramResourceLocation_is_loaded() -> bool {
    !glGetProgramResourceLocation_p.load(RELAX).is_null()
  }

  /// [glGetProgramResourceLocationIndex](http://docs.gl/gl4/glGetProgramResourceLocationIndex)(program, programInterface, name)
  /// * `programInterface` group: ProgramInterface
  /// * `name` len: COMPSIZE(name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramResourceLocationIndex(
    program: GLuint,
    programInterface: GLenum,
    name: *const GLchar,
  ) -> GLint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetProgramResourceLocationIndex({:?}, {:#X}, {:p});",
        program,
        programInterface,
        name
      );
    }
    let p = glGetProgramResourceLocationIndex_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint>,
    >(p)
    {
      Some(fn_p) => fn_p(program, programInterface, name),
      None => {
        go_panic_because_fn_not_loaded("glGetProgramResourceLocationIndex")
      }
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetProgramResourceLocationIndex" != "glGetError" {
        report_error_as_necessary_from(
          "glGetProgramResourceLocationIndex",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetProgramResourceLocationIndex_p: APcv = ap_null();
  /// Tries to load [`glGetProgramResourceLocationIndex`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetProgramResourceLocationIndex_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glGetProgramResourceLocationIndex\0");
    glGetProgramResourceLocationIndex_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetProgramResourceLocationIndex`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramResourceLocationIndex_is_loaded() -> bool {
    !glGetProgramResourceLocationIndex_p.load(RELAX).is_null()
  }

  /// [glGetProgramResourceName](http://docs.gl/gl4/glGetProgramResourceName)(program, programInterface, index, bufSize, length, name)
  /// * `programInterface` group: ProgramInterface
  /// * `length` len: 1
  /// * `name` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramResourceName(
    program: GLuint,
    programInterface: GLenum,
    index: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    name: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetProgramResourceName({:?}, {:#X}, {:?}, {:?}, {:p}, {:p});", program, programInterface, index, bufSize, length, name);
    }
    let p = glGetProgramResourceName_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLenum,
          GLuint,
          GLsizei,
          *mut GLsizei,
          *mut GLchar,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(program, programInterface, index, bufSize, length, name)
      }
      None => go_panic_because_fn_not_loaded("glGetProgramResourceName"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetProgramResourceName" != "glGetError" {
        report_error_as_necessary_from(
          "glGetProgramResourceName",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetProgramResourceName_p: APcv = ap_null();
  /// Tries to load [`glGetProgramResourceName`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetProgramResourceName_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetProgramResourceName\0");
    glGetProgramResourceName_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetProgramResourceName`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramResourceName_is_loaded() -> bool {
    !glGetProgramResourceName_p.load(RELAX).is_null()
  }

  /// [glGetProgramResourceiv](http://docs.gl/gl4/glGetProgramResourceiv)(program, programInterface, index, propCount, props, count, length, params)
  /// * `programInterface` group: ProgramInterface
  /// * `props` group: ProgramResourceProperty
  /// * `props` len: propCount
  /// * `length` len: 1
  /// * `params` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramResourceiv(
    program: GLuint,
    programInterface: GLenum,
    index: GLuint,
    propCount: GLsizei,
    props: *const GLenum,
    count: GLsizei,
    length: *mut GLsizei,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetProgramResourceiv({:?}, {:#X}, {:?}, {:?}, {:p}, {:?}, {:p}, {:p});", program, programInterface, index, propCount, props, count, length, params);
    }
    let p = glGetProgramResourceiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLenum,
          GLuint,
          GLsizei,
          *const GLenum,
          GLsizei,
          *mut GLsizei,
          *mut GLint,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        program,
        programInterface,
        index,
        propCount,
        props,
        count,
        length,
        params,
      ),
      None => go_panic_because_fn_not_loaded("glGetProgramResourceiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetProgramResourceiv" != "glGetError" {
        report_error_as_necessary_from("glGetProgramResourceiv", glGetError());
      }
    }
    out
  }
  static glGetProgramResourceiv_p: APcv = ap_null();
  /// Tries to load [`glGetProgramResourceiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetProgramResourceiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetProgramResourceiv\0");
    glGetProgramResourceiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetProgramResourceiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramResourceiv_is_loaded() -> bool {
    !glGetProgramResourceiv_p.load(RELAX).is_null()
  }

  /// [glGetProgramStageiv](http://docs.gl/gl4/glGetProgramStageiv)(program, shadertype, pname, values)
  /// * `shadertype` group: ShaderType
  /// * `pname` group: ProgramStagePName
  /// * `values` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramStageiv(
    program: GLuint,
    shadertype: GLenum,
    pname: GLenum,
    values: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetProgramStageiv({:?}, {:#X}, {:#X}, {:p});",
        program,
        shadertype,
        pname,
        values
      );
    }
    let p = glGetProgramStageiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum, *mut GLint)>>(
        p,
      ) {
        Some(fn_p) => fn_p(program, shadertype, pname, values),
        None => go_panic_because_fn_not_loaded("glGetProgramStageiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetProgramStageiv" != "glGetError" {
        report_error_as_necessary_from("glGetProgramStageiv", glGetError());
      }
    }
    out
  }
  static glGetProgramStageiv_p: APcv = ap_null();
  /// Tries to load [`glGetProgramStageiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetProgramStageiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetProgramStageiv\0");
    glGetProgramStageiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetProgramStageiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramStageiv_is_loaded() -> bool {
    !glGetProgramStageiv_p.load(RELAX).is_null()
  }

  /// [glGetProgramiv](http://docs.gl/gl4/glGetProgramiv)(program, pname, params)
  /// * `pname` group: ProgramPropertyARB
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetProgramiv(
    program: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetProgramiv({:?}, {:#X}, {:p});",
        program,
        pname,
        params
      );
    }
    let p = glGetProgramiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(program, pname, params),
        None => go_panic_because_fn_not_loaded("glGetProgramiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetProgramiv" != "glGetError" {
        report_error_as_necessary_from("glGetProgramiv", glGetError());
      }
    }
    out
  }
  static glGetProgramiv_p: APcv = ap_null();
  /// Tries to load [`glGetProgramiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetProgramiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetProgramiv\0");
    glGetProgramiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetProgramiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetProgramiv_is_loaded() -> bool {
    !glGetProgramiv_p.load(RELAX).is_null()
  }

  /// [glGetQueryBufferObjecti64v](http://docs.gl/gl4/glGetQueryBufferObjecti64v)(id, buffer, pname, offset)
  /// * `pname` group: QueryObjectParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryBufferObjecti64v(
    id: GLuint,
    buffer: GLuint,
    pname: GLenum,
    offset: GLintptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryBufferObjecti64v({:?}, {:?}, {:#X}, {:?});",
        id,
        buffer,
        pname,
        offset
      );
    }
    let p = glGetQueryBufferObjecti64v_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLuint, GLenum, GLintptr)>>(p)
      {
        Some(fn_p) => fn_p(id, buffer, pname, offset),
        None => go_panic_because_fn_not_loaded("glGetQueryBufferObjecti64v"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetQueryBufferObjecti64v" != "glGetError" {
        report_error_as_necessary_from(
          "glGetQueryBufferObjecti64v",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetQueryBufferObjecti64v_p: APcv = ap_null();
  /// Tries to load [`glGetQueryBufferObjecti64v`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetQueryBufferObjecti64v_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetQueryBufferObjecti64v\0");
    glGetQueryBufferObjecti64v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetQueryBufferObjecti64v`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryBufferObjecti64v_is_loaded() -> bool {
    !glGetQueryBufferObjecti64v_p.load(RELAX).is_null()
  }

  /// [glGetQueryBufferObjectiv](http://docs.gl/gl4/glGetQueryBufferObjectiv)(id, buffer, pname, offset)
  /// * `pname` group: QueryObjectParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryBufferObjectiv(
    id: GLuint,
    buffer: GLuint,
    pname: GLenum,
    offset: GLintptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryBufferObjectiv({:?}, {:?}, {:#X}, {:?});",
        id,
        buffer,
        pname,
        offset
      );
    }
    let p = glGetQueryBufferObjectiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLuint, GLenum, GLintptr)>>(p)
      {
        Some(fn_p) => fn_p(id, buffer, pname, offset),
        None => go_panic_because_fn_not_loaded("glGetQueryBufferObjectiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetQueryBufferObjectiv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetQueryBufferObjectiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetQueryBufferObjectiv_p: APcv = ap_null();
  /// Tries to load [`glGetQueryBufferObjectiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetQueryBufferObjectiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetQueryBufferObjectiv\0");
    glGetQueryBufferObjectiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetQueryBufferObjectiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryBufferObjectiv_is_loaded() -> bool {
    !glGetQueryBufferObjectiv_p.load(RELAX).is_null()
  }

  /// [glGetQueryBufferObjectui64v](http://docs.gl/gl4/glGetQueryBufferObjectui64v)(id, buffer, pname, offset)
  /// * `pname` group: QueryObjectParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryBufferObjectui64v(
    id: GLuint,
    buffer: GLuint,
    pname: GLenum,
    offset: GLintptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryBufferObjectui64v({:?}, {:?}, {:#X}, {:?});",
        id,
        buffer,
        pname,
        offset
      );
    }
    let p = glGetQueryBufferObjectui64v_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLuint, GLenum, GLintptr)>>(p)
      {
        Some(fn_p) => fn_p(id, buffer, pname, offset),
        None => go_panic_because_fn_not_loaded("glGetQueryBufferObjectui64v"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetQueryBufferObjectui64v" != "glGetError" {
        report_error_as_necessary_from(
          "glGetQueryBufferObjectui64v",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetQueryBufferObjectui64v_p: APcv = ap_null();
  /// Tries to load [`glGetQueryBufferObjectui64v`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetQueryBufferObjectui64v_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetQueryBufferObjectui64v\0");
    glGetQueryBufferObjectui64v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetQueryBufferObjectui64v`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryBufferObjectui64v_is_loaded() -> bool {
    !glGetQueryBufferObjectui64v_p.load(RELAX).is_null()
  }

  /// [glGetQueryBufferObjectuiv](http://docs.gl/gl4/glGetQueryBufferObjectuiv)(id, buffer, pname, offset)
  /// * `pname` group: QueryObjectParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryBufferObjectuiv(
    id: GLuint,
    buffer: GLuint,
    pname: GLenum,
    offset: GLintptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryBufferObjectuiv({:?}, {:?}, {:#X}, {:?});",
        id,
        buffer,
        pname,
        offset
      );
    }
    let p = glGetQueryBufferObjectuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLuint, GLenum, GLintptr)>>(p)
      {
        Some(fn_p) => fn_p(id, buffer, pname, offset),
        None => go_panic_because_fn_not_loaded("glGetQueryBufferObjectuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetQueryBufferObjectuiv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetQueryBufferObjectuiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetQueryBufferObjectuiv_p: APcv = ap_null();
  /// Tries to load [`glGetQueryBufferObjectuiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetQueryBufferObjectuiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetQueryBufferObjectuiv\0");
    glGetQueryBufferObjectuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetQueryBufferObjectuiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryBufferObjectuiv_is_loaded() -> bool {
    !glGetQueryBufferObjectuiv_p.load(RELAX).is_null()
  }

  /// [glGetQueryIndexediv](http://docs.gl/gl4/glGetQueryIndexediv)(target, index, pname, params)
  /// * `target` group: QueryTarget
  /// * `pname` group: QueryParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryIndexediv(
    target: GLenum,
    index: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryIndexediv({:#X}, {:?}, {:#X}, {:p});",
        target,
        index,
        pname,
        params
      );
    }
    let p = glGetQueryIndexediv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLuint, GLenum, *mut GLint)>>(
        p,
      ) {
        Some(fn_p) => fn_p(target, index, pname, params),
        None => go_panic_because_fn_not_loaded("glGetQueryIndexediv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetQueryIndexediv" != "glGetError" {
        report_error_as_necessary_from("glGetQueryIndexediv", glGetError());
      }
    }
    out
  }
  static glGetQueryIndexediv_p: APcv = ap_null();
  /// Tries to load [`glGetQueryIndexediv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetQueryIndexediv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetQueryIndexediv\0");
    glGetQueryIndexediv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetQueryIndexediv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryIndexediv_is_loaded() -> bool {
    !glGetQueryIndexediv_p.load(RELAX).is_null()
  }

  /// [glGetQueryObjecti64v](http://docs.gl/gl4/glGetQueryObjecti64v)(id, pname, params)
  /// * `pname` group: QueryObjectParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryObjecti64v(
    id: GLuint,
    pname: GLenum,
    params: *mut GLint64,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryObjecti64v({:?}, {:#X}, {:p});",
        id,
        pname,
        params
      );
    }
    let p = glGetQueryObjecti64v_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint64)>>(p) {
        Some(fn_p) => fn_p(id, pname, params),
        None => go_panic_because_fn_not_loaded("glGetQueryObjecti64v"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetQueryObjecti64v" != "glGetError" {
        report_error_as_necessary_from("glGetQueryObjecti64v", glGetError());
      }
    }
    out
  }
  static glGetQueryObjecti64v_p: APcv = ap_null();
  /// Tries to load [`glGetQueryObjecti64v`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetQueryObjecti64v_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetQueryObjecti64v\0");
    glGetQueryObjecti64v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetQueryObjecti64v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryObjecti64v_is_loaded() -> bool {
    !glGetQueryObjecti64v_p.load(RELAX).is_null()
  }

  /// [glGetQueryObjectiv](http://docs.gl/gl4/glGetQueryObjectiv)(id, pname, params)
  /// * `pname` group: QueryObjectParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryObjectiv(
    id: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryObjectiv({:?}, {:#X}, {:p});",
        id,
        pname,
        params
      );
    }
    let p = glGetQueryObjectiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(id, pname, params),
        None => go_panic_because_fn_not_loaded("glGetQueryObjectiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetQueryObjectiv" != "glGetError" {
        report_error_as_necessary_from("glGetQueryObjectiv", glGetError());
      }
    }
    out
  }
  static glGetQueryObjectiv_p: APcv = ap_null();
  /// Tries to load [`glGetQueryObjectiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetQueryObjectiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetQueryObjectiv\0");
    glGetQueryObjectiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetQueryObjectiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryObjectiv_is_loaded() -> bool {
    !glGetQueryObjectiv_p.load(RELAX).is_null()
  }

  /// [glGetQueryObjectui64v](http://docs.gl/gl4/glGetQueryObjectui64v)(id, pname, params)
  /// * `pname` group: QueryObjectParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryObjectui64v(
    id: GLuint,
    pname: GLenum,
    params: *mut GLuint64,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryObjectui64v({:?}, {:#X}, {:p});",
        id,
        pname,
        params
      );
    }
    let p = glGetQueryObjectui64v_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLuint64)>>(p) {
        Some(fn_p) => fn_p(id, pname, params),
        None => go_panic_because_fn_not_loaded("glGetQueryObjectui64v"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetQueryObjectui64v" != "glGetError" {
        report_error_as_necessary_from("glGetQueryObjectui64v", glGetError());
      }
    }
    out
  }
  static glGetQueryObjectui64v_p: APcv = ap_null();
  /// Tries to load [`glGetQueryObjectui64v`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetQueryObjectui64v_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetQueryObjectui64v\0");
    glGetQueryObjectui64v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetQueryObjectui64v`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryObjectui64v_is_loaded() -> bool {
    !glGetQueryObjectui64v_p.load(RELAX).is_null()
  }

  /// [glGetQueryObjectuiv](http://docs.gl/gl4/glGetQueryObjectuiv)(id, pname, params)
  /// * `pname` group: QueryObjectParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryObjectuiv(
    id: GLuint,
    pname: GLenum,
    params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryObjectuiv({:?}, {:#X}, {:p});",
        id,
        pname,
        params
      );
    }
    let p = glGetQueryObjectuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(id, pname, params),
        None => go_panic_because_fn_not_loaded("glGetQueryObjectuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetQueryObjectuiv" != "glGetError" {
        report_error_as_necessary_from("glGetQueryObjectuiv", glGetError());
      }
    }
    out
  }
  static glGetQueryObjectuiv_p: APcv = ap_null();
  /// Tries to load [`glGetQueryObjectuiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetQueryObjectuiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetQueryObjectuiv\0");
    glGetQueryObjectuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetQueryObjectuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryObjectuiv_is_loaded() -> bool {
    !glGetQueryObjectuiv_p.load(RELAX).is_null()
  }

  /// [glGetQueryiv](http://docs.gl/gl4/glGetQueryiv)(target, pname, params)
  /// * `target` group: QueryTarget
  /// * `pname` group: QueryParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetQueryiv(
    target: GLenum,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetQueryiv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glGetQueryiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glGetQueryiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetQueryiv" != "glGetError" {
        report_error_as_necessary_from("glGetQueryiv", glGetError());
      }
    }
    out
  }
  static glGetQueryiv_p: APcv = ap_null();
  /// Tries to load [`glGetQueryiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetQueryiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetQueryiv\0");
    glGetQueryiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetQueryiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetQueryiv_is_loaded() -> bool {
    !glGetQueryiv_p.load(RELAX).is_null()
  }

  /// [glGetRenderbufferParameteriv](http://docs.gl/gl4/glGetRenderbufferParameteriv)(target, pname, params)
  /// * `target` group: RenderbufferTarget
  /// * `pname` group: RenderbufferParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetRenderbufferParameteriv(
    target: GLenum,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetRenderbufferParameteriv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glGetRenderbufferParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glGetRenderbufferParameteriv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetRenderbufferParameteriv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetRenderbufferParameteriv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetRenderbufferParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetRenderbufferParameteriv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetRenderbufferParameteriv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetRenderbufferParameteriv\0");
    glGetRenderbufferParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetRenderbufferParameteriv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetRenderbufferParameteriv_is_loaded() -> bool {
    !glGetRenderbufferParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetSamplerParameterIiv](http://docs.gl/gl4/glGetSamplerParameterIiv)(sampler, pname, params)
  /// * `pname` group: SamplerParameterI
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetSamplerParameterIiv(
    sampler: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetSamplerParameterIiv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        params
      );
    }
    let p = glGetSamplerParameterIiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(sampler, pname, params),
        None => go_panic_because_fn_not_loaded("glGetSamplerParameterIiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetSamplerParameterIiv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetSamplerParameterIiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetSamplerParameterIiv_p: APcv = ap_null();
  /// Tries to load [`glGetSamplerParameterIiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetSamplerParameterIiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetSamplerParameterIiv\0");
    glGetSamplerParameterIiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetSamplerParameterIiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetSamplerParameterIiv_is_loaded() -> bool {
    !glGetSamplerParameterIiv_p.load(RELAX).is_null()
  }

  /// [glGetSamplerParameterIuiv](http://docs.gl/gl4/glGetSamplerParameterIuiv)(sampler, pname, params)
  /// * `pname` group: SamplerParameterI
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetSamplerParameterIuiv(
    sampler: GLuint,
    pname: GLenum,
    params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetSamplerParameterIuiv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        params
      );
    }
    let p = glGetSamplerParameterIuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(sampler, pname, params),
        None => go_panic_because_fn_not_loaded("glGetSamplerParameterIuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetSamplerParameterIuiv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetSamplerParameterIuiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetSamplerParameterIuiv_p: APcv = ap_null();
  /// Tries to load [`glGetSamplerParameterIuiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetSamplerParameterIuiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetSamplerParameterIuiv\0");
    glGetSamplerParameterIuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetSamplerParameterIuiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetSamplerParameterIuiv_is_loaded() -> bool {
    !glGetSamplerParameterIuiv_p.load(RELAX).is_null()
  }

  /// [glGetSamplerParameterfv](http://docs.gl/gl4/glGetSamplerParameterfv)(sampler, pname, params)
  /// * `pname` group: SamplerParameterF
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetSamplerParameterfv(
    sampler: GLuint,
    pname: GLenum,
    params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetSamplerParameterfv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        params
      );
    }
    let p = glGetSamplerParameterfv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLfloat)>>(p) {
        Some(fn_p) => fn_p(sampler, pname, params),
        None => go_panic_because_fn_not_loaded("glGetSamplerParameterfv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetSamplerParameterfv" != "glGetError" {
        report_error_as_necessary_from("glGetSamplerParameterfv", glGetError());
      }
    }
    out
  }
  static glGetSamplerParameterfv_p: APcv = ap_null();
  /// Tries to load [`glGetSamplerParameterfv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetSamplerParameterfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetSamplerParameterfv\0");
    glGetSamplerParameterfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetSamplerParameterfv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetSamplerParameterfv_is_loaded() -> bool {
    !glGetSamplerParameterfv_p.load(RELAX).is_null()
  }

  /// [glGetSamplerParameteriv](http://docs.gl/gl4/glGetSamplerParameteriv)(sampler, pname, params)
  /// * `pname` group: SamplerParameterI
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetSamplerParameteriv(
    sampler: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetSamplerParameteriv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        params
      );
    }
    let p = glGetSamplerParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(sampler, pname, params),
        None => go_panic_because_fn_not_loaded("glGetSamplerParameteriv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetSamplerParameteriv" != "glGetError" {
        report_error_as_necessary_from("glGetSamplerParameteriv", glGetError());
      }
    }
    out
  }
  static glGetSamplerParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetSamplerParameteriv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetSamplerParameteriv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetSamplerParameteriv\0");
    glGetSamplerParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetSamplerParameteriv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetSamplerParameteriv_is_loaded() -> bool {
    !glGetSamplerParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetShaderInfoLog](http://docs.gl/gl4/glGetShaderInfoLog)(shader, bufSize, length, infoLog)
  /// * `length` len: 1
  /// * `infoLog` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetShaderInfoLog(
    shader: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    infoLog: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetShaderInfoLog({:?}, {:?}, {:p}, {:p});",
        shader,
        bufSize,
        length,
        infoLog
      );
    }
    let p = glGetShaderInfoLog_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar)>,
    >(p)
    {
      Some(fn_p) => fn_p(shader, bufSize, length, infoLog),
      None => go_panic_because_fn_not_loaded("glGetShaderInfoLog"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetShaderInfoLog" != "glGetError" {
        report_error_as_necessary_from("glGetShaderInfoLog", glGetError());
      }
    }
    out
  }
  static glGetShaderInfoLog_p: APcv = ap_null();
  /// Tries to load [`glGetShaderInfoLog`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetShaderInfoLog_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetShaderInfoLog\0");
    glGetShaderInfoLog_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetShaderInfoLog`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetShaderInfoLog_is_loaded() -> bool {
    !glGetShaderInfoLog_p.load(RELAX).is_null()
  }

  /// [glGetShaderPrecisionFormat](http://docs.gl/gl4/glGetShaderPrecisionFormat)(shadertype, precisiontype, range, precision)
  /// * `shadertype` group: ShaderType
  /// * `precisiontype` group: PrecisionType
  /// * `range` len: 2
  /// * `precision` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetShaderPrecisionFormat(
    shadertype: GLenum,
    precisiontype: GLenum,
    range: *mut GLint,
    precision: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetShaderPrecisionFormat({:#X}, {:#X}, {:p}, {:p});",
        shadertype,
        precisiontype,
        range,
        precision
      );
    }
    let p = glGetShaderPrecisionFormat_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLenum, *mut GLint, *mut GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(shadertype, precisiontype, range, precision),
      None => go_panic_because_fn_not_loaded("glGetShaderPrecisionFormat"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetShaderPrecisionFormat" != "glGetError" {
        report_error_as_necessary_from(
          "glGetShaderPrecisionFormat",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetShaderPrecisionFormat_p: APcv = ap_null();
  /// Tries to load [`glGetShaderPrecisionFormat`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetShaderPrecisionFormat_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetShaderPrecisionFormat\0");
    glGetShaderPrecisionFormat_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetShaderPrecisionFormat`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetShaderPrecisionFormat_is_loaded() -> bool {
    !glGetShaderPrecisionFormat_p.load(RELAX).is_null()
  }

  /// [glGetShaderSource](http://docs.gl/gl4/glGetShaderSource)(shader, bufSize, length, source)
  /// * `length` len: 1
  /// * `source` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetShaderSource(
    shader: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    source: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetShaderSource({:?}, {:?}, {:p}, {:p});",
        shader,
        bufSize,
        length,
        source
      );
    }
    let p = glGetShaderSource_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar)>,
    >(p)
    {
      Some(fn_p) => fn_p(shader, bufSize, length, source),
      None => go_panic_because_fn_not_loaded("glGetShaderSource"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetShaderSource" != "glGetError" {
        report_error_as_necessary_from("glGetShaderSource", glGetError());
      }
    }
    out
  }
  static glGetShaderSource_p: APcv = ap_null();
  /// Tries to load [`glGetShaderSource`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetShaderSource_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetShaderSource\0");
    glGetShaderSource_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetShaderSource`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetShaderSource_is_loaded() -> bool {
    !glGetShaderSource_p.load(RELAX).is_null()
  }

  /// [glGetShaderiv](http://docs.gl/gl4/glGetShaderiv)(shader, pname, params)
  /// * `pname` group: ShaderParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetShaderiv(
    shader: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetShaderiv({:?}, {:#X}, {:p});",
        shader,
        pname,
        params
      );
    }
    let p = glGetShaderiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(shader, pname, params),
        None => go_panic_because_fn_not_loaded("glGetShaderiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetShaderiv" != "glGetError" {
        report_error_as_necessary_from("glGetShaderiv", glGetError());
      }
    }
    out
  }
  static glGetShaderiv_p: APcv = ap_null();
  /// Tries to load [`glGetShaderiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetShaderiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetShaderiv\0");
    glGetShaderiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetShaderiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetShaderiv_is_loaded() -> bool {
    !glGetShaderiv_p.load(RELAX).is_null()
  }

  /// [glGetString](http://docs.gl/gl4/glGetString)(name)
  /// * `name` group: StringName
  /// * return value group: String
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetString(name: GLenum) -> *const GLubyte {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetString({:#X});", name);
    }
    let p = glGetString_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum) -> *const GLubyte>>(p)
    {
      Some(fn_p) => fn_p(name),
      None => go_panic_because_fn_not_loaded("glGetString"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetString" != "glGetError" {
        report_error_as_necessary_from("glGetString", glGetError());
      }
    }
    out
  }
  static glGetString_p: APcv = ap_null();
  /// Tries to load [`glGetString`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetString_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetString\0");
    glGetString_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetString`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetString_is_loaded() -> bool {
    !glGetString_p.load(RELAX).is_null()
  }

  /// [glGetStringi](http://docs.gl/gl4/glGetStringi)(name, index)
  /// * `name` group: StringName
  /// * return value group: String
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetStringi(name: GLenum, index: GLuint) -> *const GLubyte {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetStringi({:#X}, {:?});", name, index);
    }
    let p = glGetStringi_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLuint) -> *const GLubyte>>(p)
      {
        Some(fn_p) => fn_p(name, index),
        None => go_panic_because_fn_not_loaded("glGetStringi"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetStringi" != "glGetError" {
        report_error_as_necessary_from("glGetStringi", glGetError());
      }
    }
    out
  }
  static glGetStringi_p: APcv = ap_null();
  /// Tries to load [`glGetStringi`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetStringi_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetStringi\0");
    glGetStringi_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetStringi`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetStringi_is_loaded() -> bool {
    !glGetStringi_p.load(RELAX).is_null()
  }

  /// [glGetSubroutineIndex](http://docs.gl/gl4/glGetSubroutineIndex)(program, shadertype, name)
  /// * `shadertype` group: ShaderType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetSubroutineIndex(
    program: GLuint,
    shadertype: GLenum,
    name: *const GLchar,
  ) -> GLuint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetSubroutineIndex({:?}, {:#X}, {:p});",
        program,
        shadertype,
        name
      );
    }
    let p = glGetSubroutineIndex_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, *const GLchar) -> GLuint>,
    >(p)
    {
      Some(fn_p) => fn_p(program, shadertype, name),
      None => go_panic_because_fn_not_loaded("glGetSubroutineIndex"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetSubroutineIndex" != "glGetError" {
        report_error_as_necessary_from("glGetSubroutineIndex", glGetError());
      }
    }
    out
  }
  static glGetSubroutineIndex_p: APcv = ap_null();
  /// Tries to load [`glGetSubroutineIndex`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetSubroutineIndex_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetSubroutineIndex\0");
    glGetSubroutineIndex_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetSubroutineIndex`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetSubroutineIndex_is_loaded() -> bool {
    !glGetSubroutineIndex_p.load(RELAX).is_null()
  }

  /// [glGetSubroutineUniformLocation](http://docs.gl/gl4/glGetSubroutineUniformLocation)(program, shadertype, name)
  /// * `shadertype` group: ShaderType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetSubroutineUniformLocation(
    program: GLuint,
    shadertype: GLenum,
    name: *const GLchar,
  ) -> GLint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetSubroutineUniformLocation({:?}, {:#X}, {:p});",
        program,
        shadertype,
        name
      );
    }
    let p = glGetSubroutineUniformLocation_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint>,
    >(p)
    {
      Some(fn_p) => fn_p(program, shadertype, name),
      None => go_panic_because_fn_not_loaded("glGetSubroutineUniformLocation"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetSubroutineUniformLocation" != "glGetError" {
        report_error_as_necessary_from(
          "glGetSubroutineUniformLocation",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetSubroutineUniformLocation_p: APcv = ap_null();
  /// Tries to load [`glGetSubroutineUniformLocation`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetSubroutineUniformLocation_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetSubroutineUniformLocation\0");
    glGetSubroutineUniformLocation_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetSubroutineUniformLocation`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetSubroutineUniformLocation_is_loaded() -> bool {
    !glGetSubroutineUniformLocation_p.load(RELAX).is_null()
  }

  /// [glGetSynciv](http://docs.gl/gl4/glGetSynciv)(sync, pname, count, length, values)
  /// * `sync` group: sync
  /// * `pname` group: SyncParameterName
  /// * `length` len: 1
  /// * `values` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetSynciv(
    sync: GLsync,
    pname: GLenum,
    count: GLsizei,
    length: *mut GLsizei,
    values: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetSynciv({:p}, {:#X}, {:?}, {:p}, {:p});",
        sync,
        pname,
        count,
        length,
        values
      );
    }
    let p = glGetSynciv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLsync, GLenum, GLsizei, *mut GLsizei, *mut GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(sync, pname, count, length, values),
      None => go_panic_because_fn_not_loaded("glGetSynciv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetSynciv" != "glGetError" {
        report_error_as_necessary_from("glGetSynciv", glGetError());
      }
    }
    out
  }
  static glGetSynciv_p: APcv = ap_null();
  /// Tries to load [`glGetSynciv`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetSynciv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetSynciv\0");
    glGetSynciv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetSynciv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetSynciv_is_loaded() -> bool {
    !glGetSynciv_p.load(RELAX).is_null()
  }

  /// [glGetTexImage](http://docs.gl/gl4/glGetTexImage)(target, level, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(target,level,format,type)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexImage(
    target: GLenum,
    level: GLint,
    format: GLenum,
    type_: GLenum,
    pixels: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexImage({:#X}, {:?}, {:#X}, {:#X}, {:p});",
        target,
        level,
        format,
        type_,
        pixels
      );
    }
    let p = glGetTexImage_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLint, GLenum, GLenum, *mut c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, level, format, type_, pixels),
      None => go_panic_because_fn_not_loaded("glGetTexImage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTexImage" != "glGetError" {
        report_error_as_necessary_from("glGetTexImage", glGetError());
      }
    }
    out
  }
  static glGetTexImage_p: APcv = ap_null();
  /// Tries to load [`glGetTexImage`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTexImage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTexImage\0");
    glGetTexImage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTexImage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexImage_is_loaded() -> bool {
    !glGetTexImage_p.load(RELAX).is_null()
  }

  /// [glGetTexLevelParameterfv](http://docs.gl/gl4/glGetTexLevelParameterfv)(target, level, pname, params)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `pname` group: GetTextureParameter
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexLevelParameterfv(
    target: GLenum,
    level: GLint,
    pname: GLenum,
    params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexLevelParameterfv({:#X}, {:?}, {:#X}, {:p});",
        target,
        level,
        pname,
        params
      );
    }
    let p = glGetTexLevelParameterfv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLint, GLenum, *mut GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, level, pname, params),
      None => go_panic_because_fn_not_loaded("glGetTexLevelParameterfv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTexLevelParameterfv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetTexLevelParameterfv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetTexLevelParameterfv_p: APcv = ap_null();
  /// Tries to load [`glGetTexLevelParameterfv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTexLevelParameterfv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTexLevelParameterfv\0");
    glGetTexLevelParameterfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTexLevelParameterfv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexLevelParameterfv_is_loaded() -> bool {
    !glGetTexLevelParameterfv_p.load(RELAX).is_null()
  }

  /// [glGetTexLevelParameteriv](http://docs.gl/gl4/glGetTexLevelParameteriv)(target, level, pname, params)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `pname` group: GetTextureParameter
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexLevelParameteriv(
    target: GLenum,
    level: GLint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexLevelParameteriv({:#X}, {:?}, {:#X}, {:p});",
        target,
        level,
        pname,
        params
      );
    }
    let p = glGetTexLevelParameteriv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLint, GLenum, *mut GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, level, pname, params),
      None => go_panic_because_fn_not_loaded("glGetTexLevelParameteriv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTexLevelParameteriv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetTexLevelParameteriv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetTexLevelParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetTexLevelParameteriv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTexLevelParameteriv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTexLevelParameteriv\0");
    glGetTexLevelParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTexLevelParameteriv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexLevelParameteriv_is_loaded() -> bool {
    !glGetTexLevelParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetTexParameterIiv](http://docs.gl/gl4/glGetTexParameterIiv)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: GetTextureParameter
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexParameterIiv(
    target: GLenum,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexParameterIiv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glGetTexParameterIiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glGetTexParameterIiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTexParameterIiv" != "glGetError" {
        report_error_as_necessary_from("glGetTexParameterIiv", glGetError());
      }
    }
    out
  }
  static glGetTexParameterIiv_p: APcv = ap_null();
  /// Tries to load [`glGetTexParameterIiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTexParameterIiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTexParameterIiv\0");
    glGetTexParameterIiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTexParameterIiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexParameterIiv_is_loaded() -> bool {
    !glGetTexParameterIiv_p.load(RELAX).is_null()
  }

  /// [glGetTexParameterIuiv](http://docs.gl/gl4/glGetTexParameterIuiv)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: GetTextureParameter
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexParameterIuiv(
    target: GLenum,
    pname: GLenum,
    params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexParameterIuiv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glGetTexParameterIuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glGetTexParameterIuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTexParameterIuiv" != "glGetError" {
        report_error_as_necessary_from("glGetTexParameterIuiv", glGetError());
      }
    }
    out
  }
  static glGetTexParameterIuiv_p: APcv = ap_null();
  /// Tries to load [`glGetTexParameterIuiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTexParameterIuiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTexParameterIuiv\0");
    glGetTexParameterIuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTexParameterIuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexParameterIuiv_is_loaded() -> bool {
    !glGetTexParameterIuiv_p.load(RELAX).is_null()
  }

  /// [glGetTexParameterfv](http://docs.gl/gl4/glGetTexParameterfv)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: GetTextureParameter
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexParameterfv(
    target: GLenum,
    pname: GLenum,
    params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexParameterfv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glGetTexParameterfv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLfloat)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glGetTexParameterfv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTexParameterfv" != "glGetError" {
        report_error_as_necessary_from("glGetTexParameterfv", glGetError());
      }
    }
    out
  }
  static glGetTexParameterfv_p: APcv = ap_null();
  /// Tries to load [`glGetTexParameterfv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTexParameterfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTexParameterfv\0");
    glGetTexParameterfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTexParameterfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexParameterfv_is_loaded() -> bool {
    !glGetTexParameterfv_p.load(RELAX).is_null()
  }

  /// [glGetTexParameteriv](http://docs.gl/gl4/glGetTexParameteriv)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: GetTextureParameter
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTexParameteriv(
    target: GLenum,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTexParameteriv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glGetTexParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glGetTexParameteriv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTexParameteriv" != "glGetError" {
        report_error_as_necessary_from("glGetTexParameteriv", glGetError());
      }
    }
    out
  }
  static glGetTexParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetTexParameteriv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTexParameteriv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTexParameteriv\0");
    glGetTexParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTexParameteriv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTexParameteriv_is_loaded() -> bool {
    !glGetTexParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetTextureImage](http://docs.gl/gl4/glGetTextureImage)(texture, level, format, type_, bufSize, pixels)
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTextureImage(
    texture: GLuint,
    level: GLint,
    format: GLenum,
    type_: GLenum,
    bufSize: GLsizei,
    pixels: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTextureImage({:?}, {:?}, {:#X}, {:#X}, {:?}, {:p});",
        texture,
        level,
        format,
        type_,
        bufSize,
        pixels
      );
    }
    let p = glGetTextureImage_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(GLuint, GLint, GLenum, GLenum, GLsizei, *mut c_void),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(texture, level, format, type_, bufSize, pixels),
      None => go_panic_because_fn_not_loaded("glGetTextureImage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTextureImage" != "glGetError" {
        report_error_as_necessary_from("glGetTextureImage", glGetError());
      }
    }
    out
  }
  static glGetTextureImage_p: APcv = ap_null();
  /// Tries to load [`glGetTextureImage`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTextureImage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTextureImage\0");
    glGetTextureImage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTextureImage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTextureImage_is_loaded() -> bool {
    !glGetTextureImage_p.load(RELAX).is_null()
  }

  /// [glGetTextureLevelParameterfv](http://docs.gl/gl4/glGetTextureLevelParameterfv)(texture, level, pname, params)
  /// * `pname` group: GetTextureParameter
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTextureLevelParameterfv(
    texture: GLuint,
    level: GLint,
    pname: GLenum,
    params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTextureLevelParameterfv({:?}, {:?}, {:#X}, {:p});",
        texture,
        level,
        pname,
        params
      );
    }
    let p = glGetTextureLevelParameterfv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLenum, *mut GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(texture, level, pname, params),
      None => go_panic_because_fn_not_loaded("glGetTextureLevelParameterfv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTextureLevelParameterfv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetTextureLevelParameterfv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetTextureLevelParameterfv_p: APcv = ap_null();
  /// Tries to load [`glGetTextureLevelParameterfv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTextureLevelParameterfv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTextureLevelParameterfv\0");
    glGetTextureLevelParameterfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTextureLevelParameterfv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTextureLevelParameterfv_is_loaded() -> bool {
    !glGetTextureLevelParameterfv_p.load(RELAX).is_null()
  }

  /// [glGetTextureLevelParameteriv](http://docs.gl/gl4/glGetTextureLevelParameteriv)(texture, level, pname, params)
  /// * `pname` group: GetTextureParameter
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTextureLevelParameteriv(
    texture: GLuint,
    level: GLint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTextureLevelParameteriv({:?}, {:?}, {:#X}, {:p});",
        texture,
        level,
        pname,
        params
      );
    }
    let p = glGetTextureLevelParameteriv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLenum, *mut GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(texture, level, pname, params),
      None => go_panic_because_fn_not_loaded("glGetTextureLevelParameteriv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTextureLevelParameteriv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetTextureLevelParameteriv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetTextureLevelParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetTextureLevelParameteriv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTextureLevelParameteriv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTextureLevelParameteriv\0");
    glGetTextureLevelParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTextureLevelParameteriv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTextureLevelParameteriv_is_loaded() -> bool {
    !glGetTextureLevelParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetTextureParameterIiv](http://docs.gl/gl4/glGetTextureParameterIiv)(texture, pname, params)
  /// * `pname` group: GetTextureParameter
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTextureParameterIiv(
    texture: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTextureParameterIiv({:?}, {:#X}, {:p});",
        texture,
        pname,
        params
      );
    }
    let p = glGetTextureParameterIiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(texture, pname, params),
        None => go_panic_because_fn_not_loaded("glGetTextureParameterIiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTextureParameterIiv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetTextureParameterIiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetTextureParameterIiv_p: APcv = ap_null();
  /// Tries to load [`glGetTextureParameterIiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTextureParameterIiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTextureParameterIiv\0");
    glGetTextureParameterIiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTextureParameterIiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTextureParameterIiv_is_loaded() -> bool {
    !glGetTextureParameterIiv_p.load(RELAX).is_null()
  }

  /// [glGetTextureParameterIuiv](http://docs.gl/gl4/glGetTextureParameterIuiv)(texture, pname, params)
  /// * `pname` group: GetTextureParameter
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTextureParameterIuiv(
    texture: GLuint,
    pname: GLenum,
    params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTextureParameterIuiv({:?}, {:#X}, {:p});",
        texture,
        pname,
        params
      );
    }
    let p = glGetTextureParameterIuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(texture, pname, params),
        None => go_panic_because_fn_not_loaded("glGetTextureParameterIuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTextureParameterIuiv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetTextureParameterIuiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetTextureParameterIuiv_p: APcv = ap_null();
  /// Tries to load [`glGetTextureParameterIuiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTextureParameterIuiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTextureParameterIuiv\0");
    glGetTextureParameterIuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTextureParameterIuiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTextureParameterIuiv_is_loaded() -> bool {
    !glGetTextureParameterIuiv_p.load(RELAX).is_null()
  }

  /// [glGetTextureParameterfv](http://docs.gl/gl4/glGetTextureParameterfv)(texture, pname, params)
  /// * `pname` group: GetTextureParameter
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTextureParameterfv(
    texture: GLuint,
    pname: GLenum,
    params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTextureParameterfv({:?}, {:#X}, {:p});",
        texture,
        pname,
        params
      );
    }
    let p = glGetTextureParameterfv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLfloat)>>(p) {
        Some(fn_p) => fn_p(texture, pname, params),
        None => go_panic_because_fn_not_loaded("glGetTextureParameterfv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTextureParameterfv" != "glGetError" {
        report_error_as_necessary_from("glGetTextureParameterfv", glGetError());
      }
    }
    out
  }
  static glGetTextureParameterfv_p: APcv = ap_null();
  /// Tries to load [`glGetTextureParameterfv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTextureParameterfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTextureParameterfv\0");
    glGetTextureParameterfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTextureParameterfv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTextureParameterfv_is_loaded() -> bool {
    !glGetTextureParameterfv_p.load(RELAX).is_null()
  }

  /// [glGetTextureParameteriv](http://docs.gl/gl4/glGetTextureParameteriv)(texture, pname, params)
  /// * `pname` group: GetTextureParameter
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTextureParameteriv(
    texture: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTextureParameteriv({:?}, {:#X}, {:p});",
        texture,
        pname,
        params
      );
    }
    let p = glGetTextureParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(texture, pname, params),
        None => go_panic_because_fn_not_loaded("glGetTextureParameteriv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTextureParameteriv" != "glGetError" {
        report_error_as_necessary_from("glGetTextureParameteriv", glGetError());
      }
    }
    out
  }
  static glGetTextureParameteriv_p: APcv = ap_null();
  /// Tries to load [`glGetTextureParameteriv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTextureParameteriv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTextureParameteriv\0");
    glGetTextureParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTextureParameteriv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTextureParameteriv_is_loaded() -> bool {
    !glGetTextureParameteriv_p.load(RELAX).is_null()
  }

  /// [glGetTextureSubImage](http://docs.gl/gl4/glGetTextureSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, bufSize, pixels)
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTextureSubImage(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    zoffset: GLint,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
    format: GLenum,
    type_: GLenum,
    bufSize: GLsizei,
    pixels: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetTextureSubImage({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:?}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, bufSize, pixels);
    }
    let p = glGetTextureSubImage_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLsizei,
          GLenum,
          GLenum,
          GLsizei,
          *mut c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        texture, level, xoffset, yoffset, zoffset, width, height, depth,
        format, type_, bufSize, pixels,
      ),
      None => go_panic_because_fn_not_loaded("glGetTextureSubImage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTextureSubImage" != "glGetError" {
        report_error_as_necessary_from("glGetTextureSubImage", glGetError());
      }
    }
    out
  }
  static glGetTextureSubImage_p: APcv = ap_null();
  /// Tries to load [`glGetTextureSubImage`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTextureSubImage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTextureSubImage\0");
    glGetTextureSubImage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTextureSubImage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTextureSubImage_is_loaded() -> bool {
    !glGetTextureSubImage_p.load(RELAX).is_null()
  }

  /// [glGetTransformFeedbackVarying](http://docs.gl/gl4/glGetTransformFeedbackVarying)(program, index, bufSize, length, size, type_, name)
  /// * `length` len: 1
  /// * `size` len: 1
  /// * `type_` group: AttributeType
  /// * `type_` len: 1
  /// * `name` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTransformFeedbackVarying(
    program: GLuint,
    index: GLuint,
    bufSize: GLsizei,
    length: *mut GLsizei,
    size: *mut GLsizei,
    type_: *mut GLenum,
    name: *mut GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetTransformFeedbackVarying({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});", program, index, bufSize, length, size, type_, name);
    }
    let p = glGetTransformFeedbackVarying_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLuint,
          GLsizei,
          *mut GLsizei,
          *mut GLsizei,
          *mut GLenum,
          *mut GLchar,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(program, index, bufSize, length, size, type_, name),
      None => go_panic_because_fn_not_loaded("glGetTransformFeedbackVarying"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTransformFeedbackVarying" != "glGetError" {
        report_error_as_necessary_from(
          "glGetTransformFeedbackVarying",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetTransformFeedbackVarying_p: APcv = ap_null();
  /// Tries to load [`glGetTransformFeedbackVarying`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTransformFeedbackVarying_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTransformFeedbackVarying\0");
    glGetTransformFeedbackVarying_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTransformFeedbackVarying`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTransformFeedbackVarying_is_loaded() -> bool {
    !glGetTransformFeedbackVarying_p.load(RELAX).is_null()
  }

  /// [glGetTransformFeedbacki64_v](http://docs.gl/gl4/glGetTransformFeedbacki64_v)(xfb, pname, index, param)
  /// * `pname` group: TransformFeedbackPName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTransformFeedbacki64_v(
    xfb: GLuint,
    pname: GLenum,
    index: GLuint,
    param: *mut GLint64,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTransformFeedbacki64_v({:?}, {:#X}, {:?}, {:p});",
        xfb,
        pname,
        index,
        param
      );
    }
    let p = glGetTransformFeedbacki64_v_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLuint, *mut GLint64)>,
    >(p)
    {
      Some(fn_p) => fn_p(xfb, pname, index, param),
      None => go_panic_because_fn_not_loaded("glGetTransformFeedbacki64_v"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTransformFeedbacki64_v" != "glGetError" {
        report_error_as_necessary_from(
          "glGetTransformFeedbacki64_v",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetTransformFeedbacki64_v_p: APcv = ap_null();
  /// Tries to load [`glGetTransformFeedbacki64_v`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTransformFeedbacki64_v_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTransformFeedbacki64_v\0");
    glGetTransformFeedbacki64_v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTransformFeedbacki64_v`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTransformFeedbacki64_v_is_loaded() -> bool {
    !glGetTransformFeedbacki64_v_p.load(RELAX).is_null()
  }

  /// [glGetTransformFeedbacki_v](http://docs.gl/gl4/glGetTransformFeedbacki_v)(xfb, pname, index, param)
  /// * `pname` group: TransformFeedbackPName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTransformFeedbacki_v(
    xfb: GLuint,
    pname: GLenum,
    index: GLuint,
    param: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTransformFeedbacki_v({:?}, {:#X}, {:?}, {:p});",
        xfb,
        pname,
        index,
        param
      );
    }
    let p = glGetTransformFeedbacki_v_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, GLuint, *mut GLint)>>(
        p,
      ) {
        Some(fn_p) => fn_p(xfb, pname, index, param),
        None => go_panic_because_fn_not_loaded("glGetTransformFeedbacki_v"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTransformFeedbacki_v" != "glGetError" {
        report_error_as_necessary_from(
          "glGetTransformFeedbacki_v",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetTransformFeedbacki_v_p: APcv = ap_null();
  /// Tries to load [`glGetTransformFeedbacki_v`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTransformFeedbacki_v_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTransformFeedbacki_v\0");
    glGetTransformFeedbacki_v_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTransformFeedbacki_v`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTransformFeedbacki_v_is_loaded() -> bool {
    !glGetTransformFeedbacki_v_p.load(RELAX).is_null()
  }

  /// [glGetTransformFeedbackiv](http://docs.gl/gl4/glGetTransformFeedbackiv)(xfb, pname, param)
  /// * `pname` group: TransformFeedbackPName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetTransformFeedbackiv(
    xfb: GLuint,
    pname: GLenum,
    param: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetTransformFeedbackiv({:?}, {:#X}, {:p});",
        xfb,
        pname,
        param
      );
    }
    let p = glGetTransformFeedbackiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(xfb, pname, param),
        None => go_panic_because_fn_not_loaded("glGetTransformFeedbackiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetTransformFeedbackiv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetTransformFeedbackiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetTransformFeedbackiv_p: APcv = ap_null();
  /// Tries to load [`glGetTransformFeedbackiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetTransformFeedbackiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetTransformFeedbackiv\0");
    glGetTransformFeedbackiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetTransformFeedbackiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetTransformFeedbackiv_is_loaded() -> bool {
    !glGetTransformFeedbackiv_p.load(RELAX).is_null()
  }

  /// [glGetUniformBlockIndex](http://docs.gl/gl4/glGetUniformBlockIndex)(program, uniformBlockName)
  /// * `uniformBlockName` len: COMPSIZE()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformBlockIndex(
    program: GLuint,
    uniformBlockName: *const GLchar,
  ) -> GLuint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetUniformBlockIndex({:?}, {:p});",
        program,
        uniformBlockName
      );
    }
    let p = glGetUniformBlockIndex_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, *const GLchar) -> GLuint>,
    >(p)
    {
      Some(fn_p) => fn_p(program, uniformBlockName),
      None => go_panic_because_fn_not_loaded("glGetUniformBlockIndex"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetUniformBlockIndex" != "glGetError" {
        report_error_as_necessary_from("glGetUniformBlockIndex", glGetError());
      }
    }
    out
  }
  static glGetUniformBlockIndex_p: APcv = ap_null();
  /// Tries to load [`glGetUniformBlockIndex`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetUniformBlockIndex_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetUniformBlockIndex\0");
    glGetUniformBlockIndex_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetUniformBlockIndex`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformBlockIndex_is_loaded() -> bool {
    !glGetUniformBlockIndex_p.load(RELAX).is_null()
  }

  /// [glGetUniformIndices](http://docs.gl/gl4/glGetUniformIndices)(program, uniformCount, uniformNames, uniformIndices)
  /// * `uniformNames` len: COMPSIZE(uniformCount)
  /// * `uniformIndices` len: COMPSIZE(uniformCount)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformIndices(
    program: GLuint,
    uniformCount: GLsizei,
    uniformNames: *const *const GLchar,
    uniformIndices: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetUniformIndices({:?}, {:?}, {:p}, {:p});",
        program,
        uniformCount,
        uniformNames,
        uniformIndices
      );
    }
    let p = glGetUniformIndices_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizei, *const *const GLchar, *mut GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, uniformCount, uniformNames, uniformIndices),
      None => go_panic_because_fn_not_loaded("glGetUniformIndices"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetUniformIndices" != "glGetError" {
        report_error_as_necessary_from("glGetUniformIndices", glGetError());
      }
    }
    out
  }
  static glGetUniformIndices_p: APcv = ap_null();
  /// Tries to load [`glGetUniformIndices`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetUniformIndices_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetUniformIndices\0");
    glGetUniformIndices_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetUniformIndices`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformIndices_is_loaded() -> bool {
    !glGetUniformIndices_p.load(RELAX).is_null()
  }

  /// [glGetUniformLocation](http://docs.gl/gl4/glGetUniformLocation)(program, name)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformLocation(
    program: GLuint,
    name: *const GLchar,
  ) -> GLint {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glGetUniformLocation({:?}, {:p});", program, name);
    }
    let p = glGetUniformLocation_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, *const GLchar) -> GLint>>(p) {
        Some(fn_p) => fn_p(program, name),
        None => go_panic_because_fn_not_loaded("glGetUniformLocation"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetUniformLocation" != "glGetError" {
        report_error_as_necessary_from("glGetUniformLocation", glGetError());
      }
    }
    out
  }
  static glGetUniformLocation_p: APcv = ap_null();
  /// Tries to load [`glGetUniformLocation`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetUniformLocation_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetUniformLocation\0");
    glGetUniformLocation_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetUniformLocation`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformLocation_is_loaded() -> bool {
    !glGetUniformLocation_p.load(RELAX).is_null()
  }

  /// [glGetUniformSubroutineuiv](http://docs.gl/gl4/glGetUniformSubroutineuiv)(shadertype, location, params)
  /// * `shadertype` group: ShaderType
  /// * `params` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformSubroutineuiv(
    shadertype: GLenum,
    location: GLint,
    params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetUniformSubroutineuiv({:#X}, {:?}, {:p});",
        shadertype,
        location,
        params
      );
    }
    let p = glGetUniformSubroutineuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLint, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(shadertype, location, params),
        None => go_panic_because_fn_not_loaded("glGetUniformSubroutineuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetUniformSubroutineuiv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetUniformSubroutineuiv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetUniformSubroutineuiv_p: APcv = ap_null();
  /// Tries to load [`glGetUniformSubroutineuiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetUniformSubroutineuiv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetUniformSubroutineuiv\0");
    glGetUniformSubroutineuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetUniformSubroutineuiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformSubroutineuiv_is_loaded() -> bool {
    !glGetUniformSubroutineuiv_p.load(RELAX).is_null()
  }

  /// [glGetUniformdv](http://docs.gl/gl4/glGetUniformdv)(program, location, params)
  /// * `params` len: COMPSIZE(program,location)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformdv(
    program: GLuint,
    location: GLint,
    params: *mut GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetUniformdv({:?}, {:?}, {:p});",
        program,
        location,
        params
      );
    }
    let p = glGetUniformdv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLint, *mut GLdouble)>>(p) {
        Some(fn_p) => fn_p(program, location, params),
        None => go_panic_because_fn_not_loaded("glGetUniformdv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetUniformdv" != "glGetError" {
        report_error_as_necessary_from("glGetUniformdv", glGetError());
      }
    }
    out
  }
  static glGetUniformdv_p: APcv = ap_null();
  /// Tries to load [`glGetUniformdv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetUniformdv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetUniformdv\0");
    glGetUniformdv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetUniformdv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformdv_is_loaded() -> bool {
    !glGetUniformdv_p.load(RELAX).is_null()
  }

  /// [glGetUniformfv](http://docs.gl/gl4/glGetUniformfv)(program, location, params)
  /// * `params` len: COMPSIZE(program,location)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformfv(
    program: GLuint,
    location: GLint,
    params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetUniformfv({:?}, {:?}, {:p});",
        program,
        location,
        params
      );
    }
    let p = glGetUniformfv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLint, *mut GLfloat)>>(p) {
        Some(fn_p) => fn_p(program, location, params),
        None => go_panic_because_fn_not_loaded("glGetUniformfv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetUniformfv" != "glGetError" {
        report_error_as_necessary_from("glGetUniformfv", glGetError());
      }
    }
    out
  }
  static glGetUniformfv_p: APcv = ap_null();
  /// Tries to load [`glGetUniformfv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetUniformfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetUniformfv\0");
    glGetUniformfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetUniformfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformfv_is_loaded() -> bool {
    !glGetUniformfv_p.load(RELAX).is_null()
  }

  /// [glGetUniformiv](http://docs.gl/gl4/glGetUniformiv)(program, location, params)
  /// * `params` len: COMPSIZE(program,location)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformiv(
    program: GLuint,
    location: GLint,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetUniformiv({:?}, {:?}, {:p});",
        program,
        location,
        params
      );
    }
    let p = glGetUniformiv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLint, *mut GLint)>>(p)
    {
      Some(fn_p) => fn_p(program, location, params),
      None => go_panic_because_fn_not_loaded("glGetUniformiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetUniformiv" != "glGetError" {
        report_error_as_necessary_from("glGetUniformiv", glGetError());
      }
    }
    out
  }
  static glGetUniformiv_p: APcv = ap_null();
  /// Tries to load [`glGetUniformiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetUniformiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetUniformiv\0");
    glGetUniformiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetUniformiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformiv_is_loaded() -> bool {
    !glGetUniformiv_p.load(RELAX).is_null()
  }

  /// [glGetUniformuiv](http://docs.gl/gl4/glGetUniformuiv)(program, location, params)
  /// * `params` len: COMPSIZE(program,location)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetUniformuiv(
    program: GLuint,
    location: GLint,
    params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetUniformuiv({:?}, {:?}, {:p});",
        program,
        location,
        params
      );
    }
    let p = glGetUniformuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLint, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(program, location, params),
        None => go_panic_because_fn_not_loaded("glGetUniformuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetUniformuiv" != "glGetError" {
        report_error_as_necessary_from("glGetUniformuiv", glGetError());
      }
    }
    out
  }
  static glGetUniformuiv_p: APcv = ap_null();
  /// Tries to load [`glGetUniformuiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetUniformuiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetUniformuiv\0");
    glGetUniformuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetUniformuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetUniformuiv_is_loaded() -> bool {
    !glGetUniformuiv_p.load(RELAX).is_null()
  }

  /// [glGetVertexArrayIndexed64iv](http://docs.gl/gl4/glGetVertexArrayIndexed64iv)(vaobj, index, pname, param)
  /// * `pname` group: VertexArrayPName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexArrayIndexed64iv(
    vaobj: GLuint,
    index: GLuint,
    pname: GLenum,
    param: *mut GLint64,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexArrayIndexed64iv({:?}, {:?}, {:#X}, {:p});",
        vaobj,
        index,
        pname,
        param
      );
    }
    let p = glGetVertexArrayIndexed64iv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLuint, GLenum, *mut GLint64)>,
    >(p)
    {
      Some(fn_p) => fn_p(vaobj, index, pname, param),
      None => go_panic_because_fn_not_loaded("glGetVertexArrayIndexed64iv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetVertexArrayIndexed64iv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetVertexArrayIndexed64iv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetVertexArrayIndexed64iv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexArrayIndexed64iv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetVertexArrayIndexed64iv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetVertexArrayIndexed64iv\0");
    glGetVertexArrayIndexed64iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetVertexArrayIndexed64iv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexArrayIndexed64iv_is_loaded() -> bool {
    !glGetVertexArrayIndexed64iv_p.load(RELAX).is_null()
  }

  /// [glGetVertexArrayIndexediv](http://docs.gl/gl4/glGetVertexArrayIndexediv)(vaobj, index, pname, param)
  /// * `pname` group: VertexArrayPName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexArrayIndexediv(
    vaobj: GLuint,
    index: GLuint,
    pname: GLenum,
    param: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexArrayIndexediv({:?}, {:?}, {:#X}, {:p});",
        vaobj,
        index,
        pname,
        param
      );
    }
    let p = glGetVertexArrayIndexediv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLuint, GLenum, *mut GLint)>>(
        p,
      ) {
        Some(fn_p) => fn_p(vaobj, index, pname, param),
        None => go_panic_because_fn_not_loaded("glGetVertexArrayIndexediv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetVertexArrayIndexediv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetVertexArrayIndexediv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetVertexArrayIndexediv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexArrayIndexediv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetVertexArrayIndexediv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetVertexArrayIndexediv\0");
    glGetVertexArrayIndexediv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetVertexArrayIndexediv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexArrayIndexediv_is_loaded() -> bool {
    !glGetVertexArrayIndexediv_p.load(RELAX).is_null()
  }

  /// [glGetVertexArrayiv](http://docs.gl/gl4/glGetVertexArrayiv)(vaobj, pname, param)
  /// * `pname` group: VertexArrayPName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexArrayiv(
    vaobj: GLuint,
    pname: GLenum,
    param: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexArrayiv({:?}, {:#X}, {:p});",
        vaobj,
        pname,
        param
      );
    }
    let p = glGetVertexArrayiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(vaobj, pname, param),
        None => go_panic_because_fn_not_loaded("glGetVertexArrayiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetVertexArrayiv" != "glGetError" {
        report_error_as_necessary_from("glGetVertexArrayiv", glGetError());
      }
    }
    out
  }
  static glGetVertexArrayiv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexArrayiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetVertexArrayiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetVertexArrayiv\0");
    glGetVertexArrayiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetVertexArrayiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexArrayiv_is_loaded() -> bool {
    !glGetVertexArrayiv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribIiv](http://docs.gl/gl4/glGetVertexAttribIiv)(index, pname, params)
  /// * `pname` group: VertexAttribEnum
  /// * `params` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribIiv(
    index: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribIiv({:?}, {:#X}, {:p});",
        index,
        pname,
        params
      );
    }
    let p = glGetVertexAttribIiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(index, pname, params),
        None => go_panic_because_fn_not_loaded("glGetVertexAttribIiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetVertexAttribIiv" != "glGetError" {
        report_error_as_necessary_from("glGetVertexAttribIiv", glGetError());
      }
    }
    out
  }
  static glGetVertexAttribIiv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribIiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetVertexAttribIiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetVertexAttribIiv\0");
    glGetVertexAttribIiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetVertexAttribIiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribIiv_is_loaded() -> bool {
    !glGetVertexAttribIiv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribIuiv](http://docs.gl/gl4/glGetVertexAttribIuiv)(index, pname, params)
  /// * `pname` group: VertexAttribEnum
  /// * `params` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribIuiv(
    index: GLuint,
    pname: GLenum,
    params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribIuiv({:?}, {:#X}, {:p});",
        index,
        pname,
        params
      );
    }
    let p = glGetVertexAttribIuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(index, pname, params),
        None => go_panic_because_fn_not_loaded("glGetVertexAttribIuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetVertexAttribIuiv" != "glGetError" {
        report_error_as_necessary_from("glGetVertexAttribIuiv", glGetError());
      }
    }
    out
  }
  static glGetVertexAttribIuiv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribIuiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetVertexAttribIuiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetVertexAttribIuiv\0");
    glGetVertexAttribIuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetVertexAttribIuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribIuiv_is_loaded() -> bool {
    !glGetVertexAttribIuiv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribLdv](http://docs.gl/gl4/glGetVertexAttribLdv)(index, pname, params)
  /// * `pname` group: VertexAttribEnum
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribLdv(
    index: GLuint,
    pname: GLenum,
    params: *mut GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribLdv({:?}, {:#X}, {:p});",
        index,
        pname,
        params
      );
    }
    let p = glGetVertexAttribLdv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLdouble)>>(p) {
        Some(fn_p) => fn_p(index, pname, params),
        None => go_panic_because_fn_not_loaded("glGetVertexAttribLdv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetVertexAttribLdv" != "glGetError" {
        report_error_as_necessary_from("glGetVertexAttribLdv", glGetError());
      }
    }
    out
  }
  static glGetVertexAttribLdv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribLdv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetVertexAttribLdv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetVertexAttribLdv\0");
    glGetVertexAttribLdv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetVertexAttribLdv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribLdv_is_loaded() -> bool {
    !glGetVertexAttribLdv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribPointerv](http://docs.gl/gl4/glGetVertexAttribPointerv)(index, pname, pointer)
  /// * `pname` group: VertexAttribPointerPropertyARB
  /// * `pointer` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribPointerv(
    index: GLuint,
    pname: GLenum,
    pointer: *mut *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribPointerv({:?}, {:#X}, {:p});",
        index,
        pname,
        pointer
      );
    }
    let p = glGetVertexAttribPointerv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut *mut c_void)>>(p)
      {
        Some(fn_p) => fn_p(index, pname, pointer),
        None => go_panic_because_fn_not_loaded("glGetVertexAttribPointerv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetVertexAttribPointerv" != "glGetError" {
        report_error_as_necessary_from(
          "glGetVertexAttribPointerv",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetVertexAttribPointerv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribPointerv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetVertexAttribPointerv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetVertexAttribPointerv\0");
    glGetVertexAttribPointerv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetVertexAttribPointerv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribPointerv_is_loaded() -> bool {
    !glGetVertexAttribPointerv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribdv](http://docs.gl/gl4/glGetVertexAttribdv)(index, pname, params)
  /// * `pname` group: VertexAttribPropertyARB
  /// * `params` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribdv(
    index: GLuint,
    pname: GLenum,
    params: *mut GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribdv({:?}, {:#X}, {:p});",
        index,
        pname,
        params
      );
    }
    let p = glGetVertexAttribdv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLdouble)>>(p) {
        Some(fn_p) => fn_p(index, pname, params),
        None => go_panic_because_fn_not_loaded("glGetVertexAttribdv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetVertexAttribdv" != "glGetError" {
        report_error_as_necessary_from("glGetVertexAttribdv", glGetError());
      }
    }
    out
  }
  static glGetVertexAttribdv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribdv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetVertexAttribdv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetVertexAttribdv\0");
    glGetVertexAttribdv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetVertexAttribdv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribdv_is_loaded() -> bool {
    !glGetVertexAttribdv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribfv](http://docs.gl/gl4/glGetVertexAttribfv)(index, pname, params)
  /// * `pname` group: VertexAttribPropertyARB
  /// * `params` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribfv(
    index: GLuint,
    pname: GLenum,
    params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribfv({:?}, {:#X}, {:p});",
        index,
        pname,
        params
      );
    }
    let p = glGetVertexAttribfv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLfloat)>>(p) {
        Some(fn_p) => fn_p(index, pname, params),
        None => go_panic_because_fn_not_loaded("glGetVertexAttribfv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetVertexAttribfv" != "glGetError" {
        report_error_as_necessary_from("glGetVertexAttribfv", glGetError());
      }
    }
    out
  }
  static glGetVertexAttribfv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribfv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetVertexAttribfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetVertexAttribfv\0");
    glGetVertexAttribfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetVertexAttribfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribfv_is_loaded() -> bool {
    !glGetVertexAttribfv_p.load(RELAX).is_null()
  }

  /// [glGetVertexAttribiv](http://docs.gl/gl4/glGetVertexAttribiv)(index, pname, params)
  /// * `pname` group: VertexAttribPropertyARB
  /// * `params` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetVertexAttribiv(
    index: GLuint,
    pname: GLenum,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetVertexAttribiv({:?}, {:#X}, {:p});",
        index,
        pname,
        params
      );
    }
    let p = glGetVertexAttribiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(index, pname, params),
        None => go_panic_because_fn_not_loaded("glGetVertexAttribiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetVertexAttribiv" != "glGetError" {
        report_error_as_necessary_from("glGetVertexAttribiv", glGetError());
      }
    }
    out
  }
  static glGetVertexAttribiv_p: APcv = ap_null();
  /// Tries to load [`glGetVertexAttribiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetVertexAttribiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetVertexAttribiv\0");
    glGetVertexAttribiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetVertexAttribiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetVertexAttribiv_is_loaded() -> bool {
    !glGetVertexAttribiv_p.load(RELAX).is_null()
  }

  /// [glGetnCompressedTexImage](http://docs.gl/gl4/glGetnCompressedTexImage)(target, lod, bufSize, pixels)
  /// * `target` group: TextureTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetnCompressedTexImage(
    target: GLenum,
    lod: GLint,
    bufSize: GLsizei,
    pixels: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetnCompressedTexImage({:#X}, {:?}, {:?}, {:p});",
        target,
        lod,
        bufSize,
        pixels
      );
    }
    let p = glGetnCompressedTexImage_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLint, GLsizei, *mut c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, lod, bufSize, pixels),
      None => go_panic_because_fn_not_loaded("glGetnCompressedTexImage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetnCompressedTexImage" != "glGetError" {
        report_error_as_necessary_from(
          "glGetnCompressedTexImage",
          glGetError(),
        );
      }
    }
    out
  }
  static glGetnCompressedTexImage_p: APcv = ap_null();
  /// Tries to load [`glGetnCompressedTexImage`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetnCompressedTexImage_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glGetnCompressedTexImage\0");
    glGetnCompressedTexImage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetnCompressedTexImage`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetnCompressedTexImage_is_loaded() -> bool {
    !glGetnCompressedTexImage_p.load(RELAX).is_null()
  }

  /// [glGetnTexImage](http://docs.gl/gl4/glGetnTexImage)(target, level, format, type_, bufSize, pixels)
  /// * `target` group: TextureTarget
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetnTexImage(
    target: GLenum,
    level: GLint,
    format: GLenum,
    type_: GLenum,
    bufSize: GLsizei,
    pixels: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetnTexImage({:#X}, {:?}, {:#X}, {:#X}, {:?}, {:p});",
        target,
        level,
        format,
        type_,
        bufSize,
        pixels
      );
    }
    let p = glGetnTexImage_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(GLenum, GLint, GLenum, GLenum, GLsizei, *mut c_void),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(target, level, format, type_, bufSize, pixels),
      None => go_panic_because_fn_not_loaded("glGetnTexImage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetnTexImage" != "glGetError" {
        report_error_as_necessary_from("glGetnTexImage", glGetError());
      }
    }
    out
  }
  static glGetnTexImage_p: APcv = ap_null();
  /// Tries to load [`glGetnTexImage`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetnTexImage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetnTexImage\0");
    glGetnTexImage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetnTexImage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetnTexImage_is_loaded() -> bool {
    !glGetnTexImage_p.load(RELAX).is_null()
  }

  /// [glGetnUniformdv](http://docs.gl/gl4/glGetnUniformdv)(program, location, bufSize, params)
  /// * `params` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetnUniformdv(
    program: GLuint,
    location: GLint,
    bufSize: GLsizei,
    params: *mut GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetnUniformdv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        bufSize,
        params
      );
    }
    let p = glGetnUniformdv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *mut GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, bufSize, params),
      None => go_panic_because_fn_not_loaded("glGetnUniformdv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetnUniformdv" != "glGetError" {
        report_error_as_necessary_from("glGetnUniformdv", glGetError());
      }
    }
    out
  }
  static glGetnUniformdv_p: APcv = ap_null();
  /// Tries to load [`glGetnUniformdv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetnUniformdv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetnUniformdv\0");
    glGetnUniformdv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetnUniformdv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetnUniformdv_is_loaded() -> bool {
    !glGetnUniformdv_p.load(RELAX).is_null()
  }

  /// [glGetnUniformfv](http://docs.gl/gl4/glGetnUniformfv)(program, location, bufSize, params)
  /// * `params` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetnUniformfv(
    program: GLuint,
    location: GLint,
    bufSize: GLsizei,
    params: *mut GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetnUniformfv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        bufSize,
        params
      );
    }
    let p = glGetnUniformfv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *mut GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, bufSize, params),
      None => go_panic_because_fn_not_loaded("glGetnUniformfv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetnUniformfv" != "glGetError" {
        report_error_as_necessary_from("glGetnUniformfv", glGetError());
      }
    }
    out
  }
  static glGetnUniformfv_p: APcv = ap_null();
  /// Tries to load [`glGetnUniformfv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetnUniformfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetnUniformfv\0");
    glGetnUniformfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetnUniformfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetnUniformfv_is_loaded() -> bool {
    !glGetnUniformfv_p.load(RELAX).is_null()
  }

  /// [glGetnUniformiv](http://docs.gl/gl4/glGetnUniformiv)(program, location, bufSize, params)
  /// * `params` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetnUniformiv(
    program: GLuint,
    location: GLint,
    bufSize: GLsizei,
    params: *mut GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetnUniformiv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        bufSize,
        params
      );
    }
    let p = glGetnUniformiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLint, GLsizei, *mut GLint)>>(
        p,
      ) {
        Some(fn_p) => fn_p(program, location, bufSize, params),
        None => go_panic_because_fn_not_loaded("glGetnUniformiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetnUniformiv" != "glGetError" {
        report_error_as_necessary_from("glGetnUniformiv", glGetError());
      }
    }
    out
  }
  static glGetnUniformiv_p: APcv = ap_null();
  /// Tries to load [`glGetnUniformiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetnUniformiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetnUniformiv\0");
    glGetnUniformiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetnUniformiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetnUniformiv_is_loaded() -> bool {
    !glGetnUniformiv_p.load(RELAX).is_null()
  }

  /// [glGetnUniformuiv](http://docs.gl/gl4/glGetnUniformuiv)(program, location, bufSize, params)
  /// * `params` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glGetnUniformuiv(
    program: GLuint,
    location: GLint,
    bufSize: GLsizei,
    params: *mut GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glGetnUniformuiv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        bufSize,
        params
      );
    }
    let p = glGetnUniformuiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *mut GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, bufSize, params),
      None => go_panic_because_fn_not_loaded("glGetnUniformuiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glGetnUniformuiv" != "glGetError" {
        report_error_as_necessary_from("glGetnUniformuiv", glGetError());
      }
    }
    out
  }
  static glGetnUniformuiv_p: APcv = ap_null();
  /// Tries to load [`glGetnUniformuiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glGetnUniformuiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glGetnUniformuiv\0");
    glGetnUniformuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glGetnUniformuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glGetnUniformuiv_is_loaded() -> bool {
    !glGetnUniformuiv_p.load(RELAX).is_null()
  }

  /// [glHint](http://docs.gl/gl4/glHint)(target, mode)
  /// * `target` group: HintTarget
  /// * `mode` group: HintMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glHint(target: GLenum, mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glHint({:#X}, {:#X});", target, mode);
    }
    let p = glHint_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLenum)>>(p) {
      Some(fn_p) => fn_p(target, mode),
      None => go_panic_because_fn_not_loaded("glHint"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glHint" != "glGetError" {
        report_error_as_necessary_from("glHint", glGetError());
      }
    }
    out
  }
  static glHint_p: APcv = ap_null();
  /// Tries to load [`glHint`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glHint_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glHint\0");
    glHint_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glHint`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glHint_is_loaded() -> bool {
    !glHint_p.load(RELAX).is_null()
  }

  /// [glInvalidateBufferData](http://docs.gl/gl4/glInvalidateBufferData)(buffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glInvalidateBufferData(buffer: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glInvalidateBufferData({:?});", buffer);
    }
    let p = glInvalidateBufferData_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(buffer),
      None => go_panic_because_fn_not_loaded("glInvalidateBufferData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glInvalidateBufferData" != "glGetError" {
        report_error_as_necessary_from("glInvalidateBufferData", glGetError());
      }
    }
    out
  }
  static glInvalidateBufferData_p: APcv = ap_null();
  /// Tries to load [`glInvalidateBufferData`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glInvalidateBufferData_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glInvalidateBufferData\0");
    glInvalidateBufferData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glInvalidateBufferData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glInvalidateBufferData_is_loaded() -> bool {
    !glInvalidateBufferData_p.load(RELAX).is_null()
  }

  /// [glInvalidateBufferSubData](http://docs.gl/gl4/glInvalidateBufferSubData)(buffer, offset, length)
  /// * `offset` group: BufferOffset
  /// * `length` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glInvalidateBufferSubData(
    buffer: GLuint,
    offset: GLintptr,
    length: GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glInvalidateBufferSubData({:?}, {:?}, {:?});",
        buffer,
        offset,
        length
      );
    }
    let p = glInvalidateBufferSubData_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLintptr, GLsizeiptr)>>(p) {
        Some(fn_p) => fn_p(buffer, offset, length),
        None => go_panic_because_fn_not_loaded("glInvalidateBufferSubData"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glInvalidateBufferSubData" != "glGetError" {
        report_error_as_necessary_from(
          "glInvalidateBufferSubData",
          glGetError(),
        );
      }
    }
    out
  }
  static glInvalidateBufferSubData_p: APcv = ap_null();
  /// Tries to load [`glInvalidateBufferSubData`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glInvalidateBufferSubData_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glInvalidateBufferSubData\0");
    glInvalidateBufferSubData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glInvalidateBufferSubData`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glInvalidateBufferSubData_is_loaded() -> bool {
    !glInvalidateBufferSubData_p.load(RELAX).is_null()
  }

  /// [glInvalidateFramebuffer](http://docs.gl/gl4/glInvalidateFramebuffer)(target, numAttachments, attachments)
  /// * `target` group: FramebufferTarget
  /// * `attachments` group: InvalidateFramebufferAttachment
  /// * `attachments` len: numAttachments
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glInvalidateFramebuffer(
    target: GLenum,
    numAttachments: GLsizei,
    attachments: *const GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glInvalidateFramebuffer({:#X}, {:?}, {:p});",
        target,
        numAttachments,
        attachments
      );
    }
    let p = glInvalidateFramebuffer_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLsizei, *const GLenum)>>(p) {
        Some(fn_p) => fn_p(target, numAttachments, attachments),
        None => go_panic_because_fn_not_loaded("glInvalidateFramebuffer"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glInvalidateFramebuffer" != "glGetError" {
        report_error_as_necessary_from("glInvalidateFramebuffer", glGetError());
      }
    }
    out
  }
  static glInvalidateFramebuffer_p: APcv = ap_null();
  /// Tries to load [`glInvalidateFramebuffer`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glInvalidateFramebuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glInvalidateFramebuffer\0");
    glInvalidateFramebuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glInvalidateFramebuffer`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glInvalidateFramebuffer_is_loaded() -> bool {
    !glInvalidateFramebuffer_p.load(RELAX).is_null()
  }

  /// [glInvalidateNamedFramebufferData](http://docs.gl/gl4/glInvalidateNamedFramebufferData)(framebuffer, numAttachments, attachments)
  /// * `attachments` group: FramebufferAttachment
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glInvalidateNamedFramebufferData(
    framebuffer: GLuint,
    numAttachments: GLsizei,
    attachments: *const GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glInvalidateNamedFramebufferData({:?}, {:?}, {:p});",
        framebuffer,
        numAttachments,
        attachments
      );
    }
    let p = glInvalidateNamedFramebufferData_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLsizei, *const GLenum)>>(p) {
        Some(fn_p) => fn_p(framebuffer, numAttachments, attachments),
        None => {
          go_panic_because_fn_not_loaded("glInvalidateNamedFramebufferData")
        }
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glInvalidateNamedFramebufferData" != "glGetError" {
        report_error_as_necessary_from(
          "glInvalidateNamedFramebufferData",
          glGetError(),
        );
      }
    }
    out
  }
  static glInvalidateNamedFramebufferData_p: APcv = ap_null();
  /// Tries to load [`glInvalidateNamedFramebufferData`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glInvalidateNamedFramebufferData_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glInvalidateNamedFramebufferData\0");
    glInvalidateNamedFramebufferData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glInvalidateNamedFramebufferData`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glInvalidateNamedFramebufferData_is_loaded() -> bool {
    !glInvalidateNamedFramebufferData_p.load(RELAX).is_null()
  }

  /// [glInvalidateNamedFramebufferSubData](http://docs.gl/gl4/glInvalidateNamedFramebufferSubData)(framebuffer, numAttachments, attachments, x, y, width, height)
  /// * `attachments` group: FramebufferAttachment
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glInvalidateNamedFramebufferSubData(
    framebuffer: GLuint,
    numAttachments: GLsizei,
    attachments: *const GLenum,
    x: GLint,
    y: GLint,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glInvalidateNamedFramebufferSubData({:?}, {:?}, {:p}, {:?}, {:?}, {:?}, {:?});", framebuffer, numAttachments, attachments, x, y, width, height);
    }
    let p = glInvalidateNamedFramebufferSubData_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLsizei,
          *const GLenum,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(framebuffer, numAttachments, attachments, x, y, width, height)
      }
      None => {
        go_panic_because_fn_not_loaded("glInvalidateNamedFramebufferSubData")
      }
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glInvalidateNamedFramebufferSubData" != "glGetError" {
        report_error_as_necessary_from(
          "glInvalidateNamedFramebufferSubData",
          glGetError(),
        );
      }
    }
    out
  }
  static glInvalidateNamedFramebufferSubData_p: APcv = ap_null();
  /// Tries to load [`glInvalidateNamedFramebufferSubData`], returns if a
  /// non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glInvalidateNamedFramebufferSubData_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glInvalidateNamedFramebufferSubData\0");
    glInvalidateNamedFramebufferSubData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glInvalidateNamedFramebufferSubData`] is
  /// loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glInvalidateNamedFramebufferSubData_is_loaded() -> bool {
    !glInvalidateNamedFramebufferSubData_p.load(RELAX).is_null()
  }

  /// [glInvalidateSubFramebuffer](http://docs.gl/gl4/glInvalidateSubFramebuffer)(target, numAttachments, attachments, x, y, width, height)
  /// * `target` group: FramebufferTarget
  /// * `attachments` group: InvalidateFramebufferAttachment
  /// * `attachments` len: numAttachments
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glInvalidateSubFramebuffer(
    target: GLenum,
    numAttachments: GLsizei,
    attachments: *const GLenum,
    x: GLint,
    y: GLint,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glInvalidateSubFramebuffer({:#X}, {:?}, {:p}, {:?}, {:?}, {:?}, {:?});", target, numAttachments, attachments, x, y, width, height);
    }
    let p = glInvalidateSubFramebuffer_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLsizei,
          *const GLenum,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(target, numAttachments, attachments, x, y, width, height)
      }
      None => go_panic_because_fn_not_loaded("glInvalidateSubFramebuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glInvalidateSubFramebuffer" != "glGetError" {
        report_error_as_necessary_from(
          "glInvalidateSubFramebuffer",
          glGetError(),
        );
      }
    }
    out
  }
  static glInvalidateSubFramebuffer_p: APcv = ap_null();
  /// Tries to load [`glInvalidateSubFramebuffer`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glInvalidateSubFramebuffer_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glInvalidateSubFramebuffer\0");
    glInvalidateSubFramebuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glInvalidateSubFramebuffer`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glInvalidateSubFramebuffer_is_loaded() -> bool {
    !glInvalidateSubFramebuffer_p.load(RELAX).is_null()
  }

  /// [glInvalidateTexImage](http://docs.gl/gl4/glInvalidateTexImage)(texture, level)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glInvalidateTexImage(texture: GLuint, level: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glInvalidateTexImage({:?}, {:?});", texture, level);
    }
    let p = glInvalidateTexImage_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLint)>>(p) {
      Some(fn_p) => fn_p(texture, level),
      None => go_panic_because_fn_not_loaded("glInvalidateTexImage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glInvalidateTexImage" != "glGetError" {
        report_error_as_necessary_from("glInvalidateTexImage", glGetError());
      }
    }
    out
  }
  static glInvalidateTexImage_p: APcv = ap_null();
  /// Tries to load [`glInvalidateTexImage`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glInvalidateTexImage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glInvalidateTexImage\0");
    glInvalidateTexImage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glInvalidateTexImage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glInvalidateTexImage_is_loaded() -> bool {
    !glInvalidateTexImage_p.load(RELAX).is_null()
  }

  /// [glInvalidateTexSubImage](http://docs.gl/gl4/glInvalidateTexSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glInvalidateTexSubImage(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    zoffset: GLint,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glInvalidateTexSubImage({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", texture, level, xoffset, yoffset, zoffset, width, height, depth);
    }
    let p = glInvalidateTexSubImage_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(texture, level, xoffset, yoffset, zoffset, width, height, depth)
      }
      None => go_panic_because_fn_not_loaded("glInvalidateTexSubImage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glInvalidateTexSubImage" != "glGetError" {
        report_error_as_necessary_from("glInvalidateTexSubImage", glGetError());
      }
    }
    out
  }
  static glInvalidateTexSubImage_p: APcv = ap_null();
  /// Tries to load [`glInvalidateTexSubImage`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glInvalidateTexSubImage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glInvalidateTexSubImage\0");
    glInvalidateTexSubImage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glInvalidateTexSubImage`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glInvalidateTexSubImage_is_loaded() -> bool {
    !glInvalidateTexSubImage_p.load(RELAX).is_null()
  }

  /// [glIsBuffer](http://docs.gl/gl4/glIsBuffer)(buffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsBuffer(buffer: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsBuffer({:?});", buffer);
    }
    let p = glIsBuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(buffer),
      None => go_panic_because_fn_not_loaded("glIsBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsBuffer" != "glGetError" {
        report_error_as_necessary_from("glIsBuffer", glGetError());
      }
    }
    out
  }
  static glIsBuffer_p: APcv = ap_null();
  /// Tries to load [`glIsBuffer`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsBuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsBuffer\0");
    glIsBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsBuffer_is_loaded() -> bool {
    !glIsBuffer_p.load(RELAX).is_null()
  }

  /// [glIsEnabled](http://docs.gl/gl4/glIsEnabled)(cap)
  /// * `cap` group: EnableCap
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsEnabled(cap: GLenum) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsEnabled({:#X});", cap);
    }
    let p = glIsEnabled_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(cap),
      None => go_panic_because_fn_not_loaded("glIsEnabled"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsEnabled" != "glGetError" {
        report_error_as_necessary_from("glIsEnabled", glGetError());
      }
    }
    out
  }
  static glIsEnabled_p: APcv = ap_null();
  /// Tries to load [`glIsEnabled`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsEnabled_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsEnabled\0");
    glIsEnabled_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsEnabled`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsEnabled_is_loaded() -> bool {
    !glIsEnabled_p.load(RELAX).is_null()
  }

  /// [glIsEnabledi](http://docs.gl/gl4/glIsEnabledi)(target, index)
  /// * `target` group: EnableCap
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsEnabledi(target: GLenum, index: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsEnabledi({:#X}, {:?});", target, index);
    }
    let p = glIsEnabledi_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(target, index),
        None => go_panic_because_fn_not_loaded("glIsEnabledi"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsEnabledi" != "glGetError" {
        report_error_as_necessary_from("glIsEnabledi", glGetError());
      }
    }
    out
  }
  static glIsEnabledi_p: APcv = ap_null();
  /// Tries to load [`glIsEnabledi`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsEnabledi_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsEnabledi\0");
    glIsEnabledi_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsEnabledi`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsEnabledi_is_loaded() -> bool {
    !glIsEnabledi_p.load(RELAX).is_null()
  }

  /// [glIsFramebuffer](http://docs.gl/gl4/glIsFramebuffer)(framebuffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsFramebuffer(framebuffer: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsFramebuffer({:?});", framebuffer);
    }
    let p = glIsFramebuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(framebuffer),
      None => go_panic_because_fn_not_loaded("glIsFramebuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsFramebuffer" != "glGetError" {
        report_error_as_necessary_from("glIsFramebuffer", glGetError());
      }
    }
    out
  }
  static glIsFramebuffer_p: APcv = ap_null();
  /// Tries to load [`glIsFramebuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsFramebuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsFramebuffer\0");
    glIsFramebuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsFramebuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsFramebuffer_is_loaded() -> bool {
    !glIsFramebuffer_p.load(RELAX).is_null()
  }

  /// [glIsProgram](http://docs.gl/gl4/glIsProgram)(program)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsProgram(program: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsProgram({:?});", program);
    }
    let p = glIsProgram_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(program),
      None => go_panic_because_fn_not_loaded("glIsProgram"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsProgram" != "glGetError" {
        report_error_as_necessary_from("glIsProgram", glGetError());
      }
    }
    out
  }
  static glIsProgram_p: APcv = ap_null();
  /// Tries to load [`glIsProgram`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsProgram_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsProgram\0");
    glIsProgram_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsProgram_is_loaded() -> bool {
    !glIsProgram_p.load(RELAX).is_null()
  }

  /// [glIsProgramPipeline](http://docs.gl/gl4/glIsProgramPipeline)(pipeline)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsProgramPipeline(pipeline: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsProgramPipeline({:?});", pipeline);
    }
    let p = glIsProgramPipeline_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(pipeline),
      None => go_panic_because_fn_not_loaded("glIsProgramPipeline"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsProgramPipeline" != "glGetError" {
        report_error_as_necessary_from("glIsProgramPipeline", glGetError());
      }
    }
    out
  }
  static glIsProgramPipeline_p: APcv = ap_null();
  /// Tries to load [`glIsProgramPipeline`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsProgramPipeline_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsProgramPipeline\0");
    glIsProgramPipeline_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsProgramPipeline`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsProgramPipeline_is_loaded() -> bool {
    !glIsProgramPipeline_p.load(RELAX).is_null()
  }

  /// [glIsQuery](http://docs.gl/gl4/glIsQuery)(id)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsQuery(id: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsQuery({:?});", id);
    }
    let p = glIsQuery_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(id),
      None => go_panic_because_fn_not_loaded("glIsQuery"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsQuery" != "glGetError" {
        report_error_as_necessary_from("glIsQuery", glGetError());
      }
    }
    out
  }
  static glIsQuery_p: APcv = ap_null();
  /// Tries to load [`glIsQuery`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsQuery_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsQuery\0");
    glIsQuery_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsQuery`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsQuery_is_loaded() -> bool {
    !glIsQuery_p.load(RELAX).is_null()
  }

  /// [glIsRenderbuffer](http://docs.gl/gl4/glIsRenderbuffer)(renderbuffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsRenderbuffer(renderbuffer: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsRenderbuffer({:?});", renderbuffer);
    }
    let p = glIsRenderbuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(renderbuffer),
      None => go_panic_because_fn_not_loaded("glIsRenderbuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsRenderbuffer" != "glGetError" {
        report_error_as_necessary_from("glIsRenderbuffer", glGetError());
      }
    }
    out
  }
  static glIsRenderbuffer_p: APcv = ap_null();
  /// Tries to load [`glIsRenderbuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsRenderbuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsRenderbuffer\0");
    glIsRenderbuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsRenderbuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsRenderbuffer_is_loaded() -> bool {
    !glIsRenderbuffer_p.load(RELAX).is_null()
  }

  /// [glIsSampler](http://docs.gl/gl4/glIsSampler)(sampler)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsSampler(sampler: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsSampler({:?});", sampler);
    }
    let p = glIsSampler_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(sampler),
      None => go_panic_because_fn_not_loaded("glIsSampler"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsSampler" != "glGetError" {
        report_error_as_necessary_from("glIsSampler", glGetError());
      }
    }
    out
  }
  static glIsSampler_p: APcv = ap_null();
  /// Tries to load [`glIsSampler`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsSampler_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsSampler\0");
    glIsSampler_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsSampler`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsSampler_is_loaded() -> bool {
    !glIsSampler_p.load(RELAX).is_null()
  }

  /// [glIsShader](http://docs.gl/gl4/glIsShader)(shader)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsShader(shader: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsShader({:?});", shader);
    }
    let p = glIsShader_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(shader),
      None => go_panic_because_fn_not_loaded("glIsShader"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsShader" != "glGetError" {
        report_error_as_necessary_from("glIsShader", glGetError());
      }
    }
    out
  }
  static glIsShader_p: APcv = ap_null();
  /// Tries to load [`glIsShader`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsShader_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsShader\0");
    glIsShader_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsShader_is_loaded() -> bool {
    !glIsShader_p.load(RELAX).is_null()
  }

  /// [glIsSync](http://docs.gl/gl4/glIsSync)(sync)
  /// * `sync` group: sync
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsSync(sync: GLsync) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsSync({:p});", sync);
    }
    let p = glIsSync_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLsync) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(sync),
      None => go_panic_because_fn_not_loaded("glIsSync"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsSync" != "glGetError" {
        report_error_as_necessary_from("glIsSync", glGetError());
      }
    }
    out
  }
  static glIsSync_p: APcv = ap_null();
  /// Tries to load [`glIsSync`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsSync_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsSync\0");
    glIsSync_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsSync`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsSync_is_loaded() -> bool {
    !glIsSync_p.load(RELAX).is_null()
  }

  /// [glIsTexture](http://docs.gl/gl4/glIsTexture)(texture)
  /// * `texture` group: Texture
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsTexture(texture: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsTexture({:?});", texture);
    }
    let p = glIsTexture_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(texture),
      None => go_panic_because_fn_not_loaded("glIsTexture"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsTexture" != "glGetError" {
        report_error_as_necessary_from("glIsTexture", glGetError());
      }
    }
    out
  }
  static glIsTexture_p: APcv = ap_null();
  /// Tries to load [`glIsTexture`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsTexture_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsTexture\0");
    glIsTexture_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsTexture`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsTexture_is_loaded() -> bool {
    !glIsTexture_p.load(RELAX).is_null()
  }

  /// [glIsTransformFeedback](http://docs.gl/gl4/glIsTransformFeedback)(id)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsTransformFeedback(id: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsTransformFeedback({:?});", id);
    }
    let p = glIsTransformFeedback_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(id),
      None => go_panic_because_fn_not_loaded("glIsTransformFeedback"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsTransformFeedback" != "glGetError" {
        report_error_as_necessary_from("glIsTransformFeedback", glGetError());
      }
    }
    out
  }
  static glIsTransformFeedback_p: APcv = ap_null();
  /// Tries to load [`glIsTransformFeedback`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsTransformFeedback_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsTransformFeedback\0");
    glIsTransformFeedback_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsTransformFeedback`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsTransformFeedback_is_loaded() -> bool {
    !glIsTransformFeedback_p.load(RELAX).is_null()
  }

  /// [glIsVertexArray](http://docs.gl/gl4/glIsVertexArray)(array)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glIsVertexArray(array: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glIsVertexArray({:?});", array);
    }
    let p = glIsVertexArray_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(array),
      None => go_panic_because_fn_not_loaded("glIsVertexArray"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glIsVertexArray" != "glGetError" {
        report_error_as_necessary_from("glIsVertexArray", glGetError());
      }
    }
    out
  }
  static glIsVertexArray_p: APcv = ap_null();
  /// Tries to load [`glIsVertexArray`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glIsVertexArray_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glIsVertexArray\0");
    glIsVertexArray_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glIsVertexArray`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glIsVertexArray_is_loaded() -> bool {
    !glIsVertexArray_p.load(RELAX).is_null()
  }

  /// [glLineWidth](http://docs.gl/gl4/glLineWidth)(width)
  /// * `width` group: CheckedFloat32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glLineWidth(width: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glLineWidth({:?});", width);
    }
    let p = glLineWidth_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLfloat)>>(p) {
      Some(fn_p) => fn_p(width),
      None => go_panic_because_fn_not_loaded("glLineWidth"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glLineWidth" != "glGetError" {
        report_error_as_necessary_from("glLineWidth", glGetError());
      }
    }
    out
  }
  static glLineWidth_p: APcv = ap_null();
  /// Tries to load [`glLineWidth`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glLineWidth_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glLineWidth\0");
    glLineWidth_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glLineWidth`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glLineWidth_is_loaded() -> bool {
    !glLineWidth_p.load(RELAX).is_null()
  }

  /// [glLinkProgram](http://docs.gl/gl4/glLinkProgram)(program)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glLinkProgram(program: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glLinkProgram({:?});", program);
    }
    let p = glLinkProgram_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(program),
      None => go_panic_because_fn_not_loaded("glLinkProgram"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glLinkProgram" != "glGetError" {
        report_error_as_necessary_from("glLinkProgram", glGetError());
      }
    }
    out
  }
  static glLinkProgram_p: APcv = ap_null();
  /// Tries to load [`glLinkProgram`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glLinkProgram_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glLinkProgram\0");
    glLinkProgram_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glLinkProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glLinkProgram_is_loaded() -> bool {
    !glLinkProgram_p.load(RELAX).is_null()
  }

  /// [glLogicOp](http://docs.gl/gl4/glLogicOp)(opcode)
  /// * `opcode` group: LogicOp
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glLogicOp(opcode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glLogicOp({:#X});", opcode);
    }
    let p = glLogicOp_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(opcode),
      None => go_panic_because_fn_not_loaded("glLogicOp"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glLogicOp" != "glGetError" {
        report_error_as_necessary_from("glLogicOp", glGetError());
      }
    }
    out
  }
  static glLogicOp_p: APcv = ap_null();
  /// Tries to load [`glLogicOp`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glLogicOp_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glLogicOp\0");
    glLogicOp_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glLogicOp`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glLogicOp_is_loaded() -> bool {
    !glLogicOp_p.load(RELAX).is_null()
  }

  /// [glMapBuffer](http://docs.gl/gl4/glMapBuffer)(target, access)
  /// * `target` group: BufferTargetARB
  /// * `access` group: BufferAccessARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMapBuffer(target: GLenum, access: GLenum) -> *mut c_void {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glMapBuffer({:#X}, {:#X});", target, access);
    }
    let p = glMapBuffer_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum) -> *mut c_void>>(p) {
        Some(fn_p) => fn_p(target, access),
        None => go_panic_because_fn_not_loaded("glMapBuffer"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMapBuffer" != "glGetError" {
        report_error_as_necessary_from("glMapBuffer", glGetError());
      }
    }
    out
  }
  static glMapBuffer_p: APcv = ap_null();
  /// Tries to load [`glMapBuffer`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMapBuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glMapBuffer\0");
    glMapBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMapBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMapBuffer_is_loaded() -> bool {
    !glMapBuffer_p.load(RELAX).is_null()
  }

  /// [glMapBufferRange](http://docs.gl/gl4/glMapBufferRange)(target, offset, length, access)
  /// * `target` group: BufferTargetARB
  /// * `offset` group: BufferOffset
  /// * `length` group: BufferSize
  /// * `access` group: MapBufferAccessMask
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMapBufferRange(
    target: GLenum,
    offset: GLintptr,
    length: GLsizeiptr,
    access: GLbitfield,
  ) -> *mut c_void {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glMapBufferRange({:#X}, {:?}, {:?}, {:?});",
        target,
        offset,
        length,
        access
      );
    }
    let p = glMapBufferRange_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLintptr,
          GLsizeiptr,
          GLbitfield,
        ) -> *mut c_void,
      >,
    >(p)
    {
      Some(fn_p) => fn_p(target, offset, length, access),
      None => go_panic_because_fn_not_loaded("glMapBufferRange"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMapBufferRange" != "glGetError" {
        report_error_as_necessary_from("glMapBufferRange", glGetError());
      }
    }
    out
  }
  static glMapBufferRange_p: APcv = ap_null();
  /// Tries to load [`glMapBufferRange`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMapBufferRange_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glMapBufferRange\0");
    glMapBufferRange_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMapBufferRange`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMapBufferRange_is_loaded() -> bool {
    !glMapBufferRange_p.load(RELAX).is_null()
  }

  /// [glMapNamedBuffer](http://docs.gl/gl4/glMapNamedBuffer)(buffer, access)
  /// * `access` group: BufferAccessARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMapNamedBuffer(
    buffer: GLuint,
    access: GLenum,
  ) -> *mut c_void {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glMapNamedBuffer({:?}, {:#X});", buffer, access);
    }
    let p = glMapNamedBuffer_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum) -> *mut c_void>>(p) {
        Some(fn_p) => fn_p(buffer, access),
        None => go_panic_because_fn_not_loaded("glMapNamedBuffer"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMapNamedBuffer" != "glGetError" {
        report_error_as_necessary_from("glMapNamedBuffer", glGetError());
      }
    }
    out
  }
  static glMapNamedBuffer_p: APcv = ap_null();
  /// Tries to load [`glMapNamedBuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMapNamedBuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glMapNamedBuffer\0");
    glMapNamedBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMapNamedBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMapNamedBuffer_is_loaded() -> bool {
    !glMapNamedBuffer_p.load(RELAX).is_null()
  }

  /// [glMapNamedBufferRange](http://docs.gl/gl4/glMapNamedBufferRange)(buffer, offset, length, access)
  /// * `length` group: BufferSize
  /// * `access` group: MapBufferAccessMask
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMapNamedBufferRange(
    buffer: GLuint,
    offset: GLintptr,
    length: GLsizeiptr,
    access: GLbitfield,
  ) -> *mut c_void {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glMapNamedBufferRange({:?}, {:?}, {:?}, {:?});",
        buffer,
        offset,
        length,
        access
      );
    }
    let p = glMapNamedBufferRange_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLintptr,
          GLsizeiptr,
          GLbitfield,
        ) -> *mut c_void,
      >,
    >(p)
    {
      Some(fn_p) => fn_p(buffer, offset, length, access),
      None => go_panic_because_fn_not_loaded("glMapNamedBufferRange"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMapNamedBufferRange" != "glGetError" {
        report_error_as_necessary_from("glMapNamedBufferRange", glGetError());
      }
    }
    out
  }
  static glMapNamedBufferRange_p: APcv = ap_null();
  /// Tries to load [`glMapNamedBufferRange`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMapNamedBufferRange_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glMapNamedBufferRange\0");
    glMapNamedBufferRange_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMapNamedBufferRange`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMapNamedBufferRange_is_loaded() -> bool {
    !glMapNamedBufferRange_p.load(RELAX).is_null()
  }

  /// [glMemoryBarrier](http://docs.gl/gl4/glMemoryBarrier)(barriers)
  /// * `barriers` group: MemoryBarrierMask
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMemoryBarrier(barriers: GLbitfield) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glMemoryBarrier({:?});", barriers);
    }
    let p = glMemoryBarrier_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLbitfield)>>(p) {
      Some(fn_p) => fn_p(barriers),
      None => go_panic_because_fn_not_loaded("glMemoryBarrier"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMemoryBarrier" != "glGetError" {
        report_error_as_necessary_from("glMemoryBarrier", glGetError());
      }
    }
    out
  }
  static glMemoryBarrier_p: APcv = ap_null();
  /// Tries to load [`glMemoryBarrier`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMemoryBarrier_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glMemoryBarrier\0");
    glMemoryBarrier_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMemoryBarrier`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMemoryBarrier_is_loaded() -> bool {
    !glMemoryBarrier_p.load(RELAX).is_null()
  }

  /// [glMemoryBarrierByRegion](http://docs.gl/gl4/glMemoryBarrierByRegion)(barriers)
  /// * `barriers` group: MemoryBarrierMask
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMemoryBarrierByRegion(barriers: GLbitfield) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glMemoryBarrierByRegion({:?});", barriers);
    }
    let p = glMemoryBarrierByRegion_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLbitfield)>>(p) {
      Some(fn_p) => fn_p(barriers),
      None => go_panic_because_fn_not_loaded("glMemoryBarrierByRegion"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMemoryBarrierByRegion" != "glGetError" {
        report_error_as_necessary_from("glMemoryBarrierByRegion", glGetError());
      }
    }
    out
  }
  static glMemoryBarrierByRegion_p: APcv = ap_null();
  /// Tries to load [`glMemoryBarrierByRegion`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMemoryBarrierByRegion_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glMemoryBarrierByRegion\0");
    glMemoryBarrierByRegion_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMemoryBarrierByRegion`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMemoryBarrierByRegion_is_loaded() -> bool {
    !glMemoryBarrierByRegion_p.load(RELAX).is_null()
  }

  /// [glMinSampleShading](http://docs.gl/gl4/glMinSampleShading)(value)
  /// * `value` group: ColorF
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMinSampleShading(value: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glMinSampleShading({:?});", value);
    }
    let p = glMinSampleShading_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLfloat)>>(p) {
      Some(fn_p) => fn_p(value),
      None => go_panic_because_fn_not_loaded("glMinSampleShading"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMinSampleShading" != "glGetError" {
        report_error_as_necessary_from("glMinSampleShading", glGetError());
      }
    }
    out
  }
  static glMinSampleShading_p: APcv = ap_null();
  /// Tries to load [`glMinSampleShading`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMinSampleShading_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glMinSampleShading\0");
    glMinSampleShading_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMinSampleShading`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMinSampleShading_is_loaded() -> bool {
    !glMinSampleShading_p.load(RELAX).is_null()
  }

  /// [glMultiDrawArrays](http://docs.gl/gl4/glMultiDrawArrays)(mode, first, count, drawcount)
  /// * `mode` group: PrimitiveType
  /// * `first` len: COMPSIZE(drawcount)
  /// * `count` len: COMPSIZE(drawcount)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMultiDrawArrays(
    mode: GLenum,
    first: *const GLint,
    count: *const GLsizei,
    drawcount: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glMultiDrawArrays({:#X}, {:p}, {:p}, {:?});",
        mode,
        first,
        count,
        drawcount
      );
    }
    let p = glMultiDrawArrays_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, *const GLint, *const GLsizei, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(mode, first, count, drawcount),
      None => go_panic_because_fn_not_loaded("glMultiDrawArrays"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMultiDrawArrays" != "glGetError" {
        report_error_as_necessary_from("glMultiDrawArrays", glGetError());
      }
    }
    out
  }
  static glMultiDrawArrays_p: APcv = ap_null();
  /// Tries to load [`glMultiDrawArrays`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMultiDrawArrays_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glMultiDrawArrays\0");
    glMultiDrawArrays_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMultiDrawArrays`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMultiDrawArrays_is_loaded() -> bool {
    !glMultiDrawArrays_p.load(RELAX).is_null()
  }

  /// [glMultiDrawArraysIndirect](http://docs.gl/gl4/glMultiDrawArraysIndirect)(mode, indirect, drawcount, stride)
  /// * `mode` group: PrimitiveType
  /// * `indirect` len: COMPSIZE(drawcount,stride)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMultiDrawArraysIndirect(
    mode: GLenum,
    indirect: *const c_void,
    drawcount: GLsizei,
    stride: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glMultiDrawArraysIndirect({:#X}, {:p}, {:?}, {:?});",
        mode,
        indirect,
        drawcount,
        stride
      );
    }
    let p = glMultiDrawArraysIndirect_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, *const c_void, GLsizei, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(mode, indirect, drawcount, stride),
      None => go_panic_because_fn_not_loaded("glMultiDrawArraysIndirect"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMultiDrawArraysIndirect" != "glGetError" {
        report_error_as_necessary_from(
          "glMultiDrawArraysIndirect",
          glGetError(),
        );
      }
    }
    out
  }
  static glMultiDrawArraysIndirect_p: APcv = ap_null();
  /// Tries to load [`glMultiDrawArraysIndirect`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMultiDrawArraysIndirect_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glMultiDrawArraysIndirect\0");
    glMultiDrawArraysIndirect_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMultiDrawArraysIndirect`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMultiDrawArraysIndirect_is_loaded() -> bool {
    !glMultiDrawArraysIndirect_p.load(RELAX).is_null()
  }

  /// [glMultiDrawArraysIndirectCount](http://docs.gl/gl4/glMultiDrawArraysIndirectCount)(mode, indirect, drawcount, maxdrawcount, stride)
  /// * `mode` group: PrimitiveType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMultiDrawArraysIndirectCount(
    mode: GLenum,
    indirect: *const c_void,
    drawcount: GLintptr,
    maxdrawcount: GLsizei,
    stride: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glMultiDrawArraysIndirectCount({:#X}, {:p}, {:?}, {:?}, {:?});", mode, indirect, drawcount, maxdrawcount, stride);
    }
    let p = glMultiDrawArraysIndirectCount_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, *const c_void, GLintptr, GLsizei, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(mode, indirect, drawcount, maxdrawcount, stride),
      None => go_panic_because_fn_not_loaded("glMultiDrawArraysIndirectCount"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMultiDrawArraysIndirectCount" != "glGetError" {
        report_error_as_necessary_from(
          "glMultiDrawArraysIndirectCount",
          glGetError(),
        );
      }
    }
    out
  }
  static glMultiDrawArraysIndirectCount_p: APcv = ap_null();
  /// Tries to load [`glMultiDrawArraysIndirectCount`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMultiDrawArraysIndirectCount_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glMultiDrawArraysIndirectCount\0");
    glMultiDrawArraysIndirectCount_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMultiDrawArraysIndirectCount`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMultiDrawArraysIndirectCount_is_loaded() -> bool {
    !glMultiDrawArraysIndirectCount_p.load(RELAX).is_null()
  }

  /// [glMultiDrawElements](http://docs.gl/gl4/glMultiDrawElements)(mode, count, type_, indices, drawcount)
  /// * `mode` group: PrimitiveType
  /// * `count` len: COMPSIZE(drawcount)
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(drawcount)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMultiDrawElements(
    mode: GLenum,
    count: *const GLsizei,
    type_: GLenum,
    indices: *const *const c_void,
    drawcount: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glMultiDrawElements({:#X}, {:p}, {:#X}, {:p}, {:?});",
        mode,
        count,
        type_,
        indices,
        drawcount
      );
    }
    let p = glMultiDrawElements_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          *const GLsizei,
          GLenum,
          *const *const c_void,
          GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(mode, count, type_, indices, drawcount),
      None => go_panic_because_fn_not_loaded("glMultiDrawElements"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMultiDrawElements" != "glGetError" {
        report_error_as_necessary_from("glMultiDrawElements", glGetError());
      }
    }
    out
  }
  static glMultiDrawElements_p: APcv = ap_null();
  /// Tries to load [`glMultiDrawElements`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMultiDrawElements_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glMultiDrawElements\0");
    glMultiDrawElements_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMultiDrawElements`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMultiDrawElements_is_loaded() -> bool {
    !glMultiDrawElements_p.load(RELAX).is_null()
  }

  /// [glMultiDrawElementsBaseVertex](http://docs.gl/gl4/glMultiDrawElementsBaseVertex)(mode, count, type_, indices, drawcount, basevertex)
  /// * `mode` group: PrimitiveType
  /// * `count` len: COMPSIZE(drawcount)
  /// * `type_` group: DrawElementsType
  /// * `indices` len: COMPSIZE(drawcount)
  /// * `basevertex` len: COMPSIZE(drawcount)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMultiDrawElementsBaseVertex(
    mode: GLenum,
    count: *const GLsizei,
    type_: GLenum,
    indices: *const *const c_void,
    drawcount: GLsizei,
    basevertex: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glMultiDrawElementsBaseVertex({:#X}, {:p}, {:#X}, {:p}, {:?}, {:p});", mode, count, type_, indices, drawcount, basevertex);
    }
    let p = glMultiDrawElementsBaseVertex_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          *const GLsizei,
          GLenum,
          *const *const c_void,
          GLsizei,
          *const GLint,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(mode, count, type_, indices, drawcount, basevertex),
      None => go_panic_because_fn_not_loaded("glMultiDrawElementsBaseVertex"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMultiDrawElementsBaseVertex" != "glGetError" {
        report_error_as_necessary_from(
          "glMultiDrawElementsBaseVertex",
          glGetError(),
        );
      }
    }
    out
  }
  static glMultiDrawElementsBaseVertex_p: APcv = ap_null();
  /// Tries to load [`glMultiDrawElementsBaseVertex`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMultiDrawElementsBaseVertex_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glMultiDrawElementsBaseVertex\0");
    glMultiDrawElementsBaseVertex_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMultiDrawElementsBaseVertex`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMultiDrawElementsBaseVertex_is_loaded() -> bool {
    !glMultiDrawElementsBaseVertex_p.load(RELAX).is_null()
  }

  /// [glMultiDrawElementsIndirect](http://docs.gl/gl4/glMultiDrawElementsIndirect)(mode, type_, indirect, drawcount, stride)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  /// * `indirect` len: COMPSIZE(drawcount,stride)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMultiDrawElementsIndirect(
    mode: GLenum,
    type_: GLenum,
    indirect: *const c_void,
    drawcount: GLsizei,
    stride: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glMultiDrawElementsIndirect({:#X}, {:#X}, {:p}, {:?}, {:?});",
        mode,
        type_,
        indirect,
        drawcount,
        stride
      );
    }
    let p = glMultiDrawElementsIndirect_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLenum, *const c_void, GLsizei, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(mode, type_, indirect, drawcount, stride),
      None => go_panic_because_fn_not_loaded("glMultiDrawElementsIndirect"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMultiDrawElementsIndirect" != "glGetError" {
        report_error_as_necessary_from(
          "glMultiDrawElementsIndirect",
          glGetError(),
        );
      }
    }
    out
  }
  static glMultiDrawElementsIndirect_p: APcv = ap_null();
  /// Tries to load [`glMultiDrawElementsIndirect`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMultiDrawElementsIndirect_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glMultiDrawElementsIndirect\0");
    glMultiDrawElementsIndirect_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMultiDrawElementsIndirect`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMultiDrawElementsIndirect_is_loaded() -> bool {
    !glMultiDrawElementsIndirect_p.load(RELAX).is_null()
  }

  /// [glMultiDrawElementsIndirectCount](http://docs.gl/gl4/glMultiDrawElementsIndirectCount)(mode, type_, indirect, drawcount, maxdrawcount, stride)
  /// * `mode` group: PrimitiveType
  /// * `type_` group: DrawElementsType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glMultiDrawElementsIndirectCount(
    mode: GLenum,
    type_: GLenum,
    indirect: *const c_void,
    drawcount: GLintptr,
    maxdrawcount: GLsizei,
    stride: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glMultiDrawElementsIndirectCount({:#X}, {:#X}, {:p}, {:?}, {:?}, {:?});", mode, type_, indirect, drawcount, maxdrawcount, stride);
    }
    let p = glMultiDrawElementsIndirectCount_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLenum,
          *const c_void,
          GLintptr,
          GLsizei,
          GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => {
        fn_p(mode, type_, indirect, drawcount, maxdrawcount, stride)
      }
      None => {
        go_panic_because_fn_not_loaded("glMultiDrawElementsIndirectCount")
      }
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glMultiDrawElementsIndirectCount" != "glGetError" {
        report_error_as_necessary_from(
          "glMultiDrawElementsIndirectCount",
          glGetError(),
        );
      }
    }
    out
  }
  static glMultiDrawElementsIndirectCount_p: APcv = ap_null();
  /// Tries to load [`glMultiDrawElementsIndirectCount`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glMultiDrawElementsIndirectCount_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glMultiDrawElementsIndirectCount\0");
    glMultiDrawElementsIndirectCount_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glMultiDrawElementsIndirectCount`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glMultiDrawElementsIndirectCount_is_loaded() -> bool {
    !glMultiDrawElementsIndirectCount_p.load(RELAX).is_null()
  }

  /// [glNamedBufferData](http://docs.gl/gl4/glNamedBufferData)(buffer, size, data, usage)
  /// * `size` group: BufferSize
  /// * `usage` group: VertexBufferObjectUsage
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glNamedBufferData(
    buffer: GLuint,
    size: GLsizeiptr,
    data: *const c_void,
    usage: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glNamedBufferData({:?}, {:?}, {:p}, {:#X});",
        buffer,
        size,
        data,
        usage
      );
    }
    let p = glNamedBufferData_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizeiptr, *const c_void, GLenum)>,
    >(p)
    {
      Some(fn_p) => fn_p(buffer, size, data, usage),
      None => go_panic_because_fn_not_loaded("glNamedBufferData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glNamedBufferData" != "glGetError" {
        report_error_as_necessary_from("glNamedBufferData", glGetError());
      }
    }
    out
  }
  static glNamedBufferData_p: APcv = ap_null();
  /// Tries to load [`glNamedBufferData`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glNamedBufferData_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glNamedBufferData\0");
    glNamedBufferData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glNamedBufferData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glNamedBufferData_is_loaded() -> bool {
    !glNamedBufferData_p.load(RELAX).is_null()
  }

  /// [glNamedBufferStorage](http://docs.gl/gl4/glNamedBufferStorage)(buffer, size, data, flags)
  /// * `size` group: BufferSize
  /// * `data` len: size
  /// * `flags` group: BufferStorageMask
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glNamedBufferStorage(
    buffer: GLuint,
    size: GLsizeiptr,
    data: *const c_void,
    flags: GLbitfield,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glNamedBufferStorage({:?}, {:?}, {:p}, {:?});",
        buffer,
        size,
        data,
        flags
      );
    }
    let p = glNamedBufferStorage_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizeiptr, *const c_void, GLbitfield)>,
    >(p)
    {
      Some(fn_p) => fn_p(buffer, size, data, flags),
      None => go_panic_because_fn_not_loaded("glNamedBufferStorage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glNamedBufferStorage" != "glGetError" {
        report_error_as_necessary_from("glNamedBufferStorage", glGetError());
      }
    }
    out
  }
  static glNamedBufferStorage_p: APcv = ap_null();
  /// Tries to load [`glNamedBufferStorage`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glNamedBufferStorage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glNamedBufferStorage\0");
    glNamedBufferStorage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glNamedBufferStorage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glNamedBufferStorage_is_loaded() -> bool {
    !glNamedBufferStorage_p.load(RELAX).is_null()
  }

  /// [glNamedBufferSubData](http://docs.gl/gl4/glNamedBufferSubData)(buffer, offset, size, data)
  /// * `size` group: BufferSize
  /// * `data` len: COMPSIZE(size)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glNamedBufferSubData(
    buffer: GLuint,
    offset: GLintptr,
    size: GLsizeiptr,
    data: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glNamedBufferSubData({:?}, {:?}, {:?}, {:p});",
        buffer,
        offset,
        size,
        data
      );
    }
    let p = glNamedBufferSubData_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLintptr, GLsizeiptr, *const c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(buffer, offset, size, data),
      None => go_panic_because_fn_not_loaded("glNamedBufferSubData"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glNamedBufferSubData" != "glGetError" {
        report_error_as_necessary_from("glNamedBufferSubData", glGetError());
      }
    }
    out
  }
  static glNamedBufferSubData_p: APcv = ap_null();
  /// Tries to load [`glNamedBufferSubData`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glNamedBufferSubData_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glNamedBufferSubData\0");
    glNamedBufferSubData_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glNamedBufferSubData`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glNamedBufferSubData_is_loaded() -> bool {
    !glNamedBufferSubData_p.load(RELAX).is_null()
  }

  /// [glNamedFramebufferDrawBuffer](http://docs.gl/gl4/glNamedFramebufferDrawBuffer)(framebuffer, buf)
  /// * `buf` group: ColorBuffer
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glNamedFramebufferDrawBuffer(framebuffer: GLuint, buf: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glNamedFramebufferDrawBuffer({:?}, {:#X});",
        framebuffer,
        buf
      );
    }
    let p = glNamedFramebufferDrawBuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum)>>(p) {
      Some(fn_p) => fn_p(framebuffer, buf),
      None => go_panic_because_fn_not_loaded("glNamedFramebufferDrawBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glNamedFramebufferDrawBuffer" != "glGetError" {
        report_error_as_necessary_from(
          "glNamedFramebufferDrawBuffer",
          glGetError(),
        );
      }
    }
    out
  }
  static glNamedFramebufferDrawBuffer_p: APcv = ap_null();
  /// Tries to load [`glNamedFramebufferDrawBuffer`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glNamedFramebufferDrawBuffer_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glNamedFramebufferDrawBuffer\0");
    glNamedFramebufferDrawBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glNamedFramebufferDrawBuffer`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glNamedFramebufferDrawBuffer_is_loaded() -> bool {
    !glNamedFramebufferDrawBuffer_p.load(RELAX).is_null()
  }

  /// [glNamedFramebufferDrawBuffers](http://docs.gl/gl4/glNamedFramebufferDrawBuffers)(framebuffer, n, bufs)
  /// * `bufs` group: ColorBuffer
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glNamedFramebufferDrawBuffers(
    framebuffer: GLuint,
    n: GLsizei,
    bufs: *const GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glNamedFramebufferDrawBuffers({:?}, {:?}, {:p});",
        framebuffer,
        n,
        bufs
      );
    }
    let p = glNamedFramebufferDrawBuffers_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLsizei, *const GLenum)>>(p) {
        Some(fn_p) => fn_p(framebuffer, n, bufs),
        None => go_panic_because_fn_not_loaded("glNamedFramebufferDrawBuffers"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glNamedFramebufferDrawBuffers" != "glGetError" {
        report_error_as_necessary_from(
          "glNamedFramebufferDrawBuffers",
          glGetError(),
        );
      }
    }
    out
  }
  static glNamedFramebufferDrawBuffers_p: APcv = ap_null();
  /// Tries to load [`glNamedFramebufferDrawBuffers`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glNamedFramebufferDrawBuffers_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glNamedFramebufferDrawBuffers\0");
    glNamedFramebufferDrawBuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glNamedFramebufferDrawBuffers`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glNamedFramebufferDrawBuffers_is_loaded() -> bool {
    !glNamedFramebufferDrawBuffers_p.load(RELAX).is_null()
  }

  /// [glNamedFramebufferParameteri](http://docs.gl/gl4/glNamedFramebufferParameteri)(framebuffer, pname, param)
  /// * `pname` group: FramebufferParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glNamedFramebufferParameteri(
    framebuffer: GLuint,
    pname: GLenum,
    param: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glNamedFramebufferParameteri({:?}, {:#X}, {:?});",
        framebuffer,
        pname,
        param
      );
    }
    let p = glNamedFramebufferParameteri_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLint)>>(p) {
      Some(fn_p) => fn_p(framebuffer, pname, param),
      None => go_panic_because_fn_not_loaded("glNamedFramebufferParameteri"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glNamedFramebufferParameteri" != "glGetError" {
        report_error_as_necessary_from(
          "glNamedFramebufferParameteri",
          glGetError(),
        );
      }
    }
    out
  }
  static glNamedFramebufferParameteri_p: APcv = ap_null();
  /// Tries to load [`glNamedFramebufferParameteri`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glNamedFramebufferParameteri_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glNamedFramebufferParameteri\0");
    glNamedFramebufferParameteri_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glNamedFramebufferParameteri`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glNamedFramebufferParameteri_is_loaded() -> bool {
    !glNamedFramebufferParameteri_p.load(RELAX).is_null()
  }

  /// [glNamedFramebufferReadBuffer](http://docs.gl/gl4/glNamedFramebufferReadBuffer)(framebuffer, src)
  /// * `src` group: ColorBuffer
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glNamedFramebufferReadBuffer(framebuffer: GLuint, src: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glNamedFramebufferReadBuffer({:?}, {:#X});",
        framebuffer,
        src
      );
    }
    let p = glNamedFramebufferReadBuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum)>>(p) {
      Some(fn_p) => fn_p(framebuffer, src),
      None => go_panic_because_fn_not_loaded("glNamedFramebufferReadBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glNamedFramebufferReadBuffer" != "glGetError" {
        report_error_as_necessary_from(
          "glNamedFramebufferReadBuffer",
          glGetError(),
        );
      }
    }
    out
  }
  static glNamedFramebufferReadBuffer_p: APcv = ap_null();
  /// Tries to load [`glNamedFramebufferReadBuffer`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glNamedFramebufferReadBuffer_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glNamedFramebufferReadBuffer\0");
    glNamedFramebufferReadBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glNamedFramebufferReadBuffer`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glNamedFramebufferReadBuffer_is_loaded() -> bool {
    !glNamedFramebufferReadBuffer_p.load(RELAX).is_null()
  }

  /// [glNamedFramebufferRenderbuffer](http://docs.gl/gl4/glNamedFramebufferRenderbuffer)(framebuffer, attachment, renderbuffertarget, renderbuffer)
  /// * `attachment` group: FramebufferAttachment
  /// * `renderbuffertarget` group: RenderbufferTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glNamedFramebufferRenderbuffer(
    framebuffer: GLuint,
    attachment: GLenum,
    renderbuffertarget: GLenum,
    renderbuffer: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glNamedFramebufferRenderbuffer({:?}, {:#X}, {:#X}, {:?});",
        framebuffer,
        attachment,
        renderbuffertarget,
        renderbuffer
      );
    }
    let p = glNamedFramebufferRenderbuffer_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum, GLuint)>>(p) {
        Some(fn_p) => {
          fn_p(framebuffer, attachment, renderbuffertarget, renderbuffer)
        }
        None => {
          go_panic_because_fn_not_loaded("glNamedFramebufferRenderbuffer")
        }
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glNamedFramebufferRenderbuffer" != "glGetError" {
        report_error_as_necessary_from(
          "glNamedFramebufferRenderbuffer",
          glGetError(),
        );
      }
    }
    out
  }
  static glNamedFramebufferRenderbuffer_p: APcv = ap_null();
  /// Tries to load [`glNamedFramebufferRenderbuffer`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glNamedFramebufferRenderbuffer_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glNamedFramebufferRenderbuffer\0");
    glNamedFramebufferRenderbuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glNamedFramebufferRenderbuffer`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glNamedFramebufferRenderbuffer_is_loaded() -> bool {
    !glNamedFramebufferRenderbuffer_p.load(RELAX).is_null()
  }

  /// [glNamedFramebufferTexture](http://docs.gl/gl4/glNamedFramebufferTexture)(framebuffer, attachment, texture, level)
  /// * `attachment` group: FramebufferAttachment
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glNamedFramebufferTexture(
    framebuffer: GLuint,
    attachment: GLenum,
    texture: GLuint,
    level: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glNamedFramebufferTexture({:?}, {:#X}, {:?}, {:?});",
        framebuffer,
        attachment,
        texture,
        level
      );
    }
    let p = glNamedFramebufferTexture_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, GLuint, GLint)>>(p) {
        Some(fn_p) => fn_p(framebuffer, attachment, texture, level),
        None => go_panic_because_fn_not_loaded("glNamedFramebufferTexture"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glNamedFramebufferTexture" != "glGetError" {
        report_error_as_necessary_from(
          "glNamedFramebufferTexture",
          glGetError(),
        );
      }
    }
    out
  }
  static glNamedFramebufferTexture_p: APcv = ap_null();
  /// Tries to load [`glNamedFramebufferTexture`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glNamedFramebufferTexture_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glNamedFramebufferTexture\0");
    glNamedFramebufferTexture_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glNamedFramebufferTexture`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glNamedFramebufferTexture_is_loaded() -> bool {
    !glNamedFramebufferTexture_p.load(RELAX).is_null()
  }

  /// [glNamedFramebufferTextureLayer](http://docs.gl/gl4/glNamedFramebufferTextureLayer)(framebuffer, attachment, texture, level, layer)
  /// * `attachment` group: FramebufferAttachment
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glNamedFramebufferTextureLayer(
    framebuffer: GLuint,
    attachment: GLenum,
    texture: GLuint,
    level: GLint,
    layer: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glNamedFramebufferTextureLayer({:?}, {:#X}, {:?}, {:?}, {:?});", framebuffer, attachment, texture, level, layer);
    }
    let p = glNamedFramebufferTextureLayer_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLuint, GLint, GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(framebuffer, attachment, texture, level, layer),
      None => go_panic_because_fn_not_loaded("glNamedFramebufferTextureLayer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glNamedFramebufferTextureLayer" != "glGetError" {
        report_error_as_necessary_from(
          "glNamedFramebufferTextureLayer",
          glGetError(),
        );
      }
    }
    out
  }
  static glNamedFramebufferTextureLayer_p: APcv = ap_null();
  /// Tries to load [`glNamedFramebufferTextureLayer`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glNamedFramebufferTextureLayer_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glNamedFramebufferTextureLayer\0");
    glNamedFramebufferTextureLayer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glNamedFramebufferTextureLayer`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glNamedFramebufferTextureLayer_is_loaded() -> bool {
    !glNamedFramebufferTextureLayer_p.load(RELAX).is_null()
  }

  /// [glNamedRenderbufferStorage](http://docs.gl/gl4/glNamedRenderbufferStorage)(renderbuffer, internalformat, width, height)
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glNamedRenderbufferStorage(
    renderbuffer: GLuint,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glNamedRenderbufferStorage({:?}, {:#X}, {:?}, {:?});",
        renderbuffer,
        internalformat,
        width,
        height
      );
    }
    let p = glNamedRenderbufferStorage_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, GLsizei, GLsizei)>>(p)
      {
        Some(fn_p) => fn_p(renderbuffer, internalformat, width, height),
        None => go_panic_because_fn_not_loaded("glNamedRenderbufferStorage"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glNamedRenderbufferStorage" != "glGetError" {
        report_error_as_necessary_from(
          "glNamedRenderbufferStorage",
          glGetError(),
        );
      }
    }
    out
  }
  static glNamedRenderbufferStorage_p: APcv = ap_null();
  /// Tries to load [`glNamedRenderbufferStorage`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glNamedRenderbufferStorage_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glNamedRenderbufferStorage\0");
    glNamedRenderbufferStorage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glNamedRenderbufferStorage`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glNamedRenderbufferStorage_is_loaded() -> bool {
    !glNamedRenderbufferStorage_p.load(RELAX).is_null()
  }

  /// [glNamedRenderbufferStorageMultisample](http://docs.gl/gl4/glNamedRenderbufferStorageMultisample)(renderbuffer, samples, internalformat, width, height)
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glNamedRenderbufferStorageMultisample(
    renderbuffer: GLuint,
    samples: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glNamedRenderbufferStorageMultisample({:?}, {:?}, {:#X}, {:?}, {:?});", renderbuffer, samples, internalformat, width, height);
    }
    let p = glNamedRenderbufferStorageMultisample_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(renderbuffer, samples, internalformat, width, height),
      None => {
        go_panic_because_fn_not_loaded("glNamedRenderbufferStorageMultisample")
      }
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glNamedRenderbufferStorageMultisample" != "glGetError" {
        report_error_as_necessary_from(
          "glNamedRenderbufferStorageMultisample",
          glGetError(),
        );
      }
    }
    out
  }
  static glNamedRenderbufferStorageMultisample_p: APcv = ap_null();
  /// Tries to load [`glNamedRenderbufferStorageMultisample`], returns if a
  /// non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glNamedRenderbufferStorageMultisample_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glNamedRenderbufferStorageMultisample\0");
    glNamedRenderbufferStorageMultisample_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glNamedRenderbufferStorageMultisample`] is
  /// loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glNamedRenderbufferStorageMultisample_is_loaded() -> bool {
    !glNamedRenderbufferStorageMultisample_p.load(RELAX).is_null()
  }

  /// [glObjectLabel](http://docs.gl/gl4/glObjectLabel)(identifier, name, length, label)
  /// * `identifier` group: ObjectIdentifier
  /// * `label` len: COMPSIZE(label,length)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glObjectLabel(
    identifier: GLenum,
    name: GLuint,
    length: GLsizei,
    label: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glObjectLabel({:#X}, {:?}, {:?}, {:p});",
        identifier,
        name,
        length,
        label
      );
    }
    let p = glObjectLabel_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLuint, GLsizei, *const GLchar)>,
    >(p)
    {
      Some(fn_p) => fn_p(identifier, name, length, label),
      None => go_panic_because_fn_not_loaded("glObjectLabel"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glObjectLabel" != "glGetError" {
        report_error_as_necessary_from("glObjectLabel", glGetError());
      }
    }
    out
  }
  static glObjectLabel_p: APcv = ap_null();
  /// Tries to load [`glObjectLabel`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glObjectLabel_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glObjectLabel\0");
    glObjectLabel_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glObjectLabel`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glObjectLabel_is_loaded() -> bool {
    !glObjectLabel_p.load(RELAX).is_null()
  }

  /// [glObjectPtrLabel](http://docs.gl/gl4/glObjectPtrLabel)(ptr, length, label)
  /// * `label` len: COMPSIZE(label,length)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glObjectPtrLabel(
    ptr: *const c_void,
    length: GLsizei,
    label: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glObjectPtrLabel({:p}, {:?}, {:p});", ptr, length, label);
    }
    let p = glObjectPtrLabel_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(*const c_void, GLsizei, *const GLchar)>,
    >(p)
    {
      Some(fn_p) => fn_p(ptr, length, label),
      None => go_panic_because_fn_not_loaded("glObjectPtrLabel"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glObjectPtrLabel" != "glGetError" {
        report_error_as_necessary_from("glObjectPtrLabel", glGetError());
      }
    }
    out
  }
  static glObjectPtrLabel_p: APcv = ap_null();
  /// Tries to load [`glObjectPtrLabel`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glObjectPtrLabel_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glObjectPtrLabel\0");
    glObjectPtrLabel_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glObjectPtrLabel`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glObjectPtrLabel_is_loaded() -> bool {
    !glObjectPtrLabel_p.load(RELAX).is_null()
  }

  /// [glPatchParameterfv](http://docs.gl/gl4/glPatchParameterfv)(pname, values)
  /// * `pname` group: PatchParameterName
  /// * `values` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPatchParameterfv(pname: GLenum, values: *const GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPatchParameterfv({:#X}, {:p});", pname, values);
    }
    let p = glPatchParameterfv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, *const GLfloat)>>(p) {
      Some(fn_p) => fn_p(pname, values),
      None => go_panic_because_fn_not_loaded("glPatchParameterfv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPatchParameterfv" != "glGetError" {
        report_error_as_necessary_from("glPatchParameterfv", glGetError());
      }
    }
    out
  }
  static glPatchParameterfv_p: APcv = ap_null();
  /// Tries to load [`glPatchParameterfv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPatchParameterfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPatchParameterfv\0");
    glPatchParameterfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPatchParameterfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPatchParameterfv_is_loaded() -> bool {
    !glPatchParameterfv_p.load(RELAX).is_null()
  }

  /// [glPatchParameteri](http://docs.gl/gl4/glPatchParameteri)(pname, value)
  /// * `pname` group: PatchParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPatchParameteri(pname: GLenum, value: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPatchParameteri({:#X}, {:?});", pname, value);
    }
    let p = glPatchParameteri_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLint)>>(p) {
      Some(fn_p) => fn_p(pname, value),
      None => go_panic_because_fn_not_loaded("glPatchParameteri"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPatchParameteri" != "glGetError" {
        report_error_as_necessary_from("glPatchParameteri", glGetError());
      }
    }
    out
  }
  static glPatchParameteri_p: APcv = ap_null();
  /// Tries to load [`glPatchParameteri`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPatchParameteri_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPatchParameteri\0");
    glPatchParameteri_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPatchParameteri`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPatchParameteri_is_loaded() -> bool {
    !glPatchParameteri_p.load(RELAX).is_null()
  }

  /// [glPauseTransformFeedback](http://docs.gl/gl4/glPauseTransformFeedback)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPauseTransformFeedback() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPauseTransformFeedback();",);
    }
    let p = glPauseTransformFeedback_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn()>>(p) {
      Some(fn_p) => fn_p(),
      None => go_panic_because_fn_not_loaded("glPauseTransformFeedback"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPauseTransformFeedback" != "glGetError" {
        report_error_as_necessary_from(
          "glPauseTransformFeedback",
          glGetError(),
        );
      }
    }
    out
  }
  static glPauseTransformFeedback_p: APcv = ap_null();
  /// Tries to load [`glPauseTransformFeedback`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPauseTransformFeedback_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glPauseTransformFeedback\0");
    glPauseTransformFeedback_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPauseTransformFeedback`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPauseTransformFeedback_is_loaded() -> bool {
    !glPauseTransformFeedback_p.load(RELAX).is_null()
  }

  /// [glPixelStoref](http://docs.gl/gl4/glPixelStoref)(pname, param)
  /// * `pname` group: PixelStoreParameter
  /// * `param` group: CheckedFloat32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPixelStoref(pname: GLenum, param: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPixelStoref({:#X}, {:?});", pname, param);
    }
    let p = glPixelStoref_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLfloat)>>(p) {
      Some(fn_p) => fn_p(pname, param),
      None => go_panic_because_fn_not_loaded("glPixelStoref"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPixelStoref" != "glGetError" {
        report_error_as_necessary_from("glPixelStoref", glGetError());
      }
    }
    out
  }
  static glPixelStoref_p: APcv = ap_null();
  /// Tries to load [`glPixelStoref`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPixelStoref_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPixelStoref\0");
    glPixelStoref_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPixelStoref`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPixelStoref_is_loaded() -> bool {
    !glPixelStoref_p.load(RELAX).is_null()
  }

  /// [glPixelStorei](http://docs.gl/gl4/glPixelStorei)(pname, param)
  /// * `pname` group: PixelStoreParameter
  /// * `param` group: CheckedInt32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPixelStorei(pname: GLenum, param: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPixelStorei({:#X}, {:?});", pname, param);
    }
    let p = glPixelStorei_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLint)>>(p) {
      Some(fn_p) => fn_p(pname, param),
      None => go_panic_because_fn_not_loaded("glPixelStorei"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPixelStorei" != "glGetError" {
        report_error_as_necessary_from("glPixelStorei", glGetError());
      }
    }
    out
  }
  static glPixelStorei_p: APcv = ap_null();
  /// Tries to load [`glPixelStorei`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPixelStorei_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPixelStorei\0");
    glPixelStorei_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPixelStorei`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPixelStorei_is_loaded() -> bool {
    !glPixelStorei_p.load(RELAX).is_null()
  }

  /// [glPointParameterf](http://docs.gl/gl4/glPointParameterf)(pname, param)
  /// * `pname` group: PointParameterNameARB
  /// * `param` group: CheckedFloat32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPointParameterf(pname: GLenum, param: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPointParameterf({:#X}, {:?});", pname, param);
    }
    let p = glPointParameterf_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLfloat)>>(p) {
      Some(fn_p) => fn_p(pname, param),
      None => go_panic_because_fn_not_loaded("glPointParameterf"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPointParameterf" != "glGetError" {
        report_error_as_necessary_from("glPointParameterf", glGetError());
      }
    }
    out
  }
  static glPointParameterf_p: APcv = ap_null();
  /// Tries to load [`glPointParameterf`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPointParameterf_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPointParameterf\0");
    glPointParameterf_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPointParameterf`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPointParameterf_is_loaded() -> bool {
    !glPointParameterf_p.load(RELAX).is_null()
  }

  /// [glPointParameterfv](http://docs.gl/gl4/glPointParameterfv)(pname, params)
  /// * `pname` group: PointParameterNameARB
  /// * `params` group: CheckedFloat32
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPointParameterfv(pname: GLenum, params: *const GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPointParameterfv({:#X}, {:p});", pname, params);
    }
    let p = glPointParameterfv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, *const GLfloat)>>(p) {
      Some(fn_p) => fn_p(pname, params),
      None => go_panic_because_fn_not_loaded("glPointParameterfv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPointParameterfv" != "glGetError" {
        report_error_as_necessary_from("glPointParameterfv", glGetError());
      }
    }
    out
  }
  static glPointParameterfv_p: APcv = ap_null();
  /// Tries to load [`glPointParameterfv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPointParameterfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPointParameterfv\0");
    glPointParameterfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPointParameterfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPointParameterfv_is_loaded() -> bool {
    !glPointParameterfv_p.load(RELAX).is_null()
  }

  /// [glPointParameteri](http://docs.gl/gl4/glPointParameteri)(pname, param)
  /// * `pname` group: PointParameterNameARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPointParameteri(pname: GLenum, param: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPointParameteri({:#X}, {:?});", pname, param);
    }
    let p = glPointParameteri_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLint)>>(p) {
      Some(fn_p) => fn_p(pname, param),
      None => go_panic_because_fn_not_loaded("glPointParameteri"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPointParameteri" != "glGetError" {
        report_error_as_necessary_from("glPointParameteri", glGetError());
      }
    }
    out
  }
  static glPointParameteri_p: APcv = ap_null();
  /// Tries to load [`glPointParameteri`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPointParameteri_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPointParameteri\0");
    glPointParameteri_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPointParameteri`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPointParameteri_is_loaded() -> bool {
    !glPointParameteri_p.load(RELAX).is_null()
  }

  /// [glPointParameteriv](http://docs.gl/gl4/glPointParameteriv)(pname, params)
  /// * `pname` group: PointParameterNameARB
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPointParameteriv(pname: GLenum, params: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPointParameteriv({:#X}, {:p});", pname, params);
    }
    let p = glPointParameteriv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, *const GLint)>>(p) {
      Some(fn_p) => fn_p(pname, params),
      None => go_panic_because_fn_not_loaded("glPointParameteriv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPointParameteriv" != "glGetError" {
        report_error_as_necessary_from("glPointParameteriv", glGetError());
      }
    }
    out
  }
  static glPointParameteriv_p: APcv = ap_null();
  /// Tries to load [`glPointParameteriv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPointParameteriv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPointParameteriv\0");
    glPointParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPointParameteriv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPointParameteriv_is_loaded() -> bool {
    !glPointParameteriv_p.load(RELAX).is_null()
  }

  /// [glPointSize](http://docs.gl/gl4/glPointSize)(size)
  /// * `size` group: CheckedFloat32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPointSize(size: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPointSize({:?});", size);
    }
    let p = glPointSize_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLfloat)>>(p) {
      Some(fn_p) => fn_p(size),
      None => go_panic_because_fn_not_loaded("glPointSize"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPointSize" != "glGetError" {
        report_error_as_necessary_from("glPointSize", glGetError());
      }
    }
    out
  }
  static glPointSize_p: APcv = ap_null();
  /// Tries to load [`glPointSize`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPointSize_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPointSize\0");
    glPointSize_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPointSize`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPointSize_is_loaded() -> bool {
    !glPointSize_p.load(RELAX).is_null()
  }

  /// [glPolygonMode](http://docs.gl/gl4/glPolygonMode)(face, mode)
  /// * `face` group: MaterialFace
  /// * `mode` group: PolygonMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPolygonMode(face: GLenum, mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPolygonMode({:#X}, {:#X});", face, mode);
    }
    let p = glPolygonMode_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLenum)>>(p) {
      Some(fn_p) => fn_p(face, mode),
      None => go_panic_because_fn_not_loaded("glPolygonMode"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPolygonMode" != "glGetError" {
        report_error_as_necessary_from("glPolygonMode", glGetError());
      }
    }
    out
  }
  static glPolygonMode_p: APcv = ap_null();
  /// Tries to load [`glPolygonMode`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPolygonMode_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPolygonMode\0");
    glPolygonMode_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPolygonMode`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPolygonMode_is_loaded() -> bool {
    !glPolygonMode_p.load(RELAX).is_null()
  }

  /// [glPolygonOffset](http://docs.gl/gl4/glPolygonOffset)(factor, units)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPolygonOffset(factor: GLfloat, units: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPolygonOffset({:?}, {:?});", factor, units);
    }
    let p = glPolygonOffset_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLfloat, GLfloat)>>(p) {
      Some(fn_p) => fn_p(factor, units),
      None => go_panic_because_fn_not_loaded("glPolygonOffset"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPolygonOffset" != "glGetError" {
        report_error_as_necessary_from("glPolygonOffset", glGetError());
      }
    }
    out
  }
  static glPolygonOffset_p: APcv = ap_null();
  /// Tries to load [`glPolygonOffset`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPolygonOffset_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPolygonOffset\0");
    glPolygonOffset_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPolygonOffset`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPolygonOffset_is_loaded() -> bool {
    !glPolygonOffset_p.load(RELAX).is_null()
  }

  /// [glPolygonOffsetClamp](http://docs.gl/gl4/glPolygonOffsetClamp)(factor, units, clamp)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPolygonOffsetClamp(
    factor: GLfloat,
    units: GLfloat,
    clamp: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glPolygonOffsetClamp({:?}, {:?}, {:?});",
        factor,
        units,
        clamp
      );
    }
    let p = glPolygonOffsetClamp_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLfloat, GLfloat, GLfloat)>>(p)
    {
      Some(fn_p) => fn_p(factor, units, clamp),
      None => go_panic_because_fn_not_loaded("glPolygonOffsetClamp"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPolygonOffsetClamp" != "glGetError" {
        report_error_as_necessary_from("glPolygonOffsetClamp", glGetError());
      }
    }
    out
  }
  static glPolygonOffsetClamp_p: APcv = ap_null();
  /// Tries to load [`glPolygonOffsetClamp`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPolygonOffsetClamp_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPolygonOffsetClamp\0");
    glPolygonOffsetClamp_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPolygonOffsetClamp`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPolygonOffsetClamp_is_loaded() -> bool {
    !glPolygonOffsetClamp_p.load(RELAX).is_null()
  }

  /// [glPopDebugGroup](http://docs.gl/gl4/glPopDebugGroup)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPopDebugGroup() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPopDebugGroup();",);
    }
    let p = glPopDebugGroup_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn()>>(p) {
      Some(fn_p) => fn_p(),
      None => go_panic_because_fn_not_loaded("glPopDebugGroup"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPopDebugGroup" != "glGetError" {
        report_error_as_necessary_from("glPopDebugGroup", glGetError());
      }
    }
    out
  }
  static glPopDebugGroup_p: APcv = ap_null();
  /// Tries to load [`glPopDebugGroup`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPopDebugGroup_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPopDebugGroup\0");
    glPopDebugGroup_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPopDebugGroup`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPopDebugGroup_is_loaded() -> bool {
    !glPopDebugGroup_p.load(RELAX).is_null()
  }

  /// [glPrimitiveRestartIndex](http://docs.gl/gl4/glPrimitiveRestartIndex)(index)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPrimitiveRestartIndex(index: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glPrimitiveRestartIndex({:?});", index);
    }
    let p = glPrimitiveRestartIndex_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(index),
      None => go_panic_because_fn_not_loaded("glPrimitiveRestartIndex"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPrimitiveRestartIndex" != "glGetError" {
        report_error_as_necessary_from("glPrimitiveRestartIndex", glGetError());
      }
    }
    out
  }
  static glPrimitiveRestartIndex_p: APcv = ap_null();
  /// Tries to load [`glPrimitiveRestartIndex`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPrimitiveRestartIndex_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPrimitiveRestartIndex\0");
    glPrimitiveRestartIndex_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPrimitiveRestartIndex`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPrimitiveRestartIndex_is_loaded() -> bool {
    !glPrimitiveRestartIndex_p.load(RELAX).is_null()
  }

  /// [glProgramBinary](http://docs.gl/gl4/glProgramBinary)(program, binaryFormat, binary, length)
  /// * `binary` len: length
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramBinary(
    program: GLuint,
    binaryFormat: GLenum,
    binary: *const c_void,
    length: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramBinary({:?}, {:#X}, {:p}, {:?});",
        program,
        binaryFormat,
        binary,
        length
      );
    }
    let p = glProgramBinary_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, *const c_void, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, binaryFormat, binary, length),
      None => go_panic_because_fn_not_loaded("glProgramBinary"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramBinary" != "glGetError" {
        report_error_as_necessary_from("glProgramBinary", glGetError());
      }
    }
    out
  }
  static glProgramBinary_p: APcv = ap_null();
  /// Tries to load [`glProgramBinary`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramBinary_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramBinary\0");
    glProgramBinary_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramBinary`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramBinary_is_loaded() -> bool {
    !glProgramBinary_p.load(RELAX).is_null()
  }

  /// [glProgramParameteri](http://docs.gl/gl4/glProgramParameteri)(program, pname, value)
  /// * `pname` group: ProgramParameterPName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramParameteri(
    program: GLuint,
    pname: GLenum,
    value: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramParameteri({:?}, {:#X}, {:?});",
        program,
        pname,
        value
      );
    }
    let p = glProgramParameteri_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLint)>>(p) {
      Some(fn_p) => fn_p(program, pname, value),
      None => go_panic_because_fn_not_loaded("glProgramParameteri"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramParameteri" != "glGetError" {
        report_error_as_necessary_from("glProgramParameteri", glGetError());
      }
    }
    out
  }
  static glProgramParameteri_p: APcv = ap_null();
  /// Tries to load [`glProgramParameteri`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramParameteri_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramParameteri\0");
    glProgramParameteri_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramParameteri`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramParameteri_is_loaded() -> bool {
    !glProgramParameteri_p.load(RELAX).is_null()
  }

  /// [glProgramUniform1d](http://docs.gl/gl4/glProgramUniform1d)(program, location, v0)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform1d(
    program: GLuint,
    location: GLint,
    v0: GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform1d({:?}, {:?}, {:?});",
        program,
        location,
        v0
      );
    }
    let p = glProgramUniform1d_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLint, GLdouble)>>(p) {
      Some(fn_p) => fn_p(program, location, v0),
      None => go_panic_because_fn_not_loaded("glProgramUniform1d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform1d" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform1d", glGetError());
      }
    }
    out
  }
  static glProgramUniform1d_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform1d`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform1d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform1d\0");
    glProgramUniform1d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform1d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform1d_is_loaded() -> bool {
    !glProgramUniform1d_p.load(RELAX).is_null()
  }

  /// [glProgramUniform1dv](http://docs.gl/gl4/glProgramUniform1dv)(program, location, count, value)
  /// * `value` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform1dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform1dv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform1dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform1dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform1dv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform1dv", glGetError());
      }
    }
    out
  }
  static glProgramUniform1dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform1dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform1dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform1dv\0");
    glProgramUniform1dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform1dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform1dv_is_loaded() -> bool {
    !glProgramUniform1dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform1f](http://docs.gl/gl4/glProgramUniform1f)(program, location, v0)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform1f(
    program: GLuint,
    location: GLint,
    v0: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform1f({:?}, {:?}, {:?});",
        program,
        location,
        v0
      );
    }
    let p = glProgramUniform1f_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLint, GLfloat)>>(p) {
      Some(fn_p) => fn_p(program, location, v0),
      None => go_panic_because_fn_not_loaded("glProgramUniform1f"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform1f" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform1f", glGetError());
      }
    }
    out
  }
  static glProgramUniform1f_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform1f`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform1f_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform1f\0");
    glProgramUniform1f_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform1f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform1f_is_loaded() -> bool {
    !glProgramUniform1f_p.load(RELAX).is_null()
  }

  /// [glProgramUniform1fv](http://docs.gl/gl4/glProgramUniform1fv)(program, location, count, value)
  /// * `value` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform1fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform1fv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform1fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform1fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform1fv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform1fv", glGetError());
      }
    }
    out
  }
  static glProgramUniform1fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform1fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform1fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform1fv\0");
    glProgramUniform1fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform1fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform1fv_is_loaded() -> bool {
    !glProgramUniform1fv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform1i](http://docs.gl/gl4/glProgramUniform1i)(program, location, v0)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform1i(
    program: GLuint,
    location: GLint,
    v0: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform1i({:?}, {:?}, {:?});",
        program,
        location,
        v0
      );
    }
    let p = glProgramUniform1i_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLint, GLint)>>(p) {
      Some(fn_p) => fn_p(program, location, v0),
      None => go_panic_because_fn_not_loaded("glProgramUniform1i"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform1i" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform1i", glGetError());
      }
    }
    out
  }
  static glProgramUniform1i_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform1i`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform1i_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform1i\0");
    glProgramUniform1i_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform1i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform1i_is_loaded() -> bool {
    !glProgramUniform1i_p.load(RELAX).is_null()
  }

  /// [glProgramUniform1iv](http://docs.gl/gl4/glProgramUniform1iv)(program, location, count, value)
  /// * `value` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform1iv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform1iv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform1iv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform1iv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform1iv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform1iv", glGetError());
      }
    }
    out
  }
  static glProgramUniform1iv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform1iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform1iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform1iv\0");
    glProgramUniform1iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform1iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform1iv_is_loaded() -> bool {
    !glProgramUniform1iv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform1ui](http://docs.gl/gl4/glProgramUniform1ui)(program, location, v0)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform1ui(
    program: GLuint,
    location: GLint,
    v0: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform1ui({:?}, {:?}, {:?});",
        program,
        location,
        v0
      );
    }
    let p = glProgramUniform1ui_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLint, GLuint)>>(p) {
      Some(fn_p) => fn_p(program, location, v0),
      None => go_panic_because_fn_not_loaded("glProgramUniform1ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform1ui" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform1ui", glGetError());
      }
    }
    out
  }
  static glProgramUniform1ui_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform1ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform1ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform1ui\0");
    glProgramUniform1ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform1ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform1ui_is_loaded() -> bool {
    !glProgramUniform1ui_p.load(RELAX).is_null()
  }

  /// [glProgramUniform1uiv](http://docs.gl/gl4/glProgramUniform1uiv)(program, location, count, value)
  /// * `value` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform1uiv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform1uiv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform1uiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform1uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform1uiv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform1uiv", glGetError());
      }
    }
    out
  }
  static glProgramUniform1uiv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform1uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform1uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform1uiv\0");
    glProgramUniform1uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform1uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform1uiv_is_loaded() -> bool {
    !glProgramUniform1uiv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform2d](http://docs.gl/gl4/glProgramUniform2d)(program, location, v0, v1)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform2d(
    program: GLuint,
    location: GLint,
    v0: GLdouble,
    v1: GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform2d({:?}, {:?}, {:?}, {:?});",
        program,
        location,
        v0,
        v1
      );
    }
    let p = glProgramUniform2d_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLdouble, GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, v0, v1),
      None => go_panic_because_fn_not_loaded("glProgramUniform2d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform2d" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform2d", glGetError());
      }
    }
    out
  }
  static glProgramUniform2d_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform2d`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform2d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform2d\0");
    glProgramUniform2d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform2d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform2d_is_loaded() -> bool {
    !glProgramUniform2d_p.load(RELAX).is_null()
  }

  /// [glProgramUniform2dv](http://docs.gl/gl4/glProgramUniform2dv)(program, location, count, value)
  /// * `value` len: count*2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform2dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform2dv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform2dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform2dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform2dv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform2dv", glGetError());
      }
    }
    out
  }
  static glProgramUniform2dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform2dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform2dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform2dv\0");
    glProgramUniform2dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform2dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform2dv_is_loaded() -> bool {
    !glProgramUniform2dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform2f](http://docs.gl/gl4/glProgramUniform2f)(program, location, v0, v1)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform2f(
    program: GLuint,
    location: GLint,
    v0: GLfloat,
    v1: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform2f({:?}, {:?}, {:?}, {:?});",
        program,
        location,
        v0,
        v1
      );
    }
    let p = glProgramUniform2f_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLfloat, GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, v0, v1),
      None => go_panic_because_fn_not_loaded("glProgramUniform2f"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform2f" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform2f", glGetError());
      }
    }
    out
  }
  static glProgramUniform2f_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform2f`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform2f_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform2f\0");
    glProgramUniform2f_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform2f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform2f_is_loaded() -> bool {
    !glProgramUniform2f_p.load(RELAX).is_null()
  }

  /// [glProgramUniform2fv](http://docs.gl/gl4/glProgramUniform2fv)(program, location, count, value)
  /// * `value` len: count*2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform2fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform2fv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform2fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform2fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform2fv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform2fv", glGetError());
      }
    }
    out
  }
  static glProgramUniform2fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform2fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform2fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform2fv\0");
    glProgramUniform2fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform2fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform2fv_is_loaded() -> bool {
    !glProgramUniform2fv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform2i](http://docs.gl/gl4/glProgramUniform2i)(program, location, v0, v1)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform2i(
    program: GLuint,
    location: GLint,
    v0: GLint,
    v1: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform2i({:?}, {:?}, {:?}, {:?});",
        program,
        location,
        v0,
        v1
      );
    }
    let p = glProgramUniform2i_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLint, GLint, GLint)>>(p) {
        Some(fn_p) => fn_p(program, location, v0, v1),
        None => go_panic_because_fn_not_loaded("glProgramUniform2i"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform2i" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform2i", glGetError());
      }
    }
    out
  }
  static glProgramUniform2i_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform2i`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform2i_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform2i\0");
    glProgramUniform2i_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform2i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform2i_is_loaded() -> bool {
    !glProgramUniform2i_p.load(RELAX).is_null()
  }

  /// [glProgramUniform2iv](http://docs.gl/gl4/glProgramUniform2iv)(program, location, count, value)
  /// * `value` len: count*2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform2iv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform2iv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform2iv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform2iv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform2iv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform2iv", glGetError());
      }
    }
    out
  }
  static glProgramUniform2iv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform2iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform2iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform2iv\0");
    glProgramUniform2iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform2iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform2iv_is_loaded() -> bool {
    !glProgramUniform2iv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform2ui](http://docs.gl/gl4/glProgramUniform2ui)(program, location, v0, v1)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform2ui(
    program: GLuint,
    location: GLint,
    v0: GLuint,
    v1: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform2ui({:?}, {:?}, {:?}, {:?});",
        program,
        location,
        v0,
        v1
      );
    }
    let p = glProgramUniform2ui_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLint, GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(program, location, v0, v1),
        None => go_panic_because_fn_not_loaded("glProgramUniform2ui"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform2ui" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform2ui", glGetError());
      }
    }
    out
  }
  static glProgramUniform2ui_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform2ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform2ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform2ui\0");
    glProgramUniform2ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform2ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform2ui_is_loaded() -> bool {
    !glProgramUniform2ui_p.load(RELAX).is_null()
  }

  /// [glProgramUniform2uiv](http://docs.gl/gl4/glProgramUniform2uiv)(program, location, count, value)
  /// * `value` len: count*2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform2uiv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform2uiv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform2uiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform2uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform2uiv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform2uiv", glGetError());
      }
    }
    out
  }
  static glProgramUniform2uiv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform2uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform2uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform2uiv\0");
    glProgramUniform2uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform2uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform2uiv_is_loaded() -> bool {
    !glProgramUniform2uiv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform3d](http://docs.gl/gl4/glProgramUniform3d)(program, location, v0, v1, v2)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform3d(
    program: GLuint,
    location: GLint,
    v0: GLdouble,
    v1: GLdouble,
    v2: GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform3d({:?}, {:?}, {:?}, {:?}, {:?});",
        program,
        location,
        v0,
        v1,
        v2
      );
    }
    let p = glProgramUniform3d_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLdouble, GLdouble, GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, v0, v1, v2),
      None => go_panic_because_fn_not_loaded("glProgramUniform3d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform3d" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform3d", glGetError());
      }
    }
    out
  }
  static glProgramUniform3d_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform3d`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform3d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform3d\0");
    glProgramUniform3d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform3d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform3d_is_loaded() -> bool {
    !glProgramUniform3d_p.load(RELAX).is_null()
  }

  /// [glProgramUniform3dv](http://docs.gl/gl4/glProgramUniform3dv)(program, location, count, value)
  /// * `value` len: count*3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform3dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform3dv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform3dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform3dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform3dv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform3dv", glGetError());
      }
    }
    out
  }
  static glProgramUniform3dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform3dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform3dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform3dv\0");
    glProgramUniform3dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform3dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform3dv_is_loaded() -> bool {
    !glProgramUniform3dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform3f](http://docs.gl/gl4/glProgramUniform3f)(program, location, v0, v1, v2)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform3f(
    program: GLuint,
    location: GLint,
    v0: GLfloat,
    v1: GLfloat,
    v2: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform3f({:?}, {:?}, {:?}, {:?}, {:?});",
        program,
        location,
        v0,
        v1,
        v2
      );
    }
    let p = glProgramUniform3f_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLfloat, GLfloat, GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, v0, v1, v2),
      None => go_panic_because_fn_not_loaded("glProgramUniform3f"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform3f" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform3f", glGetError());
      }
    }
    out
  }
  static glProgramUniform3f_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform3f`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform3f_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform3f\0");
    glProgramUniform3f_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform3f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform3f_is_loaded() -> bool {
    !glProgramUniform3f_p.load(RELAX).is_null()
  }

  /// [glProgramUniform3fv](http://docs.gl/gl4/glProgramUniform3fv)(program, location, count, value)
  /// * `value` len: count*3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform3fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform3fv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform3fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform3fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform3fv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform3fv", glGetError());
      }
    }
    out
  }
  static glProgramUniform3fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform3fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform3fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform3fv\0");
    glProgramUniform3fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform3fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform3fv_is_loaded() -> bool {
    !glProgramUniform3fv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform3i](http://docs.gl/gl4/glProgramUniform3i)(program, location, v0, v1, v2)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform3i(
    program: GLuint,
    location: GLint,
    v0: GLint,
    v1: GLint,
    v2: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform3i({:?}, {:?}, {:?}, {:?}, {:?});",
        program,
        location,
        v0,
        v1,
        v2
      );
    }
    let p = glProgramUniform3i_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLint, GLint, GLint, GLint)>>(
        p,
      ) {
        Some(fn_p) => fn_p(program, location, v0, v1, v2),
        None => go_panic_because_fn_not_loaded("glProgramUniform3i"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform3i" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform3i", glGetError());
      }
    }
    out
  }
  static glProgramUniform3i_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform3i`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform3i_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform3i\0");
    glProgramUniform3i_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform3i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform3i_is_loaded() -> bool {
    !glProgramUniform3i_p.load(RELAX).is_null()
  }

  /// [glProgramUniform3iv](http://docs.gl/gl4/glProgramUniform3iv)(program, location, count, value)
  /// * `value` len: count*3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform3iv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform3iv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform3iv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform3iv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform3iv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform3iv", glGetError());
      }
    }
    out
  }
  static glProgramUniform3iv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform3iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform3iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform3iv\0");
    glProgramUniform3iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform3iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform3iv_is_loaded() -> bool {
    !glProgramUniform3iv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform3ui](http://docs.gl/gl4/glProgramUniform3ui)(program, location, v0, v1, v2)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform3ui(
    program: GLuint,
    location: GLint,
    v0: GLuint,
    v1: GLuint,
    v2: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform3ui({:?}, {:?}, {:?}, {:?}, {:?});",
        program,
        location,
        v0,
        v1,
        v2
      );
    }
    let p = glProgramUniform3ui_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLuint, GLuint, GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, v0, v1, v2),
      None => go_panic_because_fn_not_loaded("glProgramUniform3ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform3ui" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform3ui", glGetError());
      }
    }
    out
  }
  static glProgramUniform3ui_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform3ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform3ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform3ui\0");
    glProgramUniform3ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform3ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform3ui_is_loaded() -> bool {
    !glProgramUniform3ui_p.load(RELAX).is_null()
  }

  /// [glProgramUniform3uiv](http://docs.gl/gl4/glProgramUniform3uiv)(program, location, count, value)
  /// * `value` len: count*3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform3uiv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform3uiv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform3uiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform3uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform3uiv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform3uiv", glGetError());
      }
    }
    out
  }
  static glProgramUniform3uiv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform3uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform3uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform3uiv\0");
    glProgramUniform3uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform3uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform3uiv_is_loaded() -> bool {
    !glProgramUniform3uiv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform4d](http://docs.gl/gl4/glProgramUniform4d)(program, location, v0, v1, v2, v3)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform4d(
    program: GLuint,
    location: GLint,
    v0: GLdouble,
    v1: GLdouble,
    v2: GLdouble,
    v3: GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform4d({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
        program,
        location,
        v0,
        v1,
        v2,
        v3
      );
    }
    let p = glProgramUniform4d_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLdouble,
          GLdouble,
          GLdouble,
          GLdouble,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, v0, v1, v2, v3),
      None => go_panic_because_fn_not_loaded("glProgramUniform4d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform4d" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform4d", glGetError());
      }
    }
    out
  }
  static glProgramUniform4d_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform4d`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform4d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform4d\0");
    glProgramUniform4d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform4d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform4d_is_loaded() -> bool {
    !glProgramUniform4d_p.load(RELAX).is_null()
  }

  /// [glProgramUniform4dv](http://docs.gl/gl4/glProgramUniform4dv)(program, location, count, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform4dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform4dv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform4dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform4dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform4dv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform4dv", glGetError());
      }
    }
    out
  }
  static glProgramUniform4dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform4dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform4dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform4dv\0");
    glProgramUniform4dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform4dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform4dv_is_loaded() -> bool {
    !glProgramUniform4dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform4f](http://docs.gl/gl4/glProgramUniform4f)(program, location, v0, v1, v2, v3)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform4f(
    program: GLuint,
    location: GLint,
    v0: GLfloat,
    v1: GLfloat,
    v2: GLfloat,
    v3: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform4f({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
        program,
        location,
        v0,
        v1,
        v2,
        v3
      );
    }
    let p = glProgramUniform4f_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLfloat, GLfloat, GLfloat, GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, v0, v1, v2, v3),
      None => go_panic_because_fn_not_loaded("glProgramUniform4f"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform4f" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform4f", glGetError());
      }
    }
    out
  }
  static glProgramUniform4f_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform4f`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform4f_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform4f\0");
    glProgramUniform4f_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform4f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform4f_is_loaded() -> bool {
    !glProgramUniform4f_p.load(RELAX).is_null()
  }

  /// [glProgramUniform4fv](http://docs.gl/gl4/glProgramUniform4fv)(program, location, count, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform4fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform4fv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform4fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform4fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform4fv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform4fv", glGetError());
      }
    }
    out
  }
  static glProgramUniform4fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform4fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform4fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform4fv\0");
    glProgramUniform4fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform4fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform4fv_is_loaded() -> bool {
    !glProgramUniform4fv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform4i](http://docs.gl/gl4/glProgramUniform4i)(program, location, v0, v1, v2, v3)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform4i(
    program: GLuint,
    location: GLint,
    v0: GLint,
    v1: GLint,
    v2: GLint,
    v3: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform4i({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
        program,
        location,
        v0,
        v1,
        v2,
        v3
      );
    }
    let p = glProgramUniform4i_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, v0, v1, v2, v3),
      None => go_panic_because_fn_not_loaded("glProgramUniform4i"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform4i" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform4i", glGetError());
      }
    }
    out
  }
  static glProgramUniform4i_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform4i`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform4i_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform4i\0");
    glProgramUniform4i_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform4i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform4i_is_loaded() -> bool {
    !glProgramUniform4i_p.load(RELAX).is_null()
  }

  /// [glProgramUniform4iv](http://docs.gl/gl4/glProgramUniform4iv)(program, location, count, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform4iv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform4iv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform4iv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform4iv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform4iv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform4iv", glGetError());
      }
    }
    out
  }
  static glProgramUniform4iv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform4iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform4iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform4iv\0");
    glProgramUniform4iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform4iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform4iv_is_loaded() -> bool {
    !glProgramUniform4iv_p.load(RELAX).is_null()
  }

  /// [glProgramUniform4ui](http://docs.gl/gl4/glProgramUniform4ui)(program, location, v0, v1, v2, v3)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform4ui(
    program: GLuint,
    location: GLint,
    v0: GLuint,
    v1: GLuint,
    v2: GLuint,
    v3: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform4ui({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
        program,
        location,
        v0,
        v1,
        v2,
        v3
      );
    }
    let p = glProgramUniform4ui_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLuint, GLuint, GLuint, GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, v0, v1, v2, v3),
      None => go_panic_because_fn_not_loaded("glProgramUniform4ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform4ui" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform4ui", glGetError());
      }
    }
    out
  }
  static glProgramUniform4ui_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform4ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform4ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform4ui\0");
    glProgramUniform4ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform4ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform4ui_is_loaded() -> bool {
    !glProgramUniform4ui_p.load(RELAX).is_null()
  }

  /// [glProgramUniform4uiv](http://docs.gl/gl4/glProgramUniform4uiv)(program, location, count, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniform4uiv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniform4uiv({:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        value
      );
    }
    let p = glProgramUniform4uiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, *const GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, value),
      None => go_panic_because_fn_not_loaded("glProgramUniform4uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniform4uiv" != "glGetError" {
        report_error_as_necessary_from("glProgramUniform4uiv", glGetError());
      }
    }
    out
  }
  static glProgramUniform4uiv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniform4uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniform4uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniform4uiv\0");
    glProgramUniform4uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniform4uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniform4uiv_is_loaded() -> bool {
    !glProgramUniform4uiv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix2dv](http://docs.gl/gl4/glProgramUniformMatrix2dv)(program, location, count, transpose, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix2dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix2dv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix2dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix2dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix2dv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix2dv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix2dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix2dv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix2dv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix2dv\0");
    glProgramUniformMatrix2dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix2dv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix2dv_is_loaded() -> bool {
    !glProgramUniformMatrix2dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix2fv](http://docs.gl/gl4/glProgramUniformMatrix2fv)(program, location, count, transpose, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix2fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix2fv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix2fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix2fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix2fv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix2fv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix2fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix2fv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix2fv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix2fv\0");
    glProgramUniformMatrix2fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix2fv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix2fv_is_loaded() -> bool {
    !glProgramUniformMatrix2fv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix2x3dv](http://docs.gl/gl4/glProgramUniformMatrix2x3dv)(program, location, count, transpose, value)
  /// * `value` len: count*6
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix2x3dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix2x3dv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix2x3dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix2x3dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix2x3dv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix2x3dv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix2x3dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix2x3dv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix2x3dv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix2x3dv\0");
    glProgramUniformMatrix2x3dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix2x3dv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix2x3dv_is_loaded() -> bool {
    !glProgramUniformMatrix2x3dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix2x3fv](http://docs.gl/gl4/glProgramUniformMatrix2x3fv)(program, location, count, transpose, value)
  /// * `value` len: count*6
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix2x3fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix2x3fv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix2x3fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix2x3fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix2x3fv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix2x3fv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix2x3fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix2x3fv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix2x3fv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix2x3fv\0");
    glProgramUniformMatrix2x3fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix2x3fv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix2x3fv_is_loaded() -> bool {
    !glProgramUniformMatrix2x3fv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix2x4dv](http://docs.gl/gl4/glProgramUniformMatrix2x4dv)(program, location, count, transpose, value)
  /// * `value` len: count*8
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix2x4dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix2x4dv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix2x4dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix2x4dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix2x4dv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix2x4dv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix2x4dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix2x4dv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix2x4dv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix2x4dv\0");
    glProgramUniformMatrix2x4dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix2x4dv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix2x4dv_is_loaded() -> bool {
    !glProgramUniformMatrix2x4dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix2x4fv](http://docs.gl/gl4/glProgramUniformMatrix2x4fv)(program, location, count, transpose, value)
  /// * `value` len: count*8
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix2x4fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix2x4fv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix2x4fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix2x4fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix2x4fv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix2x4fv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix2x4fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix2x4fv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix2x4fv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix2x4fv\0");
    glProgramUniformMatrix2x4fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix2x4fv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix2x4fv_is_loaded() -> bool {
    !glProgramUniformMatrix2x4fv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix3dv](http://docs.gl/gl4/glProgramUniformMatrix3dv)(program, location, count, transpose, value)
  /// * `value` len: count*9
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix3dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix3dv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix3dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix3dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix3dv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix3dv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix3dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix3dv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix3dv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix3dv\0");
    glProgramUniformMatrix3dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix3dv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix3dv_is_loaded() -> bool {
    !glProgramUniformMatrix3dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix3fv](http://docs.gl/gl4/glProgramUniformMatrix3fv)(program, location, count, transpose, value)
  /// * `value` len: count*9
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix3fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix3fv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix3fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix3fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix3fv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix3fv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix3fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix3fv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix3fv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix3fv\0");
    glProgramUniformMatrix3fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix3fv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix3fv_is_loaded() -> bool {
    !glProgramUniformMatrix3fv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix3x2dv](http://docs.gl/gl4/glProgramUniformMatrix3x2dv)(program, location, count, transpose, value)
  /// * `value` len: count*6
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix3x2dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix3x2dv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix3x2dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix3x2dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix3x2dv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix3x2dv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix3x2dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix3x2dv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix3x2dv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix3x2dv\0");
    glProgramUniformMatrix3x2dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix3x2dv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix3x2dv_is_loaded() -> bool {
    !glProgramUniformMatrix3x2dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix3x2fv](http://docs.gl/gl4/glProgramUniformMatrix3x2fv)(program, location, count, transpose, value)
  /// * `value` len: count*6
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix3x2fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix3x2fv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix3x2fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix3x2fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix3x2fv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix3x2fv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix3x2fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix3x2fv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix3x2fv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix3x2fv\0");
    glProgramUniformMatrix3x2fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix3x2fv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix3x2fv_is_loaded() -> bool {
    !glProgramUniformMatrix3x2fv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix3x4dv](http://docs.gl/gl4/glProgramUniformMatrix3x4dv)(program, location, count, transpose, value)
  /// * `value` len: count*12
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix3x4dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix3x4dv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix3x4dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix3x4dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix3x4dv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix3x4dv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix3x4dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix3x4dv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix3x4dv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix3x4dv\0");
    glProgramUniformMatrix3x4dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix3x4dv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix3x4dv_is_loaded() -> bool {
    !glProgramUniformMatrix3x4dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix3x4fv](http://docs.gl/gl4/glProgramUniformMatrix3x4fv)(program, location, count, transpose, value)
  /// * `value` len: count*12
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix3x4fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix3x4fv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix3x4fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix3x4fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix3x4fv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix3x4fv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix3x4fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix3x4fv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix3x4fv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix3x4fv\0");
    glProgramUniformMatrix3x4fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix3x4fv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix3x4fv_is_loaded() -> bool {
    !glProgramUniformMatrix3x4fv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix4dv](http://docs.gl/gl4/glProgramUniformMatrix4dv)(program, location, count, transpose, value)
  /// * `value` len: count*16
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix4dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix4dv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix4dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix4dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix4dv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix4dv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix4dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix4dv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix4dv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix4dv\0");
    glProgramUniformMatrix4dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix4dv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix4dv_is_loaded() -> bool {
    !glProgramUniformMatrix4dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix4fv](http://docs.gl/gl4/glProgramUniformMatrix4fv)(program, location, count, transpose, value)
  /// * `value` len: count*16
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix4fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix4fv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix4fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix4fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix4fv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix4fv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix4fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix4fv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix4fv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix4fv\0");
    glProgramUniformMatrix4fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix4fv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix4fv_is_loaded() -> bool {
    !glProgramUniformMatrix4fv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix4x2dv](http://docs.gl/gl4/glProgramUniformMatrix4x2dv)(program, location, count, transpose, value)
  /// * `value` len: count*8
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix4x2dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix4x2dv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix4x2dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix4x2dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix4x2dv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix4x2dv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix4x2dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix4x2dv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix4x2dv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix4x2dv\0");
    glProgramUniformMatrix4x2dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix4x2dv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix4x2dv_is_loaded() -> bool {
    !glProgramUniformMatrix4x2dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix4x2fv](http://docs.gl/gl4/glProgramUniformMatrix4x2fv)(program, location, count, transpose, value)
  /// * `value` len: count*8
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix4x2fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix4x2fv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix4x2fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix4x2fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix4x2fv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix4x2fv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix4x2fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix4x2fv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix4x2fv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix4x2fv\0");
    glProgramUniformMatrix4x2fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix4x2fv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix4x2fv_is_loaded() -> bool {
    !glProgramUniformMatrix4x2fv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix4x3dv](http://docs.gl/gl4/glProgramUniformMatrix4x3dv)(program, location, count, transpose, value)
  /// * `value` len: count*12
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix4x3dv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix4x3dv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix4x3dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix4x3dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix4x3dv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix4x3dv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix4x3dv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix4x3dv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix4x3dv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix4x3dv\0");
    glProgramUniformMatrix4x3dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix4x3dv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix4x3dv_is_loaded() -> bool {
    !glProgramUniformMatrix4x3dv_p.load(RELAX).is_null()
  }

  /// [glProgramUniformMatrix4x3fv](http://docs.gl/gl4/glProgramUniformMatrix4x3fv)(program, location, count, transpose, value)
  /// * `value` len: count*12
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProgramUniformMatrix4x3fv(
    program: GLuint,
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glProgramUniformMatrix4x3fv({:?}, {:?}, {:?}, {:?}, {:p});",
        program,
        location,
        count,
        transpose,
        value
      );
    }
    let p = glProgramUniformMatrix4x3fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glProgramUniformMatrix4x3fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProgramUniformMatrix4x3fv" != "glGetError" {
        report_error_as_necessary_from(
          "glProgramUniformMatrix4x3fv",
          glGetError(),
        );
      }
    }
    out
  }
  static glProgramUniformMatrix4x3fv_p: APcv = ap_null();
  /// Tries to load [`glProgramUniformMatrix4x3fv`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProgramUniformMatrix4x3fv_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glProgramUniformMatrix4x3fv\0");
    glProgramUniformMatrix4x3fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProgramUniformMatrix4x3fv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProgramUniformMatrix4x3fv_is_loaded() -> bool {
    !glProgramUniformMatrix4x3fv_p.load(RELAX).is_null()
  }

  /// [glProvokingVertex](http://docs.gl/gl4/glProvokingVertex)(mode)
  /// * `mode` group: VertexProvokingMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glProvokingVertex(mode: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glProvokingVertex({:#X});", mode);
    }
    let p = glProvokingVertex_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(mode),
      None => go_panic_because_fn_not_loaded("glProvokingVertex"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glProvokingVertex" != "glGetError" {
        report_error_as_necessary_from("glProvokingVertex", glGetError());
      }
    }
    out
  }
  static glProvokingVertex_p: APcv = ap_null();
  /// Tries to load [`glProvokingVertex`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glProvokingVertex_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glProvokingVertex\0");
    glProvokingVertex_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glProvokingVertex`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glProvokingVertex_is_loaded() -> bool {
    !glProvokingVertex_p.load(RELAX).is_null()
  }

  /// [glPushDebugGroup](http://docs.gl/gl4/glPushDebugGroup)(source, id, length, message)
  /// * `source` group: DebugSource
  /// * `message` len: COMPSIZE(message,length)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glPushDebugGroup(
    source: GLenum,
    id: GLuint,
    length: GLsizei,
    message: *const GLchar,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glPushDebugGroup({:#X}, {:?}, {:?}, {:p});",
        source,
        id,
        length,
        message
      );
    }
    let p = glPushDebugGroup_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLuint, GLsizei, *const GLchar)>,
    >(p)
    {
      Some(fn_p) => fn_p(source, id, length, message),
      None => go_panic_because_fn_not_loaded("glPushDebugGroup"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glPushDebugGroup" != "glGetError" {
        report_error_as_necessary_from("glPushDebugGroup", glGetError());
      }
    }
    out
  }
  static glPushDebugGroup_p: APcv = ap_null();
  /// Tries to load [`glPushDebugGroup`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glPushDebugGroup_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glPushDebugGroup\0");
    glPushDebugGroup_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glPushDebugGroup`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glPushDebugGroup_is_loaded() -> bool {
    !glPushDebugGroup_p.load(RELAX).is_null()
  }

  /// [glQueryCounter](http://docs.gl/gl4/glQueryCounter)(id, target)
  /// * `target` group: QueryCounterTarget
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glQueryCounter(id: GLuint, target: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glQueryCounter({:?}, {:#X});", id, target);
    }
    let p = glQueryCounter_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum)>>(p) {
      Some(fn_p) => fn_p(id, target),
      None => go_panic_because_fn_not_loaded("glQueryCounter"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glQueryCounter" != "glGetError" {
        report_error_as_necessary_from("glQueryCounter", glGetError());
      }
    }
    out
  }
  static glQueryCounter_p: APcv = ap_null();
  /// Tries to load [`glQueryCounter`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glQueryCounter_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glQueryCounter\0");
    glQueryCounter_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glQueryCounter`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glQueryCounter_is_loaded() -> bool {
    !glQueryCounter_p.load(RELAX).is_null()
  }

  /// [glReadBuffer](http://docs.gl/gl4/glReadBuffer)(src)
  /// * `src` group: ReadBufferMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glReadBuffer(src: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glReadBuffer({:#X});", src);
    }
    let p = glReadBuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
      Some(fn_p) => fn_p(src),
      None => go_panic_because_fn_not_loaded("glReadBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glReadBuffer" != "glGetError" {
        report_error_as_necessary_from("glReadBuffer", glGetError());
      }
    }
    out
  }
  static glReadBuffer_p: APcv = ap_null();
  /// Tries to load [`glReadBuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glReadBuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glReadBuffer\0");
    glReadBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glReadBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glReadBuffer_is_loaded() -> bool {
    !glReadBuffer_p.load(RELAX).is_null()
  }

  /// [glReadPixels](http://docs.gl/gl4/glReadPixels)(x, y, width, height, format, type_, pixels)
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width,height)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glReadPixels(
    x: GLint,
    y: GLint,
    width: GLsizei,
    height: GLsizei,
    format: GLenum,
    type_: GLenum,
    pixels: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glReadPixels({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
        x,
        y,
        width,
        height,
        format,
        type_,
        pixels
      );
    }
    let p = glReadPixels_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLenum,
          GLenum,
          *mut c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(x, y, width, height, format, type_, pixels),
      None => go_panic_because_fn_not_loaded("glReadPixels"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glReadPixels" != "glGetError" {
        report_error_as_necessary_from("glReadPixels", glGetError());
      }
    }
    out
  }
  static glReadPixels_p: APcv = ap_null();
  /// Tries to load [`glReadPixels`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glReadPixels_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glReadPixels\0");
    glReadPixels_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glReadPixels`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glReadPixels_is_loaded() -> bool {
    !glReadPixels_p.load(RELAX).is_null()
  }

  /// [glReadnPixels](http://docs.gl/gl4/glReadnPixels)(x, y, width, height, format, type_, bufSize, data)
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `data` len: bufSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glReadnPixels(
    x: GLint,
    y: GLint,
    width: GLsizei,
    height: GLsizei,
    format: GLenum,
    type_: GLenum,
    bufSize: GLsizei,
    data: *mut c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glReadnPixels({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:?}, {:p});", x, y, width, height, format, type_, bufSize, data);
    }
    let p = glReadnPixels_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLenum,
          GLenum,
          GLsizei,
          *mut c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(x, y, width, height, format, type_, bufSize, data),
      None => go_panic_because_fn_not_loaded("glReadnPixels"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glReadnPixels" != "glGetError" {
        report_error_as_necessary_from("glReadnPixels", glGetError());
      }
    }
    out
  }
  static glReadnPixels_p: APcv = ap_null();
  /// Tries to load [`glReadnPixels`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glReadnPixels_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glReadnPixels\0");
    glReadnPixels_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glReadnPixels`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glReadnPixels_is_loaded() -> bool {
    !glReadnPixels_p.load(RELAX).is_null()
  }

  /// [glReleaseShaderCompiler](http://docs.gl/gl4/glReleaseShaderCompiler)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glReleaseShaderCompiler() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glReleaseShaderCompiler();",);
    }
    let p = glReleaseShaderCompiler_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn()>>(p) {
      Some(fn_p) => fn_p(),
      None => go_panic_because_fn_not_loaded("glReleaseShaderCompiler"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glReleaseShaderCompiler" != "glGetError" {
        report_error_as_necessary_from("glReleaseShaderCompiler", glGetError());
      }
    }
    out
  }
  static glReleaseShaderCompiler_p: APcv = ap_null();
  /// Tries to load [`glReleaseShaderCompiler`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glReleaseShaderCompiler_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glReleaseShaderCompiler\0");
    glReleaseShaderCompiler_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glReleaseShaderCompiler`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glReleaseShaderCompiler_is_loaded() -> bool {
    !glReleaseShaderCompiler_p.load(RELAX).is_null()
  }

  /// [glRenderbufferStorage](http://docs.gl/gl4/glRenderbufferStorage)(target, internalformat, width, height)
  /// * `target` group: RenderbufferTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glRenderbufferStorage(
    target: GLenum,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glRenderbufferStorage({:#X}, {:#X}, {:?}, {:?});",
        target,
        internalformat,
        width,
        height
      );
    }
    let p = glRenderbufferStorage_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, GLsizei, GLsizei)>>(p)
      {
        Some(fn_p) => fn_p(target, internalformat, width, height),
        None => go_panic_because_fn_not_loaded("glRenderbufferStorage"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glRenderbufferStorage" != "glGetError" {
        report_error_as_necessary_from("glRenderbufferStorage", glGetError());
      }
    }
    out
  }
  static glRenderbufferStorage_p: APcv = ap_null();
  /// Tries to load [`glRenderbufferStorage`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glRenderbufferStorage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glRenderbufferStorage\0");
    glRenderbufferStorage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glRenderbufferStorage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glRenderbufferStorage_is_loaded() -> bool {
    !glRenderbufferStorage_p.load(RELAX).is_null()
  }

  /// [glRenderbufferStorageMultisample](http://docs.gl/gl4/glRenderbufferStorageMultisample)(target, samples, internalformat, width, height)
  /// * `target` group: RenderbufferTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glRenderbufferStorageMultisample(
    target: GLenum,
    samples: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glRenderbufferStorageMultisample({:#X}, {:?}, {:#X}, {:?}, {:?});", target, samples, internalformat, width, height);
    }
    let p = glRenderbufferStorageMultisample_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, samples, internalformat, width, height),
      None => {
        go_panic_because_fn_not_loaded("glRenderbufferStorageMultisample")
      }
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glRenderbufferStorageMultisample" != "glGetError" {
        report_error_as_necessary_from(
          "glRenderbufferStorageMultisample",
          glGetError(),
        );
      }
    }
    out
  }
  static glRenderbufferStorageMultisample_p: APcv = ap_null();
  /// Tries to load [`glRenderbufferStorageMultisample`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glRenderbufferStorageMultisample_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p =
      do_the_load(get_proc_address, b"glRenderbufferStorageMultisample\0");
    glRenderbufferStorageMultisample_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glRenderbufferStorageMultisample`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glRenderbufferStorageMultisample_is_loaded() -> bool {
    !glRenderbufferStorageMultisample_p.load(RELAX).is_null()
  }

  /// [glResumeTransformFeedback](http://docs.gl/gl4/glResumeTransformFeedback)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glResumeTransformFeedback() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glResumeTransformFeedback();",);
    }
    let p = glResumeTransformFeedback_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn()>>(p) {
      Some(fn_p) => fn_p(),
      None => go_panic_because_fn_not_loaded("glResumeTransformFeedback"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glResumeTransformFeedback" != "glGetError" {
        report_error_as_necessary_from(
          "glResumeTransformFeedback",
          glGetError(),
        );
      }
    }
    out
  }
  static glResumeTransformFeedback_p: APcv = ap_null();
  /// Tries to load [`glResumeTransformFeedback`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glResumeTransformFeedback_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glResumeTransformFeedback\0");
    glResumeTransformFeedback_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glResumeTransformFeedback`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glResumeTransformFeedback_is_loaded() -> bool {
    !glResumeTransformFeedback_p.load(RELAX).is_null()
  }

  /// [glSampleCoverage](http://docs.gl/gl4/glSampleCoverage)(value, invert)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSampleCoverage(value: GLfloat, invert: GLboolean) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glSampleCoverage({:?}, {:?});", value, invert);
    }
    let p = glSampleCoverage_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLfloat, GLboolean)>>(p) {
      Some(fn_p) => fn_p(value, invert),
      None => go_panic_because_fn_not_loaded("glSampleCoverage"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glSampleCoverage" != "glGetError" {
        report_error_as_necessary_from("glSampleCoverage", glGetError());
      }
    }
    out
  }
  static glSampleCoverage_p: APcv = ap_null();
  /// Tries to load [`glSampleCoverage`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glSampleCoverage_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glSampleCoverage\0");
    glSampleCoverage_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glSampleCoverage`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSampleCoverage_is_loaded() -> bool {
    !glSampleCoverage_p.load(RELAX).is_null()
  }

  /// [glSampleMaski](http://docs.gl/gl4/glSampleMaski)(maskNumber, mask)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSampleMaski(maskNumber: GLuint, mask: GLbitfield) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glSampleMaski({:?}, {:?});", maskNumber, mask);
    }
    let p = glSampleMaski_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLbitfield)>>(p) {
      Some(fn_p) => fn_p(maskNumber, mask),
      None => go_panic_because_fn_not_loaded("glSampleMaski"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glSampleMaski" != "glGetError" {
        report_error_as_necessary_from("glSampleMaski", glGetError());
      }
    }
    out
  }
  static glSampleMaski_p: APcv = ap_null();
  /// Tries to load [`glSampleMaski`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glSampleMaski_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glSampleMaski\0");
    glSampleMaski_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glSampleMaski`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSampleMaski_is_loaded() -> bool {
    !glSampleMaski_p.load(RELAX).is_null()
  }

  /// [glSamplerParameterIiv](http://docs.gl/gl4/glSamplerParameterIiv)(sampler, pname, param)
  /// * `pname` group: SamplerParameterI
  /// * `param` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSamplerParameterIiv(
    sampler: GLuint,
    pname: GLenum,
    param: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSamplerParameterIiv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        param
      );
    }
    let p = glSamplerParameterIiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLint)>>(p) {
        Some(fn_p) => fn_p(sampler, pname, param),
        None => go_panic_because_fn_not_loaded("glSamplerParameterIiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glSamplerParameterIiv" != "glGetError" {
        report_error_as_necessary_from("glSamplerParameterIiv", glGetError());
      }
    }
    out
  }
  static glSamplerParameterIiv_p: APcv = ap_null();
  /// Tries to load [`glSamplerParameterIiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glSamplerParameterIiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glSamplerParameterIiv\0");
    glSamplerParameterIiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glSamplerParameterIiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSamplerParameterIiv_is_loaded() -> bool {
    !glSamplerParameterIiv_p.load(RELAX).is_null()
  }

  /// [glSamplerParameterIuiv](http://docs.gl/gl4/glSamplerParameterIuiv)(sampler, pname, param)
  /// * `pname` group: SamplerParameterI
  /// * `param` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSamplerParameterIuiv(
    sampler: GLuint,
    pname: GLenum,
    param: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSamplerParameterIuiv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        param
      );
    }
    let p = glSamplerParameterIuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(sampler, pname, param),
        None => go_panic_because_fn_not_loaded("glSamplerParameterIuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glSamplerParameterIuiv" != "glGetError" {
        report_error_as_necessary_from("glSamplerParameterIuiv", glGetError());
      }
    }
    out
  }
  static glSamplerParameterIuiv_p: APcv = ap_null();
  /// Tries to load [`glSamplerParameterIuiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glSamplerParameterIuiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glSamplerParameterIuiv\0");
    glSamplerParameterIuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glSamplerParameterIuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSamplerParameterIuiv_is_loaded() -> bool {
    !glSamplerParameterIuiv_p.load(RELAX).is_null()
  }

  /// [glSamplerParameterf](http://docs.gl/gl4/glSamplerParameterf)(sampler, pname, param)
  /// * `pname` group: SamplerParameterF
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSamplerParameterf(
    sampler: GLuint,
    pname: GLenum,
    param: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSamplerParameterf({:?}, {:#X}, {:?});",
        sampler,
        pname,
        param
      );
    }
    let p = glSamplerParameterf_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLfloat)>>(p) {
      Some(fn_p) => fn_p(sampler, pname, param),
      None => go_panic_because_fn_not_loaded("glSamplerParameterf"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glSamplerParameterf" != "glGetError" {
        report_error_as_necessary_from("glSamplerParameterf", glGetError());
      }
    }
    out
  }
  static glSamplerParameterf_p: APcv = ap_null();
  /// Tries to load [`glSamplerParameterf`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glSamplerParameterf_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glSamplerParameterf\0");
    glSamplerParameterf_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glSamplerParameterf`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSamplerParameterf_is_loaded() -> bool {
    !glSamplerParameterf_p.load(RELAX).is_null()
  }

  /// [glSamplerParameterfv](http://docs.gl/gl4/glSamplerParameterfv)(sampler, pname, param)
  /// * `pname` group: SamplerParameterF
  /// * `param` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSamplerParameterfv(
    sampler: GLuint,
    pname: GLenum,
    param: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSamplerParameterfv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        param
      );
    }
    let p = glSamplerParameterfv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLfloat)>>(p) {
        Some(fn_p) => fn_p(sampler, pname, param),
        None => go_panic_because_fn_not_loaded("glSamplerParameterfv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glSamplerParameterfv" != "glGetError" {
        report_error_as_necessary_from("glSamplerParameterfv", glGetError());
      }
    }
    out
  }
  static glSamplerParameterfv_p: APcv = ap_null();
  /// Tries to load [`glSamplerParameterfv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glSamplerParameterfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glSamplerParameterfv\0");
    glSamplerParameterfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glSamplerParameterfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSamplerParameterfv_is_loaded() -> bool {
    !glSamplerParameterfv_p.load(RELAX).is_null()
  }

  /// [glSamplerParameteri](http://docs.gl/gl4/glSamplerParameteri)(sampler, pname, param)
  /// * `pname` group: SamplerParameterI
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSamplerParameteri(
    sampler: GLuint,
    pname: GLenum,
    param: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSamplerParameteri({:?}, {:#X}, {:?});",
        sampler,
        pname,
        param
      );
    }
    let p = glSamplerParameteri_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLint)>>(p) {
      Some(fn_p) => fn_p(sampler, pname, param),
      None => go_panic_because_fn_not_loaded("glSamplerParameteri"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glSamplerParameteri" != "glGetError" {
        report_error_as_necessary_from("glSamplerParameteri", glGetError());
      }
    }
    out
  }
  static glSamplerParameteri_p: APcv = ap_null();
  /// Tries to load [`glSamplerParameteri`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glSamplerParameteri_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glSamplerParameteri\0");
    glSamplerParameteri_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glSamplerParameteri`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSamplerParameteri_is_loaded() -> bool {
    !glSamplerParameteri_p.load(RELAX).is_null()
  }

  /// [glSamplerParameteriv](http://docs.gl/gl4/glSamplerParameteriv)(sampler, pname, param)
  /// * `pname` group: SamplerParameterI
  /// * `param` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSamplerParameteriv(
    sampler: GLuint,
    pname: GLenum,
    param: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSamplerParameteriv({:?}, {:#X}, {:p});",
        sampler,
        pname,
        param
      );
    }
    let p = glSamplerParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLint)>>(p) {
        Some(fn_p) => fn_p(sampler, pname, param),
        None => go_panic_because_fn_not_loaded("glSamplerParameteriv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glSamplerParameteriv" != "glGetError" {
        report_error_as_necessary_from("glSamplerParameteriv", glGetError());
      }
    }
    out
  }
  static glSamplerParameteriv_p: APcv = ap_null();
  /// Tries to load [`glSamplerParameteriv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glSamplerParameteriv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glSamplerParameteriv\0");
    glSamplerParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glSamplerParameteriv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSamplerParameteriv_is_loaded() -> bool {
    !glSamplerParameteriv_p.load(RELAX).is_null()
  }

  /// [glScissor](http://docs.gl/gl4/glScissor)(x, y, width, height)
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glScissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glScissor({:?}, {:?}, {:?}, {:?});", x, y, width, height);
    }
    let p = glScissor_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLint, GLsizei, GLsizei)>>(p) {
        Some(fn_p) => fn_p(x, y, width, height),
        None => go_panic_because_fn_not_loaded("glScissor"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glScissor" != "glGetError" {
        report_error_as_necessary_from("glScissor", glGetError());
      }
    }
    out
  }
  static glScissor_p: APcv = ap_null();
  /// Tries to load [`glScissor`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glScissor_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glScissor\0");
    glScissor_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glScissor`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glScissor_is_loaded() -> bool {
    !glScissor_p.load(RELAX).is_null()
  }

  /// [glScissorArrayv](http://docs.gl/gl4/glScissorArrayv)(first, count, v)
  /// * `v` len: COMPSIZE(count)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glScissorArrayv(
    first: GLuint,
    count: GLsizei,
    v: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glScissorArrayv({:?}, {:?}, {:p});", first, count, v);
    }
    let p = glScissorArrayv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLsizei, *const GLint)>>(p) {
        Some(fn_p) => fn_p(first, count, v),
        None => go_panic_because_fn_not_loaded("glScissorArrayv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glScissorArrayv" != "glGetError" {
        report_error_as_necessary_from("glScissorArrayv", glGetError());
      }
    }
    out
  }
  static glScissorArrayv_p: APcv = ap_null();
  /// Tries to load [`glScissorArrayv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glScissorArrayv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glScissorArrayv\0");
    glScissorArrayv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glScissorArrayv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glScissorArrayv_is_loaded() -> bool {
    !glScissorArrayv_p.load(RELAX).is_null()
  }

  /// [glScissorIndexed](http://docs.gl/gl4/glScissorIndexed)(index, left, bottom, width, height)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glScissorIndexed(
    index: GLuint,
    left: GLint,
    bottom: GLint,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glScissorIndexed({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        left,
        bottom,
        width,
        height
      );
    }
    let p = glScissorIndexed_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLint, GLsizei, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, left, bottom, width, height),
      None => go_panic_because_fn_not_loaded("glScissorIndexed"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glScissorIndexed" != "glGetError" {
        report_error_as_necessary_from("glScissorIndexed", glGetError());
      }
    }
    out
  }
  static glScissorIndexed_p: APcv = ap_null();
  /// Tries to load [`glScissorIndexed`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glScissorIndexed_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glScissorIndexed\0");
    glScissorIndexed_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glScissorIndexed`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glScissorIndexed_is_loaded() -> bool {
    !glScissorIndexed_p.load(RELAX).is_null()
  }

  /// [glScissorIndexedv](http://docs.gl/gl4/glScissorIndexedv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glScissorIndexedv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glScissorIndexedv({:?}, {:p});", index, v);
    }
    let p = glScissorIndexedv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glScissorIndexedv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glScissorIndexedv" != "glGetError" {
        report_error_as_necessary_from("glScissorIndexedv", glGetError());
      }
    }
    out
  }
  static glScissorIndexedv_p: APcv = ap_null();
  /// Tries to load [`glScissorIndexedv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glScissorIndexedv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glScissorIndexedv\0");
    glScissorIndexedv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glScissorIndexedv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glScissorIndexedv_is_loaded() -> bool {
    !glScissorIndexedv_p.load(RELAX).is_null()
  }

  /// [glShaderBinary](http://docs.gl/gl4/glShaderBinary)(count, shaders, binaryformat, binary, length)
  /// * `shaders` len: count
  /// * `binary` len: length
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glShaderBinary(
    count: GLsizei,
    shaders: *const GLuint,
    binaryformat: GLenum,
    binary: *const c_void,
    length: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glShaderBinary({:?}, {:p}, {:#X}, {:p}, {:?});",
        count,
        shaders,
        binaryformat,
        binary,
        length
      );
    }
    let p = glShaderBinary_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLsizei,
          *const GLuint,
          GLenum,
          *const c_void,
          GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(count, shaders, binaryformat, binary, length),
      None => go_panic_because_fn_not_loaded("glShaderBinary"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glShaderBinary" != "glGetError" {
        report_error_as_necessary_from("glShaderBinary", glGetError());
      }
    }
    out
  }
  static glShaderBinary_p: APcv = ap_null();
  /// Tries to load [`glShaderBinary`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glShaderBinary_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glShaderBinary\0");
    glShaderBinary_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glShaderBinary`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glShaderBinary_is_loaded() -> bool {
    !glShaderBinary_p.load(RELAX).is_null()
  }

  /// [glShaderSource](http://docs.gl/gl4/glShaderSource)(shader, count, string, length)
  /// * `string` len: count
  /// * `length` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glShaderSource(
    shader: GLuint,
    count: GLsizei,
    string: *const *const GLchar,
    length: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glShaderSource({:?}, {:?}, {:p}, {:p});",
        shader,
        count,
        string,
        length
      );
    }
    let p = glShaderSource_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(GLuint, GLsizei, *const *const GLchar, *const GLint),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(shader, count, string, length),
      None => go_panic_because_fn_not_loaded("glShaderSource"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glShaderSource" != "glGetError" {
        report_error_as_necessary_from("glShaderSource", glGetError());
      }
    }
    out
  }
  static glShaderSource_p: APcv = ap_null();
  /// Tries to load [`glShaderSource`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glShaderSource_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glShaderSource\0");
    glShaderSource_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glShaderSource`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glShaderSource_is_loaded() -> bool {
    !glShaderSource_p.load(RELAX).is_null()
  }

  /// [glShaderStorageBlockBinding](http://docs.gl/gl4/glShaderStorageBlockBinding)(program, storageBlockIndex, storageBlockBinding)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glShaderStorageBlockBinding(
    program: GLuint,
    storageBlockIndex: GLuint,
    storageBlockBinding: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glShaderStorageBlockBinding({:?}, {:?}, {:?});",
        program,
        storageBlockIndex,
        storageBlockBinding
      );
    }
    let p = glShaderStorageBlockBinding_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(program, storageBlockIndex, storageBlockBinding),
      None => go_panic_because_fn_not_loaded("glShaderStorageBlockBinding"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glShaderStorageBlockBinding" != "glGetError" {
        report_error_as_necessary_from(
          "glShaderStorageBlockBinding",
          glGetError(),
        );
      }
    }
    out
  }
  static glShaderStorageBlockBinding_p: APcv = ap_null();
  /// Tries to load [`glShaderStorageBlockBinding`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glShaderStorageBlockBinding_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glShaderStorageBlockBinding\0");
    glShaderStorageBlockBinding_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glShaderStorageBlockBinding`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glShaderStorageBlockBinding_is_loaded() -> bool {
    !glShaderStorageBlockBinding_p.load(RELAX).is_null()
  }

  /// [glSpecializeShader](http://docs.gl/gl4/glSpecializeShader)(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glSpecializeShader(
    shader: GLuint,
    pEntryPoint: *const GLchar,
    numSpecializationConstants: GLuint,
    pConstantIndex: *const GLuint,
    pConstantValue: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glSpecializeShader({:?}, {:p}, {:?}, {:p}, {:p});",
        shader,
        pEntryPoint,
        numSpecializationConstants,
        pConstantIndex,
        pConstantValue
      );
    }
    let p = glSpecializeShader_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          *const GLchar,
          GLuint,
          *const GLuint,
          *const GLuint,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        shader,
        pEntryPoint,
        numSpecializationConstants,
        pConstantIndex,
        pConstantValue,
      ),
      None => go_panic_because_fn_not_loaded("glSpecializeShader"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glSpecializeShader" != "glGetError" {
        report_error_as_necessary_from("glSpecializeShader", glGetError());
      }
    }
    out
  }
  static glSpecializeShader_p: APcv = ap_null();
  /// Tries to load [`glSpecializeShader`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glSpecializeShader_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glSpecializeShader\0");
    glSpecializeShader_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glSpecializeShader`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glSpecializeShader_is_loaded() -> bool {
    !glSpecializeShader_p.load(RELAX).is_null()
  }

  /// [glStencilFunc](http://docs.gl/gl4/glStencilFunc)(func, ref_, mask)
  /// * `func` group: StencilFunction
  /// * `ref_` group: StencilValue
  /// * `mask` group: MaskedStencilValue
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glStencilFunc(func: GLenum, ref_: GLint, mask: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glStencilFunc({:#X}, {:?}, {:?});", func, ref_, mask);
    }
    let p = glStencilFunc_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLint, GLuint)>>(p) {
      Some(fn_p) => fn_p(func, ref_, mask),
      None => go_panic_because_fn_not_loaded("glStencilFunc"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glStencilFunc" != "glGetError" {
        report_error_as_necessary_from("glStencilFunc", glGetError());
      }
    }
    out
  }
  static glStencilFunc_p: APcv = ap_null();
  /// Tries to load [`glStencilFunc`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glStencilFunc_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glStencilFunc\0");
    glStencilFunc_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glStencilFunc`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glStencilFunc_is_loaded() -> bool {
    !glStencilFunc_p.load(RELAX).is_null()
  }

  /// [glStencilFuncSeparate](http://docs.gl/gl4/glStencilFuncSeparate)(face, func, ref_, mask)
  /// * `face` group: StencilFaceDirection
  /// * `func` group: StencilFunction
  /// * `ref_` group: StencilValue
  /// * `mask` group: MaskedStencilValue
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glStencilFuncSeparate(
    face: GLenum,
    func: GLenum,
    ref_: GLint,
    mask: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glStencilFuncSeparate({:#X}, {:#X}, {:?}, {:?});",
        face,
        func,
        ref_,
        mask
      );
    }
    let p = glStencilFuncSeparate_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, GLint, GLuint)>>(p) {
        Some(fn_p) => fn_p(face, func, ref_, mask),
        None => go_panic_because_fn_not_loaded("glStencilFuncSeparate"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glStencilFuncSeparate" != "glGetError" {
        report_error_as_necessary_from("glStencilFuncSeparate", glGetError());
      }
    }
    out
  }
  static glStencilFuncSeparate_p: APcv = ap_null();
  /// Tries to load [`glStencilFuncSeparate`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glStencilFuncSeparate_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glStencilFuncSeparate\0");
    glStencilFuncSeparate_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glStencilFuncSeparate`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glStencilFuncSeparate_is_loaded() -> bool {
    !glStencilFuncSeparate_p.load(RELAX).is_null()
  }

  /// [glStencilMask](http://docs.gl/gl4/glStencilMask)(mask)
  /// * `mask` group: MaskedStencilValue
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glStencilMask(mask: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glStencilMask({:?});", mask);
    }
    let p = glStencilMask_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(mask),
      None => go_panic_because_fn_not_loaded("glStencilMask"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glStencilMask" != "glGetError" {
        report_error_as_necessary_from("glStencilMask", glGetError());
      }
    }
    out
  }
  static glStencilMask_p: APcv = ap_null();
  /// Tries to load [`glStencilMask`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glStencilMask_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glStencilMask\0");
    glStencilMask_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glStencilMask`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glStencilMask_is_loaded() -> bool {
    !glStencilMask_p.load(RELAX).is_null()
  }

  /// [glStencilMaskSeparate](http://docs.gl/gl4/glStencilMaskSeparate)(face, mask)
  /// * `face` group: StencilFaceDirection
  /// * `mask` group: MaskedStencilValue
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glStencilMaskSeparate(face: GLenum, mask: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glStencilMaskSeparate({:#X}, {:?});", face, mask);
    }
    let p = glStencilMaskSeparate_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(face, mask),
      None => go_panic_because_fn_not_loaded("glStencilMaskSeparate"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glStencilMaskSeparate" != "glGetError" {
        report_error_as_necessary_from("glStencilMaskSeparate", glGetError());
      }
    }
    out
  }
  static glStencilMaskSeparate_p: APcv = ap_null();
  /// Tries to load [`glStencilMaskSeparate`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glStencilMaskSeparate_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glStencilMaskSeparate\0");
    glStencilMaskSeparate_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glStencilMaskSeparate`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glStencilMaskSeparate_is_loaded() -> bool {
    !glStencilMaskSeparate_p.load(RELAX).is_null()
  }

  /// [glStencilOp](http://docs.gl/gl4/glStencilOp)(fail, zfail, zpass)
  /// * `fail` group: StencilOp
  /// * `zfail` group: StencilOp
  /// * `zpass` group: StencilOp
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glStencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glStencilOp({:#X}, {:#X}, {:#X});", fail, zfail, zpass);
    }
    let p = glStencilOp_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLenum, GLenum)>>(p) {
      Some(fn_p) => fn_p(fail, zfail, zpass),
      None => go_panic_because_fn_not_loaded("glStencilOp"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glStencilOp" != "glGetError" {
        report_error_as_necessary_from("glStencilOp", glGetError());
      }
    }
    out
  }
  static glStencilOp_p: APcv = ap_null();
  /// Tries to load [`glStencilOp`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glStencilOp_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glStencilOp\0");
    glStencilOp_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glStencilOp`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glStencilOp_is_loaded() -> bool {
    !glStencilOp_p.load(RELAX).is_null()
  }

  /// [glStencilOpSeparate](http://docs.gl/gl4/glStencilOpSeparate)(face, sfail, dpfail, dppass)
  /// * `face` group: StencilFaceDirection
  /// * `sfail` group: StencilOp
  /// * `dpfail` group: StencilOp
  /// * `dppass` group: StencilOp
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glStencilOpSeparate(
    face: GLenum,
    sfail: GLenum,
    dpfail: GLenum,
    dppass: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glStencilOpSeparate({:#X}, {:#X}, {:#X}, {:#X});",
        face,
        sfail,
        dpfail,
        dppass
      );
    }
    let p = glStencilOpSeparate_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, GLenum, GLenum)>>(p) {
        Some(fn_p) => fn_p(face, sfail, dpfail, dppass),
        None => go_panic_because_fn_not_loaded("glStencilOpSeparate"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glStencilOpSeparate" != "glGetError" {
        report_error_as_necessary_from("glStencilOpSeparate", glGetError());
      }
    }
    out
  }
  static glStencilOpSeparate_p: APcv = ap_null();
  /// Tries to load [`glStencilOpSeparate`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glStencilOpSeparate_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glStencilOpSeparate\0");
    glStencilOpSeparate_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glStencilOpSeparate`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glStencilOpSeparate_is_loaded() -> bool {
    !glStencilOpSeparate_p.load(RELAX).is_null()
  }

  /// [glTexBuffer](http://docs.gl/gl4/glTexBuffer)(target, internalformat, buffer)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexBuffer(
    target: GLenum,
    internalformat: GLenum,
    buffer: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexBuffer({:#X}, {:#X}, {:?});",
        target,
        internalformat,
        buffer
      );
    }
    let p = glTexBuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(target, internalformat, buffer),
      None => go_panic_because_fn_not_loaded("glTexBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexBuffer" != "glGetError" {
        report_error_as_necessary_from("glTexBuffer", glGetError());
      }
    }
    out
  }
  static glTexBuffer_p: APcv = ap_null();
  /// Tries to load [`glTexBuffer`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexBuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexBuffer\0");
    glTexBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexBuffer_is_loaded() -> bool {
    !glTexBuffer_p.load(RELAX).is_null()
  }

  /// [glTexBufferRange](http://docs.gl/gl4/glTexBufferRange)(target, internalformat, buffer, offset, size)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  /// * `offset` group: BufferOffset
  /// * `size` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexBufferRange(
    target: GLenum,
    internalformat: GLenum,
    buffer: GLuint,
    offset: GLintptr,
    size: GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexBufferRange({:#X}, {:#X}, {:?}, {:?}, {:?});",
        target,
        internalformat,
        buffer,
        offset,
        size
      );
    }
    let p = glTexBufferRange_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLenum, GLuint, GLintptr, GLsizeiptr)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, internalformat, buffer, offset, size),
      None => go_panic_because_fn_not_loaded("glTexBufferRange"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexBufferRange" != "glGetError" {
        report_error_as_necessary_from("glTexBufferRange", glGetError());
      }
    }
    out
  }
  static glTexBufferRange_p: APcv = ap_null();
  /// Tries to load [`glTexBufferRange`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexBufferRange_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexBufferRange\0");
    glTexBufferRange_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexBufferRange`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexBufferRange_is_loaded() -> bool {
    !glTexBufferRange_p.load(RELAX).is_null()
  }

  /// [glTexImage1D](http://docs.gl/gl4/glTexImage1D)(target, level, internalformat, width, border, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `border` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexImage1D(
    target: GLenum,
    level: GLint,
    internalformat: GLint,
    width: GLsizei,
    border: GLint,
    format: GLenum,
    type_: GLenum,
    pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexImage1D({:#X}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, border, format, type_, pixels);
    }
    let p = glTexImage1D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLint,
          GLsizei,
          GLint,
          GLenum,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target,
        level,
        internalformat,
        width,
        border,
        format,
        type_,
        pixels,
      ),
      None => go_panic_because_fn_not_loaded("glTexImage1D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexImage1D" != "glGetError" {
        report_error_as_necessary_from("glTexImage1D", glGetError());
      }
    }
    out
  }
  static glTexImage1D_p: APcv = ap_null();
  /// Tries to load [`glTexImage1D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexImage1D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexImage1D\0");
    glTexImage1D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexImage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexImage1D_is_loaded() -> bool {
    !glTexImage1D_p.load(RELAX).is_null()
  }

  /// [glTexImage2D](http://docs.gl/gl4/glTexImage2D)(target, level, internalformat, width, height, border, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `border` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width,height)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexImage2D(
    target: GLenum,
    level: GLint,
    internalformat: GLint,
    width: GLsizei,
    height: GLsizei,
    border: GLint,
    format: GLenum,
    type_: GLenum,
    pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, height, border, format, type_, pixels);
    }
    let p = glTexImage2D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLint,
          GLenum,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target,
        level,
        internalformat,
        width,
        height,
        border,
        format,
        type_,
        pixels,
      ),
      None => go_panic_because_fn_not_loaded("glTexImage2D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexImage2D" != "glGetError" {
        report_error_as_necessary_from("glTexImage2D", glGetError());
      }
    }
    out
  }
  static glTexImage2D_p: APcv = ap_null();
  /// Tries to load [`glTexImage2D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexImage2D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexImage2D\0");
    glTexImage2D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexImage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexImage2D_is_loaded() -> bool {
    !glTexImage2D_p.load(RELAX).is_null()
  }

  /// [glTexImage2DMultisample](http://docs.gl/gl4/glTexImage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexImage2DMultisample(
    target: GLenum,
    samples: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
    fixedsamplelocations: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexImage2DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, fixedsamplelocations);
    }
    let p = glTexImage2DMultisample_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLsizei,
          GLenum,
          GLsizei,
          GLsizei,
          GLboolean,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target,
        samples,
        internalformat,
        width,
        height,
        fixedsamplelocations,
      ),
      None => go_panic_because_fn_not_loaded("glTexImage2DMultisample"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexImage2DMultisample" != "glGetError" {
        report_error_as_necessary_from("glTexImage2DMultisample", glGetError());
      }
    }
    out
  }
  static glTexImage2DMultisample_p: APcv = ap_null();
  /// Tries to load [`glTexImage2DMultisample`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexImage2DMultisample_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexImage2DMultisample\0");
    glTexImage2DMultisample_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexImage2DMultisample`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexImage2DMultisample_is_loaded() -> bool {
    !glTexImage2DMultisample_p.load(RELAX).is_null()
  }

  /// [glTexImage3D](http://docs.gl/gl4/glTexImage3D)(target, level, internalformat, width, height, depth, border, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `internalformat` group: InternalFormat
  /// * `border` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width,height,depth)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexImage3D(
    target: GLenum,
    level: GLint,
    internalformat: GLint,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
    border: GLint,
    format: GLenum,
    type_: GLenum,
    pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, height, depth, border, format, type_, pixels);
    }
    let p = glTexImage3D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLsizei,
          GLint,
          GLenum,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        format,
        type_,
        pixels,
      ),
      None => go_panic_because_fn_not_loaded("glTexImage3D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexImage3D" != "glGetError" {
        report_error_as_necessary_from("glTexImage3D", glGetError());
      }
    }
    out
  }
  static glTexImage3D_p: APcv = ap_null();
  /// Tries to load [`glTexImage3D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexImage3D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexImage3D\0");
    glTexImage3D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexImage3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexImage3D_is_loaded() -> bool {
    !glTexImage3D_p.load(RELAX).is_null()
  }

  /// [glTexImage3DMultisample](http://docs.gl/gl4/glTexImage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexImage3DMultisample(
    target: GLenum,
    samples: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
    fixedsamplelocations: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexImage3DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, depth, fixedsamplelocations);
    }
    let p = glTexImage3DMultisample_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLsizei,
          GLenum,
          GLsizei,
          GLsizei,
          GLsizei,
          GLboolean,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target,
        samples,
        internalformat,
        width,
        height,
        depth,
        fixedsamplelocations,
      ),
      None => go_panic_because_fn_not_loaded("glTexImage3DMultisample"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexImage3DMultisample" != "glGetError" {
        report_error_as_necessary_from("glTexImage3DMultisample", glGetError());
      }
    }
    out
  }
  static glTexImage3DMultisample_p: APcv = ap_null();
  /// Tries to load [`glTexImage3DMultisample`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexImage3DMultisample_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexImage3DMultisample\0");
    glTexImage3DMultisample_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexImage3DMultisample`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexImage3DMultisample_is_loaded() -> bool {
    !glTexImage3DMultisample_p.load(RELAX).is_null()
  }

  /// [glTexParameterIiv](http://docs.gl/gl4/glTexParameterIiv)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: TextureParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexParameterIiv(
    target: GLenum,
    pname: GLenum,
    params: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexParameterIiv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glTexParameterIiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *const GLint)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glTexParameterIiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexParameterIiv" != "glGetError" {
        report_error_as_necessary_from("glTexParameterIiv", glGetError());
      }
    }
    out
  }
  static glTexParameterIiv_p: APcv = ap_null();
  /// Tries to load [`glTexParameterIiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexParameterIiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexParameterIiv\0");
    glTexParameterIiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexParameterIiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexParameterIiv_is_loaded() -> bool {
    !glTexParameterIiv_p.load(RELAX).is_null()
  }

  /// [glTexParameterIuiv](http://docs.gl/gl4/glTexParameterIuiv)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: TextureParameterName
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexParameterIuiv(
    target: GLenum,
    pname: GLenum,
    params: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexParameterIuiv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glTexParameterIuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glTexParameterIuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexParameterIuiv" != "glGetError" {
        report_error_as_necessary_from("glTexParameterIuiv", glGetError());
      }
    }
    out
  }
  static glTexParameterIuiv_p: APcv = ap_null();
  /// Tries to load [`glTexParameterIuiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexParameterIuiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexParameterIuiv\0");
    glTexParameterIuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexParameterIuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexParameterIuiv_is_loaded() -> bool {
    !glTexParameterIuiv_p.load(RELAX).is_null()
  }

  /// [glTexParameterf](http://docs.gl/gl4/glTexParameterf)(target, pname, param)
  /// * `target` group: TextureTarget
  /// * `pname` group: TextureParameterName
  /// * `param` group: CheckedFloat32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexParameterf(target: GLenum, pname: GLenum, param: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexParameterf({:#X}, {:#X}, {:?});",
        target,
        pname,
        param
      );
    }
    let p = glTexParameterf_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLenum, GLfloat)>>(p) {
      Some(fn_p) => fn_p(target, pname, param),
      None => go_panic_because_fn_not_loaded("glTexParameterf"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexParameterf" != "glGetError" {
        report_error_as_necessary_from("glTexParameterf", glGetError());
      }
    }
    out
  }
  static glTexParameterf_p: APcv = ap_null();
  /// Tries to load [`glTexParameterf`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexParameterf_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexParameterf\0");
    glTexParameterf_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexParameterf`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexParameterf_is_loaded() -> bool {
    !glTexParameterf_p.load(RELAX).is_null()
  }

  /// [glTexParameterfv](http://docs.gl/gl4/glTexParameterfv)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: TextureParameterName
  /// * `params` group: CheckedFloat32
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexParameterfv(
    target: GLenum,
    pname: GLenum,
    params: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexParameterfv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glTexParameterfv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *const GLfloat)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glTexParameterfv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexParameterfv" != "glGetError" {
        report_error_as_necessary_from("glTexParameterfv", glGetError());
      }
    }
    out
  }
  static glTexParameterfv_p: APcv = ap_null();
  /// Tries to load [`glTexParameterfv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexParameterfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexParameterfv\0");
    glTexParameterfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexParameterfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexParameterfv_is_loaded() -> bool {
    !glTexParameterfv_p.load(RELAX).is_null()
  }

  /// [glTexParameteri](http://docs.gl/gl4/glTexParameteri)(target, pname, param)
  /// * `target` group: TextureTarget
  /// * `pname` group: TextureParameterName
  /// * `param` group: CheckedInt32
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexParameteri(target: GLenum, pname: GLenum, param: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexParameteri({:#X}, {:#X}, {:?});",
        target,
        pname,
        param
      );
    }
    let p = glTexParameteri_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum, GLenum, GLint)>>(p) {
      Some(fn_p) => fn_p(target, pname, param),
      None => go_panic_because_fn_not_loaded("glTexParameteri"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexParameteri" != "glGetError" {
        report_error_as_necessary_from("glTexParameteri", glGetError());
      }
    }
    out
  }
  static glTexParameteri_p: APcv = ap_null();
  /// Tries to load [`glTexParameteri`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexParameteri_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexParameteri\0");
    glTexParameteri_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexParameteri`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexParameteri_is_loaded() -> bool {
    !glTexParameteri_p.load(RELAX).is_null()
  }

  /// [glTexParameteriv](http://docs.gl/gl4/glTexParameteriv)(target, pname, params)
  /// * `target` group: TextureTarget
  /// * `pname` group: TextureParameterName
  /// * `params` group: CheckedInt32
  /// * `params` len: COMPSIZE(pname)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexParameteriv(
    target: GLenum,
    pname: GLenum,
    params: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexParameteriv({:#X}, {:#X}, {:p});",
        target,
        pname,
        params
      );
    }
    let p = glTexParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLenum, *const GLint)>>(p) {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glTexParameteriv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexParameteriv" != "glGetError" {
        report_error_as_necessary_from("glTexParameteriv", glGetError());
      }
    }
    out
  }
  static glTexParameteriv_p: APcv = ap_null();
  /// Tries to load [`glTexParameteriv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexParameteriv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexParameteriv\0");
    glTexParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexParameteriv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexParameteriv_is_loaded() -> bool {
    !glTexParameteriv_p.load(RELAX).is_null()
  }

  /// [glTexStorage1D](http://docs.gl/gl4/glTexStorage1D)(target, levels, internalformat, width)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexStorage1D(
    target: GLenum,
    levels: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexStorage1D({:#X}, {:?}, {:#X}, {:?});",
        target,
        levels,
        internalformat,
        width
      );
    }
    let p = glTexStorage1D_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLsizei, GLenum, GLsizei)>>(p)
      {
        Some(fn_p) => fn_p(target, levels, internalformat, width),
        None => go_panic_because_fn_not_loaded("glTexStorage1D"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexStorage1D" != "glGetError" {
        report_error_as_necessary_from("glTexStorage1D", glGetError());
      }
    }
    out
  }
  static glTexStorage1D_p: APcv = ap_null();
  /// Tries to load [`glTexStorage1D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexStorage1D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexStorage1D\0");
    glTexStorage1D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexStorage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexStorage1D_is_loaded() -> bool {
    !glTexStorage1D_p.load(RELAX).is_null()
  }

  /// [glTexStorage2D](http://docs.gl/gl4/glTexStorage2D)(target, levels, internalformat, width, height)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexStorage2D(
    target: GLenum,
    levels: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexStorage2D({:#X}, {:?}, {:#X}, {:?}, {:?});",
        target,
        levels,
        internalformat,
        width,
        height
      );
    }
    let p = glTexStorage2D_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, levels, internalformat, width, height),
      None => go_panic_because_fn_not_loaded("glTexStorage2D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexStorage2D" != "glGetError" {
        report_error_as_necessary_from("glTexStorage2D", glGetError());
      }
    }
    out
  }
  static glTexStorage2D_p: APcv = ap_null();
  /// Tries to load [`glTexStorage2D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexStorage2D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexStorage2D\0");
    glTexStorage2D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexStorage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexStorage2D_is_loaded() -> bool {
    !glTexStorage2D_p.load(RELAX).is_null()
  }

  /// [glTexStorage2DMultisample](http://docs.gl/gl4/glTexStorage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexStorage2DMultisample(
    target: GLenum,
    samples: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
    fixedsamplelocations: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexStorage2DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, fixedsamplelocations);
    }
    let p = glTexStorage2DMultisample_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLsizei,
          GLenum,
          GLsizei,
          GLsizei,
          GLboolean,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target,
        samples,
        internalformat,
        width,
        height,
        fixedsamplelocations,
      ),
      None => go_panic_because_fn_not_loaded("glTexStorage2DMultisample"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexStorage2DMultisample" != "glGetError" {
        report_error_as_necessary_from(
          "glTexStorage2DMultisample",
          glGetError(),
        );
      }
    }
    out
  }
  static glTexStorage2DMultisample_p: APcv = ap_null();
  /// Tries to load [`glTexStorage2DMultisample`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexStorage2DMultisample_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glTexStorage2DMultisample\0");
    glTexStorage2DMultisample_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexStorage2DMultisample`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexStorage2DMultisample_is_loaded() -> bool {
    !glTexStorage2DMultisample_p.load(RELAX).is_null()
  }

  /// [glTexStorage3D](http://docs.gl/gl4/glTexStorage3D)(target, levels, internalformat, width, height, depth)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexStorage3D(
    target: GLenum,
    levels: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexStorage3D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});",
        target,
        levels,
        internalformat,
        width,
        height,
        depth
      );
    }
    let p = glTexStorage3D_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(target, levels, internalformat, width, height, depth),
      None => go_panic_because_fn_not_loaded("glTexStorage3D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexStorage3D" != "glGetError" {
        report_error_as_necessary_from("glTexStorage3D", glGetError());
      }
    }
    out
  }
  static glTexStorage3D_p: APcv = ap_null();
  /// Tries to load [`glTexStorage3D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexStorage3D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexStorage3D\0");
    glTexStorage3D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexStorage3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexStorage3D_is_loaded() -> bool {
    !glTexStorage3D_p.load(RELAX).is_null()
  }

  /// [glTexStorage3DMultisample](http://docs.gl/gl4/glTexStorage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexStorage3DMultisample(
    target: GLenum,
    samples: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
    fixedsamplelocations: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexStorage3DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, depth, fixedsamplelocations);
    }
    let p = glTexStorage3DMultisample_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLsizei,
          GLenum,
          GLsizei,
          GLsizei,
          GLsizei,
          GLboolean,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target,
        samples,
        internalformat,
        width,
        height,
        depth,
        fixedsamplelocations,
      ),
      None => go_panic_because_fn_not_loaded("glTexStorage3DMultisample"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexStorage3DMultisample" != "glGetError" {
        report_error_as_necessary_from(
          "glTexStorage3DMultisample",
          glGetError(),
        );
      }
    }
    out
  }
  static glTexStorage3DMultisample_p: APcv = ap_null();
  /// Tries to load [`glTexStorage3DMultisample`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexStorage3DMultisample_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glTexStorage3DMultisample\0");
    glTexStorage3DMultisample_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexStorage3DMultisample`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexStorage3DMultisample_is_loaded() -> bool {
    !glTexStorage3DMultisample_p.load(RELAX).is_null()
  }

  /// [glTexSubImage1D](http://docs.gl/gl4/glTexSubImage1D)(target, level, xoffset, width, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexSubImage1D(
    target: GLenum,
    level: GLint,
    xoffset: GLint,
    width: GLsizei,
    format: GLenum,
    type_: GLenum,
    pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
        target,
        level,
        xoffset,
        width,
        format,
        type_,
        pixels
      );
    }
    let p = glTexSubImage1D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLint,
          GLsizei,
          GLenum,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(target, level, xoffset, width, format, type_, pixels),
      None => go_panic_because_fn_not_loaded("glTexSubImage1D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexSubImage1D" != "glGetError" {
        report_error_as_necessary_from("glTexSubImage1D", glGetError());
      }
    }
    out
  }
  static glTexSubImage1D_p: APcv = ap_null();
  /// Tries to load [`glTexSubImage1D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexSubImage1D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexSubImage1D\0");
    glTexSubImage1D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexSubImage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexSubImage1D_is_loaded() -> bool {
    !glTexSubImage1D_p.load(RELAX).is_null()
  }

  /// [glTexSubImage2D](http://docs.gl/gl4/glTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `yoffset` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width,height)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexSubImage2D(
    target: GLenum,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    width: GLsizei,
    height: GLsizei,
    format: GLenum,
    type_: GLenum,
    pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, xoffset, yoffset, width, height, format, type_, pixels);
    }
    let p = glTexSubImage2D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLenum,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target, level, xoffset, yoffset, width, height, format, type_, pixels,
      ),
      None => go_panic_because_fn_not_loaded("glTexSubImage2D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexSubImage2D" != "glGetError" {
        report_error_as_necessary_from("glTexSubImage2D", glGetError());
      }
    }
    out
  }
  static glTexSubImage2D_p: APcv = ap_null();
  /// Tries to load [`glTexSubImage2D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexSubImage2D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexSubImage2D\0");
    glTexSubImage2D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexSubImage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexSubImage2D_is_loaded() -> bool {
    !glTexSubImage2D_p.load(RELAX).is_null()
  }

  /// [glTexSubImage3D](http://docs.gl/gl4/glTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)
  /// * `target` group: TextureTarget
  /// * `level` group: CheckedInt32
  /// * `xoffset` group: CheckedInt32
  /// * `yoffset` group: CheckedInt32
  /// * `zoffset` group: CheckedInt32
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  /// * `pixels` len: COMPSIZE(format,type,width,height,depth)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTexSubImage3D(
    target: GLenum,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    zoffset: GLint,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
    format: GLenum,
    type_: GLenum,
    pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels);
    }
    let p = glTexSubImage3D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLenum,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLsizei,
          GLenum,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        target, level, xoffset, yoffset, zoffset, width, height, depth, format,
        type_, pixels,
      ),
      None => go_panic_because_fn_not_loaded("glTexSubImage3D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTexSubImage3D" != "glGetError" {
        report_error_as_necessary_from("glTexSubImage3D", glGetError());
      }
    }
    out
  }
  static glTexSubImage3D_p: APcv = ap_null();
  /// Tries to load [`glTexSubImage3D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTexSubImage3D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTexSubImage3D\0");
    glTexSubImage3D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTexSubImage3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTexSubImage3D_is_loaded() -> bool {
    !glTexSubImage3D_p.load(RELAX).is_null()
  }

  /// [glTextureBarrier](http://docs.gl/gl4/glTextureBarrier)()
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureBarrier() {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTextureBarrier();",);
    }
    let p = glTextureBarrier_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn()>>(p) {
      Some(fn_p) => fn_p(),
      None => go_panic_because_fn_not_loaded("glTextureBarrier"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureBarrier" != "glGetError" {
        report_error_as_necessary_from("glTextureBarrier", glGetError());
      }
    }
    out
  }
  static glTextureBarrier_p: APcv = ap_null();
  /// Tries to load [`glTextureBarrier`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureBarrier_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureBarrier\0");
    glTextureBarrier_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureBarrier`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureBarrier_is_loaded() -> bool {
    !glTextureBarrier_p.load(RELAX).is_null()
  }

  /// [glTextureBuffer](http://docs.gl/gl4/glTextureBuffer)(texture, internalformat, buffer)
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureBuffer(
    texture: GLuint,
    internalformat: GLenum,
    buffer: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTextureBuffer({:?}, {:#X}, {:?});",
        texture,
        internalformat,
        buffer
      );
    }
    let p = glTextureBuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLuint)>>(p) {
      Some(fn_p) => fn_p(texture, internalformat, buffer),
      None => go_panic_because_fn_not_loaded("glTextureBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureBuffer" != "glGetError" {
        report_error_as_necessary_from("glTextureBuffer", glGetError());
      }
    }
    out
  }
  static glTextureBuffer_p: APcv = ap_null();
  /// Tries to load [`glTextureBuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureBuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureBuffer\0");
    glTextureBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureBuffer_is_loaded() -> bool {
    !glTextureBuffer_p.load(RELAX).is_null()
  }

  /// [glTextureBufferRange](http://docs.gl/gl4/glTextureBufferRange)(texture, internalformat, buffer, offset, size)
  /// * `internalformat` group: InternalFormat
  /// * `size` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureBufferRange(
    texture: GLuint,
    internalformat: GLenum,
    buffer: GLuint,
    offset: GLintptr,
    size: GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTextureBufferRange({:?}, {:#X}, {:?}, {:?}, {:?});",
        texture,
        internalformat,
        buffer,
        offset,
        size
      );
    }
    let p = glTextureBufferRange_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLuint, GLintptr, GLsizeiptr)>,
    >(p)
    {
      Some(fn_p) => fn_p(texture, internalformat, buffer, offset, size),
      None => go_panic_because_fn_not_loaded("glTextureBufferRange"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureBufferRange" != "glGetError" {
        report_error_as_necessary_from("glTextureBufferRange", glGetError());
      }
    }
    out
  }
  static glTextureBufferRange_p: APcv = ap_null();
  /// Tries to load [`glTextureBufferRange`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureBufferRange_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureBufferRange\0");
    glTextureBufferRange_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureBufferRange`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureBufferRange_is_loaded() -> bool {
    !glTextureBufferRange_p.load(RELAX).is_null()
  }

  /// [glTextureParameterIiv](http://docs.gl/gl4/glTextureParameterIiv)(texture, pname, params)
  /// * `pname` group: TextureParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureParameterIiv(
    texture: GLuint,
    pname: GLenum,
    params: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTextureParameterIiv({:?}, {:#X}, {:p});",
        texture,
        pname,
        params
      );
    }
    let p = glTextureParameterIiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLint)>>(p) {
        Some(fn_p) => fn_p(texture, pname, params),
        None => go_panic_because_fn_not_loaded("glTextureParameterIiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureParameterIiv" != "glGetError" {
        report_error_as_necessary_from("glTextureParameterIiv", glGetError());
      }
    }
    out
  }
  static glTextureParameterIiv_p: APcv = ap_null();
  /// Tries to load [`glTextureParameterIiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureParameterIiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureParameterIiv\0");
    glTextureParameterIiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureParameterIiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureParameterIiv_is_loaded() -> bool {
    !glTextureParameterIiv_p.load(RELAX).is_null()
  }

  /// [glTextureParameterIuiv](http://docs.gl/gl4/glTextureParameterIuiv)(texture, pname, params)
  /// * `pname` group: TextureParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureParameterIuiv(
    texture: GLuint,
    pname: GLenum,
    params: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTextureParameterIuiv({:?}, {:#X}, {:p});",
        texture,
        pname,
        params
      );
    }
    let p = glTextureParameterIuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(texture, pname, params),
        None => go_panic_because_fn_not_loaded("glTextureParameterIuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureParameterIuiv" != "glGetError" {
        report_error_as_necessary_from("glTextureParameterIuiv", glGetError());
      }
    }
    out
  }
  static glTextureParameterIuiv_p: APcv = ap_null();
  /// Tries to load [`glTextureParameterIuiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureParameterIuiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureParameterIuiv\0");
    glTextureParameterIuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureParameterIuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureParameterIuiv_is_loaded() -> bool {
    !glTextureParameterIuiv_p.load(RELAX).is_null()
  }

  /// [glTextureParameterf](http://docs.gl/gl4/glTextureParameterf)(texture, pname, param)
  /// * `pname` group: TextureParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureParameterf(
    texture: GLuint,
    pname: GLenum,
    param: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTextureParameterf({:?}, {:#X}, {:?});",
        texture,
        pname,
        param
      );
    }
    let p = glTextureParameterf_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLfloat)>>(p) {
      Some(fn_p) => fn_p(texture, pname, param),
      None => go_panic_because_fn_not_loaded("glTextureParameterf"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureParameterf" != "glGetError" {
        report_error_as_necessary_from("glTextureParameterf", glGetError());
      }
    }
    out
  }
  static glTextureParameterf_p: APcv = ap_null();
  /// Tries to load [`glTextureParameterf`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureParameterf_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureParameterf\0");
    glTextureParameterf_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureParameterf`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureParameterf_is_loaded() -> bool {
    !glTextureParameterf_p.load(RELAX).is_null()
  }

  /// [glTextureParameterfv](http://docs.gl/gl4/glTextureParameterfv)(texture, pname, param)
  /// * `pname` group: TextureParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureParameterfv(
    texture: GLuint,
    pname: GLenum,
    param: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTextureParameterfv({:?}, {:#X}, {:p});",
        texture,
        pname,
        param
      );
    }
    let p = glTextureParameterfv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLfloat)>>(p) {
        Some(fn_p) => fn_p(texture, pname, param),
        None => go_panic_because_fn_not_loaded("glTextureParameterfv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureParameterfv" != "glGetError" {
        report_error_as_necessary_from("glTextureParameterfv", glGetError());
      }
    }
    out
  }
  static glTextureParameterfv_p: APcv = ap_null();
  /// Tries to load [`glTextureParameterfv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureParameterfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureParameterfv\0");
    glTextureParameterfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureParameterfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureParameterfv_is_loaded() -> bool {
    !glTextureParameterfv_p.load(RELAX).is_null()
  }

  /// [glTextureParameteri](http://docs.gl/gl4/glTextureParameteri)(texture, pname, param)
  /// * `pname` group: TextureParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureParameteri(
    texture: GLuint,
    pname: GLenum,
    param: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTextureParameteri({:?}, {:#X}, {:?});",
        texture,
        pname,
        param
      );
    }
    let p = glTextureParameteri_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLint)>>(p) {
      Some(fn_p) => fn_p(texture, pname, param),
      None => go_panic_because_fn_not_loaded("glTextureParameteri"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureParameteri" != "glGetError" {
        report_error_as_necessary_from("glTextureParameteri", glGetError());
      }
    }
    out
  }
  static glTextureParameteri_p: APcv = ap_null();
  /// Tries to load [`glTextureParameteri`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureParameteri_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureParameteri\0");
    glTextureParameteri_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureParameteri`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureParameteri_is_loaded() -> bool {
    !glTextureParameteri_p.load(RELAX).is_null()
  }

  /// [glTextureParameteriv](http://docs.gl/gl4/glTextureParameteriv)(texture, pname, param)
  /// * `pname` group: TextureParameterName
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureParameteriv(
    texture: GLuint,
    pname: GLenum,
    param: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTextureParameteriv({:?}, {:#X}, {:p});",
        texture,
        pname,
        param
      );
    }
    let p = glTextureParameteriv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLint)>>(p) {
        Some(fn_p) => fn_p(texture, pname, param),
        None => go_panic_because_fn_not_loaded("glTextureParameteriv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureParameteriv" != "glGetError" {
        report_error_as_necessary_from("glTextureParameteriv", glGetError());
      }
    }
    out
  }
  static glTextureParameteriv_p: APcv = ap_null();
  /// Tries to load [`glTextureParameteriv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureParameteriv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureParameteriv\0");
    glTextureParameteriv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureParameteriv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureParameteriv_is_loaded() -> bool {
    !glTextureParameteriv_p.load(RELAX).is_null()
  }

  /// [glTextureStorage1D](http://docs.gl/gl4/glTextureStorage1D)(texture, levels, internalformat, width)
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureStorage1D(
    texture: GLuint,
    levels: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTextureStorage1D({:?}, {:?}, {:#X}, {:?});",
        texture,
        levels,
        internalformat,
        width
      );
    }
    let p = glTextureStorage1D_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLsizei, GLenum, GLsizei)>>(p)
      {
        Some(fn_p) => fn_p(texture, levels, internalformat, width),
        None => go_panic_because_fn_not_loaded("glTextureStorage1D"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureStorage1D" != "glGetError" {
        report_error_as_necessary_from("glTextureStorage1D", glGetError());
      }
    }
    out
  }
  static glTextureStorage1D_p: APcv = ap_null();
  /// Tries to load [`glTextureStorage1D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureStorage1D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureStorage1D\0");
    glTextureStorage1D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureStorage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureStorage1D_is_loaded() -> bool {
    !glTextureStorage1D_p.load(RELAX).is_null()
  }

  /// [glTextureStorage2D](http://docs.gl/gl4/glTextureStorage2D)(texture, levels, internalformat, width, height)
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureStorage2D(
    texture: GLuint,
    levels: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTextureStorage2D({:?}, {:?}, {:#X}, {:?}, {:?});",
        texture,
        levels,
        internalformat,
        width,
        height
      );
    }
    let p = glTextureStorage2D_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(texture, levels, internalformat, width, height),
      None => go_panic_because_fn_not_loaded("glTextureStorage2D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureStorage2D" != "glGetError" {
        report_error_as_necessary_from("glTextureStorage2D", glGetError());
      }
    }
    out
  }
  static glTextureStorage2D_p: APcv = ap_null();
  /// Tries to load [`glTextureStorage2D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureStorage2D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureStorage2D\0");
    glTextureStorage2D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureStorage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureStorage2D_is_loaded() -> bool {
    !glTextureStorage2D_p.load(RELAX).is_null()
  }

  /// [glTextureStorage2DMultisample](http://docs.gl/gl4/glTextureStorage2DMultisample)(texture, samples, internalformat, width, height, fixedsamplelocations)
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureStorage2DMultisample(
    texture: GLuint,
    samples: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
    fixedsamplelocations: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTextureStorage2DMultisample({:?}, {:?}, {:#X}, {:?}, {:?}, {:?});", texture, samples, internalformat, width, height, fixedsamplelocations);
    }
    let p = glTextureStorage2DMultisample_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLsizei,
          GLenum,
          GLsizei,
          GLsizei,
          GLboolean,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        texture,
        samples,
        internalformat,
        width,
        height,
        fixedsamplelocations,
      ),
      None => go_panic_because_fn_not_loaded("glTextureStorage2DMultisample"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureStorage2DMultisample" != "glGetError" {
        report_error_as_necessary_from(
          "glTextureStorage2DMultisample",
          glGetError(),
        );
      }
    }
    out
  }
  static glTextureStorage2DMultisample_p: APcv = ap_null();
  /// Tries to load [`glTextureStorage2DMultisample`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureStorage2DMultisample_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureStorage2DMultisample\0");
    glTextureStorage2DMultisample_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureStorage2DMultisample`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureStorage2DMultisample_is_loaded() -> bool {
    !glTextureStorage2DMultisample_p.load(RELAX).is_null()
  }

  /// [glTextureStorage3D](http://docs.gl/gl4/glTextureStorage3D)(texture, levels, internalformat, width, height, depth)
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureStorage3D(
    texture: GLuint,
    levels: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTextureStorage3D({:?}, {:?}, {:#X}, {:?}, {:?}, {:?});",
        texture,
        levels,
        internalformat,
        width,
        height,
        depth
      );
    }
    let p = glTextureStorage3D_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(texture, levels, internalformat, width, height, depth),
      None => go_panic_because_fn_not_loaded("glTextureStorage3D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureStorage3D" != "glGetError" {
        report_error_as_necessary_from("glTextureStorage3D", glGetError());
      }
    }
    out
  }
  static glTextureStorage3D_p: APcv = ap_null();
  /// Tries to load [`glTextureStorage3D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureStorage3D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureStorage3D\0");
    glTextureStorage3D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureStorage3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureStorage3D_is_loaded() -> bool {
    !glTextureStorage3D_p.load(RELAX).is_null()
  }

  /// [glTextureStorage3DMultisample](http://docs.gl/gl4/glTextureStorage3DMultisample)(texture, samples, internalformat, width, height, depth, fixedsamplelocations)
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureStorage3DMultisample(
    texture: GLuint,
    samples: GLsizei,
    internalformat: GLenum,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
    fixedsamplelocations: GLboolean,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTextureStorage3DMultisample({:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", texture, samples, internalformat, width, height, depth, fixedsamplelocations);
    }
    let p = glTextureStorage3DMultisample_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLsizei,
          GLenum,
          GLsizei,
          GLsizei,
          GLsizei,
          GLboolean,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        texture,
        samples,
        internalformat,
        width,
        height,
        depth,
        fixedsamplelocations,
      ),
      None => go_panic_because_fn_not_loaded("glTextureStorage3DMultisample"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureStorage3DMultisample" != "glGetError" {
        report_error_as_necessary_from(
          "glTextureStorage3DMultisample",
          glGetError(),
        );
      }
    }
    out
  }
  static glTextureStorage3DMultisample_p: APcv = ap_null();
  /// Tries to load [`glTextureStorage3DMultisample`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureStorage3DMultisample_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureStorage3DMultisample\0");
    glTextureStorage3DMultisample_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureStorage3DMultisample`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureStorage3DMultisample_is_loaded() -> bool {
    !glTextureStorage3DMultisample_p.load(RELAX).is_null()
  }

  /// [glTextureSubImage1D](http://docs.gl/gl4/glTextureSubImage1D)(texture, level, xoffset, width, format, type_, pixels)
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureSubImage1D(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    width: GLsizei,
    format: GLenum,
    type_: GLenum,
    pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTextureSubImage1D({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", texture, level, xoffset, width, format, type_, pixels);
    }
    let p = glTextureSubImage1D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLint,
          GLsizei,
          GLenum,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(texture, level, xoffset, width, format, type_, pixels),
      None => go_panic_because_fn_not_loaded("glTextureSubImage1D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureSubImage1D" != "glGetError" {
        report_error_as_necessary_from("glTextureSubImage1D", glGetError());
      }
    }
    out
  }
  static glTextureSubImage1D_p: APcv = ap_null();
  /// Tries to load [`glTextureSubImage1D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureSubImage1D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureSubImage1D\0");
    glTextureSubImage1D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureSubImage1D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureSubImage1D_is_loaded() -> bool {
    !glTextureSubImage1D_p.load(RELAX).is_null()
  }

  /// [glTextureSubImage2D](http://docs.gl/gl4/glTextureSubImage2D)(texture, level, xoffset, yoffset, width, height, format, type_, pixels)
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureSubImage2D(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    width: GLsizei,
    height: GLsizei,
    format: GLenum,
    type_: GLenum,
    pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTextureSubImage2D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", texture, level, xoffset, yoffset, width, height, format, type_, pixels);
    }
    let p = glTextureSubImage2D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLenum,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        texture, level, xoffset, yoffset, width, height, format, type_, pixels,
      ),
      None => go_panic_because_fn_not_loaded("glTextureSubImage2D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureSubImage2D" != "glGetError" {
        report_error_as_necessary_from("glTextureSubImage2D", glGetError());
      }
    }
    out
  }
  static glTextureSubImage2D_p: APcv = ap_null();
  /// Tries to load [`glTextureSubImage2D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureSubImage2D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureSubImage2D\0");
    glTextureSubImage2D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureSubImage2D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureSubImage2D_is_loaded() -> bool {
    !glTextureSubImage2D_p.load(RELAX).is_null()
  }

  /// [glTextureSubImage3D](http://docs.gl/gl4/glTextureSubImage3D)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)
  /// * `format` group: PixelFormat
  /// * `type_` group: PixelType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureSubImage3D(
    texture: GLuint,
    level: GLint,
    xoffset: GLint,
    yoffset: GLint,
    zoffset: GLint,
    width: GLsizei,
    height: GLsizei,
    depth: GLsizei,
    format: GLenum,
    type_: GLenum,
    pixels: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTextureSubImage3D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels);
    }
    let p = glTextureSubImage3D_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLint,
          GLint,
          GLint,
          GLsizei,
          GLsizei,
          GLsizei,
          GLenum,
          GLenum,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        texture, level, xoffset, yoffset, zoffset, width, height, depth,
        format, type_, pixels,
      ),
      None => go_panic_because_fn_not_loaded("glTextureSubImage3D"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureSubImage3D" != "glGetError" {
        report_error_as_necessary_from("glTextureSubImage3D", glGetError());
      }
    }
    out
  }
  static glTextureSubImage3D_p: APcv = ap_null();
  /// Tries to load [`glTextureSubImage3D`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureSubImage3D_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureSubImage3D\0");
    glTextureSubImage3D_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureSubImage3D`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureSubImage3D_is_loaded() -> bool {
    !glTextureSubImage3D_p.load(RELAX).is_null()
  }

  /// [glTextureView](http://docs.gl/gl4/glTextureView)(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers)
  /// * `target` group: TextureTarget
  /// * `internalformat` group: InternalFormat
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTextureView(
    texture: GLuint,
    target: GLenum,
    origtexture: GLuint,
    internalformat: GLenum,
    minlevel: GLuint,
    numlevels: GLuint,
    minlayer: GLuint,
    numlayers: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glTextureView({:?}, {:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    }
    let p = glTextureView_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLenum,
          GLuint,
          GLenum,
          GLuint,
          GLuint,
          GLuint,
          GLuint,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(
        texture,
        target,
        origtexture,
        internalformat,
        minlevel,
        numlevels,
        minlayer,
        numlayers,
      ),
      None => go_panic_because_fn_not_loaded("glTextureView"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTextureView" != "glGetError" {
        report_error_as_necessary_from("glTextureView", glGetError());
      }
    }
    out
  }
  static glTextureView_p: APcv = ap_null();
  /// Tries to load [`glTextureView`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTextureView_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glTextureView\0");
    glTextureView_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTextureView`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTextureView_is_loaded() -> bool {
    !glTextureView_p.load(RELAX).is_null()
  }

  /// [glTransformFeedbackBufferBase](http://docs.gl/gl4/glTransformFeedbackBufferBase)(xfb, index, buffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTransformFeedbackBufferBase(
    xfb: GLuint,
    index: GLuint,
    buffer: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTransformFeedbackBufferBase({:?}, {:?}, {:?});",
        xfb,
        index,
        buffer
      );
    }
    let p = glTransformFeedbackBufferBase_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(xfb, index, buffer),
      None => go_panic_because_fn_not_loaded("glTransformFeedbackBufferBase"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTransformFeedbackBufferBase" != "glGetError" {
        report_error_as_necessary_from(
          "glTransformFeedbackBufferBase",
          glGetError(),
        );
      }
    }
    out
  }
  static glTransformFeedbackBufferBase_p: APcv = ap_null();
  /// Tries to load [`glTransformFeedbackBufferBase`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTransformFeedbackBufferBase_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glTransformFeedbackBufferBase\0");
    glTransformFeedbackBufferBase_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTransformFeedbackBufferBase`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTransformFeedbackBufferBase_is_loaded() -> bool {
    !glTransformFeedbackBufferBase_p.load(RELAX).is_null()
  }

  /// [glTransformFeedbackBufferRange](http://docs.gl/gl4/glTransformFeedbackBufferRange)(xfb, index, buffer, offset, size)
  /// * `size` group: BufferSize
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTransformFeedbackBufferRange(
    xfb: GLuint,
    index: GLuint,
    buffer: GLuint,
    offset: GLintptr,
    size: GLsizeiptr,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTransformFeedbackBufferRange({:?}, {:?}, {:?}, {:?}, {:?});",
        xfb,
        index,
        buffer,
        offset,
        size
      );
    }
    let p = glTransformFeedbackBufferRange_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLuint, GLuint, GLintptr, GLsizeiptr)>,
    >(p)
    {
      Some(fn_p) => fn_p(xfb, index, buffer, offset, size),
      None => go_panic_because_fn_not_loaded("glTransformFeedbackBufferRange"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTransformFeedbackBufferRange" != "glGetError" {
        report_error_as_necessary_from(
          "glTransformFeedbackBufferRange",
          glGetError(),
        );
      }
    }
    out
  }
  static glTransformFeedbackBufferRange_p: APcv = ap_null();
  /// Tries to load [`glTransformFeedbackBufferRange`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTransformFeedbackBufferRange_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glTransformFeedbackBufferRange\0");
    glTransformFeedbackBufferRange_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTransformFeedbackBufferRange`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTransformFeedbackBufferRange_is_loaded() -> bool {
    !glTransformFeedbackBufferRange_p.load(RELAX).is_null()
  }

  /// [glTransformFeedbackVaryings](http://docs.gl/gl4/glTransformFeedbackVaryings)(program, count, varyings, bufferMode)
  /// * `varyings` len: count
  /// * `bufferMode` group: TransformFeedbackBufferMode
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glTransformFeedbackVaryings(
    program: GLuint,
    count: GLsizei,
    varyings: *const *const GLchar,
    bufferMode: GLenum,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glTransformFeedbackVaryings({:?}, {:?}, {:p}, {:#X});",
        program,
        count,
        varyings,
        bufferMode
      );
    }
    let p = glTransformFeedbackVaryings_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizei, *const *const GLchar, GLenum)>,
    >(p)
    {
      Some(fn_p) => fn_p(program, count, varyings, bufferMode),
      None => go_panic_because_fn_not_loaded("glTransformFeedbackVaryings"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glTransformFeedbackVaryings" != "glGetError" {
        report_error_as_necessary_from(
          "glTransformFeedbackVaryings",
          glGetError(),
        );
      }
    }
    out
  }
  static glTransformFeedbackVaryings_p: APcv = ap_null();
  /// Tries to load [`glTransformFeedbackVaryings`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glTransformFeedbackVaryings_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glTransformFeedbackVaryings\0");
    glTransformFeedbackVaryings_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glTransformFeedbackVaryings`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glTransformFeedbackVaryings_is_loaded() -> bool {
    !glTransformFeedbackVaryings_p.load(RELAX).is_null()
  }

  /// [glUniform1d](http://docs.gl/gl4/glUniform1d)(location, x)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1d(location: GLint, x: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform1d({:?}, {:?});", location, x);
    }
    let p = glUniform1d_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLint, GLdouble)>>(p) {
      Some(fn_p) => fn_p(location, x),
      None => go_panic_because_fn_not_loaded("glUniform1d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform1d" != "glGetError" {
        report_error_as_necessary_from("glUniform1d", glGetError());
      }
    }
    out
  }
  static glUniform1d_p: APcv = ap_null();
  /// Tries to load [`glUniform1d`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform1d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform1d\0");
    glUniform1d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform1d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1d_is_loaded() -> bool {
    !glUniform1d_p.load(RELAX).is_null()
  }

  /// [glUniform1dv](http://docs.gl/gl4/glUniform1dv)(location, count, value)
  /// * `value` len: count*1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1dv(
    location: GLint,
    count: GLsizei,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform1dv({:?}, {:?}, {:p});", location, count, value);
    }
    let p = glUniform1dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, value),
      None => go_panic_because_fn_not_loaded("glUniform1dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform1dv" != "glGetError" {
        report_error_as_necessary_from("glUniform1dv", glGetError());
      }
    }
    out
  }
  static glUniform1dv_p: APcv = ap_null();
  /// Tries to load [`glUniform1dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform1dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform1dv\0");
    glUniform1dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform1dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1dv_is_loaded() -> bool {
    !glUniform1dv_p.load(RELAX).is_null()
  }

  /// [glUniform1f](http://docs.gl/gl4/glUniform1f)(location, v0)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1f(location: GLint, v0: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform1f({:?}, {:?});", location, v0);
    }
    let p = glUniform1f_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLint, GLfloat)>>(p) {
      Some(fn_p) => fn_p(location, v0),
      None => go_panic_because_fn_not_loaded("glUniform1f"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform1f" != "glGetError" {
        report_error_as_necessary_from("glUniform1f", glGetError());
      }
    }
    out
  }
  static glUniform1f_p: APcv = ap_null();
  /// Tries to load [`glUniform1f`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform1f_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform1f\0");
    glUniform1f_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform1f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1f_is_loaded() -> bool {
    !glUniform1f_p.load(RELAX).is_null()
  }

  /// [glUniform1fv](http://docs.gl/gl4/glUniform1fv)(location, count, value)
  /// * `value` len: count*1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1fv(
    location: GLint,
    count: GLsizei,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform1fv({:?}, {:?}, {:p});", location, count, value);
    }
    let p = glUniform1fv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLfloat)>>(p) {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform1fv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform1fv" != "glGetError" {
        report_error_as_necessary_from("glUniform1fv", glGetError());
      }
    }
    out
  }
  static glUniform1fv_p: APcv = ap_null();
  /// Tries to load [`glUniform1fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform1fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform1fv\0");
    glUniform1fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform1fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1fv_is_loaded() -> bool {
    !glUniform1fv_p.load(RELAX).is_null()
  }

  /// [glUniform1i](http://docs.gl/gl4/glUniform1i)(location, v0)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1i(location: GLint, v0: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform1i({:?}, {:?});", location, v0);
    }
    let p = glUniform1i_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLint, GLint)>>(p) {
      Some(fn_p) => fn_p(location, v0),
      None => go_panic_because_fn_not_loaded("glUniform1i"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform1i" != "glGetError" {
        report_error_as_necessary_from("glUniform1i", glGetError());
      }
    }
    out
  }
  static glUniform1i_p: APcv = ap_null();
  /// Tries to load [`glUniform1i`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform1i_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform1i\0");
    glUniform1i_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform1i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1i_is_loaded() -> bool {
    !glUniform1i_p.load(RELAX).is_null()
  }

  /// [glUniform1iv](http://docs.gl/gl4/glUniform1iv)(location, count, value)
  /// * `value` len: count*1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1iv(
    location: GLint,
    count: GLsizei,
    value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform1iv({:?}, {:?}, {:p});", location, count, value);
    }
    let p = glUniform1iv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLint)>>(p) {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform1iv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform1iv" != "glGetError" {
        report_error_as_necessary_from("glUniform1iv", glGetError());
      }
    }
    out
  }
  static glUniform1iv_p: APcv = ap_null();
  /// Tries to load [`glUniform1iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform1iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform1iv\0");
    glUniform1iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform1iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1iv_is_loaded() -> bool {
    !glUniform1iv_p.load(RELAX).is_null()
  }

  /// [glUniform1ui](http://docs.gl/gl4/glUniform1ui)(location, v0)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1ui(location: GLint, v0: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform1ui({:?}, {:?});", location, v0);
    }
    let p = glUniform1ui_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLint, GLuint)>>(p) {
      Some(fn_p) => fn_p(location, v0),
      None => go_panic_because_fn_not_loaded("glUniform1ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform1ui" != "glGetError" {
        report_error_as_necessary_from("glUniform1ui", glGetError());
      }
    }
    out
  }
  static glUniform1ui_p: APcv = ap_null();
  /// Tries to load [`glUniform1ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform1ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform1ui\0");
    glUniform1ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform1ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1ui_is_loaded() -> bool {
    !glUniform1ui_p.load(RELAX).is_null()
  }

  /// [glUniform1uiv](http://docs.gl/gl4/glUniform1uiv)(location, count, value)
  /// * `value` len: count*1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform1uiv(
    location: GLint,
    count: GLsizei,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform1uiv({:?}, {:?}, {:p});",
        location,
        count,
        value
      );
    }
    let p = glUniform1uiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform1uiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform1uiv" != "glGetError" {
        report_error_as_necessary_from("glUniform1uiv", glGetError());
      }
    }
    out
  }
  static glUniform1uiv_p: APcv = ap_null();
  /// Tries to load [`glUniform1uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform1uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform1uiv\0");
    glUniform1uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform1uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform1uiv_is_loaded() -> bool {
    !glUniform1uiv_p.load(RELAX).is_null()
  }

  /// [glUniform2d](http://docs.gl/gl4/glUniform2d)(location, x, y)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2d(location: GLint, x: GLdouble, y: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform2d({:?}, {:?}, {:?});", location, x, y);
    }
    let p = glUniform2d_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLint, GLdouble, GLdouble)>>(p)
    {
      Some(fn_p) => fn_p(location, x, y),
      None => go_panic_because_fn_not_loaded("glUniform2d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform2d" != "glGetError" {
        report_error_as_necessary_from("glUniform2d", glGetError());
      }
    }
    out
  }
  static glUniform2d_p: APcv = ap_null();
  /// Tries to load [`glUniform2d`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform2d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform2d\0");
    glUniform2d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform2d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2d_is_loaded() -> bool {
    !glUniform2d_p.load(RELAX).is_null()
  }

  /// [glUniform2dv](http://docs.gl/gl4/glUniform2dv)(location, count, value)
  /// * `value` len: count*2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2dv(
    location: GLint,
    count: GLsizei,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform2dv({:?}, {:?}, {:p});", location, count, value);
    }
    let p = glUniform2dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, value),
      None => go_panic_because_fn_not_loaded("glUniform2dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform2dv" != "glGetError" {
        report_error_as_necessary_from("glUniform2dv", glGetError());
      }
    }
    out
  }
  static glUniform2dv_p: APcv = ap_null();
  /// Tries to load [`glUniform2dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform2dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform2dv\0");
    glUniform2dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform2dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2dv_is_loaded() -> bool {
    !glUniform2dv_p.load(RELAX).is_null()
  }

  /// [glUniform2f](http://docs.gl/gl4/glUniform2f)(location, v0, v1)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2f(location: GLint, v0: GLfloat, v1: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform2f({:?}, {:?}, {:?});", location, v0, v1);
    }
    let p = glUniform2f_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLint, GLfloat, GLfloat)>>(p) {
      Some(fn_p) => fn_p(location, v0, v1),
      None => go_panic_because_fn_not_loaded("glUniform2f"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform2f" != "glGetError" {
        report_error_as_necessary_from("glUniform2f", glGetError());
      }
    }
    out
  }
  static glUniform2f_p: APcv = ap_null();
  /// Tries to load [`glUniform2f`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform2f_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform2f\0");
    glUniform2f_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform2f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2f_is_loaded() -> bool {
    !glUniform2f_p.load(RELAX).is_null()
  }

  /// [glUniform2fv](http://docs.gl/gl4/glUniform2fv)(location, count, value)
  /// * `value` len: count*2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2fv(
    location: GLint,
    count: GLsizei,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform2fv({:?}, {:?}, {:p});", location, count, value);
    }
    let p = glUniform2fv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLfloat)>>(p) {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform2fv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform2fv" != "glGetError" {
        report_error_as_necessary_from("glUniform2fv", glGetError());
      }
    }
    out
  }
  static glUniform2fv_p: APcv = ap_null();
  /// Tries to load [`glUniform2fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform2fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform2fv\0");
    glUniform2fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform2fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2fv_is_loaded() -> bool {
    !glUniform2fv_p.load(RELAX).is_null()
  }

  /// [glUniform2i](http://docs.gl/gl4/glUniform2i)(location, v0, v1)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2i(location: GLint, v0: GLint, v1: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform2i({:?}, {:?}, {:?});", location, v0, v1);
    }
    let p = glUniform2i_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLint, GLint, GLint)>>(p) {
      Some(fn_p) => fn_p(location, v0, v1),
      None => go_panic_because_fn_not_loaded("glUniform2i"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform2i" != "glGetError" {
        report_error_as_necessary_from("glUniform2i", glGetError());
      }
    }
    out
  }
  static glUniform2i_p: APcv = ap_null();
  /// Tries to load [`glUniform2i`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform2i_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform2i\0");
    glUniform2i_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform2i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2i_is_loaded() -> bool {
    !glUniform2i_p.load(RELAX).is_null()
  }

  /// [glUniform2iv](http://docs.gl/gl4/glUniform2iv)(location, count, value)
  /// * `value` len: count*2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2iv(
    location: GLint,
    count: GLsizei,
    value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform2iv({:?}, {:?}, {:p});", location, count, value);
    }
    let p = glUniform2iv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLint)>>(p) {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform2iv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform2iv" != "glGetError" {
        report_error_as_necessary_from("glUniform2iv", glGetError());
      }
    }
    out
  }
  static glUniform2iv_p: APcv = ap_null();
  /// Tries to load [`glUniform2iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform2iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform2iv\0");
    glUniform2iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform2iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2iv_is_loaded() -> bool {
    !glUniform2iv_p.load(RELAX).is_null()
  }

  /// [glUniform2ui](http://docs.gl/gl4/glUniform2ui)(location, v0, v1)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2ui(location: GLint, v0: GLuint, v1: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform2ui({:?}, {:?}, {:?});", location, v0, v1);
    }
    let p = glUniform2ui_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLint, GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(location, v0, v1),
      None => go_panic_because_fn_not_loaded("glUniform2ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform2ui" != "glGetError" {
        report_error_as_necessary_from("glUniform2ui", glGetError());
      }
    }
    out
  }
  static glUniform2ui_p: APcv = ap_null();
  /// Tries to load [`glUniform2ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform2ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform2ui\0");
    glUniform2ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform2ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2ui_is_loaded() -> bool {
    !glUniform2ui_p.load(RELAX).is_null()
  }

  /// [glUniform2uiv](http://docs.gl/gl4/glUniform2uiv)(location, count, value)
  /// * `value` len: count*2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform2uiv(
    location: GLint,
    count: GLsizei,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform2uiv({:?}, {:?}, {:p});",
        location,
        count,
        value
      );
    }
    let p = glUniform2uiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform2uiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform2uiv" != "glGetError" {
        report_error_as_necessary_from("glUniform2uiv", glGetError());
      }
    }
    out
  }
  static glUniform2uiv_p: APcv = ap_null();
  /// Tries to load [`glUniform2uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform2uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform2uiv\0");
    glUniform2uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform2uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform2uiv_is_loaded() -> bool {
    !glUniform2uiv_p.load(RELAX).is_null()
  }

  /// [glUniform3d](http://docs.gl/gl4/glUniform3d)(location, x, y, z)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3d(
    location: GLint,
    x: GLdouble,
    y: GLdouble,
    z: GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform3d({:?}, {:?}, {:?}, {:?});", location, x, y, z);
    }
    let p = glUniform3d_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLdouble, GLdouble, GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, x, y, z),
      None => go_panic_because_fn_not_loaded("glUniform3d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform3d" != "glGetError" {
        report_error_as_necessary_from("glUniform3d", glGetError());
      }
    }
    out
  }
  static glUniform3d_p: APcv = ap_null();
  /// Tries to load [`glUniform3d`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform3d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform3d\0");
    glUniform3d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform3d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3d_is_loaded() -> bool {
    !glUniform3d_p.load(RELAX).is_null()
  }

  /// [glUniform3dv](http://docs.gl/gl4/glUniform3dv)(location, count, value)
  /// * `value` len: count*3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3dv(
    location: GLint,
    count: GLsizei,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform3dv({:?}, {:?}, {:p});", location, count, value);
    }
    let p = glUniform3dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, value),
      None => go_panic_because_fn_not_loaded("glUniform3dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform3dv" != "glGetError" {
        report_error_as_necessary_from("glUniform3dv", glGetError());
      }
    }
    out
  }
  static glUniform3dv_p: APcv = ap_null();
  /// Tries to load [`glUniform3dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform3dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform3dv\0");
    glUniform3dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform3dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3dv_is_loaded() -> bool {
    !glUniform3dv_p.load(RELAX).is_null()
  }

  /// [glUniform3f](http://docs.gl/gl4/glUniform3f)(location, v0, v1, v2)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3f(
    location: GLint,
    v0: GLfloat,
    v1: GLfloat,
    v2: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform3f({:?}, {:?}, {:?}, {:?});",
        location,
        v0,
        v1,
        v2
      );
    }
    let p = glUniform3f_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLfloat, GLfloat, GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(location, v0, v1, v2),
        None => go_panic_because_fn_not_loaded("glUniform3f"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform3f" != "glGetError" {
        report_error_as_necessary_from("glUniform3f", glGetError());
      }
    }
    out
  }
  static glUniform3f_p: APcv = ap_null();
  /// Tries to load [`glUniform3f`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform3f_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform3f\0");
    glUniform3f_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform3f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3f_is_loaded() -> bool {
    !glUniform3f_p.load(RELAX).is_null()
  }

  /// [glUniform3fv](http://docs.gl/gl4/glUniform3fv)(location, count, value)
  /// * `value` len: count*3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3fv(
    location: GLint,
    count: GLsizei,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform3fv({:?}, {:?}, {:p});", location, count, value);
    }
    let p = glUniform3fv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLfloat)>>(p) {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform3fv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform3fv" != "glGetError" {
        report_error_as_necessary_from("glUniform3fv", glGetError());
      }
    }
    out
  }
  static glUniform3fv_p: APcv = ap_null();
  /// Tries to load [`glUniform3fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform3fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform3fv\0");
    glUniform3fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform3fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3fv_is_loaded() -> bool {
    !glUniform3fv_p.load(RELAX).is_null()
  }

  /// [glUniform3i](http://docs.gl/gl4/glUniform3i)(location, v0, v1, v2)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3i(location: GLint, v0: GLint, v1: GLint, v2: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform3i({:?}, {:?}, {:?}, {:?});",
        location,
        v0,
        v1,
        v2
      );
    }
    let p = glUniform3i_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLint, GLint, GLint)>>(p) {
        Some(fn_p) => fn_p(location, v0, v1, v2),
        None => go_panic_because_fn_not_loaded("glUniform3i"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform3i" != "glGetError" {
        report_error_as_necessary_from("glUniform3i", glGetError());
      }
    }
    out
  }
  static glUniform3i_p: APcv = ap_null();
  /// Tries to load [`glUniform3i`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform3i_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform3i\0");
    glUniform3i_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform3i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3i_is_loaded() -> bool {
    !glUniform3i_p.load(RELAX).is_null()
  }

  /// [glUniform3iv](http://docs.gl/gl4/glUniform3iv)(location, count, value)
  /// * `value` len: count*3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3iv(
    location: GLint,
    count: GLsizei,
    value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform3iv({:?}, {:?}, {:p});", location, count, value);
    }
    let p = glUniform3iv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLint)>>(p) {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform3iv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform3iv" != "glGetError" {
        report_error_as_necessary_from("glUniform3iv", glGetError());
      }
    }
    out
  }
  static glUniform3iv_p: APcv = ap_null();
  /// Tries to load [`glUniform3iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform3iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform3iv\0");
    glUniform3iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform3iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3iv_is_loaded() -> bool {
    !glUniform3iv_p.load(RELAX).is_null()
  }

  /// [glUniform3ui](http://docs.gl/gl4/glUniform3ui)(location, v0, v1, v2)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3ui(
    location: GLint,
    v0: GLuint,
    v1: GLuint,
    v2: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform3ui({:?}, {:?}, {:?}, {:?});",
        location,
        v0,
        v1,
        v2
      );
    }
    let p = glUniform3ui_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLuint, GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(location, v0, v1, v2),
        None => go_panic_because_fn_not_loaded("glUniform3ui"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform3ui" != "glGetError" {
        report_error_as_necessary_from("glUniform3ui", glGetError());
      }
    }
    out
  }
  static glUniform3ui_p: APcv = ap_null();
  /// Tries to load [`glUniform3ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform3ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform3ui\0");
    glUniform3ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform3ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3ui_is_loaded() -> bool {
    !glUniform3ui_p.load(RELAX).is_null()
  }

  /// [glUniform3uiv](http://docs.gl/gl4/glUniform3uiv)(location, count, value)
  /// * `value` len: count*3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform3uiv(
    location: GLint,
    count: GLsizei,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform3uiv({:?}, {:?}, {:p});",
        location,
        count,
        value
      );
    }
    let p = glUniform3uiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform3uiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform3uiv" != "glGetError" {
        report_error_as_necessary_from("glUniform3uiv", glGetError());
      }
    }
    out
  }
  static glUniform3uiv_p: APcv = ap_null();
  /// Tries to load [`glUniform3uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform3uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform3uiv\0");
    glUniform3uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform3uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform3uiv_is_loaded() -> bool {
    !glUniform3uiv_p.load(RELAX).is_null()
  }

  /// [glUniform4d](http://docs.gl/gl4/glUniform4d)(location, x, y, z, w)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4d(
    location: GLint,
    x: GLdouble,
    y: GLdouble,
    z: GLdouble,
    w: GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform4d({:?}, {:?}, {:?}, {:?}, {:?});",
        location,
        x,
        y,
        z,
        w
      );
    }
    let p = glUniform4d_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLdouble, GLdouble, GLdouble, GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, x, y, z, w),
      None => go_panic_because_fn_not_loaded("glUniform4d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform4d" != "glGetError" {
        report_error_as_necessary_from("glUniform4d", glGetError());
      }
    }
    out
  }
  static glUniform4d_p: APcv = ap_null();
  /// Tries to load [`glUniform4d`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform4d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform4d\0");
    glUniform4d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform4d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4d_is_loaded() -> bool {
    !glUniform4d_p.load(RELAX).is_null()
  }

  /// [glUniform4dv](http://docs.gl/gl4/glUniform4dv)(location, count, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4dv(
    location: GLint,
    count: GLsizei,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform4dv({:?}, {:?}, {:p});", location, count, value);
    }
    let p = glUniform4dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, value),
      None => go_panic_because_fn_not_loaded("glUniform4dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform4dv" != "glGetError" {
        report_error_as_necessary_from("glUniform4dv", glGetError());
      }
    }
    out
  }
  static glUniform4dv_p: APcv = ap_null();
  /// Tries to load [`glUniform4dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform4dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform4dv\0");
    glUniform4dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform4dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4dv_is_loaded() -> bool {
    !glUniform4dv_p.load(RELAX).is_null()
  }

  /// [glUniform4f](http://docs.gl/gl4/glUniform4f)(location, v0, v1, v2, v3)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4f(
    location: GLint,
    v0: GLfloat,
    v1: GLfloat,
    v2: GLfloat,
    v3: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform4f({:?}, {:?}, {:?}, {:?}, {:?});",
        location,
        v0,
        v1,
        v2,
        v3
      );
    }
    let p = glUniform4f_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLfloat, GLfloat, GLfloat, GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, v0, v1, v2, v3),
      None => go_panic_because_fn_not_loaded("glUniform4f"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform4f" != "glGetError" {
        report_error_as_necessary_from("glUniform4f", glGetError());
      }
    }
    out
  }
  static glUniform4f_p: APcv = ap_null();
  /// Tries to load [`glUniform4f`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform4f_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform4f\0");
    glUniform4f_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform4f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4f_is_loaded() -> bool {
    !glUniform4f_p.load(RELAX).is_null()
  }

  /// [glUniform4fv](http://docs.gl/gl4/glUniform4fv)(location, count, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4fv(
    location: GLint,
    count: GLsizei,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform4fv({:?}, {:?}, {:p});", location, count, value);
    }
    let p = glUniform4fv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLfloat)>>(p) {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform4fv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform4fv" != "glGetError" {
        report_error_as_necessary_from("glUniform4fv", glGetError());
      }
    }
    out
  }
  static glUniform4fv_p: APcv = ap_null();
  /// Tries to load [`glUniform4fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform4fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform4fv\0");
    glUniform4fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform4fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4fv_is_loaded() -> bool {
    !glUniform4fv_p.load(RELAX).is_null()
  }

  /// [glUniform4i](http://docs.gl/gl4/glUniform4i)(location, v0, v1, v2, v3)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4i(
    location: GLint,
    v0: GLint,
    v1: GLint,
    v2: GLint,
    v3: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform4i({:?}, {:?}, {:?}, {:?}, {:?});",
        location,
        v0,
        v1,
        v2,
        v3
      );
    }
    let p = glUniform4i_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLint, GLint, GLint, GLint)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, v0, v1, v2, v3),
      None => go_panic_because_fn_not_loaded("glUniform4i"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform4i" != "glGetError" {
        report_error_as_necessary_from("glUniform4i", glGetError());
      }
    }
    out
  }
  static glUniform4i_p: APcv = ap_null();
  /// Tries to load [`glUniform4i`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform4i_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform4i\0");
    glUniform4i_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform4i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4i_is_loaded() -> bool {
    !glUniform4i_p.load(RELAX).is_null()
  }

  /// [glUniform4iv](http://docs.gl/gl4/glUniform4iv)(location, count, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4iv(
    location: GLint,
    count: GLsizei,
    value: *const GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUniform4iv({:?}, {:?}, {:p});", location, count, value);
    }
    let p = glUniform4iv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLint)>>(p) {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform4iv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform4iv" != "glGetError" {
        report_error_as_necessary_from("glUniform4iv", glGetError());
      }
    }
    out
  }
  static glUniform4iv_p: APcv = ap_null();
  /// Tries to load [`glUniform4iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform4iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform4iv\0");
    glUniform4iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform4iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4iv_is_loaded() -> bool {
    !glUniform4iv_p.load(RELAX).is_null()
  }

  /// [glUniform4ui](http://docs.gl/gl4/glUniform4ui)(location, v0, v1, v2, v3)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4ui(
    location: GLint,
    v0: GLuint,
    v1: GLuint,
    v2: GLuint,
    v3: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform4ui({:?}, {:?}, {:?}, {:?}, {:?});",
        location,
        v0,
        v1,
        v2,
        v3
      );
    }
    let p = glUniform4ui_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLuint, GLuint, GLuint, GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, v0, v1, v2, v3),
      None => go_panic_because_fn_not_loaded("glUniform4ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform4ui" != "glGetError" {
        report_error_as_necessary_from("glUniform4ui", glGetError());
      }
    }
    out
  }
  static glUniform4ui_p: APcv = ap_null();
  /// Tries to load [`glUniform4ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform4ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform4ui\0");
    glUniform4ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform4ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4ui_is_loaded() -> bool {
    !glUniform4ui_p.load(RELAX).is_null()
  }

  /// [glUniform4uiv](http://docs.gl/gl4/glUniform4uiv)(location, count, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniform4uiv(
    location: GLint,
    count: GLsizei,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniform4uiv({:?}, {:?}, {:p});",
        location,
        count,
        value
      );
    }
    let p = glUniform4uiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform4uiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniform4uiv" != "glGetError" {
        report_error_as_necessary_from("glUniform4uiv", glGetError());
      }
    }
    out
  }
  static glUniform4uiv_p: APcv = ap_null();
  /// Tries to load [`glUniform4uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniform4uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniform4uiv\0");
    glUniform4uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniform4uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniform4uiv_is_loaded() -> bool {
    !glUniform4uiv_p.load(RELAX).is_null()
  }

  /// [glUniformBlockBinding](http://docs.gl/gl4/glUniformBlockBinding)(program, uniformBlockIndex, uniformBlockBinding)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformBlockBinding(
    program: GLuint,
    uniformBlockIndex: GLuint,
    uniformBlockBinding: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformBlockBinding({:?}, {:?}, {:?});",
        program,
        uniformBlockIndex,
        uniformBlockBinding
      );
    }
    let p = glUniformBlockBinding_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(program, uniformBlockIndex, uniformBlockBinding),
      None => go_panic_because_fn_not_loaded("glUniformBlockBinding"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformBlockBinding" != "glGetError" {
        report_error_as_necessary_from("glUniformBlockBinding", glGetError());
      }
    }
    out
  }
  static glUniformBlockBinding_p: APcv = ap_null();
  /// Tries to load [`glUniformBlockBinding`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformBlockBinding_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformBlockBinding\0");
    glUniformBlockBinding_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformBlockBinding`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformBlockBinding_is_loaded() -> bool {
    !glUniformBlockBinding_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix2dv](http://docs.gl/gl4/glUniformMatrix2dv)(location, count, transpose, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix2dv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix2dv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix2dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix2dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix2dv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix2dv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix2dv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix2dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix2dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix2dv\0");
    glUniformMatrix2dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix2dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix2dv_is_loaded() -> bool {
    !glUniformMatrix2dv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix2fv](http://docs.gl/gl4/glUniformMatrix2fv)(location, count, transpose, value)
  /// * `value` len: count*4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix2fv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix2fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix2fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix2fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix2fv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix2fv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix2fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix2fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix2fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix2fv\0");
    glUniformMatrix2fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix2fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix2fv_is_loaded() -> bool {
    !glUniformMatrix2fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix2x3dv](http://docs.gl/gl4/glUniformMatrix2x3dv)(location, count, transpose, value)
  /// * `value` len: count*6
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix2x3dv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix2x3dv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix2x3dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix2x3dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix2x3dv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix2x3dv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix2x3dv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix2x3dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix2x3dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix2x3dv\0");
    glUniformMatrix2x3dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix2x3dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix2x3dv_is_loaded() -> bool {
    !glUniformMatrix2x3dv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix2x3fv](http://docs.gl/gl4/glUniformMatrix2x3fv)(location, count, transpose, value)
  /// * `value` len: count*6
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix2x3fv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix2x3fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix2x3fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix2x3fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix2x3fv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix2x3fv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix2x3fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix2x3fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix2x3fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix2x3fv\0");
    glUniformMatrix2x3fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix2x3fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix2x3fv_is_loaded() -> bool {
    !glUniformMatrix2x3fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix2x4dv](http://docs.gl/gl4/glUniformMatrix2x4dv)(location, count, transpose, value)
  /// * `value` len: count*8
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix2x4dv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix2x4dv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix2x4dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix2x4dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix2x4dv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix2x4dv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix2x4dv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix2x4dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix2x4dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix2x4dv\0");
    glUniformMatrix2x4dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix2x4dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix2x4dv_is_loaded() -> bool {
    !glUniformMatrix2x4dv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix2x4fv](http://docs.gl/gl4/glUniformMatrix2x4fv)(location, count, transpose, value)
  /// * `value` len: count*8
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix2x4fv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix2x4fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix2x4fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix2x4fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix2x4fv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix2x4fv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix2x4fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix2x4fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix2x4fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix2x4fv\0");
    glUniformMatrix2x4fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix2x4fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix2x4fv_is_loaded() -> bool {
    !glUniformMatrix2x4fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix3dv](http://docs.gl/gl4/glUniformMatrix3dv)(location, count, transpose, value)
  /// * `value` len: count*9
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix3dv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix3dv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix3dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix3dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix3dv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix3dv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix3dv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix3dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix3dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix3dv\0");
    glUniformMatrix3dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix3dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix3dv_is_loaded() -> bool {
    !glUniformMatrix3dv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix3fv](http://docs.gl/gl4/glUniformMatrix3fv)(location, count, transpose, value)
  /// * `value` len: count*9
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix3fv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix3fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix3fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix3fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix3fv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix3fv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix3fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix3fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix3fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix3fv\0");
    glUniformMatrix3fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix3fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix3fv_is_loaded() -> bool {
    !glUniformMatrix3fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix3x2dv](http://docs.gl/gl4/glUniformMatrix3x2dv)(location, count, transpose, value)
  /// * `value` len: count*6
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix3x2dv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix3x2dv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix3x2dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix3x2dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix3x2dv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix3x2dv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix3x2dv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix3x2dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix3x2dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix3x2dv\0");
    glUniformMatrix3x2dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix3x2dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix3x2dv_is_loaded() -> bool {
    !glUniformMatrix3x2dv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix3x2fv](http://docs.gl/gl4/glUniformMatrix3x2fv)(location, count, transpose, value)
  /// * `value` len: count*6
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix3x2fv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix3x2fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix3x2fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix3x2fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix3x2fv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix3x2fv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix3x2fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix3x2fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix3x2fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix3x2fv\0");
    glUniformMatrix3x2fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix3x2fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix3x2fv_is_loaded() -> bool {
    !glUniformMatrix3x2fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix3x4dv](http://docs.gl/gl4/glUniformMatrix3x4dv)(location, count, transpose, value)
  /// * `value` len: count*12
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix3x4dv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix3x4dv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix3x4dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix3x4dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix3x4dv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix3x4dv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix3x4dv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix3x4dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix3x4dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix3x4dv\0");
    glUniformMatrix3x4dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix3x4dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix3x4dv_is_loaded() -> bool {
    !glUniformMatrix3x4dv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix3x4fv](http://docs.gl/gl4/glUniformMatrix3x4fv)(location, count, transpose, value)
  /// * `value` len: count*12
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix3x4fv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix3x4fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix3x4fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix3x4fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix3x4fv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix3x4fv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix3x4fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix3x4fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix3x4fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix3x4fv\0");
    glUniformMatrix3x4fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix3x4fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix3x4fv_is_loaded() -> bool {
    !glUniformMatrix3x4fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix4dv](http://docs.gl/gl4/glUniformMatrix4dv)(location, count, transpose, value)
  /// * `value` len: count*16
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix4dv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix4dv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix4dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix4dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix4dv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix4dv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix4dv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix4dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix4dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix4dv\0");
    glUniformMatrix4dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix4dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix4dv_is_loaded() -> bool {
    !glUniformMatrix4dv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix4fv](http://docs.gl/gl4/glUniformMatrix4fv)(location, count, transpose, value)
  /// * `value` len: count*16
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix4fv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix4fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix4fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix4fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix4fv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix4fv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix4fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix4fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix4fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix4fv\0");
    glUniformMatrix4fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix4fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix4fv_is_loaded() -> bool {
    !glUniformMatrix4fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix4x2dv](http://docs.gl/gl4/glUniformMatrix4x2dv)(location, count, transpose, value)
  /// * `value` len: count*8
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix4x2dv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix4x2dv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix4x2dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix4x2dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix4x2dv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix4x2dv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix4x2dv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix4x2dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix4x2dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix4x2dv\0");
    glUniformMatrix4x2dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix4x2dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix4x2dv_is_loaded() -> bool {
    !glUniformMatrix4x2dv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix4x2fv](http://docs.gl/gl4/glUniformMatrix4x2fv)(location, count, transpose, value)
  /// * `value` len: count*8
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix4x2fv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix4x2fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix4x2fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix4x2fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix4x2fv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix4x2fv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix4x2fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix4x2fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix4x2fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix4x2fv\0");
    glUniformMatrix4x2fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix4x2fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix4x2fv_is_loaded() -> bool {
    !glUniformMatrix4x2fv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix4x3dv](http://docs.gl/gl4/glUniformMatrix4x3dv)(location, count, transpose, value)
  /// * `value` len: count*12
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix4x3dv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix4x3dv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix4x3dv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix4x3dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix4x3dv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix4x3dv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix4x3dv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix4x3dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix4x3dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix4x3dv\0");
    glUniformMatrix4x3dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix4x3dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix4x3dv_is_loaded() -> bool {
    !glUniformMatrix4x3dv_p.load(RELAX).is_null()
  }

  /// [glUniformMatrix4x3fv](http://docs.gl/gl4/glUniformMatrix4x3fv)(location, count, transpose, value)
  /// * `value` len: count*12
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformMatrix4x3fv(
    location: GLint,
    count: GLsizei,
    transpose: GLboolean,
    value: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformMatrix4x3fv({:?}, {:?}, {:?}, {:p});",
        location,
        count,
        transpose,
        value
      );
    }
    let p = glUniformMatrix4x3fv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(location, count, transpose, value),
      None => go_panic_because_fn_not_loaded("glUniformMatrix4x3fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformMatrix4x3fv" != "glGetError" {
        report_error_as_necessary_from("glUniformMatrix4x3fv", glGetError());
      }
    }
    out
  }
  static glUniformMatrix4x3fv_p: APcv = ap_null();
  /// Tries to load [`glUniformMatrix4x3fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformMatrix4x3fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformMatrix4x3fv\0");
    glUniformMatrix4x3fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformMatrix4x3fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformMatrix4x3fv_is_loaded() -> bool {
    !glUniformMatrix4x3fv_p.load(RELAX).is_null()
  }

  /// [glUniformSubroutinesuiv](http://docs.gl/gl4/glUniformSubroutinesuiv)(shadertype, count, indices)
  /// * `shadertype` group: ShaderType
  /// * `indices` len: count
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUniformSubroutinesuiv(
    shadertype: GLenum,
    count: GLsizei,
    indices: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUniformSubroutinesuiv({:#X}, {:?}, {:p});",
        shadertype,
        count,
        indices
      );
    }
    let p = glUniformSubroutinesuiv_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLenum, GLsizei, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(shadertype, count, indices),
        None => go_panic_because_fn_not_loaded("glUniformSubroutinesuiv"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUniformSubroutinesuiv" != "glGetError" {
        report_error_as_necessary_from("glUniformSubroutinesuiv", glGetError());
      }
    }
    out
  }
  static glUniformSubroutinesuiv_p: APcv = ap_null();
  /// Tries to load [`glUniformSubroutinesuiv`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUniformSubroutinesuiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUniformSubroutinesuiv\0");
    glUniformSubroutinesuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUniformSubroutinesuiv`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUniformSubroutinesuiv_is_loaded() -> bool {
    !glUniformSubroutinesuiv_p.load(RELAX).is_null()
  }

  /// [glUnmapBuffer](http://docs.gl/gl4/glUnmapBuffer)(target)
  /// * `target` group: BufferTargetARB
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUnmapBuffer(target: GLenum) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUnmapBuffer({:#X});", target);
    }
    let p = glUnmapBuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLenum) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(target),
      None => go_panic_because_fn_not_loaded("glUnmapBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUnmapBuffer" != "glGetError" {
        report_error_as_necessary_from("glUnmapBuffer", glGetError());
      }
    }
    out
  }
  static glUnmapBuffer_p: APcv = ap_null();
  /// Tries to load [`glUnmapBuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUnmapBuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUnmapBuffer\0");
    glUnmapBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUnmapBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUnmapBuffer_is_loaded() -> bool {
    !glUnmapBuffer_p.load(RELAX).is_null()
  }

  /// [glUnmapNamedBuffer](http://docs.gl/gl4/glUnmapNamedBuffer)(buffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUnmapNamedBuffer(buffer: GLuint) -> GLboolean {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUnmapNamedBuffer({:?});", buffer);
    }
    let p = glUnmapNamedBuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
      Some(fn_p) => fn_p(buffer),
      None => go_panic_because_fn_not_loaded("glUnmapNamedBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUnmapNamedBuffer" != "glGetError" {
        report_error_as_necessary_from("glUnmapNamedBuffer", glGetError());
      }
    }
    out
  }
  static glUnmapNamedBuffer_p: APcv = ap_null();
  /// Tries to load [`glUnmapNamedBuffer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUnmapNamedBuffer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUnmapNamedBuffer\0");
    glUnmapNamedBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUnmapNamedBuffer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUnmapNamedBuffer_is_loaded() -> bool {
    !glUnmapNamedBuffer_p.load(RELAX).is_null()
  }

  /// [glUseProgram](http://docs.gl/gl4/glUseProgram)(program)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUseProgram(program: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glUseProgram({:?});", program);
    }
    let p = glUseProgram_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(program),
      None => go_panic_because_fn_not_loaded("glUseProgram"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUseProgram" != "glGetError" {
        report_error_as_necessary_from("glUseProgram", glGetError());
      }
    }
    out
  }
  static glUseProgram_p: APcv = ap_null();
  /// Tries to load [`glUseProgram`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUseProgram_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUseProgram\0");
    glUseProgram_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUseProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUseProgram_is_loaded() -> bool {
    !glUseProgram_p.load(RELAX).is_null()
  }

  /// [glUseProgramStages](http://docs.gl/gl4/glUseProgramStages)(pipeline, stages, program)
  /// * `stages` group: UseProgramStageMask
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glUseProgramStages(
    pipeline: GLuint,
    stages: GLbitfield,
    program: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glUseProgramStages({:?}, {:?}, {:?});",
        pipeline,
        stages,
        program
      );
    }
    let p = glUseProgramStages_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLbitfield, GLuint)>>(p) {
        Some(fn_p) => fn_p(pipeline, stages, program),
        None => go_panic_because_fn_not_loaded("glUseProgramStages"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glUseProgramStages" != "glGetError" {
        report_error_as_necessary_from("glUseProgramStages", glGetError());
      }
    }
    out
  }
  static glUseProgramStages_p: APcv = ap_null();
  /// Tries to load [`glUseProgramStages`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glUseProgramStages_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glUseProgramStages\0");
    glUseProgramStages_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glUseProgramStages`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glUseProgramStages_is_loaded() -> bool {
    !glUseProgramStages_p.load(RELAX).is_null()
  }

  /// [glValidateProgram](http://docs.gl/gl4/glValidateProgram)(program)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glValidateProgram(program: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glValidateProgram({:?});", program);
    }
    let p = glValidateProgram_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(program),
      None => go_panic_because_fn_not_loaded("glValidateProgram"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glValidateProgram" != "glGetError" {
        report_error_as_necessary_from("glValidateProgram", glGetError());
      }
    }
    out
  }
  static glValidateProgram_p: APcv = ap_null();
  /// Tries to load [`glValidateProgram`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glValidateProgram_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glValidateProgram\0");
    glValidateProgram_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glValidateProgram`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glValidateProgram_is_loaded() -> bool {
    !glValidateProgram_p.load(RELAX).is_null()
  }

  /// [glValidateProgramPipeline](http://docs.gl/gl4/glValidateProgramPipeline)(pipeline)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glValidateProgramPipeline(pipeline: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glValidateProgramPipeline({:?});", pipeline);
    }
    let p = glValidateProgramPipeline_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
      Some(fn_p) => fn_p(pipeline),
      None => go_panic_because_fn_not_loaded("glValidateProgramPipeline"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glValidateProgramPipeline" != "glGetError" {
        report_error_as_necessary_from(
          "glValidateProgramPipeline",
          glGetError(),
        );
      }
    }
    out
  }
  static glValidateProgramPipeline_p: APcv = ap_null();
  /// Tries to load [`glValidateProgramPipeline`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glValidateProgramPipeline_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glValidateProgramPipeline\0");
    glValidateProgramPipeline_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glValidateProgramPipeline`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glValidateProgramPipeline_is_loaded() -> bool {
    !glValidateProgramPipeline_p.load(RELAX).is_null()
  }

  /// [glVertexArrayAttribBinding](http://docs.gl/gl4/glVertexArrayAttribBinding)(vaobj, attribindex, bindingindex)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexArrayAttribBinding(
    vaobj: GLuint,
    attribindex: GLuint,
    bindingindex: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexArrayAttribBinding({:?}, {:?}, {:?});",
        vaobj,
        attribindex,
        bindingindex
      );
    }
    let p = glVertexArrayAttribBinding_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(vaobj, attribindex, bindingindex),
      None => go_panic_because_fn_not_loaded("glVertexArrayAttribBinding"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexArrayAttribBinding" != "glGetError" {
        report_error_as_necessary_from(
          "glVertexArrayAttribBinding",
          glGetError(),
        );
      }
    }
    out
  }
  static glVertexArrayAttribBinding_p: APcv = ap_null();
  /// Tries to load [`glVertexArrayAttribBinding`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexArrayAttribBinding_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexArrayAttribBinding\0");
    glVertexArrayAttribBinding_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexArrayAttribBinding`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexArrayAttribBinding_is_loaded() -> bool {
    !glVertexArrayAttribBinding_p.load(RELAX).is_null()
  }

  /// [glVertexArrayAttribFormat](http://docs.gl/gl4/glVertexArrayAttribFormat)(vaobj, attribindex, size, type_, normalized, relativeoffset)
  /// * `type_` group: VertexAttribType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexArrayAttribFormat(
    vaobj: GLuint,
    attribindex: GLuint,
    size: GLint,
    type_: GLenum,
    normalized: GLboolean,
    relativeoffset: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexArrayAttribFormat({:?}, {:?}, {:?}, {:#X}, {:?}, {:?});", vaobj, attribindex, size, type_, normalized, relativeoffset);
    }
    let p = glVertexArrayAttribFormat_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLuint, GLint, GLenum, GLboolean, GLuint)>,
    >(p)
    {
      Some(fn_p) => {
        fn_p(vaobj, attribindex, size, type_, normalized, relativeoffset)
      }
      None => go_panic_because_fn_not_loaded("glVertexArrayAttribFormat"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexArrayAttribFormat" != "glGetError" {
        report_error_as_necessary_from(
          "glVertexArrayAttribFormat",
          glGetError(),
        );
      }
    }
    out
  }
  static glVertexArrayAttribFormat_p: APcv = ap_null();
  /// Tries to load [`glVertexArrayAttribFormat`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexArrayAttribFormat_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexArrayAttribFormat\0");
    glVertexArrayAttribFormat_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexArrayAttribFormat`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexArrayAttribFormat_is_loaded() -> bool {
    !glVertexArrayAttribFormat_p.load(RELAX).is_null()
  }

  /// [glVertexArrayAttribIFormat](http://docs.gl/gl4/glVertexArrayAttribIFormat)(vaobj, attribindex, size, type_, relativeoffset)
  /// * `type_` group: VertexAttribIType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexArrayAttribIFormat(
    vaobj: GLuint,
    attribindex: GLuint,
    size: GLint,
    type_: GLenum,
    relativeoffset: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexArrayAttribIFormat({:?}, {:?}, {:?}, {:#X}, {:?});",
        vaobj,
        attribindex,
        size,
        type_,
        relativeoffset
      );
    }
    let p = glVertexArrayAttribIFormat_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLuint, GLint, GLenum, GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(vaobj, attribindex, size, type_, relativeoffset),
      None => go_panic_because_fn_not_loaded("glVertexArrayAttribIFormat"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexArrayAttribIFormat" != "glGetError" {
        report_error_as_necessary_from(
          "glVertexArrayAttribIFormat",
          glGetError(),
        );
      }
    }
    out
  }
  static glVertexArrayAttribIFormat_p: APcv = ap_null();
  /// Tries to load [`glVertexArrayAttribIFormat`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexArrayAttribIFormat_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexArrayAttribIFormat\0");
    glVertexArrayAttribIFormat_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexArrayAttribIFormat`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexArrayAttribIFormat_is_loaded() -> bool {
    !glVertexArrayAttribIFormat_p.load(RELAX).is_null()
  }

  /// [glVertexArrayAttribLFormat](http://docs.gl/gl4/glVertexArrayAttribLFormat)(vaobj, attribindex, size, type_, relativeoffset)
  /// * `type_` group: VertexAttribLType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexArrayAttribLFormat(
    vaobj: GLuint,
    attribindex: GLuint,
    size: GLint,
    type_: GLenum,
    relativeoffset: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexArrayAttribLFormat({:?}, {:?}, {:?}, {:#X}, {:?});",
        vaobj,
        attribindex,
        size,
        type_,
        relativeoffset
      );
    }
    let p = glVertexArrayAttribLFormat_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLuint, GLint, GLenum, GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(vaobj, attribindex, size, type_, relativeoffset),
      None => go_panic_because_fn_not_loaded("glVertexArrayAttribLFormat"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexArrayAttribLFormat" != "glGetError" {
        report_error_as_necessary_from(
          "glVertexArrayAttribLFormat",
          glGetError(),
        );
      }
    }
    out
  }
  static glVertexArrayAttribLFormat_p: APcv = ap_null();
  /// Tries to load [`glVertexArrayAttribLFormat`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexArrayAttribLFormat_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexArrayAttribLFormat\0");
    glVertexArrayAttribLFormat_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexArrayAttribLFormat`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexArrayAttribLFormat_is_loaded() -> bool {
    !glVertexArrayAttribLFormat_p.load(RELAX).is_null()
  }

  /// [glVertexArrayBindingDivisor](http://docs.gl/gl4/glVertexArrayBindingDivisor)(vaobj, bindingindex, divisor)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexArrayBindingDivisor(
    vaobj: GLuint,
    bindingindex: GLuint,
    divisor: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexArrayBindingDivisor({:?}, {:?}, {:?});",
        vaobj,
        bindingindex,
        divisor
      );
    }
    let p = glVertexArrayBindingDivisor_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(vaobj, bindingindex, divisor),
      None => go_panic_because_fn_not_loaded("glVertexArrayBindingDivisor"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexArrayBindingDivisor" != "glGetError" {
        report_error_as_necessary_from(
          "glVertexArrayBindingDivisor",
          glGetError(),
        );
      }
    }
    out
  }
  static glVertexArrayBindingDivisor_p: APcv = ap_null();
  /// Tries to load [`glVertexArrayBindingDivisor`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexArrayBindingDivisor_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexArrayBindingDivisor\0");
    glVertexArrayBindingDivisor_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexArrayBindingDivisor`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexArrayBindingDivisor_is_loaded() -> bool {
    !glVertexArrayBindingDivisor_p.load(RELAX).is_null()
  }

  /// [glVertexArrayElementBuffer](http://docs.gl/gl4/glVertexArrayElementBuffer)(vaobj, buffer)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexArrayElementBuffer(vaobj: GLuint, buffer: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexArrayElementBuffer({:?}, {:?});", vaobj, buffer);
    }
    let p = glVertexArrayElementBuffer_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(vaobj, buffer),
      None => go_panic_because_fn_not_loaded("glVertexArrayElementBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexArrayElementBuffer" != "glGetError" {
        report_error_as_necessary_from(
          "glVertexArrayElementBuffer",
          glGetError(),
        );
      }
    }
    out
  }
  static glVertexArrayElementBuffer_p: APcv = ap_null();
  /// Tries to load [`glVertexArrayElementBuffer`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexArrayElementBuffer_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexArrayElementBuffer\0");
    glVertexArrayElementBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexArrayElementBuffer`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexArrayElementBuffer_is_loaded() -> bool {
    !glVertexArrayElementBuffer_p.load(RELAX).is_null()
  }

  /// [glVertexArrayVertexBuffer](http://docs.gl/gl4/glVertexArrayVertexBuffer)(vaobj, bindingindex, buffer, offset, stride)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexArrayVertexBuffer(
    vaobj: GLuint,
    bindingindex: GLuint,
    buffer: GLuint,
    offset: GLintptr,
    stride: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexArrayVertexBuffer({:?}, {:?}, {:?}, {:?}, {:?});",
        vaobj,
        bindingindex,
        buffer,
        offset,
        stride
      );
    }
    let p = glVertexArrayVertexBuffer_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLuint, GLuint, GLintptr, GLsizei)>,
    >(p)
    {
      Some(fn_p) => fn_p(vaobj, bindingindex, buffer, offset, stride),
      None => go_panic_because_fn_not_loaded("glVertexArrayVertexBuffer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexArrayVertexBuffer" != "glGetError" {
        report_error_as_necessary_from(
          "glVertexArrayVertexBuffer",
          glGetError(),
        );
      }
    }
    out
  }
  static glVertexArrayVertexBuffer_p: APcv = ap_null();
  /// Tries to load [`glVertexArrayVertexBuffer`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexArrayVertexBuffer_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexArrayVertexBuffer\0");
    glVertexArrayVertexBuffer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexArrayVertexBuffer`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexArrayVertexBuffer_is_loaded() -> bool {
    !glVertexArrayVertexBuffer_p.load(RELAX).is_null()
  }

  /// [glVertexArrayVertexBuffers](http://docs.gl/gl4/glVertexArrayVertexBuffers)(vaobj, first, count, buffers, offsets, strides)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexArrayVertexBuffers(
    vaobj: GLuint,
    first: GLuint,
    count: GLsizei,
    buffers: *const GLuint,
    offsets: *const GLintptr,
    strides: *const GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexArrayVertexBuffers({:?}, {:?}, {:?}, {:p}, {:p}, {:p});", vaobj, first, count, buffers, offsets, strides);
    }
    let p = glVertexArrayVertexBuffers_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLuint,
          GLsizei,
          *const GLuint,
          *const GLintptr,
          *const GLsizei,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(vaobj, first, count, buffers, offsets, strides),
      None => go_panic_because_fn_not_loaded("glVertexArrayVertexBuffers"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexArrayVertexBuffers" != "glGetError" {
        report_error_as_necessary_from(
          "glVertexArrayVertexBuffers",
          glGetError(),
        );
      }
    }
    out
  }
  static glVertexArrayVertexBuffers_p: APcv = ap_null();
  /// Tries to load [`glVertexArrayVertexBuffers`], returns if a non-null
  /// pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexArrayVertexBuffers_load_with(
    get_proc_address: &mut GPA,
  ) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexArrayVertexBuffers\0");
    glVertexArrayVertexBuffers_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexArrayVertexBuffers`] is loaded
  /// (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexArrayVertexBuffers_is_loaded() -> bool {
    !glVertexArrayVertexBuffers_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib1d](http://docs.gl/gl4/glVertexAttrib1d)(index, x)
  /// * vector equivalent: [`glVertexAttrib1dv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib1d(index: GLuint, x: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib1d({:?}, {:?});", index, x);
    }
    let p = glVertexAttrib1d_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLdouble)>>(p) {
      Some(fn_p) => fn_p(index, x),
      None => go_panic_because_fn_not_loaded("glVertexAttrib1d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib1d" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib1d", glGetError());
      }
    }
    out
  }
  static glVertexAttrib1d_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib1d`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib1d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib1d\0");
    glVertexAttrib1d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib1d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib1d_is_loaded() -> bool {
    !glVertexAttrib1d_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib1dv](http://docs.gl/gl4/glVertexAttrib1dv)(index, v)
  /// * `v` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib1dv(index: GLuint, v: *const GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib1dv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib1dv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib1dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib1dv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib1dv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib1dv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib1dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib1dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib1dv\0");
    glVertexAttrib1dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib1dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib1dv_is_loaded() -> bool {
    !glVertexAttrib1dv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib1f](http://docs.gl/gl4/glVertexAttrib1f)(index, x)
  /// * vector equivalent: [`glVertexAttrib1fv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib1f(index: GLuint, x: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib1f({:?}, {:?});", index, x);
    }
    let p = glVertexAttrib1f_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLfloat)>>(p) {
      Some(fn_p) => fn_p(index, x),
      None => go_panic_because_fn_not_loaded("glVertexAttrib1f"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib1f" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib1f", glGetError());
      }
    }
    out
  }
  static glVertexAttrib1f_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib1f`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib1f_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib1f\0");
    glVertexAttrib1f_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib1f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib1f_is_loaded() -> bool {
    !glVertexAttrib1f_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib1fv](http://docs.gl/gl4/glVertexAttrib1fv)(index, v)
  /// * `v` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib1fv(index: GLuint, v: *const GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib1fv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib1fv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLfloat)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib1fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib1fv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib1fv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib1fv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib1fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib1fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib1fv\0");
    glVertexAttrib1fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib1fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib1fv_is_loaded() -> bool {
    !glVertexAttrib1fv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib1s](http://docs.gl/gl4/glVertexAttrib1s)(index, x)
  /// * vector equivalent: [`glVertexAttrib1sv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib1s(index: GLuint, x: GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib1s({:?}, {:?});", index, x);
    }
    let p = glVertexAttrib1s_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLshort)>>(p) {
      Some(fn_p) => fn_p(index, x),
      None => go_panic_because_fn_not_loaded("glVertexAttrib1s"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib1s" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib1s", glGetError());
      }
    }
    out
  }
  static glVertexAttrib1s_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib1s`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib1s_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib1s\0");
    glVertexAttrib1s_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib1s`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib1s_is_loaded() -> bool {
    !glVertexAttrib1s_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib1sv](http://docs.gl/gl4/glVertexAttrib1sv)(index, v)
  /// * `v` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib1sv(index: GLuint, v: *const GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib1sv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib1sv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLshort)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib1sv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib1sv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib1sv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib1sv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib1sv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib1sv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib1sv\0");
    glVertexAttrib1sv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib1sv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib1sv_is_loaded() -> bool {
    !glVertexAttrib1sv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib2d](http://docs.gl/gl4/glVertexAttrib2d)(index, x, y)
  /// * vector equivalent: [`glVertexAttrib2dv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib2d(index: GLuint, x: GLdouble, y: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib2d({:?}, {:?}, {:?});", index, x, y);
    }
    let p = glVertexAttrib2d_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLdouble, GLdouble)>>(p) {
        Some(fn_p) => fn_p(index, x, y),
        None => go_panic_because_fn_not_loaded("glVertexAttrib2d"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib2d" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib2d", glGetError());
      }
    }
    out
  }
  static glVertexAttrib2d_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib2d`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib2d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib2d\0");
    glVertexAttrib2d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib2d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib2d_is_loaded() -> bool {
    !glVertexAttrib2d_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib2dv](http://docs.gl/gl4/glVertexAttrib2dv)(index, v)
  /// * `v` len: 2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib2dv(index: GLuint, v: *const GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib2dv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib2dv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib2dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib2dv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib2dv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib2dv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib2dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib2dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib2dv\0");
    glVertexAttrib2dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib2dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib2dv_is_loaded() -> bool {
    !glVertexAttrib2dv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib2f](http://docs.gl/gl4/glVertexAttrib2f)(index, x, y)
  /// * vector equivalent: [`glVertexAttrib2fv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib2f({:?}, {:?}, {:?});", index, x, y);
    }
    let p = glVertexAttrib2f_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLfloat, GLfloat)>>(p)
    {
      Some(fn_p) => fn_p(index, x, y),
      None => go_panic_because_fn_not_loaded("glVertexAttrib2f"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib2f" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib2f", glGetError());
      }
    }
    out
  }
  static glVertexAttrib2f_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib2f`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib2f_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib2f\0");
    glVertexAttrib2f_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib2f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib2f_is_loaded() -> bool {
    !glVertexAttrib2f_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib2fv](http://docs.gl/gl4/glVertexAttrib2fv)(index, v)
  /// * `v` len: 2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib2fv(index: GLuint, v: *const GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib2fv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib2fv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLfloat)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib2fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib2fv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib2fv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib2fv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib2fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib2fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib2fv\0");
    glVertexAttrib2fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib2fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib2fv_is_loaded() -> bool {
    !glVertexAttrib2fv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib2s](http://docs.gl/gl4/glVertexAttrib2s)(index, x, y)
  /// * vector equivalent: [`glVertexAttrib2sv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib2s(index: GLuint, x: GLshort, y: GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib2s({:?}, {:?}, {:?});", index, x, y);
    }
    let p = glVertexAttrib2s_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLshort, GLshort)>>(p)
    {
      Some(fn_p) => fn_p(index, x, y),
      None => go_panic_because_fn_not_loaded("glVertexAttrib2s"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib2s" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib2s", glGetError());
      }
    }
    out
  }
  static glVertexAttrib2s_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib2s`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib2s_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib2s\0");
    glVertexAttrib2s_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib2s`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib2s_is_loaded() -> bool {
    !glVertexAttrib2s_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib2sv](http://docs.gl/gl4/glVertexAttrib2sv)(index, v)
  /// * `v` len: 2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib2sv(index: GLuint, v: *const GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib2sv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib2sv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLshort)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib2sv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib2sv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib2sv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib2sv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib2sv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib2sv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib2sv\0");
    glVertexAttrib2sv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib2sv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib2sv_is_loaded() -> bool {
    !glVertexAttrib2sv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib3d](http://docs.gl/gl4/glVertexAttrib3d)(index, x, y, z)
  /// * vector equivalent: [`glVertexAttrib3dv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib3d(
    index: GLuint,
    x: GLdouble,
    y: GLdouble,
    z: GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib3d({:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z
      );
    }
    let p = glVertexAttrib3d_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, x, y, z),
      None => go_panic_because_fn_not_loaded("glVertexAttrib3d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib3d" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib3d", glGetError());
      }
    }
    out
  }
  static glVertexAttrib3d_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib3d`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib3d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib3d\0");
    glVertexAttrib3d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib3d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib3d_is_loaded() -> bool {
    !glVertexAttrib3d_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib3dv](http://docs.gl/gl4/glVertexAttrib3dv)(index, v)
  /// * `v` len: 3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib3dv(index: GLuint, v: *const GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib3dv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib3dv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib3dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib3dv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib3dv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib3dv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib3dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib3dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib3dv\0");
    glVertexAttrib3dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib3dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib3dv_is_loaded() -> bool {
    !glVertexAttrib3dv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib3f](http://docs.gl/gl4/glVertexAttrib3f)(index, x, y, z)
  /// * vector equivalent: [`glVertexAttrib3fv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib3f(
    index: GLuint,
    x: GLfloat,
    y: GLfloat,
    z: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib3f({:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z
      );
    }
    let p = glVertexAttrib3f_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, x, y, z),
      None => go_panic_because_fn_not_loaded("glVertexAttrib3f"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib3f" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib3f", glGetError());
      }
    }
    out
  }
  static glVertexAttrib3f_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib3f`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib3f_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib3f\0");
    glVertexAttrib3f_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib3f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib3f_is_loaded() -> bool {
    !glVertexAttrib3f_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib3fv](http://docs.gl/gl4/glVertexAttrib3fv)(index, v)
  /// * `v` len: 3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib3fv(index: GLuint, v: *const GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib3fv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib3fv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLfloat)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib3fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib3fv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib3fv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib3fv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib3fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib3fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib3fv\0");
    glVertexAttrib3fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib3fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib3fv_is_loaded() -> bool {
    !glVertexAttrib3fv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib3s](http://docs.gl/gl4/glVertexAttrib3s)(index, x, y, z)
  /// * vector equivalent: [`glVertexAttrib3sv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib3s(
    index: GLuint,
    x: GLshort,
    y: GLshort,
    z: GLshort,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib3s({:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z
      );
    }
    let p = glVertexAttrib3s_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLshort, GLshort, GLshort)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, x, y, z),
      None => go_panic_because_fn_not_loaded("glVertexAttrib3s"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib3s" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib3s", glGetError());
      }
    }
    out
  }
  static glVertexAttrib3s_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib3s`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib3s_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib3s\0");
    glVertexAttrib3s_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib3s`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib3s_is_loaded() -> bool {
    !glVertexAttrib3s_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib3sv](http://docs.gl/gl4/glVertexAttrib3sv)(index, v)
  /// * `v` len: 3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib3sv(index: GLuint, v: *const GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib3sv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib3sv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLshort)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib3sv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib3sv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib3sv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib3sv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib3sv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib3sv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib3sv\0");
    glVertexAttrib3sv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib3sv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib3sv_is_loaded() -> bool {
    !glVertexAttrib3sv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Nbv](http://docs.gl/gl4/glVertexAttrib4Nbv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Nbv(index: GLuint, v: *const GLbyte) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4Nbv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4Nbv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLbyte)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4Nbv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4Nbv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4Nbv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4Nbv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Nbv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4Nbv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4Nbv\0");
    glVertexAttrib4Nbv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4Nbv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Nbv_is_loaded() -> bool {
    !glVertexAttrib4Nbv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Niv](http://docs.gl/gl4/glVertexAttrib4Niv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Niv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4Niv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4Niv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4Niv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4Niv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4Niv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4Niv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Niv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4Niv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4Niv\0");
    glVertexAttrib4Niv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4Niv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Niv_is_loaded() -> bool {
    !glVertexAttrib4Niv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Nsv](http://docs.gl/gl4/glVertexAttrib4Nsv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Nsv(index: GLuint, v: *const GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4Nsv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4Nsv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLshort)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4Nsv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4Nsv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4Nsv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4Nsv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Nsv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4Nsv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4Nsv\0");
    glVertexAttrib4Nsv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4Nsv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Nsv_is_loaded() -> bool {
    !glVertexAttrib4Nsv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Nub](http://docs.gl/gl4/glVertexAttrib4Nub)(index, x, y, z, w)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Nub(
    index: GLuint,
    x: GLubyte,
    y: GLubyte,
    z: GLubyte,
    w: GLubyte,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib4Nub({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let p = glVertexAttrib4Nub_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLubyte, GLubyte, GLubyte, GLubyte)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, x, y, z, w),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4Nub"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4Nub" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4Nub", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4Nub_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Nub`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4Nub_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4Nub\0");
    glVertexAttrib4Nub_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4Nub`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Nub_is_loaded() -> bool {
    !glVertexAttrib4Nub_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Nubv](http://docs.gl/gl4/glVertexAttrib4Nubv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Nubv(index: GLuint, v: *const GLubyte) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4Nubv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4Nubv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLubyte)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4Nubv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4Nubv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4Nubv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4Nubv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Nubv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4Nubv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4Nubv\0");
    glVertexAttrib4Nubv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4Nubv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Nubv_is_loaded() -> bool {
    !glVertexAttrib4Nubv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Nuiv](http://docs.gl/gl4/glVertexAttrib4Nuiv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Nuiv(index: GLuint, v: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4Nuiv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4Nuiv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4Nuiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4Nuiv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4Nuiv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4Nuiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Nuiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4Nuiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4Nuiv\0");
    glVertexAttrib4Nuiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4Nuiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Nuiv_is_loaded() -> bool {
    !glVertexAttrib4Nuiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4Nusv](http://docs.gl/gl4/glVertexAttrib4Nusv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4Nusv(index: GLuint, v: *const GLushort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4Nusv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4Nusv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLushort)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4Nusv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4Nusv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4Nusv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4Nusv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4Nusv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4Nusv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4Nusv\0");
    glVertexAttrib4Nusv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4Nusv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4Nusv_is_loaded() -> bool {
    !glVertexAttrib4Nusv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4bv](http://docs.gl/gl4/glVertexAttrib4bv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4bv(index: GLuint, v: *const GLbyte) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4bv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4bv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLbyte)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4bv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4bv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4bv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4bv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4bv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4bv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4bv\0");
    glVertexAttrib4bv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4bv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4bv_is_loaded() -> bool {
    !glVertexAttrib4bv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4d](http://docs.gl/gl4/glVertexAttrib4d)(index, x, y, z, w)
  /// * vector equivalent: [`glVertexAttrib4dv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4d(
    index: GLuint,
    x: GLdouble,
    y: GLdouble,
    z: GLdouble,
    w: GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib4d({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let p = glVertexAttrib4d_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble, GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, x, y, z, w),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4d" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4d", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4d_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4d`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4d\0");
    glVertexAttrib4d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4d_is_loaded() -> bool {
    !glVertexAttrib4d_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4dv](http://docs.gl/gl4/glVertexAttrib4dv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4dv(index: GLuint, v: *const GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4dv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4dv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4dv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4dv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4dv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4dv\0");
    glVertexAttrib4dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4dv_is_loaded() -> bool {
    !glVertexAttrib4dv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4f](http://docs.gl/gl4/glVertexAttrib4f)(index, x, y, z, w)
  /// * vector equivalent: [`glVertexAttrib4fv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4f(
    index: GLuint,
    x: GLfloat,
    y: GLfloat,
    z: GLfloat,
    w: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib4f({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let p = glVertexAttrib4f_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat, GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, x, y, z, w),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4f"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4f" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4f", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4f_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4f`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4f_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4f\0");
    glVertexAttrib4f_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4f`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4f_is_loaded() -> bool {
    !glVertexAttrib4f_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4fv](http://docs.gl/gl4/glVertexAttrib4fv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4fv(index: GLuint, v: *const GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4fv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4fv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLfloat)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4fv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4fv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4fv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4fv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4fv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4fv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4fv\0");
    glVertexAttrib4fv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4fv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4fv_is_loaded() -> bool {
    !glVertexAttrib4fv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4iv](http://docs.gl/gl4/glVertexAttrib4iv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4iv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4iv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4iv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4iv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4iv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4iv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4iv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4iv\0");
    glVertexAttrib4iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4iv_is_loaded() -> bool {
    !glVertexAttrib4iv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4s](http://docs.gl/gl4/glVertexAttrib4s)(index, x, y, z, w)
  /// * vector equivalent: [`glVertexAttrib4sv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4s(
    index: GLuint,
    x: GLshort,
    y: GLshort,
    z: GLshort,
    w: GLshort,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttrib4s({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let p = glVertexAttrib4s_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLshort, GLshort, GLshort, GLshort)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, x, y, z, w),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4s"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4s" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4s", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4s_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4s`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4s_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4s\0");
    glVertexAttrib4s_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4s`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4s_is_loaded() -> bool {
    !glVertexAttrib4s_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4sv](http://docs.gl/gl4/glVertexAttrib4sv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4sv(index: GLuint, v: *const GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4sv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4sv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLshort)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4sv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4sv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4sv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4sv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4sv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4sv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4sv\0");
    glVertexAttrib4sv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4sv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4sv_is_loaded() -> bool {
    !glVertexAttrib4sv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4ubv](http://docs.gl/gl4/glVertexAttrib4ubv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4ubv(index: GLuint, v: *const GLubyte) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4ubv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4ubv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLubyte)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4ubv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4ubv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4ubv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4ubv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4ubv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4ubv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4ubv\0");
    glVertexAttrib4ubv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4ubv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4ubv_is_loaded() -> bool {
    !glVertexAttrib4ubv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4uiv](http://docs.gl/gl4/glVertexAttrib4uiv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4uiv(index: GLuint, v: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4uiv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4uiv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4uiv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4uiv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4uiv\0");
    glVertexAttrib4uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4uiv_is_loaded() -> bool {
    !glVertexAttrib4uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttrib4usv](http://docs.gl/gl4/glVertexAttrib4usv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttrib4usv(index: GLuint, v: *const GLushort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttrib4usv({:?}, {:p});", index, v);
    }
    let p = glVertexAttrib4usv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLushort)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttrib4usv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttrib4usv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttrib4usv", glGetError());
      }
    }
    out
  }
  static glVertexAttrib4usv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttrib4usv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttrib4usv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttrib4usv\0");
    glVertexAttrib4usv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttrib4usv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttrib4usv_is_loaded() -> bool {
    !glVertexAttrib4usv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribBinding](http://docs.gl/gl4/glVertexAttribBinding)(attribindex, bindingindex)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribBinding(
    attribindex: GLuint,
    bindingindex: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribBinding({:?}, {:?});",
        attribindex,
        bindingindex
      );
    }
    let p = glVertexAttribBinding_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(attribindex, bindingindex),
      None => go_panic_because_fn_not_loaded("glVertexAttribBinding"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribBinding" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribBinding", glGetError());
      }
    }
    out
  }
  static glVertexAttribBinding_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribBinding`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribBinding_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribBinding\0");
    glVertexAttribBinding_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribBinding`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribBinding_is_loaded() -> bool {
    !glVertexAttribBinding_p.load(RELAX).is_null()
  }

  /// [glVertexAttribDivisor](http://docs.gl/gl4/glVertexAttribDivisor)(index, divisor)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribDivisor(index: GLuint, divisor: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribDivisor({:?}, {:?});", index, divisor);
    }
    let p = glVertexAttribDivisor_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(index, divisor),
      None => go_panic_because_fn_not_loaded("glVertexAttribDivisor"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribDivisor" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribDivisor", glGetError());
      }
    }
    out
  }
  static glVertexAttribDivisor_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribDivisor`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribDivisor_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribDivisor\0");
    glVertexAttribDivisor_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribDivisor`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribDivisor_is_loaded() -> bool {
    !glVertexAttribDivisor_p.load(RELAX).is_null()
  }

  /// [glVertexAttribFormat](http://docs.gl/gl4/glVertexAttribFormat)(attribindex, size, type_, normalized, relativeoffset)
  /// * `type_` group: VertexAttribType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribFormat(
    attribindex: GLuint,
    size: GLint,
    type_: GLenum,
    normalized: GLboolean,
    relativeoffset: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribFormat({:?}, {:?}, {:#X}, {:?}, {:?});",
        attribindex,
        size,
        type_,
        normalized,
        relativeoffset
      );
    }
    let p = glVertexAttribFormat_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLenum, GLboolean, GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(attribindex, size, type_, normalized, relativeoffset),
      None => go_panic_because_fn_not_loaded("glVertexAttribFormat"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribFormat" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribFormat", glGetError());
      }
    }
    out
  }
  static glVertexAttribFormat_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribFormat`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribFormat_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribFormat\0");
    glVertexAttribFormat_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribFormat`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribFormat_is_loaded() -> bool {
    !glVertexAttribFormat_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI1i](http://docs.gl/gl4/glVertexAttribI1i)(index, x)
  /// * vector equivalent: [`glVertexAttribI1iv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI1i(index: GLuint, x: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI1i({:?}, {:?});", index, x);
    }
    let p = glVertexAttribI1i_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLint)>>(p) {
      Some(fn_p) => fn_p(index, x),
      None => go_panic_because_fn_not_loaded("glVertexAttribI1i"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI1i" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI1i", glGetError());
      }
    }
    out
  }
  static glVertexAttribI1i_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI1i`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI1i_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI1i\0");
    glVertexAttribI1i_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI1i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI1i_is_loaded() -> bool {
    !glVertexAttribI1i_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI1iv](http://docs.gl/gl4/glVertexAttribI1iv)(index, v)
  /// * `v` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI1iv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI1iv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribI1iv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribI1iv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI1iv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI1iv", glGetError());
      }
    }
    out
  }
  static glVertexAttribI1iv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI1iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI1iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI1iv\0");
    glVertexAttribI1iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI1iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI1iv_is_loaded() -> bool {
    !glVertexAttribI1iv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI1ui](http://docs.gl/gl4/glVertexAttribI1ui)(index, x)
  /// * vector equivalent: [`glVertexAttribI1uiv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI1ui(index: GLuint, x: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI1ui({:?}, {:?});", index, x);
    }
    let p = glVertexAttribI1ui_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(index, x),
      None => go_panic_because_fn_not_loaded("glVertexAttribI1ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI1ui" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI1ui", glGetError());
      }
    }
    out
  }
  static glVertexAttribI1ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI1ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI1ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI1ui\0");
    glVertexAttribI1ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI1ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI1ui_is_loaded() -> bool {
    !glVertexAttribI1ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI1uiv](http://docs.gl/gl4/glVertexAttribI1uiv)(index, v)
  /// * `v` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI1uiv(index: GLuint, v: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI1uiv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribI1uiv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribI1uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI1uiv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI1uiv", glGetError());
      }
    }
    out
  }
  static glVertexAttribI1uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI1uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI1uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI1uiv\0");
    glVertexAttribI1uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI1uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI1uiv_is_loaded() -> bool {
    !glVertexAttribI1uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI2i](http://docs.gl/gl4/glVertexAttribI2i)(index, x, y)
  /// * vector equivalent: [`glVertexAttribI2iv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI2i(index: GLuint, x: GLint, y: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI2i({:?}, {:?}, {:?});", index, x, y);
    }
    let p = glVertexAttribI2i_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLint, GLint)>>(p) {
      Some(fn_p) => fn_p(index, x, y),
      None => go_panic_because_fn_not_loaded("glVertexAttribI2i"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI2i" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI2i", glGetError());
      }
    }
    out
  }
  static glVertexAttribI2i_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI2i`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI2i_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI2i\0");
    glVertexAttribI2i_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI2i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI2i_is_loaded() -> bool {
    !glVertexAttribI2i_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI2iv](http://docs.gl/gl4/glVertexAttribI2iv)(index, v)
  /// * `v` len: 2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI2iv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI2iv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribI2iv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribI2iv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI2iv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI2iv", glGetError());
      }
    }
    out
  }
  static glVertexAttribI2iv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI2iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI2iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI2iv\0");
    glVertexAttribI2iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI2iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI2iv_is_loaded() -> bool {
    !glVertexAttribI2iv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI2ui](http://docs.gl/gl4/glVertexAttribI2ui)(index, x, y)
  /// * vector equivalent: [`glVertexAttribI2uiv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI2ui(index: GLuint, x: GLuint, y: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI2ui({:?}, {:?}, {:?});", index, x, y);
    }
    let p = glVertexAttribI2ui_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(index, x, y),
      None => go_panic_because_fn_not_loaded("glVertexAttribI2ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI2ui" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI2ui", glGetError());
      }
    }
    out
  }
  static glVertexAttribI2ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI2ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI2ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI2ui\0");
    glVertexAttribI2ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI2ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI2ui_is_loaded() -> bool {
    !glVertexAttribI2ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI2uiv](http://docs.gl/gl4/glVertexAttribI2uiv)(index, v)
  /// * `v` len: 2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI2uiv(index: GLuint, v: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI2uiv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribI2uiv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribI2uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI2uiv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI2uiv", glGetError());
      }
    }
    out
  }
  static glVertexAttribI2uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI2uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI2uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI2uiv\0");
    glVertexAttribI2uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI2uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI2uiv_is_loaded() -> bool {
    !glVertexAttribI2uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI3i](http://docs.gl/gl4/glVertexAttribI3i)(index, x, y, z)
  /// * vector equivalent: [`glVertexAttribI3iv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI3i(index: GLuint, x: GLint, y: GLint, z: GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribI3i({:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z
      );
    }
    let p = glVertexAttribI3i_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLint, GLint, GLint)>>(p) {
        Some(fn_p) => fn_p(index, x, y, z),
        None => go_panic_because_fn_not_loaded("glVertexAttribI3i"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI3i" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI3i", glGetError());
      }
    }
    out
  }
  static glVertexAttribI3i_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI3i`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI3i_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI3i\0");
    glVertexAttribI3i_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI3i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI3i_is_loaded() -> bool {
    !glVertexAttribI3i_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI3iv](http://docs.gl/gl4/glVertexAttribI3iv)(index, v)
  /// * `v` len: 3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI3iv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI3iv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribI3iv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribI3iv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI3iv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI3iv", glGetError());
      }
    }
    out
  }
  static glVertexAttribI3iv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI3iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI3iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI3iv\0");
    glVertexAttribI3iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI3iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI3iv_is_loaded() -> bool {
    !glVertexAttribI3iv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI3ui](http://docs.gl/gl4/glVertexAttribI3ui)(index, x, y, z)
  /// * vector equivalent: [`glVertexAttribI3uiv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI3ui(
    index: GLuint,
    x: GLuint,
    y: GLuint,
    z: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribI3ui({:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z
      );
    }
    let p = glVertexAttribI3ui_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(index, x, y, z),
        None => go_panic_because_fn_not_loaded("glVertexAttribI3ui"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI3ui" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI3ui", glGetError());
      }
    }
    out
  }
  static glVertexAttribI3ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI3ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI3ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI3ui\0");
    glVertexAttribI3ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI3ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI3ui_is_loaded() -> bool {
    !glVertexAttribI3ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI3uiv](http://docs.gl/gl4/glVertexAttribI3uiv)(index, v)
  /// * `v` len: 3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI3uiv(index: GLuint, v: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI3uiv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribI3uiv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribI3uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI3uiv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI3uiv", glGetError());
      }
    }
    out
  }
  static glVertexAttribI3uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI3uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI3uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI3uiv\0");
    glVertexAttribI3uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI3uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI3uiv_is_loaded() -> bool {
    !glVertexAttribI3uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4bv](http://docs.gl/gl4/glVertexAttribI4bv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4bv(index: GLuint, v: *const GLbyte) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI4bv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribI4bv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLbyte)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribI4bv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI4bv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI4bv", glGetError());
      }
    }
    out
  }
  static glVertexAttribI4bv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4bv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI4bv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI4bv\0");
    glVertexAttribI4bv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI4bv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4bv_is_loaded() -> bool {
    !glVertexAttribI4bv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4i](http://docs.gl/gl4/glVertexAttribI4i)(index, x, y, z, w)
  /// * vector equivalent: [`glVertexAttribI4iv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4i(
    index: GLuint,
    x: GLint,
    y: GLint,
    z: GLint,
    w: GLint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribI4i({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let p = glVertexAttribI4i_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLint, GLint, GLint, GLint)>>(
        p,
      ) {
        Some(fn_p) => fn_p(index, x, y, z, w),
        None => go_panic_because_fn_not_loaded("glVertexAttribI4i"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI4i" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI4i", glGetError());
      }
    }
    out
  }
  static glVertexAttribI4i_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4i`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI4i_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI4i\0");
    glVertexAttribI4i_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI4i`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4i_is_loaded() -> bool {
    !glVertexAttribI4i_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4iv](http://docs.gl/gl4/glVertexAttribI4iv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4iv(index: GLuint, v: *const GLint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI4iv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribI4iv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribI4iv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI4iv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI4iv", glGetError());
      }
    }
    out
  }
  static glVertexAttribI4iv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4iv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI4iv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI4iv\0");
    glVertexAttribI4iv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI4iv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4iv_is_loaded() -> bool {
    !glVertexAttribI4iv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4sv](http://docs.gl/gl4/glVertexAttribI4sv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4sv(index: GLuint, v: *const GLshort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI4sv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribI4sv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLshort)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribI4sv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI4sv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI4sv", glGetError());
      }
    }
    out
  }
  static glVertexAttribI4sv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4sv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI4sv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI4sv\0");
    glVertexAttribI4sv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI4sv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4sv_is_loaded() -> bool {
    !glVertexAttribI4sv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4ubv](http://docs.gl/gl4/glVertexAttribI4ubv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4ubv(index: GLuint, v: *const GLubyte) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI4ubv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribI4ubv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLubyte)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribI4ubv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI4ubv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI4ubv", glGetError());
      }
    }
    out
  }
  static glVertexAttribI4ubv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4ubv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI4ubv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI4ubv\0");
    glVertexAttribI4ubv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI4ubv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4ubv_is_loaded() -> bool {
    !glVertexAttribI4ubv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4ui](http://docs.gl/gl4/glVertexAttribI4ui)(index, x, y, z, w)
  /// * vector equivalent: [`glVertexAttribI4uiv`]
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4ui(
    index: GLuint,
    x: GLuint,
    y: GLuint,
    z: GLuint,
    w: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribI4ui({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let p = glVertexAttribI4ui_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLuint, GLuint, GLuint, GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, x, y, z, w),
      None => go_panic_because_fn_not_loaded("glVertexAttribI4ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI4ui" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI4ui", glGetError());
      }
    }
    out
  }
  static glVertexAttribI4ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI4ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI4ui\0");
    glVertexAttribI4ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI4ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4ui_is_loaded() -> bool {
    !glVertexAttribI4ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4uiv](http://docs.gl/gl4/glVertexAttribI4uiv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4uiv(index: GLuint, v: *const GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI4uiv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribI4uiv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLuint)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribI4uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI4uiv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI4uiv", glGetError());
      }
    }
    out
  }
  static glVertexAttribI4uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI4uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI4uiv\0");
    glVertexAttribI4uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI4uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4uiv_is_loaded() -> bool {
    !glVertexAttribI4uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribI4usv](http://docs.gl/gl4/glVertexAttribI4usv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribI4usv(index: GLuint, v: *const GLushort) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribI4usv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribI4usv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLushort)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribI4usv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribI4usv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribI4usv", glGetError());
      }
    }
    out
  }
  static glVertexAttribI4usv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribI4usv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribI4usv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribI4usv\0");
    glVertexAttribI4usv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribI4usv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribI4usv_is_loaded() -> bool {
    !glVertexAttribI4usv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribIFormat](http://docs.gl/gl4/glVertexAttribIFormat)(attribindex, size, type_, relativeoffset)
  /// * `type_` group: VertexAttribIType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribIFormat(
    attribindex: GLuint,
    size: GLint,
    type_: GLenum,
    relativeoffset: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribIFormat({:?}, {:?}, {:#X}, {:?});",
        attribindex,
        size,
        type_,
        relativeoffset
      );
    }
    let p = glVertexAttribIFormat_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLint, GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(attribindex, size, type_, relativeoffset),
        None => go_panic_because_fn_not_loaded("glVertexAttribIFormat"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribIFormat" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribIFormat", glGetError());
      }
    }
    out
  }
  static glVertexAttribIFormat_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribIFormat`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribIFormat_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribIFormat\0");
    glVertexAttribIFormat_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribIFormat`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribIFormat_is_loaded() -> bool {
    !glVertexAttribIFormat_p.load(RELAX).is_null()
  }

  /// [glVertexAttribIPointer](http://docs.gl/gl4/glVertexAttribIPointer)(index, size, type_, stride, pointer)
  /// * `type_` group: VertexAttribIType
  /// * `pointer` len: COMPSIZE(size,type,stride)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribIPointer(
    index: GLuint,
    size: GLint,
    type_: GLenum,
    stride: GLsizei,
    pointer: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribIPointer({:?}, {:?}, {:#X}, {:?}, {:p});",
        index,
        size,
        type_,
        stride,
        pointer
      );
    }
    let p = glVertexAttribIPointer_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLenum, GLsizei, *const c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, size, type_, stride, pointer),
      None => go_panic_because_fn_not_loaded("glVertexAttribIPointer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribIPointer" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribIPointer", glGetError());
      }
    }
    out
  }
  static glVertexAttribIPointer_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribIPointer`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribIPointer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribIPointer\0");
    glVertexAttribIPointer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribIPointer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribIPointer_is_loaded() -> bool {
    !glVertexAttribIPointer_p.load(RELAX).is_null()
  }

  /// [glVertexAttribL1d](http://docs.gl/gl4/glVertexAttribL1d)(index, x)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribL1d(index: GLuint, x: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribL1d({:?}, {:?});", index, x);
    }
    let p = glVertexAttribL1d_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLdouble)>>(p) {
      Some(fn_p) => fn_p(index, x),
      None => go_panic_because_fn_not_loaded("glVertexAttribL1d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribL1d" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribL1d", glGetError());
      }
    }
    out
  }
  static glVertexAttribL1d_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribL1d`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribL1d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribL1d\0");
    glVertexAttribL1d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribL1d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribL1d_is_loaded() -> bool {
    !glVertexAttribL1d_p.load(RELAX).is_null()
  }

  /// [glVertexAttribL1dv](http://docs.gl/gl4/glVertexAttribL1dv)(index, v)
  /// * `v` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribL1dv(index: GLuint, v: *const GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribL1dv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribL1dv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribL1dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribL1dv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribL1dv", glGetError());
      }
    }
    out
  }
  static glVertexAttribL1dv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribL1dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribL1dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribL1dv\0");
    glVertexAttribL1dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribL1dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribL1dv_is_loaded() -> bool {
    !glVertexAttribL1dv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribL2d](http://docs.gl/gl4/glVertexAttribL2d)(index, x, y)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribL2d(index: GLuint, x: GLdouble, y: GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribL2d({:?}, {:?}, {:?});", index, x, y);
    }
    let p = glVertexAttribL2d_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLdouble, GLdouble)>>(p) {
        Some(fn_p) => fn_p(index, x, y),
        None => go_panic_because_fn_not_loaded("glVertexAttribL2d"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribL2d" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribL2d", glGetError());
      }
    }
    out
  }
  static glVertexAttribL2d_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribL2d`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribL2d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribL2d\0");
    glVertexAttribL2d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribL2d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribL2d_is_loaded() -> bool {
    !glVertexAttribL2d_p.load(RELAX).is_null()
  }

  /// [glVertexAttribL2dv](http://docs.gl/gl4/glVertexAttribL2dv)(index, v)
  /// * `v` len: 2
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribL2dv(index: GLuint, v: *const GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribL2dv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribL2dv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribL2dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribL2dv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribL2dv", glGetError());
      }
    }
    out
  }
  static glVertexAttribL2dv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribL2dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribL2dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribL2dv\0");
    glVertexAttribL2dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribL2dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribL2dv_is_loaded() -> bool {
    !glVertexAttribL2dv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribL3d](http://docs.gl/gl4/glVertexAttribL3d)(index, x, y, z)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribL3d(
    index: GLuint,
    x: GLdouble,
    y: GLdouble,
    z: GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribL3d({:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z
      );
    }
    let p = glVertexAttribL3d_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, x, y, z),
      None => go_panic_because_fn_not_loaded("glVertexAttribL3d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribL3d" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribL3d", glGetError());
      }
    }
    out
  }
  static glVertexAttribL3d_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribL3d`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribL3d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribL3d\0");
    glVertexAttribL3d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribL3d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribL3d_is_loaded() -> bool {
    !glVertexAttribL3d_p.load(RELAX).is_null()
  }

  /// [glVertexAttribL3dv](http://docs.gl/gl4/glVertexAttribL3dv)(index, v)
  /// * `v` len: 3
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribL3dv(index: GLuint, v: *const GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribL3dv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribL3dv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribL3dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribL3dv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribL3dv", glGetError());
      }
    }
    out
  }
  static glVertexAttribL3dv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribL3dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribL3dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribL3dv\0");
    glVertexAttribL3dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribL3dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribL3dv_is_loaded() -> bool {
    !glVertexAttribL3dv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribL4d](http://docs.gl/gl4/glVertexAttribL4d)(index, x, y, z, w)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribL4d(
    index: GLuint,
    x: GLdouble,
    y: GLdouble,
    z: GLdouble,
    w: GLdouble,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribL4d({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        z,
        w
      );
    }
    let p = glVertexAttribL4d_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble, GLdouble)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, x, y, z, w),
      None => go_panic_because_fn_not_loaded("glVertexAttribL4d"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribL4d" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribL4d", glGetError());
      }
    }
    out
  }
  static glVertexAttribL4d_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribL4d`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribL4d_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribL4d\0");
    glVertexAttribL4d_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribL4d`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribL4d_is_loaded() -> bool {
    !glVertexAttribL4d_p.load(RELAX).is_null()
  }

  /// [glVertexAttribL4dv](http://docs.gl/gl4/glVertexAttribL4dv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribL4dv(index: GLuint, v: *const GLdouble) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glVertexAttribL4dv({:?}, {:p});", index, v);
    }
    let p = glVertexAttribL4dv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glVertexAttribL4dv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribL4dv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribL4dv", glGetError());
      }
    }
    out
  }
  static glVertexAttribL4dv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribL4dv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribL4dv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribL4dv\0");
    glVertexAttribL4dv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribL4dv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribL4dv_is_loaded() -> bool {
    !glVertexAttribL4dv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribLFormat](http://docs.gl/gl4/glVertexAttribLFormat)(attribindex, size, type_, relativeoffset)
  /// * `type_` group: VertexAttribLType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribLFormat(
    attribindex: GLuint,
    size: GLint,
    type_: GLenum,
    relativeoffset: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribLFormat({:?}, {:?}, {:#X}, {:?});",
        attribindex,
        size,
        type_,
        relativeoffset
      );
    }
    let p = glVertexAttribLFormat_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLuint, GLint, GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(attribindex, size, type_, relativeoffset),
        None => go_panic_because_fn_not_loaded("glVertexAttribLFormat"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribLFormat" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribLFormat", glGetError());
      }
    }
    out
  }
  static glVertexAttribLFormat_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribLFormat`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribLFormat_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribLFormat\0");
    glVertexAttribLFormat_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribLFormat`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribLFormat_is_loaded() -> bool {
    !glVertexAttribLFormat_p.load(RELAX).is_null()
  }

  /// [glVertexAttribLPointer](http://docs.gl/gl4/glVertexAttribLPointer)(index, size, type_, stride, pointer)
  /// * `type_` group: VertexAttribLType
  /// * `pointer` len: size
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribLPointer(
    index: GLuint,
    size: GLint,
    type_: GLenum,
    stride: GLsizei,
    pointer: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribLPointer({:?}, {:?}, {:#X}, {:?}, {:p});",
        index,
        size,
        type_,
        stride,
        pointer
      );
    }
    let p = glVertexAttribLPointer_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLint, GLenum, GLsizei, *const c_void)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, size, type_, stride, pointer),
      None => go_panic_because_fn_not_loaded("glVertexAttribLPointer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribLPointer" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribLPointer", glGetError());
      }
    }
    out
  }
  static glVertexAttribLPointer_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribLPointer`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribLPointer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribLPointer\0");
    glVertexAttribLPointer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribLPointer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribLPointer_is_loaded() -> bool {
    !glVertexAttribLPointer_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP1ui](http://docs.gl/gl4/glVertexAttribP1ui)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP1ui(
    index: GLuint,
    type_: GLenum,
    normalized: GLboolean,
    value: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP1ui({:?}, {:#X}, {:?}, {:?});",
        index,
        type_,
        normalized,
        value
      );
    }
    let p = glVertexAttribP1ui_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLboolean, GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, type_, normalized, value),
      None => go_panic_because_fn_not_loaded("glVertexAttribP1ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribP1ui" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribP1ui", glGetError());
      }
    }
    out
  }
  static glVertexAttribP1ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP1ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribP1ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribP1ui\0");
    glVertexAttribP1ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribP1ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP1ui_is_loaded() -> bool {
    !glVertexAttribP1ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP1uiv](http://docs.gl/gl4/glVertexAttribP1uiv)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  /// * `value` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP1uiv(
    index: GLuint,
    type_: GLenum,
    normalized: GLboolean,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP1uiv({:?}, {:#X}, {:?}, {:p});",
        index,
        type_,
        normalized,
        value
      );
    }
    let p = glVertexAttribP1uiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, type_, normalized, value),
      None => go_panic_because_fn_not_loaded("glVertexAttribP1uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribP1uiv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribP1uiv", glGetError());
      }
    }
    out
  }
  static glVertexAttribP1uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP1uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribP1uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribP1uiv\0");
    glVertexAttribP1uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribP1uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP1uiv_is_loaded() -> bool {
    !glVertexAttribP1uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP2ui](http://docs.gl/gl4/glVertexAttribP2ui)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP2ui(
    index: GLuint,
    type_: GLenum,
    normalized: GLboolean,
    value: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP2ui({:?}, {:#X}, {:?}, {:?});",
        index,
        type_,
        normalized,
        value
      );
    }
    let p = glVertexAttribP2ui_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLboolean, GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, type_, normalized, value),
      None => go_panic_because_fn_not_loaded("glVertexAttribP2ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribP2ui" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribP2ui", glGetError());
      }
    }
    out
  }
  static glVertexAttribP2ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP2ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribP2ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribP2ui\0");
    glVertexAttribP2ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribP2ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP2ui_is_loaded() -> bool {
    !glVertexAttribP2ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP2uiv](http://docs.gl/gl4/glVertexAttribP2uiv)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  /// * `value` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP2uiv(
    index: GLuint,
    type_: GLenum,
    normalized: GLboolean,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP2uiv({:?}, {:#X}, {:?}, {:p});",
        index,
        type_,
        normalized,
        value
      );
    }
    let p = glVertexAttribP2uiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, type_, normalized, value),
      None => go_panic_because_fn_not_loaded("glVertexAttribP2uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribP2uiv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribP2uiv", glGetError());
      }
    }
    out
  }
  static glVertexAttribP2uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP2uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribP2uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribP2uiv\0");
    glVertexAttribP2uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribP2uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP2uiv_is_loaded() -> bool {
    !glVertexAttribP2uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP3ui](http://docs.gl/gl4/glVertexAttribP3ui)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP3ui(
    index: GLuint,
    type_: GLenum,
    normalized: GLboolean,
    value: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP3ui({:?}, {:#X}, {:?}, {:?});",
        index,
        type_,
        normalized,
        value
      );
    }
    let p = glVertexAttribP3ui_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLboolean, GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, type_, normalized, value),
      None => go_panic_because_fn_not_loaded("glVertexAttribP3ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribP3ui" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribP3ui", glGetError());
      }
    }
    out
  }
  static glVertexAttribP3ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP3ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribP3ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribP3ui\0");
    glVertexAttribP3ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribP3ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP3ui_is_loaded() -> bool {
    !glVertexAttribP3ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP3uiv](http://docs.gl/gl4/glVertexAttribP3uiv)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  /// * `value` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP3uiv(
    index: GLuint,
    type_: GLenum,
    normalized: GLboolean,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP3uiv({:?}, {:#X}, {:?}, {:p});",
        index,
        type_,
        normalized,
        value
      );
    }
    let p = glVertexAttribP3uiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, type_, normalized, value),
      None => go_panic_because_fn_not_loaded("glVertexAttribP3uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribP3uiv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribP3uiv", glGetError());
      }
    }
    out
  }
  static glVertexAttribP3uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP3uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribP3uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribP3uiv\0");
    glVertexAttribP3uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribP3uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP3uiv_is_loaded() -> bool {
    !glVertexAttribP3uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP4ui](http://docs.gl/gl4/glVertexAttribP4ui)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP4ui(
    index: GLuint,
    type_: GLenum,
    normalized: GLboolean,
    value: GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP4ui({:?}, {:#X}, {:?}, {:?});",
        index,
        type_,
        normalized,
        value
      );
    }
    let p = glVertexAttribP4ui_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLboolean, GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, type_, normalized, value),
      None => go_panic_because_fn_not_loaded("glVertexAttribP4ui"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribP4ui" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribP4ui", glGetError());
      }
    }
    out
  }
  static glVertexAttribP4ui_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP4ui`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribP4ui_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribP4ui\0");
    glVertexAttribP4ui_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribP4ui`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP4ui_is_loaded() -> bool {
    !glVertexAttribP4ui_p.load(RELAX).is_null()
  }

  /// [glVertexAttribP4uiv](http://docs.gl/gl4/glVertexAttribP4uiv)(index, type_, normalized, value)
  /// * `type_` group: VertexAttribPointerType
  /// * `value` len: 1
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribP4uiv(
    index: GLuint,
    type_: GLenum,
    normalized: GLboolean,
    value: *const GLuint,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribP4uiv({:?}, {:#X}, {:?}, {:p});",
        index,
        type_,
        normalized,
        value
      );
    }
    let p = glVertexAttribP4uiv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, type_, normalized, value),
      None => go_panic_because_fn_not_loaded("glVertexAttribP4uiv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribP4uiv" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribP4uiv", glGetError());
      }
    }
    out
  }
  static glVertexAttribP4uiv_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribP4uiv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribP4uiv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribP4uiv\0");
    glVertexAttribP4uiv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribP4uiv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribP4uiv_is_loaded() -> bool {
    !glVertexAttribP4uiv_p.load(RELAX).is_null()
  }

  /// [glVertexAttribPointer](http://docs.gl/gl4/glVertexAttribPointer)(index, size, type_, normalized, stride, pointer)
  /// * `type_` group: VertexAttribPointerType
  /// * `pointer` len: COMPSIZE(size,type,stride)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexAttribPointer(
    index: GLuint,
    size: GLint,
    type_: GLenum,
    normalized: GLboolean,
    stride: GLsizei,
    pointer: *const c_void,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexAttribPointer({:?}, {:?}, {:#X}, {:?}, {:?}, {:p});",
        index,
        size,
        type_,
        normalized,
        stride,
        pointer
      );
    }
    let p = glVertexAttribPointer_p.load(RELAX);
    let out = match t_::<
      _,
      O<
        extern "system" fn(
          GLuint,
          GLint,
          GLenum,
          GLboolean,
          GLsizei,
          *const c_void,
        ),
      >,
    >(p)
    {
      Some(fn_p) => fn_p(index, size, type_, normalized, stride, pointer),
      None => go_panic_because_fn_not_loaded("glVertexAttribPointer"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexAttribPointer" != "glGetError" {
        report_error_as_necessary_from("glVertexAttribPointer", glGetError());
      }
    }
    out
  }
  static glVertexAttribPointer_p: APcv = ap_null();
  /// Tries to load [`glVertexAttribPointer`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexAttribPointer_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexAttribPointer\0");
    glVertexAttribPointer_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexAttribPointer`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexAttribPointer_is_loaded() -> bool {
    !glVertexAttribPointer_p.load(RELAX).is_null()
  }

  /// [glVertexBindingDivisor](http://docs.gl/gl4/glVertexBindingDivisor)(bindingindex, divisor)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glVertexBindingDivisor(bindingindex: GLuint, divisor: GLuint) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glVertexBindingDivisor({:?}, {:?});",
        bindingindex,
        divisor
      );
    }
    let p = glVertexBindingDivisor_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
      Some(fn_p) => fn_p(bindingindex, divisor),
      None => go_panic_because_fn_not_loaded("glVertexBindingDivisor"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glVertexBindingDivisor" != "glGetError" {
        report_error_as_necessary_from("glVertexBindingDivisor", glGetError());
      }
    }
    out
  }
  static glVertexBindingDivisor_p: APcv = ap_null();
  /// Tries to load [`glVertexBindingDivisor`], returns if a non-null pointer
  /// was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glVertexBindingDivisor_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glVertexBindingDivisor\0");
    glVertexBindingDivisor_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glVertexBindingDivisor`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glVertexBindingDivisor_is_loaded() -> bool {
    !glVertexBindingDivisor_p.load(RELAX).is_null()
  }

  /// [glViewport](http://docs.gl/gl4/glViewport)(x, y, width, height)
  /// * `x` group: WinCoord
  /// * `y` group: WinCoord
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glViewport(
    x: GLint,
    y: GLint,
    width: GLsizei,
    height: GLsizei,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glViewport({:?}, {:?}, {:?}, {:?});",
        x,
        y,
        width,
        height
      );
    }
    let p = glViewport_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLint, GLint, GLsizei, GLsizei)>>(p) {
        Some(fn_p) => fn_p(x, y, width, height),
        None => go_panic_because_fn_not_loaded("glViewport"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glViewport" != "glGetError" {
        report_error_as_necessary_from("glViewport", glGetError());
      }
    }
    out
  }
  static glViewport_p: APcv = ap_null();
  /// Tries to load [`glViewport`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glViewport_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glViewport\0");
    glViewport_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glViewport`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glViewport_is_loaded() -> bool {
    !glViewport_p.load(RELAX).is_null()
  }

  /// [glViewportArrayv](http://docs.gl/gl4/glViewportArrayv)(first, count, v)
  /// * `v` len: COMPSIZE(count)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glViewportArrayv(
    first: GLuint,
    count: GLsizei,
    v: *const GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glViewportArrayv({:?}, {:?}, {:p});", first, count, v);
    }
    let p = glViewportArrayv_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLsizei, *const GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(first, count, v),
      None => go_panic_because_fn_not_loaded("glViewportArrayv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glViewportArrayv" != "glGetError" {
        report_error_as_necessary_from("glViewportArrayv", glGetError());
      }
    }
    out
  }
  static glViewportArrayv_p: APcv = ap_null();
  /// Tries to load [`glViewportArrayv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glViewportArrayv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glViewportArrayv\0");
    glViewportArrayv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glViewportArrayv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glViewportArrayv_is_loaded() -> bool {
    !glViewportArrayv_p.load(RELAX).is_null()
  }

  /// [glViewportIndexedf](http://docs.gl/gl4/glViewportIndexedf)(index, x, y, w, h)
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glViewportIndexedf(
    index: GLuint,
    x: GLfloat,
    y: GLfloat,
    w: GLfloat,
    h: GLfloat,
  ) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!(
        "calling glViewportIndexedf({:?}, {:?}, {:?}, {:?}, {:?});",
        index,
        x,
        y,
        w,
        h
      );
    }
    let p = glViewportIndexedf_p.load(RELAX);
    let out = match t_::<
      _,
      O<extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat, GLfloat)>,
    >(p)
    {
      Some(fn_p) => fn_p(index, x, y, w, h),
      None => go_panic_because_fn_not_loaded("glViewportIndexedf"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glViewportIndexedf" != "glGetError" {
        report_error_as_necessary_from("glViewportIndexedf", glGetError());
      }
    }
    out
  }
  static glViewportIndexedf_p: APcv = ap_null();
  /// Tries to load [`glViewportIndexedf`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glViewportIndexedf_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glViewportIndexedf\0");
    glViewportIndexedf_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glViewportIndexedf`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glViewportIndexedf_is_loaded() -> bool {
    !glViewportIndexedf_p.load(RELAX).is_null()
  }

  /// [glViewportIndexedfv](http://docs.gl/gl4/glViewportIndexedfv)(index, v)
  /// * `v` len: 4
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glViewportIndexedfv(index: GLuint, v: *const GLfloat) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glViewportIndexedfv({:?}, {:p});", index, v);
    }
    let p = glViewportIndexedfv_p.load(RELAX);
    let out = match t_::<_, O<extern "system" fn(GLuint, *const GLfloat)>>(p) {
      Some(fn_p) => fn_p(index, v),
      None => go_panic_because_fn_not_loaded("glViewportIndexedfv"),
    };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glViewportIndexedfv" != "glGetError" {
        report_error_as_necessary_from("glViewportIndexedfv", glGetError());
      }
    }
    out
  }
  static glViewportIndexedfv_p: APcv = ap_null();
  /// Tries to load [`glViewportIndexedfv`], returns if a non-null pointer was
  /// obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glViewportIndexedfv_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glViewportIndexedfv\0");
    glViewportIndexedfv_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glViewportIndexedfv`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glViewportIndexedfv_is_loaded() -> bool {
    !glViewportIndexedfv_p.load(RELAX).is_null()
  }

  /// [glWaitSync](http://docs.gl/gl4/glWaitSync)(sync, flags, timeout)
  /// * `sync` group: sync
  #[cfg_attr(feature = "inline", inline)]
  #[cfg_attr(feature = "inline_always", inline(always))]
  pub unsafe fn glWaitSync(sync: GLsync, flags: GLbitfield, timeout: GLuint64) {
    #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
    {
      trace!("calling glWaitSync({:p}, {:?}, {:?});", sync, flags, timeout);
    }
    let p = glWaitSync_p.load(RELAX);
    let out =
      match t_::<_, O<extern "system" fn(GLsync, GLbitfield, GLuint64)>>(p) {
        Some(fn_p) => fn_p(sync, flags, timeout),
        None => go_panic_because_fn_not_loaded("glWaitSync"),
      };
    #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
    {
      if "glWaitSync" != "glGetError" {
        report_error_as_necessary_from("glWaitSync", glGetError());
      }
    }
    out
  }
  static glWaitSync_p: APcv = ap_null();
  /// Tries to load [`glWaitSync`], returns if a non-null pointer was obtained.
  ///
  /// # Safety
  /// * This function promises to always pass a null terminated pointer to your
  ///   closure.
  #[doc(hidden)]
  pub fn glWaitSync_load_with(get_proc_address: &mut GPA) -> bool {
    let p = do_the_load(get_proc_address, b"glWaitSync\0");
    glWaitSync_p.store(p, RELAX);
    !p.is_null()
  }
  /// Checks if the pointer for [`glWaitSync`] is loaded (non-null).
  #[inline]
  #[doc(hidden)]
  pub fn glWaitSync_is_loaded() -> bool {
    !glWaitSync_p.load(RELAX).is_null()
  }
}

#[cfg(feature = "struct_loader")]
pub use struct_commands::*;
#[cfg(feature = "struct_loader")]
mod struct_commands {
  use super::*;
  impl GlFns {
    /// Constructs a new struct with all pointers loaded by the
    /// `get_proc_address` given.
    #[inline]
    pub fn load_with(get_proc_address: &mut GPA) -> Self {
      // Safety: the struct is nothing but `AtomicPtr` fields, which can be
      // safely constructed with `zeroed`.
      let out: Self = unsafe { core::mem::zeroed() };
      out.load_all_with(get_proc_address);
      out
    }

    /// Loads all pointers using the `get_proc_address` given.
    #[doc(hidden)]
    #[inline(never)]
    pub fn load_all_with(&self, get_proc_address: &mut GPA) {
      self.ActiveShaderProgram_load_with(get_proc_address);
      self.ActiveTexture_load_with(get_proc_address);
      self.AttachShader_load_with(get_proc_address);
      self.BeginConditionalRender_load_with(get_proc_address);
      self.BeginQuery_load_with(get_proc_address);
      self.BeginQueryIndexed_load_with(get_proc_address);
      self.BeginTransformFeedback_load_with(get_proc_address);
      self.BindAttribLocation_load_with(get_proc_address);
      self.BindBuffer_load_with(get_proc_address);
      self.BindBufferBase_load_with(get_proc_address);
      self.BindBufferRange_load_with(get_proc_address);
      self.BindBuffersBase_load_with(get_proc_address);
      self.BindBuffersRange_load_with(get_proc_address);
      self.BindFragDataLocation_load_with(get_proc_address);
      self.BindFragDataLocationIndexed_load_with(get_proc_address);
      self.BindFramebuffer_load_with(get_proc_address);
      self.BindImageTexture_load_with(get_proc_address);
      self.BindImageTextures_load_with(get_proc_address);
      self.BindProgramPipeline_load_with(get_proc_address);
      self.BindRenderbuffer_load_with(get_proc_address);
      self.BindSampler_load_with(get_proc_address);
      self.BindSamplers_load_with(get_proc_address);
      self.BindTexture_load_with(get_proc_address);
      self.BindTextureUnit_load_with(get_proc_address);
      self.BindTextures_load_with(get_proc_address);
      self.BindTransformFeedback_load_with(get_proc_address);
      self.BindVertexArray_load_with(get_proc_address);
      self.BindVertexBuffer_load_with(get_proc_address);
      self.BindVertexBuffers_load_with(get_proc_address);
      self.BlendColor_load_with(get_proc_address);
      self.BlendEquation_load_with(get_proc_address);
      self.BlendEquationSeparate_load_with(get_proc_address);
      self.BlendEquationSeparatei_load_with(get_proc_address);
      self.BlendEquationSeparateiARB_load_with(get_proc_address);
      self.BlendEquationi_load_with(get_proc_address);
      self.BlendEquationiARB_load_with(get_proc_address);
      self.BlendFunc_load_with(get_proc_address);
      self.BlendFuncSeparate_load_with(get_proc_address);
      self.BlendFuncSeparatei_load_with(get_proc_address);
      self.BlendFuncSeparateiARB_load_with(get_proc_address);
      self.BlendFunci_load_with(get_proc_address);
      self.BlendFunciARB_load_with(get_proc_address);
      self.BlitFramebuffer_load_with(get_proc_address);
      self.BlitNamedFramebuffer_load_with(get_proc_address);
      self.BufferData_load_with(get_proc_address);
      self.BufferStorage_load_with(get_proc_address);
      self.BufferSubData_load_with(get_proc_address);
      self.CheckFramebufferStatus_load_with(get_proc_address);
      self.CheckNamedFramebufferStatus_load_with(get_proc_address);
      self.ClampColor_load_with(get_proc_address);
      self.Clear_load_with(get_proc_address);
      self.ClearBufferData_load_with(get_proc_address);
      self.ClearBufferSubData_load_with(get_proc_address);
      self.ClearBufferfi_load_with(get_proc_address);
      self.ClearBufferfv_load_with(get_proc_address);
      self.ClearBufferiv_load_with(get_proc_address);
      self.ClearBufferuiv_load_with(get_proc_address);
      self.ClearColor_load_with(get_proc_address);
      self.ClearDepth_load_with(get_proc_address);
      self.ClearDepthf_load_with(get_proc_address);
      self.ClearNamedBufferData_load_with(get_proc_address);
      self.ClearNamedBufferSubData_load_with(get_proc_address);
      self.ClearNamedFramebufferfi_load_with(get_proc_address);
      self.ClearNamedFramebufferfv_load_with(get_proc_address);
      self.ClearNamedFramebufferiv_load_with(get_proc_address);
      self.ClearNamedFramebufferuiv_load_with(get_proc_address);
      self.ClearStencil_load_with(get_proc_address);
      self.ClearTexImage_load_with(get_proc_address);
      self.ClearTexSubImage_load_with(get_proc_address);
      self.ClientWaitSync_load_with(get_proc_address);
      self.ClipControl_load_with(get_proc_address);
      self.ColorMask_load_with(get_proc_address);
      self.ColorMaski_load_with(get_proc_address);
      self.CompileShader_load_with(get_proc_address);
      self.CompressedTexImage1D_load_with(get_proc_address);
      self.CompressedTexImage2D_load_with(get_proc_address);
      self.CompressedTexImage3D_load_with(get_proc_address);
      self.CompressedTexSubImage1D_load_with(get_proc_address);
      self.CompressedTexSubImage2D_load_with(get_proc_address);
      self.CompressedTexSubImage3D_load_with(get_proc_address);
      self.CompressedTextureSubImage1D_load_with(get_proc_address);
      self.CompressedTextureSubImage2D_load_with(get_proc_address);
      self.CompressedTextureSubImage3D_load_with(get_proc_address);
      self.CopyBufferSubData_load_with(get_proc_address);
      self.CopyImageSubData_load_with(get_proc_address);
      self.CopyNamedBufferSubData_load_with(get_proc_address);
      self.CopyTexImage1D_load_with(get_proc_address);
      self.CopyTexImage2D_load_with(get_proc_address);
      self.CopyTexSubImage1D_load_with(get_proc_address);
      self.CopyTexSubImage2D_load_with(get_proc_address);
      self.CopyTexSubImage3D_load_with(get_proc_address);
      self.CopyTextureSubImage1D_load_with(get_proc_address);
      self.CopyTextureSubImage2D_load_with(get_proc_address);
      self.CopyTextureSubImage3D_load_with(get_proc_address);
      self.CreateBuffers_load_with(get_proc_address);
      self.CreateFramebuffers_load_with(get_proc_address);
      self.CreateProgram_load_with(get_proc_address);
      self.CreateProgramPipelines_load_with(get_proc_address);
      self.CreateQueries_load_with(get_proc_address);
      self.CreateRenderbuffers_load_with(get_proc_address);
      self.CreateSamplers_load_with(get_proc_address);
      self.CreateShader_load_with(get_proc_address);
      self.CreateShaderProgramv_load_with(get_proc_address);
      self.CreateTextures_load_with(get_proc_address);
      self.CreateTransformFeedbacks_load_with(get_proc_address);
      self.CreateVertexArrays_load_with(get_proc_address);
      self.CullFace_load_with(get_proc_address);
      self.DebugMessageCallback_load_with(get_proc_address);
      self.DebugMessageControl_load_with(get_proc_address);
      self.DebugMessageInsert_load_with(get_proc_address);
      self.DeleteBuffers_load_with(get_proc_address);
      self.DeleteFramebuffers_load_with(get_proc_address);
      self.DeleteProgram_load_with(get_proc_address);
      self.DeleteProgramPipelines_load_with(get_proc_address);
      self.DeleteQueries_load_with(get_proc_address);
      self.DeleteRenderbuffers_load_with(get_proc_address);
      self.DeleteSamplers_load_with(get_proc_address);
      self.DeleteShader_load_with(get_proc_address);
      self.DeleteSync_load_with(get_proc_address);
      self.DeleteTextures_load_with(get_proc_address);
      self.DeleteTransformFeedbacks_load_with(get_proc_address);
      self.DeleteVertexArrays_load_with(get_proc_address);
      self.DepthFunc_load_with(get_proc_address);
      self.DepthMask_load_with(get_proc_address);
      self.DepthRange_load_with(get_proc_address);
      self.DepthRangeArrayv_load_with(get_proc_address);
      self.DepthRangeIndexed_load_with(get_proc_address);
      self.DepthRangef_load_with(get_proc_address);
      self.DetachShader_load_with(get_proc_address);
      self.Disable_load_with(get_proc_address);
      self.DisableVertexArrayAttrib_load_with(get_proc_address);
      self.DisableVertexAttribArray_load_with(get_proc_address);
      self.Disablei_load_with(get_proc_address);
      self.DispatchCompute_load_with(get_proc_address);
      self.DispatchComputeIndirect_load_with(get_proc_address);
      self.DrawArrays_load_with(get_proc_address);
      self.DrawArraysIndirect_load_with(get_proc_address);
      self.DrawArraysInstanced_load_with(get_proc_address);
      self.DrawArraysInstancedBaseInstance_load_with(get_proc_address);
      self.DrawBuffer_load_with(get_proc_address);
      self.DrawBuffers_load_with(get_proc_address);
      self.DrawElements_load_with(get_proc_address);
      self.DrawElementsBaseVertex_load_with(get_proc_address);
      self.DrawElementsIndirect_load_with(get_proc_address);
      self.DrawElementsInstanced_load_with(get_proc_address);
      self.DrawElementsInstancedBaseInstance_load_with(get_proc_address);
      self.DrawElementsInstancedBaseVertex_load_with(get_proc_address);
      self.DrawElementsInstancedBaseVertexBaseInstance_load_with(
        get_proc_address,
      );
      self.DrawRangeElements_load_with(get_proc_address);
      self.DrawRangeElementsBaseVertex_load_with(get_proc_address);
      self.DrawTransformFeedback_load_with(get_proc_address);
      self.DrawTransformFeedbackInstanced_load_with(get_proc_address);
      self.DrawTransformFeedbackStream_load_with(get_proc_address);
      self.DrawTransformFeedbackStreamInstanced_load_with(get_proc_address);
      self.Enable_load_with(get_proc_address);
      self.EnableVertexArrayAttrib_load_with(get_proc_address);
      self.EnableVertexAttribArray_load_with(get_proc_address);
      self.Enablei_load_with(get_proc_address);
      self.EndConditionalRender_load_with(get_proc_address);
      self.EndQuery_load_with(get_proc_address);
      self.EndQueryIndexed_load_with(get_proc_address);
      self.EndTransformFeedback_load_with(get_proc_address);
      self.FenceSync_load_with(get_proc_address);
      self.Finish_load_with(get_proc_address);
      self.Flush_load_with(get_proc_address);
      self.FlushMappedBufferRange_load_with(get_proc_address);
      self.FlushMappedNamedBufferRange_load_with(get_proc_address);
      self.FramebufferParameteri_load_with(get_proc_address);
      self.FramebufferRenderbuffer_load_with(get_proc_address);
      self.FramebufferTexture_load_with(get_proc_address);
      self.FramebufferTexture1D_load_with(get_proc_address);
      self.FramebufferTexture2D_load_with(get_proc_address);
      self.FramebufferTexture3D_load_with(get_proc_address);
      self.FramebufferTextureLayer_load_with(get_proc_address);
      self.FrontFace_load_with(get_proc_address);
      self.GenBuffers_load_with(get_proc_address);
      self.GenFramebuffers_load_with(get_proc_address);
      self.GenProgramPipelines_load_with(get_proc_address);
      self.GenQueries_load_with(get_proc_address);
      self.GenRenderbuffers_load_with(get_proc_address);
      self.GenSamplers_load_with(get_proc_address);
      self.GenTextures_load_with(get_proc_address);
      self.GenTransformFeedbacks_load_with(get_proc_address);
      self.GenVertexArrays_load_with(get_proc_address);
      self.GenerateMipmap_load_with(get_proc_address);
      self.GenerateTextureMipmap_load_with(get_proc_address);
      self.GetActiveAtomicCounterBufferiv_load_with(get_proc_address);
      self.GetActiveAttrib_load_with(get_proc_address);
      self.GetActiveSubroutineName_load_with(get_proc_address);
      self.GetActiveSubroutineUniformName_load_with(get_proc_address);
      self.GetActiveSubroutineUniformiv_load_with(get_proc_address);
      self.GetActiveUniform_load_with(get_proc_address);
      self.GetActiveUniformBlockName_load_with(get_proc_address);
      self.GetActiveUniformBlockiv_load_with(get_proc_address);
      self.GetActiveUniformName_load_with(get_proc_address);
      self.GetActiveUniformsiv_load_with(get_proc_address);
      self.GetAttachedShaders_load_with(get_proc_address);
      self.GetAttribLocation_load_with(get_proc_address);
      self.GetBooleani_v_load_with(get_proc_address);
      self.GetBooleanv_load_with(get_proc_address);
      self.GetBufferParameteri64v_load_with(get_proc_address);
      self.GetBufferParameteriv_load_with(get_proc_address);
      self.GetBufferPointerv_load_with(get_proc_address);
      self.GetBufferSubData_load_with(get_proc_address);
      self.GetCompressedTexImage_load_with(get_proc_address);
      self.GetCompressedTextureImage_load_with(get_proc_address);
      self.GetCompressedTextureSubImage_load_with(get_proc_address);
      self.GetDebugMessageLog_load_with(get_proc_address);
      self.GetDoublei_v_load_with(get_proc_address);
      self.GetDoublev_load_with(get_proc_address);
      self.GetError_load_with(get_proc_address);
      self.GetFloati_v_load_with(get_proc_address);
      self.GetFloatv_load_with(get_proc_address);
      self.GetFragDataIndex_load_with(get_proc_address);
      self.GetFragDataLocation_load_with(get_proc_address);
      self.GetFramebufferAttachmentParameteriv_load_with(get_proc_address);
      self.GetFramebufferParameteriv_load_with(get_proc_address);
      self.GetGraphicsResetStatus_load_with(get_proc_address);
      self.GetInteger64i_v_load_with(get_proc_address);
      self.GetInteger64v_load_with(get_proc_address);
      self.GetIntegeri_v_load_with(get_proc_address);
      self.GetIntegerv_load_with(get_proc_address);
      self.GetInternalformati64v_load_with(get_proc_address);
      self.GetInternalformativ_load_with(get_proc_address);
      self.GetMultisamplefv_load_with(get_proc_address);
      self.GetNamedBufferParameteri64v_load_with(get_proc_address);
      self.GetNamedBufferParameteriv_load_with(get_proc_address);
      self.GetNamedBufferPointerv_load_with(get_proc_address);
      self.GetNamedBufferSubData_load_with(get_proc_address);
      self.GetNamedFramebufferAttachmentParameteriv_load_with(get_proc_address);
      self.GetNamedFramebufferParameteriv_load_with(get_proc_address);
      self.GetNamedRenderbufferParameteriv_load_with(get_proc_address);
      self.GetObjectLabel_load_with(get_proc_address);
      self.GetObjectPtrLabel_load_with(get_proc_address);
      self.GetPointerv_load_with(get_proc_address);
      self.GetProgramBinary_load_with(get_proc_address);
      self.GetProgramInfoLog_load_with(get_proc_address);
      self.GetProgramInterfaceiv_load_with(get_proc_address);
      self.GetProgramPipelineInfoLog_load_with(get_proc_address);
      self.GetProgramPipelineiv_load_with(get_proc_address);
      self.GetProgramResourceIndex_load_with(get_proc_address);
      self.GetProgramResourceLocation_load_with(get_proc_address);
      self.GetProgramResourceLocationIndex_load_with(get_proc_address);
      self.GetProgramResourceName_load_with(get_proc_address);
      self.GetProgramResourceiv_load_with(get_proc_address);
      self.GetProgramStageiv_load_with(get_proc_address);
      self.GetProgramiv_load_with(get_proc_address);
      self.GetQueryBufferObjecti64v_load_with(get_proc_address);
      self.GetQueryBufferObjectiv_load_with(get_proc_address);
      self.GetQueryBufferObjectui64v_load_with(get_proc_address);
      self.GetQueryBufferObjectuiv_load_with(get_proc_address);
      self.GetQueryIndexediv_load_with(get_proc_address);
      self.GetQueryObjecti64v_load_with(get_proc_address);
      self.GetQueryObjectiv_load_with(get_proc_address);
      self.GetQueryObjectui64v_load_with(get_proc_address);
      self.GetQueryObjectuiv_load_with(get_proc_address);
      self.GetQueryiv_load_with(get_proc_address);
      self.GetRenderbufferParameteriv_load_with(get_proc_address);
      self.GetSamplerParameterIiv_load_with(get_proc_address);
      self.GetSamplerParameterIuiv_load_with(get_proc_address);
      self.GetSamplerParameterfv_load_with(get_proc_address);
      self.GetSamplerParameteriv_load_with(get_proc_address);
      self.GetShaderInfoLog_load_with(get_proc_address);
      self.GetShaderPrecisionFormat_load_with(get_proc_address);
      self.GetShaderSource_load_with(get_proc_address);
      self.GetShaderiv_load_with(get_proc_address);
      self.GetString_load_with(get_proc_address);
      self.GetStringi_load_with(get_proc_address);
      self.GetSubroutineIndex_load_with(get_proc_address);
      self.GetSubroutineUniformLocation_load_with(get_proc_address);
      self.GetSynciv_load_with(get_proc_address);
      self.GetTexImage_load_with(get_proc_address);
      self.GetTexLevelParameterfv_load_with(get_proc_address);
      self.GetTexLevelParameteriv_load_with(get_proc_address);
      self.GetTexParameterIiv_load_with(get_proc_address);
      self.GetTexParameterIuiv_load_with(get_proc_address);
      self.GetTexParameterfv_load_with(get_proc_address);
      self.GetTexParameteriv_load_with(get_proc_address);
      self.GetTextureImage_load_with(get_proc_address);
      self.GetTextureLevelParameterfv_load_with(get_proc_address);
      self.GetTextureLevelParameteriv_load_with(get_proc_address);
      self.GetTextureParameterIiv_load_with(get_proc_address);
      self.GetTextureParameterIuiv_load_with(get_proc_address);
      self.GetTextureParameterfv_load_with(get_proc_address);
      self.GetTextureParameteriv_load_with(get_proc_address);
      self.GetTextureSubImage_load_with(get_proc_address);
      self.GetTransformFeedbackVarying_load_with(get_proc_address);
      self.GetTransformFeedbacki64_v_load_with(get_proc_address);
      self.GetTransformFeedbacki_v_load_with(get_proc_address);
      self.GetTransformFeedbackiv_load_with(get_proc_address);
      self.GetUniformBlockIndex_load_with(get_proc_address);
      self.GetUniformIndices_load_with(get_proc_address);
      self.GetUniformLocation_load_with(get_proc_address);
      self.GetUniformSubroutineuiv_load_with(get_proc_address);
      self.GetUniformdv_load_with(get_proc_address);
      self.GetUniformfv_load_with(get_proc_address);
      self.GetUniformiv_load_with(get_proc_address);
      self.GetUniformuiv_load_with(get_proc_address);
      self.GetVertexArrayIndexed64iv_load_with(get_proc_address);
      self.GetVertexArrayIndexediv_load_with(get_proc_address);
      self.GetVertexArrayiv_load_with(get_proc_address);
      self.GetVertexAttribIiv_load_with(get_proc_address);
      self.GetVertexAttribIuiv_load_with(get_proc_address);
      self.GetVertexAttribLdv_load_with(get_proc_address);
      self.GetVertexAttribPointerv_load_with(get_proc_address);
      self.GetVertexAttribdv_load_with(get_proc_address);
      self.GetVertexAttribfv_load_with(get_proc_address);
      self.GetVertexAttribiv_load_with(get_proc_address);
      self.GetnCompressedTexImage_load_with(get_proc_address);
      self.GetnTexImage_load_with(get_proc_address);
      self.GetnUniformdv_load_with(get_proc_address);
      self.GetnUniformfv_load_with(get_proc_address);
      self.GetnUniformiv_load_with(get_proc_address);
      self.GetnUniformuiv_load_with(get_proc_address);
      self.Hint_load_with(get_proc_address);
      self.InvalidateBufferData_load_with(get_proc_address);
      self.InvalidateBufferSubData_load_with(get_proc_address);
      self.InvalidateFramebuffer_load_with(get_proc_address);
      self.InvalidateNamedFramebufferData_load_with(get_proc_address);
      self.InvalidateNamedFramebufferSubData_load_with(get_proc_address);
      self.InvalidateSubFramebuffer_load_with(get_proc_address);
      self.InvalidateTexImage_load_with(get_proc_address);
      self.InvalidateTexSubImage_load_with(get_proc_address);
      self.IsBuffer_load_with(get_proc_address);
      self.IsEnabled_load_with(get_proc_address);
      self.IsEnabledi_load_with(get_proc_address);
      self.IsFramebuffer_load_with(get_proc_address);
      self.IsProgram_load_with(get_proc_address);
      self.IsProgramPipeline_load_with(get_proc_address);
      self.IsQuery_load_with(get_proc_address);
      self.IsRenderbuffer_load_with(get_proc_address);
      self.IsSampler_load_with(get_proc_address);
      self.IsShader_load_with(get_proc_address);
      self.IsSync_load_with(get_proc_address);
      self.IsTexture_load_with(get_proc_address);
      self.IsTransformFeedback_load_with(get_proc_address);
      self.IsVertexArray_load_with(get_proc_address);
      self.LineWidth_load_with(get_proc_address);
      self.LinkProgram_load_with(get_proc_address);
      self.LogicOp_load_with(get_proc_address);
      self.MapBuffer_load_with(get_proc_address);
      self.MapBufferRange_load_with(get_proc_address);
      self.MapNamedBuffer_load_with(get_proc_address);
      self.MapNamedBufferRange_load_with(get_proc_address);
      self.MemoryBarrier_load_with(get_proc_address);
      self.MemoryBarrierByRegion_load_with(get_proc_address);
      self.MinSampleShading_load_with(get_proc_address);
      self.MultiDrawArrays_load_with(get_proc_address);
      self.MultiDrawArraysIndirect_load_with(get_proc_address);
      self.MultiDrawArraysIndirectCount_load_with(get_proc_address);
      self.MultiDrawElements_load_with(get_proc_address);
      self.MultiDrawElementsBaseVertex_load_with(get_proc_address);
      self.MultiDrawElementsIndirect_load_with(get_proc_address);
      self.MultiDrawElementsIndirectCount_load_with(get_proc_address);
      self.NamedBufferData_load_with(get_proc_address);
      self.NamedBufferStorage_load_with(get_proc_address);
      self.NamedBufferSubData_load_with(get_proc_address);
      self.NamedFramebufferDrawBuffer_load_with(get_proc_address);
      self.NamedFramebufferDrawBuffers_load_with(get_proc_address);
      self.NamedFramebufferParameteri_load_with(get_proc_address);
      self.NamedFramebufferReadBuffer_load_with(get_proc_address);
      self.NamedFramebufferRenderbuffer_load_with(get_proc_address);
      self.NamedFramebufferTexture_load_with(get_proc_address);
      self.NamedFramebufferTextureLayer_load_with(get_proc_address);
      self.NamedRenderbufferStorage_load_with(get_proc_address);
      self.NamedRenderbufferStorageMultisample_load_with(get_proc_address);
      self.ObjectLabel_load_with(get_proc_address);
      self.ObjectPtrLabel_load_with(get_proc_address);
      self.PatchParameterfv_load_with(get_proc_address);
      self.PatchParameteri_load_with(get_proc_address);
      self.PauseTransformFeedback_load_with(get_proc_address);
      self.PixelStoref_load_with(get_proc_address);
      self.PixelStorei_load_with(get_proc_address);
      self.PointParameterf_load_with(get_proc_address);
      self.PointParameterfv_load_with(get_proc_address);
      self.PointParameteri_load_with(get_proc_address);
      self.PointParameteriv_load_with(get_proc_address);
      self.PointSize_load_with(get_proc_address);
      self.PolygonMode_load_with(get_proc_address);
      self.PolygonOffset_load_with(get_proc_address);
      self.PolygonOffsetClamp_load_with(get_proc_address);
      self.PopDebugGroup_load_with(get_proc_address);
      self.PrimitiveRestartIndex_load_with(get_proc_address);
      self.ProgramBinary_load_with(get_proc_address);
      self.ProgramParameteri_load_with(get_proc_address);
      self.ProgramUniform1d_load_with(get_proc_address);
      self.ProgramUniform1dv_load_with(get_proc_address);
      self.ProgramUniform1f_load_with(get_proc_address);
      self.ProgramUniform1fv_load_with(get_proc_address);
      self.ProgramUniform1i_load_with(get_proc_address);
      self.ProgramUniform1iv_load_with(get_proc_address);
      self.ProgramUniform1ui_load_with(get_proc_address);
      self.ProgramUniform1uiv_load_with(get_proc_address);
      self.ProgramUniform2d_load_with(get_proc_address);
      self.ProgramUniform2dv_load_with(get_proc_address);
      self.ProgramUniform2f_load_with(get_proc_address);
      self.ProgramUniform2fv_load_with(get_proc_address);
      self.ProgramUniform2i_load_with(get_proc_address);
      self.ProgramUniform2iv_load_with(get_proc_address);
      self.ProgramUniform2ui_load_with(get_proc_address);
      self.ProgramUniform2uiv_load_with(get_proc_address);
      self.ProgramUniform3d_load_with(get_proc_address);
      self.ProgramUniform3dv_load_with(get_proc_address);
      self.ProgramUniform3f_load_with(get_proc_address);
      self.ProgramUniform3fv_load_with(get_proc_address);
      self.ProgramUniform3i_load_with(get_proc_address);
      self.ProgramUniform3iv_load_with(get_proc_address);
      self.ProgramUniform3ui_load_with(get_proc_address);
      self.ProgramUniform3uiv_load_with(get_proc_address);
      self.ProgramUniform4d_load_with(get_proc_address);
      self.ProgramUniform4dv_load_with(get_proc_address);
      self.ProgramUniform4f_load_with(get_proc_address);
      self.ProgramUniform4fv_load_with(get_proc_address);
      self.ProgramUniform4i_load_with(get_proc_address);
      self.ProgramUniform4iv_load_with(get_proc_address);
      self.ProgramUniform4ui_load_with(get_proc_address);
      self.ProgramUniform4uiv_load_with(get_proc_address);
      self.ProgramUniformMatrix2dv_load_with(get_proc_address);
      self.ProgramUniformMatrix2fv_load_with(get_proc_address);
      self.ProgramUniformMatrix2x3dv_load_with(get_proc_address);
      self.ProgramUniformMatrix2x3fv_load_with(get_proc_address);
      self.ProgramUniformMatrix2x4dv_load_with(get_proc_address);
      self.ProgramUniformMatrix2x4fv_load_with(get_proc_address);
      self.ProgramUniformMatrix3dv_load_with(get_proc_address);
      self.ProgramUniformMatrix3fv_load_with(get_proc_address);
      self.ProgramUniformMatrix3x2dv_load_with(get_proc_address);
      self.ProgramUniformMatrix3x2fv_load_with(get_proc_address);
      self.ProgramUniformMatrix3x4dv_load_with(get_proc_address);
      self.ProgramUniformMatrix3x4fv_load_with(get_proc_address);
      self.ProgramUniformMatrix4dv_load_with(get_proc_address);
      self.ProgramUniformMatrix4fv_load_with(get_proc_address);
      self.ProgramUniformMatrix4x2dv_load_with(get_proc_address);
      self.ProgramUniformMatrix4x2fv_load_with(get_proc_address);
      self.ProgramUniformMatrix4x3dv_load_with(get_proc_address);
      self.ProgramUniformMatrix4x3fv_load_with(get_proc_address);
      self.ProvokingVertex_load_with(get_proc_address);
      self.PushDebugGroup_load_with(get_proc_address);
      self.QueryCounter_load_with(get_proc_address);
      self.ReadBuffer_load_with(get_proc_address);
      self.ReadPixels_load_with(get_proc_address);
      self.ReadnPixels_load_with(get_proc_address);
      self.ReleaseShaderCompiler_load_with(get_proc_address);
      self.RenderbufferStorage_load_with(get_proc_address);
      self.RenderbufferStorageMultisample_load_with(get_proc_address);
      self.ResumeTransformFeedback_load_with(get_proc_address);
      self.SampleCoverage_load_with(get_proc_address);
      self.SampleMaski_load_with(get_proc_address);
      self.SamplerParameterIiv_load_with(get_proc_address);
      self.SamplerParameterIuiv_load_with(get_proc_address);
      self.SamplerParameterf_load_with(get_proc_address);
      self.SamplerParameterfv_load_with(get_proc_address);
      self.SamplerParameteri_load_with(get_proc_address);
      self.SamplerParameteriv_load_with(get_proc_address);
      self.Scissor_load_with(get_proc_address);
      self.ScissorArrayv_load_with(get_proc_address);
      self.ScissorIndexed_load_with(get_proc_address);
      self.ScissorIndexedv_load_with(get_proc_address);
      self.ShaderBinary_load_with(get_proc_address);
      self.ShaderSource_load_with(get_proc_address);
      self.ShaderStorageBlockBinding_load_with(get_proc_address);
      self.SpecializeShader_load_with(get_proc_address);
      self.StencilFunc_load_with(get_proc_address);
      self.StencilFuncSeparate_load_with(get_proc_address);
      self.StencilMask_load_with(get_proc_address);
      self.StencilMaskSeparate_load_with(get_proc_address);
      self.StencilOp_load_with(get_proc_address);
      self.StencilOpSeparate_load_with(get_proc_address);
      self.TexBuffer_load_with(get_proc_address);
      self.TexBufferRange_load_with(get_proc_address);
      self.TexImage1D_load_with(get_proc_address);
      self.TexImage2D_load_with(get_proc_address);
      self.TexImage2DMultisample_load_with(get_proc_address);
      self.TexImage3D_load_with(get_proc_address);
      self.TexImage3DMultisample_load_with(get_proc_address);
      self.TexParameterIiv_load_with(get_proc_address);
      self.TexParameterIuiv_load_with(get_proc_address);
      self.TexParameterf_load_with(get_proc_address);
      self.TexParameterfv_load_with(get_proc_address);
      self.TexParameteri_load_with(get_proc_address);
      self.TexParameteriv_load_with(get_proc_address);
      self.TexStorage1D_load_with(get_proc_address);
      self.TexStorage2D_load_with(get_proc_address);
      self.TexStorage2DMultisample_load_with(get_proc_address);
      self.TexStorage3D_load_with(get_proc_address);
      self.TexStorage3DMultisample_load_with(get_proc_address);
      self.TexSubImage1D_load_with(get_proc_address);
      self.TexSubImage2D_load_with(get_proc_address);
      self.TexSubImage3D_load_with(get_proc_address);
      self.TextureBarrier_load_with(get_proc_address);
      self.TextureBuffer_load_with(get_proc_address);
      self.TextureBufferRange_load_with(get_proc_address);
      self.TextureParameterIiv_load_with(get_proc_address);
      self.TextureParameterIuiv_load_with(get_proc_address);
      self.TextureParameterf_load_with(get_proc_address);
      self.TextureParameterfv_load_with(get_proc_address);
      self.TextureParameteri_load_with(get_proc_address);
      self.TextureParameteriv_load_with(get_proc_address);
      self.TextureStorage1D_load_with(get_proc_address);
      self.TextureStorage2D_load_with(get_proc_address);
      self.TextureStorage2DMultisample_load_with(get_proc_address);
      self.TextureStorage3D_load_with(get_proc_address);
      self.TextureStorage3DMultisample_load_with(get_proc_address);
      self.TextureSubImage1D_load_with(get_proc_address);
      self.TextureSubImage2D_load_with(get_proc_address);
      self.TextureSubImage3D_load_with(get_proc_address);
      self.TextureView_load_with(get_proc_address);
      self.TransformFeedbackBufferBase_load_with(get_proc_address);
      self.TransformFeedbackBufferRange_load_with(get_proc_address);
      self.TransformFeedbackVaryings_load_with(get_proc_address);
      self.Uniform1d_load_with(get_proc_address);
      self.Uniform1dv_load_with(get_proc_address);
      self.Uniform1f_load_with(get_proc_address);
      self.Uniform1fv_load_with(get_proc_address);
      self.Uniform1i_load_with(get_proc_address);
      self.Uniform1iv_load_with(get_proc_address);
      self.Uniform1ui_load_with(get_proc_address);
      self.Uniform1uiv_load_with(get_proc_address);
      self.Uniform2d_load_with(get_proc_address);
      self.Uniform2dv_load_with(get_proc_address);
      self.Uniform2f_load_with(get_proc_address);
      self.Uniform2fv_load_with(get_proc_address);
      self.Uniform2i_load_with(get_proc_address);
      self.Uniform2iv_load_with(get_proc_address);
      self.Uniform2ui_load_with(get_proc_address);
      self.Uniform2uiv_load_with(get_proc_address);
      self.Uniform3d_load_with(get_proc_address);
      self.Uniform3dv_load_with(get_proc_address);
      self.Uniform3f_load_with(get_proc_address);
      self.Uniform3fv_load_with(get_proc_address);
      self.Uniform3i_load_with(get_proc_address);
      self.Uniform3iv_load_with(get_proc_address);
      self.Uniform3ui_load_with(get_proc_address);
      self.Uniform3uiv_load_with(get_proc_address);
      self.Uniform4d_load_with(get_proc_address);
      self.Uniform4dv_load_with(get_proc_address);
      self.Uniform4f_load_with(get_proc_address);
      self.Uniform4fv_load_with(get_proc_address);
      self.Uniform4i_load_with(get_proc_address);
      self.Uniform4iv_load_with(get_proc_address);
      self.Uniform4ui_load_with(get_proc_address);
      self.Uniform4uiv_load_with(get_proc_address);
      self.UniformBlockBinding_load_with(get_proc_address);
      self.UniformMatrix2dv_load_with(get_proc_address);
      self.UniformMatrix2fv_load_with(get_proc_address);
      self.UniformMatrix2x3dv_load_with(get_proc_address);
      self.UniformMatrix2x3fv_load_with(get_proc_address);
      self.UniformMatrix2x4dv_load_with(get_proc_address);
      self.UniformMatrix2x4fv_load_with(get_proc_address);
      self.UniformMatrix3dv_load_with(get_proc_address);
      self.UniformMatrix3fv_load_with(get_proc_address);
      self.UniformMatrix3x2dv_load_with(get_proc_address);
      self.UniformMatrix3x2fv_load_with(get_proc_address);
      self.UniformMatrix3x4dv_load_with(get_proc_address);
      self.UniformMatrix3x4fv_load_with(get_proc_address);
      self.UniformMatrix4dv_load_with(get_proc_address);
      self.UniformMatrix4fv_load_with(get_proc_address);
      self.UniformMatrix4x2dv_load_with(get_proc_address);
      self.UniformMatrix4x2fv_load_with(get_proc_address);
      self.UniformMatrix4x3dv_load_with(get_proc_address);
      self.UniformMatrix4x3fv_load_with(get_proc_address);
      self.UniformSubroutinesuiv_load_with(get_proc_address);
      self.UnmapBuffer_load_with(get_proc_address);
      self.UnmapNamedBuffer_load_with(get_proc_address);
      self.UseProgram_load_with(get_proc_address);
      self.UseProgramStages_load_with(get_proc_address);
      self.ValidateProgram_load_with(get_proc_address);
      self.ValidateProgramPipeline_load_with(get_proc_address);
      self.VertexArrayAttribBinding_load_with(get_proc_address);
      self.VertexArrayAttribFormat_load_with(get_proc_address);
      self.VertexArrayAttribIFormat_load_with(get_proc_address);
      self.VertexArrayAttribLFormat_load_with(get_proc_address);
      self.VertexArrayBindingDivisor_load_with(get_proc_address);
      self.VertexArrayElementBuffer_load_with(get_proc_address);
      self.VertexArrayVertexBuffer_load_with(get_proc_address);
      self.VertexArrayVertexBuffers_load_with(get_proc_address);
      self.VertexAttrib1d_load_with(get_proc_address);
      self.VertexAttrib1dv_load_with(get_proc_address);
      self.VertexAttrib1f_load_with(get_proc_address);
      self.VertexAttrib1fv_load_with(get_proc_address);
      self.VertexAttrib1s_load_with(get_proc_address);
      self.VertexAttrib1sv_load_with(get_proc_address);
      self.VertexAttrib2d_load_with(get_proc_address);
      self.VertexAttrib2dv_load_with(get_proc_address);
      self.VertexAttrib2f_load_with(get_proc_address);
      self.VertexAttrib2fv_load_with(get_proc_address);
      self.VertexAttrib2s_load_with(get_proc_address);
      self.VertexAttrib2sv_load_with(get_proc_address);
      self.VertexAttrib3d_load_with(get_proc_address);
      self.VertexAttrib3dv_load_with(get_proc_address);
      self.VertexAttrib3f_load_with(get_proc_address);
      self.VertexAttrib3fv_load_with(get_proc_address);
      self.VertexAttrib3s_load_with(get_proc_address);
      self.VertexAttrib3sv_load_with(get_proc_address);
      self.VertexAttrib4Nbv_load_with(get_proc_address);
      self.VertexAttrib4Niv_load_with(get_proc_address);
      self.VertexAttrib4Nsv_load_with(get_proc_address);
      self.VertexAttrib4Nub_load_with(get_proc_address);
      self.VertexAttrib4Nubv_load_with(get_proc_address);
      self.VertexAttrib4Nuiv_load_with(get_proc_address);
      self.VertexAttrib4Nusv_load_with(get_proc_address);
      self.VertexAttrib4bv_load_with(get_proc_address);
      self.VertexAttrib4d_load_with(get_proc_address);
      self.VertexAttrib4dv_load_with(get_proc_address);
      self.VertexAttrib4f_load_with(get_proc_address);
      self.VertexAttrib4fv_load_with(get_proc_address);
      self.VertexAttrib4iv_load_with(get_proc_address);
      self.VertexAttrib4s_load_with(get_proc_address);
      self.VertexAttrib4sv_load_with(get_proc_address);
      self.VertexAttrib4ubv_load_with(get_proc_address);
      self.VertexAttrib4uiv_load_with(get_proc_address);
      self.VertexAttrib4usv_load_with(get_proc_address);
      self.VertexAttribBinding_load_with(get_proc_address);
      self.VertexAttribDivisor_load_with(get_proc_address);
      self.VertexAttribFormat_load_with(get_proc_address);
      self.VertexAttribI1i_load_with(get_proc_address);
      self.VertexAttribI1iv_load_with(get_proc_address);
      self.VertexAttribI1ui_load_with(get_proc_address);
      self.VertexAttribI1uiv_load_with(get_proc_address);
      self.VertexAttribI2i_load_with(get_proc_address);
      self.VertexAttribI2iv_load_with(get_proc_address);
      self.VertexAttribI2ui_load_with(get_proc_address);
      self.VertexAttribI2uiv_load_with(get_proc_address);
      self.VertexAttribI3i_load_with(get_proc_address);
      self.VertexAttribI3iv_load_with(get_proc_address);
      self.VertexAttribI3ui_load_with(get_proc_address);
      self.VertexAttribI3uiv_load_with(get_proc_address);
      self.VertexAttribI4bv_load_with(get_proc_address);
      self.VertexAttribI4i_load_with(get_proc_address);
      self.VertexAttribI4iv_load_with(get_proc_address);
      self.VertexAttribI4sv_load_with(get_proc_address);
      self.VertexAttribI4ubv_load_with(get_proc_address);
      self.VertexAttribI4ui_load_with(get_proc_address);
      self.VertexAttribI4uiv_load_with(get_proc_address);
      self.VertexAttribI4usv_load_with(get_proc_address);
      self.VertexAttribIFormat_load_with(get_proc_address);
      self.VertexAttribIPointer_load_with(get_proc_address);
      self.VertexAttribL1d_load_with(get_proc_address);
      self.VertexAttribL1dv_load_with(get_proc_address);
      self.VertexAttribL2d_load_with(get_proc_address);
      self.VertexAttribL2dv_load_with(get_proc_address);
      self.VertexAttribL3d_load_with(get_proc_address);
      self.VertexAttribL3dv_load_with(get_proc_address);
      self.VertexAttribL4d_load_with(get_proc_address);
      self.VertexAttribL4dv_load_with(get_proc_address);
      self.VertexAttribLFormat_load_with(get_proc_address);
      self.VertexAttribLPointer_load_with(get_proc_address);
      self.VertexAttribP1ui_load_with(get_proc_address);
      self.VertexAttribP1uiv_load_with(get_proc_address);
      self.VertexAttribP2ui_load_with(get_proc_address);
      self.VertexAttribP2uiv_load_with(get_proc_address);
      self.VertexAttribP3ui_load_with(get_proc_address);
      self.VertexAttribP3uiv_load_with(get_proc_address);
      self.VertexAttribP4ui_load_with(get_proc_address);
      self.VertexAttribP4uiv_load_with(get_proc_address);
      self.VertexAttribPointer_load_with(get_proc_address);
      self.VertexBindingDivisor_load_with(get_proc_address);
      self.Viewport_load_with(get_proc_address);
      self.ViewportArrayv_load_with(get_proc_address);
      self.ViewportIndexedf_load_with(get_proc_address);
      self.ViewportIndexedfv_load_with(get_proc_address);
      self.WaitSync_load_with(get_proc_address);
    }
    /// [glActiveShaderProgram](http://docs.gl/gl4/glActiveShaderProgram)(pipeline, program)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ActiveShaderProgram(
      &self,
      pipeline: GLuint,
      program: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ActiveShaderProgram({:?}, {:?});",
          pipeline,
          program
        );
      }
      let p = self.glActiveShaderProgram_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(pipeline, program),
        None => go_panic_because_fn_not_loaded("glActiveShaderProgram"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glActiveShaderProgram" != "glGetError" {
          report_error_as_necessary_from(
            "ActiveShaderProgram",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ActiveShaderProgram_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glActiveShaderProgram\0");
      self.glActiveShaderProgram_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ActiveShaderProgram_is_loaded(&self) -> bool {
      !self.glActiveShaderProgram_p.load(RELAX).is_null()
    }
    /// [glActiveTexture](http://docs.gl/gl4/glActiveTexture)(texture)
    /// * `texture` group: TextureUnit
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ActiveTexture(&self, texture: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ActiveTexture({:#X});", texture);
      }
      let p = self.glActiveTexture_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(texture),
        None => go_panic_because_fn_not_loaded("glActiveTexture"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glActiveTexture" != "glGetError" {
          report_error_as_necessary_from("ActiveTexture", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ActiveTexture_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glActiveTexture\0");
      self.glActiveTexture_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ActiveTexture_is_loaded(&self) -> bool {
      !self.glActiveTexture_p.load(RELAX).is_null()
    }
    /// [glAttachShader](http://docs.gl/gl4/glAttachShader)(program, shader)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn AttachShader(&self, program: GLuint, shader: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.AttachShader({:?}, {:?});", program, shader);
      }
      let p = self.glAttachShader_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(program, shader),
        None => go_panic_because_fn_not_loaded("glAttachShader"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glAttachShader" != "glGetError" {
          report_error_as_necessary_from("AttachShader", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn AttachShader_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glAttachShader\0");
      self.glAttachShader_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn AttachShader_is_loaded(&self) -> bool {
      !self.glAttachShader_p.load(RELAX).is_null()
    }
    /// [glBeginConditionalRender](http://docs.gl/gl4/glBeginConditionalRender)(id, mode)
    /// * `mode` group: ConditionalRenderMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BeginConditionalRender(&self, id: GLuint, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BeginConditionalRender({:?}, {:#X});", id, mode);
      }
      let p = self.glBeginConditionalRender_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum)>>(p) {
        Some(fn_p) => fn_p(id, mode),
        None => go_panic_because_fn_not_loaded("glBeginConditionalRender"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBeginConditionalRender" != "glGetError" {
          report_error_as_necessary_from(
            "BeginConditionalRender",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BeginConditionalRender_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBeginConditionalRender\0");
      self.glBeginConditionalRender_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BeginConditionalRender_is_loaded(&self) -> bool {
      !self.glBeginConditionalRender_p.load(RELAX).is_null()
    }
    /// [glBeginQuery](http://docs.gl/gl4/glBeginQuery)(target, id)
    /// * `target` group: QueryTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BeginQuery(&self, target: GLenum, id: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BeginQuery({:#X}, {:?});", target, id);
      }
      let p = self.glBeginQuery_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(target, id),
        None => go_panic_because_fn_not_loaded("glBeginQuery"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBeginQuery" != "glGetError" {
          report_error_as_necessary_from("BeginQuery", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BeginQuery_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBeginQuery\0");
      self.glBeginQuery_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BeginQuery_is_loaded(&self) -> bool {
      !self.glBeginQuery_p.load(RELAX).is_null()
    }
    /// [glBeginQueryIndexed](http://docs.gl/gl4/glBeginQueryIndexed)(target, index, id)
    /// * `target` group: QueryTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BeginQueryIndexed(
      &self,
      target: GLenum,
      index: GLuint,
      id: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BeginQueryIndexed({:#X}, {:?}, {:?});",
          target,
          index,
          id
        );
      }
      let p = self.glBeginQueryIndexed_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint, GLuint)>>(p)
      {
        Some(fn_p) => fn_p(target, index, id),
        None => go_panic_because_fn_not_loaded("glBeginQueryIndexed"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBeginQueryIndexed" != "glGetError" {
          report_error_as_necessary_from("BeginQueryIndexed", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BeginQueryIndexed_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBeginQueryIndexed\0");
      self.glBeginQueryIndexed_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BeginQueryIndexed_is_loaded(&self) -> bool {
      !self.glBeginQueryIndexed_p.load(RELAX).is_null()
    }
    /// [glBeginTransformFeedback](http://docs.gl/gl4/glBeginTransformFeedback)(primitiveMode)
    /// * `primitiveMode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BeginTransformFeedback(&self, primitiveMode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BeginTransformFeedback({:#X});", primitiveMode);
      }
      let p = self.glBeginTransformFeedback_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(primitiveMode),
        None => go_panic_because_fn_not_loaded("glBeginTransformFeedback"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBeginTransformFeedback" != "glGetError" {
          report_error_as_necessary_from(
            "BeginTransformFeedback",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BeginTransformFeedback_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBeginTransformFeedback\0");
      self.glBeginTransformFeedback_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BeginTransformFeedback_is_loaded(&self) -> bool {
      !self.glBeginTransformFeedback_p.load(RELAX).is_null()
    }
    /// [glBindAttribLocation](http://docs.gl/gl4/glBindAttribLocation)(program, index, name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindAttribLocation(
      &self,
      program: GLuint,
      index: GLuint,
      name: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindAttribLocation({:?}, {:?}, {:p});",
          program,
          index,
          name
        );
      }
      let p = self.glBindAttribLocation_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, *const GLchar)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, index, name),
        None => go_panic_because_fn_not_loaded("glBindAttribLocation"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindAttribLocation" != "glGetError" {
          report_error_as_necessary_from("BindAttribLocation", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindAttribLocation_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindAttribLocation\0");
      self.glBindAttribLocation_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindAttribLocation_is_loaded(&self) -> bool {
      !self.glBindAttribLocation_p.load(RELAX).is_null()
    }
    /// [glBindBuffer](http://docs.gl/gl4/glBindBuffer)(target, buffer)
    /// * `target` group: BufferTargetARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindBuffer(&self, target: GLenum, buffer: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindBuffer({:#X}, {:?});", target, buffer);
      }
      let p = self.glBindBuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(target, buffer),
        None => go_panic_because_fn_not_loaded("glBindBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindBuffer" != "glGetError" {
          report_error_as_necessary_from("BindBuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindBuffer_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBindBuffer\0");
      self.glBindBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindBuffer_is_loaded(&self) -> bool {
      !self.glBindBuffer_p.load(RELAX).is_null()
    }
    /// [glBindBufferBase](http://docs.gl/gl4/glBindBufferBase)(target, index, buffer)
    /// * `target` group: BufferTargetARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindBufferBase(
      &self,
      target: GLenum,
      index: GLuint,
      buffer: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindBufferBase({:#X}, {:?}, {:?});",
          target,
          index,
          buffer
        );
      }
      let p = self.glBindBufferBase_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint, GLuint)>>(p)
      {
        Some(fn_p) => fn_p(target, index, buffer),
        None => go_panic_because_fn_not_loaded("glBindBufferBase"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindBufferBase" != "glGetError" {
          report_error_as_necessary_from("BindBufferBase", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindBufferBase_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBindBufferBase\0");
      self.glBindBufferBase_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindBufferBase_is_loaded(&self) -> bool {
      !self.glBindBufferBase_p.load(RELAX).is_null()
    }
    /// [glBindBufferRange](http://docs.gl/gl4/glBindBufferRange)(target, index, buffer, offset, size)
    /// * `target` group: BufferTargetARB
    /// * `offset` group: BufferOffset
    /// * `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindBufferRange(
      &self,
      target: GLenum,
      index: GLuint,
      buffer: GLuint,
      offset: GLintptr,
      size: GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindBufferRange({:#X}, {:?}, {:?}, {:?}, {:?});",
          target,
          index,
          buffer,
          offset,
          size
        );
      }
      let p = self.glBindBufferRange_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLuint, GLuint, GLintptr, GLsizeiptr)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, index, buffer, offset, size),
        None => go_panic_because_fn_not_loaded("glBindBufferRange"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindBufferRange" != "glGetError" {
          report_error_as_necessary_from("BindBufferRange", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindBufferRange_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindBufferRange\0");
      self.glBindBufferRange_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindBufferRange_is_loaded(&self) -> bool {
      !self.glBindBufferRange_p.load(RELAX).is_null()
    }
    /// [glBindBuffersBase](http://docs.gl/gl4/glBindBuffersBase)(target, first, count, buffers)
    /// * `target` group: BufferTargetARB
    /// * `buffers` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindBuffersBase(
      &self,
      target: GLenum,
      first: GLuint,
      count: GLsizei,
      buffers: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindBuffersBase({:#X}, {:?}, {:?}, {:p});",
          target,
          first,
          count,
          buffers
        );
      }
      let p = self.glBindBuffersBase_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLuint, GLsizei, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, first, count, buffers),
        None => go_panic_because_fn_not_loaded("glBindBuffersBase"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindBuffersBase" != "glGetError" {
          report_error_as_necessary_from("BindBuffersBase", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindBuffersBase_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindBuffersBase\0");
      self.glBindBuffersBase_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindBuffersBase_is_loaded(&self) -> bool {
      !self.glBindBuffersBase_p.load(RELAX).is_null()
    }
    /// [glBindBuffersRange](http://docs.gl/gl4/glBindBuffersRange)(target, first, count, buffers, offsets, sizes)
    /// * `target` group: BufferTargetARB
    /// * `buffers` len: count
    /// * `offsets` len: count
    /// * `sizes` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindBuffersRange(
      &self,
      target: GLenum,
      first: GLuint,
      count: GLsizei,
      buffers: *const GLuint,
      offsets: *const GLintptr,
      sizes: *const GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindBuffersRange({:#X}, {:?}, {:?}, {:p}, {:p}, {:p});",
          target,
          first,
          count,
          buffers,
          offsets,
          sizes
        );
      }
      let p = self.glBindBuffersRange_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLuint,
            GLsizei,
            *const GLuint,
            *const GLintptr,
            *const GLsizeiptr,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(target, first, count, buffers, offsets, sizes),
        None => go_panic_because_fn_not_loaded("glBindBuffersRange"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindBuffersRange" != "glGetError" {
          report_error_as_necessary_from("BindBuffersRange", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindBuffersRange_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindBuffersRange\0");
      self.glBindBuffersRange_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindBuffersRange_is_loaded(&self) -> bool {
      !self.glBindBuffersRange_p.load(RELAX).is_null()
    }
    /// [glBindFragDataLocation](http://docs.gl/gl4/glBindFragDataLocation)(program, color, name)
    /// * `name` len: COMPSIZE(name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindFragDataLocation(
      &self,
      program: GLuint,
      color: GLuint,
      name: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindFragDataLocation({:?}, {:?}, {:p});",
          program,
          color,
          name
        );
      }
      let p = self.glBindFragDataLocation_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, *const GLchar)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, color, name),
        None => go_panic_because_fn_not_loaded("glBindFragDataLocation"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindFragDataLocation" != "glGetError" {
          report_error_as_necessary_from(
            "BindFragDataLocation",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindFragDataLocation_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindFragDataLocation\0");
      self.glBindFragDataLocation_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindFragDataLocation_is_loaded(&self) -> bool {
      !self.glBindFragDataLocation_p.load(RELAX).is_null()
    }
    /// [glBindFragDataLocationIndexed](http://docs.gl/gl4/glBindFragDataLocationIndexed)(program, colorNumber, index, name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindFragDataLocationIndexed(
      &self,
      program: GLuint,
      colorNumber: GLuint,
      index: GLuint,
      name: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindFragDataLocationIndexed({:?}, {:?}, {:?}, {:p});",
          program,
          colorNumber,
          index,
          name
        );
      }
      let p = self.glBindFragDataLocationIndexed_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLuint, *const GLchar)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, colorNumber, index, name),
        None => go_panic_because_fn_not_loaded("glBindFragDataLocationIndexed"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindFragDataLocationIndexed" != "glGetError" {
          report_error_as_necessary_from(
            "BindFragDataLocationIndexed",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindFragDataLocationIndexed_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindFragDataLocationIndexed\0");
      self.glBindFragDataLocationIndexed_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindFragDataLocationIndexed_is_loaded(&self) -> bool {
      !self.glBindFragDataLocationIndexed_p.load(RELAX).is_null()
    }
    /// [glBindFramebuffer](http://docs.gl/gl4/glBindFramebuffer)(target, framebuffer)
    /// * `target` group: FramebufferTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindFramebuffer(&self, target: GLenum, framebuffer: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindFramebuffer({:#X}, {:?});", target, framebuffer);
      }
      let p = self.glBindFramebuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(target, framebuffer),
        None => go_panic_because_fn_not_loaded("glBindFramebuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindFramebuffer" != "glGetError" {
          report_error_as_necessary_from("BindFramebuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindFramebuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindFramebuffer\0");
      self.glBindFramebuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindFramebuffer_is_loaded(&self) -> bool {
      !self.glBindFramebuffer_p.load(RELAX).is_null()
    }
    /// [glBindImageTexture](http://docs.gl/gl4/glBindImageTexture)(unit, texture, level, layered, layer, access, format)
    /// * `access` group: BufferAccessARB
    /// * `format` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindImageTexture(
      &self,
      unit: GLuint,
      texture: GLuint,
      level: GLint,
      layered: GLboolean,
      layer: GLint,
      access: GLenum,
      format: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindImageTexture({:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X});", unit, texture, level, layered, layer, access, format);
      }
      let p = self.glBindImageTexture_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLuint,
            GLint,
            GLboolean,
            GLint,
            GLenum,
            GLenum,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(unit, texture, level, layered, layer, access, format)
        }
        None => go_panic_because_fn_not_loaded("glBindImageTexture"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindImageTexture" != "glGetError" {
          report_error_as_necessary_from("BindImageTexture", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindImageTexture_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindImageTexture\0");
      self.glBindImageTexture_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindImageTexture_is_loaded(&self) -> bool {
      !self.glBindImageTexture_p.load(RELAX).is_null()
    }
    /// [glBindImageTextures](http://docs.gl/gl4/glBindImageTextures)(first, count, textures)
    /// * `textures` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindImageTextures(
      &self,
      first: GLuint,
      count: GLsizei,
      textures: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindImageTextures({:?}, {:?}, {:p});",
          first,
          count,
          textures
        );
      }
      let p = self.glBindImageTextures_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLsizei, *const GLuint)>>(p)
        {
          Some(fn_p) => fn_p(first, count, textures),
          None => go_panic_because_fn_not_loaded("glBindImageTextures"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindImageTextures" != "glGetError" {
          report_error_as_necessary_from("BindImageTextures", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindImageTextures_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindImageTextures\0");
      self.glBindImageTextures_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindImageTextures_is_loaded(&self) -> bool {
      !self.glBindImageTextures_p.load(RELAX).is_null()
    }
    /// [glBindProgramPipeline](http://docs.gl/gl4/glBindProgramPipeline)(pipeline)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindProgramPipeline(&self, pipeline: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindProgramPipeline({:?});", pipeline);
      }
      let p = self.glBindProgramPipeline_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(pipeline),
        None => go_panic_because_fn_not_loaded("glBindProgramPipeline"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindProgramPipeline" != "glGetError" {
          report_error_as_necessary_from(
            "BindProgramPipeline",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindProgramPipeline_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindProgramPipeline\0");
      self.glBindProgramPipeline_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindProgramPipeline_is_loaded(&self) -> bool {
      !self.glBindProgramPipeline_p.load(RELAX).is_null()
    }
    /// [glBindRenderbuffer](http://docs.gl/gl4/glBindRenderbuffer)(target, renderbuffer)
    /// * `target` group: RenderbufferTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindRenderbuffer(
      &self,
      target: GLenum,
      renderbuffer: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindRenderbuffer({:#X}, {:?});",
          target,
          renderbuffer
        );
      }
      let p = self.glBindRenderbuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(target, renderbuffer),
        None => go_panic_because_fn_not_loaded("glBindRenderbuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindRenderbuffer" != "glGetError" {
          report_error_as_necessary_from("BindRenderbuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindRenderbuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindRenderbuffer\0");
      self.glBindRenderbuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindRenderbuffer_is_loaded(&self) -> bool {
      !self.glBindRenderbuffer_p.load(RELAX).is_null()
    }
    /// [glBindSampler](http://docs.gl/gl4/glBindSampler)(unit, sampler)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindSampler(&self, unit: GLuint, sampler: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindSampler({:?}, {:?});", unit, sampler);
      }
      let p = self.glBindSampler_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(unit, sampler),
        None => go_panic_because_fn_not_loaded("glBindSampler"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindSampler" != "glGetError" {
          report_error_as_necessary_from("BindSampler", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindSampler_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBindSampler\0");
      self.glBindSampler_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindSampler_is_loaded(&self) -> bool {
      !self.glBindSampler_p.load(RELAX).is_null()
    }
    /// [glBindSamplers](http://docs.gl/gl4/glBindSamplers)(first, count, samplers)
    /// * `samplers` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindSamplers(
      &self,
      first: GLuint,
      count: GLsizei,
      samplers: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindSamplers({:?}, {:?}, {:p});",
          first,
          count,
          samplers
        );
      }
      let p = self.glBindSamplers_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLsizei, *const GLuint)>>(p)
        {
          Some(fn_p) => fn_p(first, count, samplers),
          None => go_panic_because_fn_not_loaded("glBindSamplers"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindSamplers" != "glGetError" {
          report_error_as_necessary_from("BindSamplers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindSamplers_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBindSamplers\0");
      self.glBindSamplers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindSamplers_is_loaded(&self) -> bool {
      !self.glBindSamplers_p.load(RELAX).is_null()
    }
    /// [glBindTexture](http://docs.gl/gl4/glBindTexture)(target, texture)
    /// * `target` group: TextureTarget
    /// * `texture` group: Texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindTexture(&self, target: GLenum, texture: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindTexture({:#X}, {:?});", target, texture);
      }
      let p = self.glBindTexture_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(target, texture),
        None => go_panic_because_fn_not_loaded("glBindTexture"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindTexture" != "glGetError" {
          report_error_as_necessary_from("BindTexture", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindTexture_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBindTexture\0");
      self.glBindTexture_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindTexture_is_loaded(&self) -> bool {
      !self.glBindTexture_p.load(RELAX).is_null()
    }
    /// [glBindTextureUnit](http://docs.gl/gl4/glBindTextureUnit)(unit, texture)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindTextureUnit(&self, unit: GLuint, texture: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindTextureUnit({:?}, {:?});", unit, texture);
      }
      let p = self.glBindTextureUnit_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(unit, texture),
        None => go_panic_because_fn_not_loaded("glBindTextureUnit"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindTextureUnit" != "glGetError" {
          report_error_as_necessary_from("BindTextureUnit", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindTextureUnit_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindTextureUnit\0");
      self.glBindTextureUnit_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindTextureUnit_is_loaded(&self) -> bool {
      !self.glBindTextureUnit_p.load(RELAX).is_null()
    }
    /// [glBindTextures](http://docs.gl/gl4/glBindTextures)(first, count, textures)
    /// * `textures` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindTextures(
      &self,
      first: GLuint,
      count: GLsizei,
      textures: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindTextures({:?}, {:?}, {:p});",
          first,
          count,
          textures
        );
      }
      let p = self.glBindTextures_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLsizei, *const GLuint)>>(p)
        {
          Some(fn_p) => fn_p(first, count, textures),
          None => go_panic_because_fn_not_loaded("glBindTextures"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindTextures" != "glGetError" {
          report_error_as_necessary_from("BindTextures", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindTextures_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBindTextures\0");
      self.glBindTextures_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindTextures_is_loaded(&self) -> bool {
      !self.glBindTextures_p.load(RELAX).is_null()
    }
    /// [glBindTransformFeedback](http://docs.gl/gl4/glBindTransformFeedback)(target, id)
    /// * `target` group: BindTransformFeedbackTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindTransformFeedback(&self, target: GLenum, id: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindTransformFeedback({:#X}, {:?});", target, id);
      }
      let p = self.glBindTransformFeedback_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(target, id),
        None => go_panic_because_fn_not_loaded("glBindTransformFeedback"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindTransformFeedback" != "glGetError" {
          report_error_as_necessary_from(
            "BindTransformFeedback",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindTransformFeedback_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindTransformFeedback\0");
      self.glBindTransformFeedback_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindTransformFeedback_is_loaded(&self) -> bool {
      !self.glBindTransformFeedback_p.load(RELAX).is_null()
    }
    /// [glBindVertexArray](http://docs.gl/gl4/glBindVertexArray)(array)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindVertexArray(&self, array: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BindVertexArray({:?});", array);
      }
      let p = self.glBindVertexArray_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(array),
        None => go_panic_because_fn_not_loaded("glBindVertexArray"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindVertexArray" != "glGetError" {
          report_error_as_necessary_from("BindVertexArray", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindVertexArray_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindVertexArray\0");
      self.glBindVertexArray_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindVertexArray_is_loaded(&self) -> bool {
      !self.glBindVertexArray_p.load(RELAX).is_null()
    }
    /// [glBindVertexBuffer](http://docs.gl/gl4/glBindVertexBuffer)(bindingindex, buffer, offset, stride)
    /// * `offset` group: BufferOffset
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindVertexBuffer(
      &self,
      bindingindex: GLuint,
      buffer: GLuint,
      offset: GLintptr,
      stride: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindVertexBuffer({:?}, {:?}, {:?}, {:?});",
          bindingindex,
          buffer,
          offset,
          stride
        );
      }
      let p = self.glBindVertexBuffer_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLintptr, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(bindingindex, buffer, offset, stride),
        None => go_panic_because_fn_not_loaded("glBindVertexBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindVertexBuffer" != "glGetError" {
          report_error_as_necessary_from("BindVertexBuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindVertexBuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindVertexBuffer\0");
      self.glBindVertexBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindVertexBuffer_is_loaded(&self) -> bool {
      !self.glBindVertexBuffer_p.load(RELAX).is_null()
    }
    /// [glBindVertexBuffers](http://docs.gl/gl4/glBindVertexBuffers)(first, count, buffers, offsets, strides)
    /// * `buffers` len: count
    /// * `offsets` len: count
    /// * `strides` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BindVertexBuffers(
      &self,
      first: GLuint,
      count: GLsizei,
      buffers: *const GLuint,
      offsets: *const GLintptr,
      strides: *const GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BindVertexBuffers({:?}, {:?}, {:p}, {:p}, {:p});",
          first,
          count,
          buffers,
          offsets,
          strides
        );
      }
      let p = self.glBindVertexBuffers_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLsizei,
            *const GLuint,
            *const GLintptr,
            *const GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(first, count, buffers, offsets, strides),
        None => go_panic_because_fn_not_loaded("glBindVertexBuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBindVertexBuffers" != "glGetError" {
          report_error_as_necessary_from("BindVertexBuffers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BindVertexBuffers_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBindVertexBuffers\0");
      self.glBindVertexBuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BindVertexBuffers_is_loaded(&self) -> bool {
      !self.glBindVertexBuffers_p.load(RELAX).is_null()
    }
    /// [glBlendColor](http://docs.gl/gl4/glBlendColor)(red, green, blue, alpha)
    /// * `red` group: ColorF
    /// * `green` group: ColorF
    /// * `blue` group: ColorF
    /// * `alpha` group: ColorF
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendColor(
      &self,
      red: GLfloat,
      green: GLfloat,
      blue: GLfloat,
      alpha: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BlendColor({:?}, {:?}, {:?}, {:?});",
          red,
          green,
          blue,
          alpha
        );
      }
      let p = self.glBlendColor_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLfloat, GLfloat, GLfloat, GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(red, green, blue, alpha),
        None => go_panic_because_fn_not_loaded("glBlendColor"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendColor" != "glGetError" {
          report_error_as_necessary_from("BlendColor", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendColor_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendColor\0");
      self.glBlendColor_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendColor_is_loaded(&self) -> bool {
      !self.glBlendColor_p.load(RELAX).is_null()
    }
    /// [glBlendEquation](http://docs.gl/gl4/glBlendEquation)(mode)
    /// * `mode` group: BlendEquationModeEXT
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendEquation(&self, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BlendEquation({:#X});", mode);
      }
      let p = self.glBlendEquation_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(mode),
        None => go_panic_because_fn_not_loaded("glBlendEquation"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendEquation" != "glGetError" {
          report_error_as_necessary_from("BlendEquation", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendEquation_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendEquation\0");
      self.glBlendEquation_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendEquation_is_loaded(&self) -> bool {
      !self.glBlendEquation_p.load(RELAX).is_null()
    }
    /// [glBlendEquationSeparate](http://docs.gl/gl4/glBlendEquationSeparate)(modeRGB, modeAlpha)
    /// * `modeRGB` group: BlendEquationModeEXT
    /// * `modeAlpha` group: BlendEquationModeEXT
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendEquationSeparate(
      &self,
      modeRGB: GLenum,
      modeAlpha: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BlendEquationSeparate({:#X}, {:#X});",
          modeRGB,
          modeAlpha
        );
      }
      let p = self.glBlendEquationSeparate_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLenum)>>(p) {
        Some(fn_p) => fn_p(modeRGB, modeAlpha),
        None => go_panic_because_fn_not_loaded("glBlendEquationSeparate"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendEquationSeparate" != "glGetError" {
          report_error_as_necessary_from(
            "BlendEquationSeparate",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendEquationSeparate_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendEquationSeparate\0");
      self.glBlendEquationSeparate_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendEquationSeparate_is_loaded(&self) -> bool {
      !self.glBlendEquationSeparate_p.load(RELAX).is_null()
    }
    /// [glBlendEquationSeparatei](http://docs.gl/gl4/glBlendEquationSeparatei)(buf, modeRGB, modeAlpha)
    /// * `modeRGB` group: BlendEquationModeEXT
    /// * `modeAlpha` group: BlendEquationModeEXT
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendEquationSeparatei(
      &self,
      buf: GLuint,
      modeRGB: GLenum,
      modeAlpha: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BlendEquationSeparatei({:?}, {:#X}, {:#X});",
          buf,
          modeRGB,
          modeAlpha
        );
      }
      let p = self.glBlendEquationSeparatei_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum)>>(p)
      {
        Some(fn_p) => fn_p(buf, modeRGB, modeAlpha),
        None => go_panic_because_fn_not_loaded("glBlendEquationSeparatei"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendEquationSeparatei" != "glGetError" {
          report_error_as_necessary_from(
            "BlendEquationSeparatei",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendEquationSeparatei_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendEquationSeparatei\0");
      self.glBlendEquationSeparatei_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendEquationSeparatei_is_loaded(&self) -> bool {
      !self.glBlendEquationSeparatei_p.load(RELAX).is_null()
    }
    /// [glBlendEquationSeparateiARB](http://docs.gl/gl4/glBlendEquationSeparateiARB)(buf, modeRGB, modeAlpha)
    /// * `modeRGB` group: BlendEquationModeEXT
    /// * `modeAlpha` group: BlendEquationModeEXT
    /// * alias of: [`glBlendEquationSeparatei`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendEquationSeparateiARB(
      &self,
      buf: GLuint,
      modeRGB: GLenum,
      modeAlpha: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BlendEquationSeparateiARB({:?}, {:#X}, {:#X});",
          buf,
          modeRGB,
          modeAlpha
        );
      }
      let p = self.glBlendEquationSeparateiARB_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum)>>(p)
      {
        Some(fn_p) => fn_p(buf, modeRGB, modeAlpha),
        None => go_panic_because_fn_not_loaded("glBlendEquationSeparateiARB"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendEquationSeparateiARB" != "glGetError" {
          report_error_as_necessary_from(
            "BlendEquationSeparateiARB",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendEquationSeparateiARB_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendEquationSeparateiARB\0");
      self.glBlendEquationSeparateiARB_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendEquationSeparateiARB_is_loaded(&self) -> bool {
      !self.glBlendEquationSeparateiARB_p.load(RELAX).is_null()
    }
    /// [glBlendEquationi](http://docs.gl/gl4/glBlendEquationi)(buf, mode)
    /// * `mode` group: BlendEquationModeEXT
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendEquationi(&self, buf: GLuint, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BlendEquationi({:?}, {:#X});", buf, mode);
      }
      let p = self.glBlendEquationi_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum)>>(p) {
        Some(fn_p) => fn_p(buf, mode),
        None => go_panic_because_fn_not_loaded("glBlendEquationi"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendEquationi" != "glGetError" {
          report_error_as_necessary_from("BlendEquationi", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendEquationi_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendEquationi\0");
      self.glBlendEquationi_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendEquationi_is_loaded(&self) -> bool {
      !self.glBlendEquationi_p.load(RELAX).is_null()
    }
    /// [glBlendEquationiARB](http://docs.gl/gl4/glBlendEquationiARB)(buf, mode)
    /// * `mode` group: BlendEquationModeEXT
    /// * alias of: [`glBlendEquationi`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendEquationiARB(&self, buf: GLuint, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BlendEquationiARB({:?}, {:#X});", buf, mode);
      }
      let p = self.glBlendEquationiARB_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum)>>(p) {
        Some(fn_p) => fn_p(buf, mode),
        None => go_panic_because_fn_not_loaded("glBlendEquationiARB"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendEquationiARB" != "glGetError" {
          report_error_as_necessary_from("BlendEquationiARB", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendEquationiARB_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendEquationiARB\0");
      self.glBlendEquationiARB_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendEquationiARB_is_loaded(&self) -> bool {
      !self.glBlendEquationiARB_p.load(RELAX).is_null()
    }
    /// [glBlendFunc](http://docs.gl/gl4/glBlendFunc)(sfactor, dfactor)
    /// * `sfactor` group: BlendingFactor
    /// * `dfactor` group: BlendingFactor
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendFunc(&self, sfactor: GLenum, dfactor: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BlendFunc({:#X}, {:#X});", sfactor, dfactor);
      }
      let p = self.glBlendFunc_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLenum)>>(p) {
        Some(fn_p) => fn_p(sfactor, dfactor),
        None => go_panic_because_fn_not_loaded("glBlendFunc"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendFunc" != "glGetError" {
          report_error_as_necessary_from("BlendFunc", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendFunc_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendFunc\0");
      self.glBlendFunc_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendFunc_is_loaded(&self) -> bool {
      !self.glBlendFunc_p.load(RELAX).is_null()
    }
    /// [glBlendFuncSeparate](http://docs.gl/gl4/glBlendFuncSeparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)
    /// * `sfactorRGB` group: BlendingFactor
    /// * `dfactorRGB` group: BlendingFactor
    /// * `sfactorAlpha` group: BlendingFactor
    /// * `dfactorAlpha` group: BlendingFactor
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendFuncSeparate(
      &self,
      sfactorRGB: GLenum,
      dfactorRGB: GLenum,
      sfactorAlpha: GLenum,
      dfactorAlpha: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BlendFuncSeparate({:#X}, {:#X}, {:#X}, {:#X});",
          sfactorRGB,
          dfactorRGB,
          sfactorAlpha,
          dfactorAlpha
        );
      }
      let p = self.glBlendFuncSeparate_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLenum, GLenum)>,
      >(p)
      {
        Some(fn_p) => fn_p(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha),
        None => go_panic_because_fn_not_loaded("glBlendFuncSeparate"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendFuncSeparate" != "glGetError" {
          report_error_as_necessary_from("BlendFuncSeparate", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendFuncSeparate_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendFuncSeparate\0");
      self.glBlendFuncSeparate_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendFuncSeparate_is_loaded(&self) -> bool {
      !self.glBlendFuncSeparate_p.load(RELAX).is_null()
    }
    /// [glBlendFuncSeparatei](http://docs.gl/gl4/glBlendFuncSeparatei)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)
    /// * `srcRGB` group: BlendingFactor
    /// * `dstRGB` group: BlendingFactor
    /// * `srcAlpha` group: BlendingFactor
    /// * `dstAlpha` group: BlendingFactor
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendFuncSeparatei(
      &self,
      buf: GLuint,
      srcRGB: GLenum,
      dstRGB: GLenum,
      srcAlpha: GLenum,
      dstAlpha: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BlendFuncSeparatei({:?}, {:#X}, {:#X}, {:#X}, {:#X});",
          buf,
          srcRGB,
          dstRGB,
          srcAlpha,
          dstAlpha
        );
      }
      let p = self.glBlendFuncSeparatei_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLenum, GLenum, GLenum)>,
      >(p)
      {
        Some(fn_p) => fn_p(buf, srcRGB, dstRGB, srcAlpha, dstAlpha),
        None => go_panic_because_fn_not_loaded("glBlendFuncSeparatei"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendFuncSeparatei" != "glGetError" {
          report_error_as_necessary_from("BlendFuncSeparatei", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendFuncSeparatei_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendFuncSeparatei\0");
      self.glBlendFuncSeparatei_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendFuncSeparatei_is_loaded(&self) -> bool {
      !self.glBlendFuncSeparatei_p.load(RELAX).is_null()
    }
    /// [glBlendFuncSeparateiARB](http://docs.gl/gl4/glBlendFuncSeparateiARB)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)
    /// * `srcRGB` group: BlendingFactor
    /// * `dstRGB` group: BlendingFactor
    /// * `srcAlpha` group: BlendingFactor
    /// * `dstAlpha` group: BlendingFactor
    /// * alias of: [`glBlendFuncSeparatei`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendFuncSeparateiARB(
      &self,
      buf: GLuint,
      srcRGB: GLenum,
      dstRGB: GLenum,
      srcAlpha: GLenum,
      dstAlpha: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BlendFuncSeparateiARB({:?}, {:#X}, {:#X}, {:#X}, {:#X});",
          buf,
          srcRGB,
          dstRGB,
          srcAlpha,
          dstAlpha
        );
      }
      let p = self.glBlendFuncSeparateiARB_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLenum, GLenum, GLenum)>,
      >(p)
      {
        Some(fn_p) => fn_p(buf, srcRGB, dstRGB, srcAlpha, dstAlpha),
        None => go_panic_because_fn_not_loaded("glBlendFuncSeparateiARB"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendFuncSeparateiARB" != "glGetError" {
          report_error_as_necessary_from(
            "BlendFuncSeparateiARB",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendFuncSeparateiARB_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendFuncSeparateiARB\0");
      self.glBlendFuncSeparateiARB_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendFuncSeparateiARB_is_loaded(&self) -> bool {
      !self.glBlendFuncSeparateiARB_p.load(RELAX).is_null()
    }
    /// [glBlendFunci](http://docs.gl/gl4/glBlendFunci)(buf, src, dst)
    /// * `src` group: BlendingFactor
    /// * `dst` group: BlendingFactor
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendFunci(&self, buf: GLuint, src: GLenum, dst: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BlendFunci({:?}, {:#X}, {:#X});", buf, src, dst);
      }
      let p = self.glBlendFunci_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum)>>(p)
      {
        Some(fn_p) => fn_p(buf, src, dst),
        None => go_panic_because_fn_not_loaded("glBlendFunci"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendFunci" != "glGetError" {
          report_error_as_necessary_from("BlendFunci", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendFunci_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendFunci\0");
      self.glBlendFunci_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendFunci_is_loaded(&self) -> bool {
      !self.glBlendFunci_p.load(RELAX).is_null()
    }
    /// [glBlendFunciARB](http://docs.gl/gl4/glBlendFunciARB)(buf, src, dst)
    /// * `src` group: BlendingFactor
    /// * `dst` group: BlendingFactor
    /// * alias of: [`glBlendFunci`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlendFunciARB(&self, buf: GLuint, src: GLenum, dst: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BlendFunciARB({:?}, {:#X}, {:#X});", buf, src, dst);
      }
      let p = self.glBlendFunciARB_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum)>>(p)
      {
        Some(fn_p) => fn_p(buf, src, dst),
        None => go_panic_because_fn_not_loaded("glBlendFunciARB"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlendFunciARB" != "glGetError" {
          report_error_as_necessary_from("BlendFunciARB", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlendFunciARB_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBlendFunciARB\0");
      self.glBlendFunciARB_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlendFunciARB_is_loaded(&self) -> bool {
      !self.glBlendFunciARB_p.load(RELAX).is_null()
    }
    /// [glBlitFramebuffer](http://docs.gl/gl4/glBlitFramebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
    /// * `mask` group: ClearBufferMask
    /// * `filter` group: BlitFramebufferFilter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlitFramebuffer(
      &self,
      srcX0: GLint,
      srcY0: GLint,
      srcX1: GLint,
      srcY1: GLint,
      dstX0: GLint,
      dstY0: GLint,
      dstX1: GLint,
      dstY1: GLint,
      mask: GLbitfield,
      filter: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BlitFramebuffer({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X});", srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
      }
      let p = self.glBlitFramebuffer_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLbitfield,
            GLenum,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter,
        ),
        None => go_panic_because_fn_not_loaded("glBlitFramebuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlitFramebuffer" != "glGetError" {
          report_error_as_necessary_from("BlitFramebuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlitFramebuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBlitFramebuffer\0");
      self.glBlitFramebuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlitFramebuffer_is_loaded(&self) -> bool {
      !self.glBlitFramebuffer_p.load(RELAX).is_null()
    }
    /// [glBlitNamedFramebuffer](http://docs.gl/gl4/glBlitNamedFramebuffer)(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
    /// * `mask` group: ClearBufferMask
    /// * `filter` group: BlitFramebufferFilter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BlitNamedFramebuffer(
      &self,
      readFramebuffer: GLuint,
      drawFramebuffer: GLuint,
      srcX0: GLint,
      srcY0: GLint,
      srcX1: GLint,
      srcY1: GLint,
      dstX0: GLint,
      dstY0: GLint,
      dstX1: GLint,
      dstY1: GLint,
      mask: GLbitfield,
      filter: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.BlitNamedFramebuffer({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X});", readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
      }
      let p = self.glBlitNamedFramebuffer_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLuint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLbitfield,
            GLenum,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          readFramebuffer,
          drawFramebuffer,
          srcX0,
          srcY0,
          srcX1,
          srcY1,
          dstX0,
          dstY0,
          dstX1,
          dstY1,
          mask,
          filter,
        ),
        None => go_panic_because_fn_not_loaded("glBlitNamedFramebuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBlitNamedFramebuffer" != "glGetError" {
          report_error_as_necessary_from(
            "BlitNamedFramebuffer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BlitNamedFramebuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glBlitNamedFramebuffer\0");
      self.glBlitNamedFramebuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BlitNamedFramebuffer_is_loaded(&self) -> bool {
      !self.glBlitNamedFramebuffer_p.load(RELAX).is_null()
    }
    /// [glBufferData](http://docs.gl/gl4/glBufferData)(target, size, data, usage)
    /// * `target` group: BufferTargetARB
    /// * `size` group: BufferSize
    /// * `data` len: size
    /// * `usage` group: BufferUsageARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BufferData(
      &self,
      target: GLenum,
      size: GLsizeiptr,
      data: *const c_void,
      usage: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BufferData({:#X}, {:?}, {:p}, {:#X});",
          target,
          size,
          data,
          usage
        );
      }
      let p = self.glBufferData_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLsizeiptr, *const c_void, GLenum)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, size, data, usage),
        None => go_panic_because_fn_not_loaded("glBufferData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBufferData" != "glGetError" {
          report_error_as_necessary_from("BufferData", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BufferData_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBufferData\0");
      self.glBufferData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BufferData_is_loaded(&self) -> bool {
      !self.glBufferData_p.load(RELAX).is_null()
    }
    /// [glBufferStorage](http://docs.gl/gl4/glBufferStorage)(target, size, data, flags)
    /// * `target` group: BufferStorageTarget
    /// * `data` len: size
    /// * `flags` group: BufferStorageMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BufferStorage(
      &self,
      target: GLenum,
      size: GLsizeiptr,
      data: *const c_void,
      flags: GLbitfield,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BufferStorage({:#X}, {:?}, {:p}, {:?});",
          target,
          size,
          data,
          flags
        );
      }
      let p = self.glBufferStorage_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLsizeiptr, *const c_void, GLbitfield)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, size, data, flags),
        None => go_panic_because_fn_not_loaded("glBufferStorage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBufferStorage" != "glGetError" {
          report_error_as_necessary_from("BufferStorage", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BufferStorage_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBufferStorage\0");
      self.glBufferStorage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BufferStorage_is_loaded(&self) -> bool {
      !self.glBufferStorage_p.load(RELAX).is_null()
    }
    /// [glBufferSubData](http://docs.gl/gl4/glBufferSubData)(target, offset, size, data)
    /// * `target` group: BufferTargetARB
    /// * `offset` group: BufferOffset
    /// * `size` group: BufferSize
    /// * `data` len: size
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn BufferSubData(
      &self,
      target: GLenum,
      offset: GLintptr,
      size: GLsizeiptr,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.BufferSubData({:#X}, {:?}, {:?}, {:p});",
          target,
          offset,
          size,
          data
        );
      }
      let p = self.glBufferSubData_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLintptr, GLsizeiptr, *const c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, offset, size, data),
        None => go_panic_because_fn_not_loaded("glBufferSubData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glBufferSubData" != "glGetError" {
          report_error_as_necessary_from("BufferSubData", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn BufferSubData_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glBufferSubData\0");
      self.glBufferSubData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn BufferSubData_is_loaded(&self) -> bool {
      !self.glBufferSubData_p.load(RELAX).is_null()
    }
    /// [glCheckFramebufferStatus](http://docs.gl/gl4/glCheckFramebufferStatus)(target)
    /// * `target` group: FramebufferTarget
    /// * return value group: FramebufferStatus
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CheckFramebufferStatus(&self, target: GLenum) -> GLenum {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CheckFramebufferStatus({:#X});", target);
      }
      let p = self.glCheckFramebufferStatus_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum) -> GLenum>>(p) {
        Some(fn_p) => fn_p(target),
        None => go_panic_because_fn_not_loaded("glCheckFramebufferStatus"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCheckFramebufferStatus" != "glGetError" {
          report_error_as_necessary_from(
            "CheckFramebufferStatus",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CheckFramebufferStatus_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCheckFramebufferStatus\0");
      self.glCheckFramebufferStatus_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CheckFramebufferStatus_is_loaded(&self) -> bool {
      !self.glCheckFramebufferStatus_p.load(RELAX).is_null()
    }
    /// [glCheckNamedFramebufferStatus](http://docs.gl/gl4/glCheckNamedFramebufferStatus)(framebuffer, target)
    /// * `target` group: FramebufferTarget
    /// * return value group: FramebufferStatus
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CheckNamedFramebufferStatus(
      &self,
      framebuffer: GLuint,
      target: GLenum,
    ) -> GLenum {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.CheckNamedFramebufferStatus({:?}, {:#X});",
          framebuffer,
          target
        );
      }
      let p = self.glCheckNamedFramebufferStatus_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum) -> GLenum>>(p) {
          Some(fn_p) => fn_p(framebuffer, target),
          None => {
            go_panic_because_fn_not_loaded("glCheckNamedFramebufferStatus")
          }
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCheckNamedFramebufferStatus" != "glGetError" {
          report_error_as_necessary_from(
            "CheckNamedFramebufferStatus",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CheckNamedFramebufferStatus_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCheckNamedFramebufferStatus\0");
      self.glCheckNamedFramebufferStatus_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CheckNamedFramebufferStatus_is_loaded(&self) -> bool {
      !self.glCheckNamedFramebufferStatus_p.load(RELAX).is_null()
    }
    /// [glClampColor](http://docs.gl/gl4/glClampColor)(target, clamp)
    /// * `target` group: ClampColorTargetARB
    /// * `clamp` group: ClampColorModeARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClampColor(&self, target: GLenum, clamp: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ClampColor({:#X}, {:#X});", target, clamp);
      }
      let p = self.glClampColor_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLenum)>>(p) {
        Some(fn_p) => fn_p(target, clamp),
        None => go_panic_because_fn_not_loaded("glClampColor"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClampColor" != "glGetError" {
          report_error_as_necessary_from("ClampColor", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClampColor_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClampColor\0");
      self.glClampColor_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClampColor_is_loaded(&self) -> bool {
      !self.glClampColor_p.load(RELAX).is_null()
    }
    /// [glClear](http://docs.gl/gl4/glClear)(mask)
    /// * `mask` group: ClearBufferMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Clear(&self, mask: GLbitfield) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Clear({:?});", mask);
      }
      let p = self.glClear_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLbitfield)>>(p) {
        Some(fn_p) => fn_p(mask),
        None => go_panic_because_fn_not_loaded("glClear"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClear" != "glGetError" {
          report_error_as_necessary_from("Clear", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Clear_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClear\0");
      self.glClear_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Clear_is_loaded(&self) -> bool {
      !self.glClear_p.load(RELAX).is_null()
    }
    /// [glClearBufferData](http://docs.gl/gl4/glClearBufferData)(target, internalformat, format, type_, data)
    /// * `target` group: BufferStorageTarget
    /// * `internalformat` group: InternalFormat
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `data` len: COMPSIZE(format,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearBufferData(
      &self,
      target: GLenum,
      internalformat: GLenum,
      format: GLenum,
      type_: GLenum,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearBufferData({:#X}, {:#X}, {:#X}, {:#X}, {:p});",
          target,
          internalformat,
          format,
          type_,
          data
        );
      }
      let p = self.glClearBufferData_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLenum, GLenum, *const c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, internalformat, format, type_, data),
        None => go_panic_because_fn_not_loaded("glClearBufferData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearBufferData" != "glGetError" {
          report_error_as_necessary_from("ClearBufferData", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearBufferData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glClearBufferData\0");
      self.glClearBufferData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearBufferData_is_loaded(&self) -> bool {
      !self.glClearBufferData_p.load(RELAX).is_null()
    }
    /// [glClearBufferSubData](http://docs.gl/gl4/glClearBufferSubData)(target, internalformat, offset, size, format, type_, data)
    /// * `target` group: BufferTargetARB
    /// * `internalformat` group: InternalFormat
    /// * `offset` group: BufferOffset
    /// * `size` group: BufferSize
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `data` len: COMPSIZE(format,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearBufferSubData(
      &self,
      target: GLenum,
      internalformat: GLenum,
      offset: GLintptr,
      size: GLsizeiptr,
      format: GLenum,
      type_: GLenum,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ClearBufferSubData({:#X}, {:#X}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, internalformat, offset, size, format, type_, data);
      }
      let p = self.glClearBufferSubData_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLenum,
            GLintptr,
            GLsizeiptr,
            GLenum,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(target, internalformat, offset, size, format, type_, data)
        }
        None => go_panic_because_fn_not_loaded("glClearBufferSubData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearBufferSubData" != "glGetError" {
          report_error_as_necessary_from("ClearBufferSubData", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearBufferSubData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glClearBufferSubData\0");
      self.glClearBufferSubData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearBufferSubData_is_loaded(&self) -> bool {
      !self.glClearBufferSubData_p.load(RELAX).is_null()
    }
    /// [glClearBufferfi](http://docs.gl/gl4/glClearBufferfi)(buffer, drawbuffer, depth, stencil)
    /// * `buffer` group: Buffer
    /// * `drawbuffer` group: DrawBufferName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearBufferfi(
      &self,
      buffer: GLenum,
      drawbuffer: GLint,
      depth: GLfloat,
      stencil: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearBufferfi({:#X}, {:?}, {:?}, {:?});",
          buffer,
          drawbuffer,
          depth,
          stencil
        );
      }
      let p = self.glClearBufferfi_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLint, GLfloat, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(buffer, drawbuffer, depth, stencil),
        None => go_panic_because_fn_not_loaded("glClearBufferfi"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearBufferfi" != "glGetError" {
          report_error_as_necessary_from("ClearBufferfi", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearBufferfi_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClearBufferfi\0");
      self.glClearBufferfi_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearBufferfi_is_loaded(&self) -> bool {
      !self.glClearBufferfi_p.load(RELAX).is_null()
    }
    /// [glClearBufferfv](http://docs.gl/gl4/glClearBufferfv)(buffer, drawbuffer, value)
    /// * `buffer` group: Buffer
    /// * `drawbuffer` group: DrawBufferName
    /// * `value` len: COMPSIZE(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearBufferfv(
      &self,
      buffer: GLenum,
      drawbuffer: GLint,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearBufferfv({:#X}, {:?}, {:p});",
          buffer,
          drawbuffer,
          value
        );
      }
      let p = self.glClearBufferfv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLint, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(buffer, drawbuffer, value),
        None => go_panic_because_fn_not_loaded("glClearBufferfv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearBufferfv" != "glGetError" {
          report_error_as_necessary_from("ClearBufferfv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearBufferfv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClearBufferfv\0");
      self.glClearBufferfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearBufferfv_is_loaded(&self) -> bool {
      !self.glClearBufferfv_p.load(RELAX).is_null()
    }
    /// [glClearBufferiv](http://docs.gl/gl4/glClearBufferiv)(buffer, drawbuffer, value)
    /// * `buffer` group: Buffer
    /// * `drawbuffer` group: DrawBufferName
    /// * `value` len: COMPSIZE(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearBufferiv(
      &self,
      buffer: GLenum,
      drawbuffer: GLint,
      value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearBufferiv({:#X}, {:?}, {:p});",
          buffer,
          drawbuffer,
          value
        );
      }
      let p = self.glClearBufferiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLint, *const GLint)>>(p) {
          Some(fn_p) => fn_p(buffer, drawbuffer, value),
          None => go_panic_because_fn_not_loaded("glClearBufferiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearBufferiv" != "glGetError" {
          report_error_as_necessary_from("ClearBufferiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearBufferiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClearBufferiv\0");
      self.glClearBufferiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearBufferiv_is_loaded(&self) -> bool {
      !self.glClearBufferiv_p.load(RELAX).is_null()
    }
    /// [glClearBufferuiv](http://docs.gl/gl4/glClearBufferuiv)(buffer, drawbuffer, value)
    /// * `buffer` group: Buffer
    /// * `drawbuffer` group: DrawBufferName
    /// * `value` len: COMPSIZE(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearBufferuiv(
      &self,
      buffer: GLenum,
      drawbuffer: GLint,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearBufferuiv({:#X}, {:?}, {:p});",
          buffer,
          drawbuffer,
          value
        );
      }
      let p = self.glClearBufferuiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLint, *const GLuint)>>(p) {
          Some(fn_p) => fn_p(buffer, drawbuffer, value),
          None => go_panic_because_fn_not_loaded("glClearBufferuiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearBufferuiv" != "glGetError" {
          report_error_as_necessary_from("ClearBufferuiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearBufferuiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClearBufferuiv\0");
      self.glClearBufferuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearBufferuiv_is_loaded(&self) -> bool {
      !self.glClearBufferuiv_p.load(RELAX).is_null()
    }
    /// [glClearColor](http://docs.gl/gl4/glClearColor)(red, green, blue, alpha)
    /// * `red` group: ColorF
    /// * `green` group: ColorF
    /// * `blue` group: ColorF
    /// * `alpha` group: ColorF
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearColor(
      &self,
      red: GLfloat,
      green: GLfloat,
      blue: GLfloat,
      alpha: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearColor({:?}, {:?}, {:?}, {:?});",
          red,
          green,
          blue,
          alpha
        );
      }
      let p = self.glClearColor_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLfloat, GLfloat, GLfloat, GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(red, green, blue, alpha),
        None => go_panic_because_fn_not_loaded("glClearColor"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearColor" != "glGetError" {
          report_error_as_necessary_from("ClearColor", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearColor_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClearColor\0");
      self.glClearColor_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearColor_is_loaded(&self) -> bool {
      !self.glClearColor_p.load(RELAX).is_null()
    }
    /// [glClearDepth](http://docs.gl/gl4/glClearDepth)(depth)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearDepth(&self, depth: GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ClearDepth({:?});", depth);
      }
      let p = self.glClearDepth_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLdouble)>>(p) {
        Some(fn_p) => fn_p(depth),
        None => go_panic_because_fn_not_loaded("glClearDepth"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearDepth" != "glGetError" {
          report_error_as_necessary_from("ClearDepth", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearDepth_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClearDepth\0");
      self.glClearDepth_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearDepth_is_loaded(&self) -> bool {
      !self.glClearDepth_p.load(RELAX).is_null()
    }
    /// [glClearDepthf](http://docs.gl/gl4/glClearDepthf)(d)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearDepthf(&self, d: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ClearDepthf({:?});", d);
      }
      let p = self.glClearDepthf_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLfloat)>>(p) {
        Some(fn_p) => fn_p(d),
        None => go_panic_because_fn_not_loaded("glClearDepthf"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearDepthf" != "glGetError" {
          report_error_as_necessary_from("ClearDepthf", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearDepthf_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClearDepthf\0");
      self.glClearDepthf_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearDepthf_is_loaded(&self) -> bool {
      !self.glClearDepthf_p.load(RELAX).is_null()
    }
    /// [glClearNamedBufferData](http://docs.gl/gl4/glClearNamedBufferData)(buffer, internalformat, format, type_, data)
    /// * `internalformat` group: InternalFormat
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearNamedBufferData(
      &self,
      buffer: GLuint,
      internalformat: GLenum,
      format: GLenum,
      type_: GLenum,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearNamedBufferData({:?}, {:#X}, {:#X}, {:#X}, {:p});",
          buffer,
          internalformat,
          format,
          type_,
          data
        );
      }
      let p = self.glClearNamedBufferData_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLenum, GLenum, *const c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(buffer, internalformat, format, type_, data),
        None => go_panic_because_fn_not_loaded("glClearNamedBufferData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearNamedBufferData" != "glGetError" {
          report_error_as_necessary_from(
            "ClearNamedBufferData",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearNamedBufferData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glClearNamedBufferData\0");
      self.glClearNamedBufferData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearNamedBufferData_is_loaded(&self) -> bool {
      !self.glClearNamedBufferData_p.load(RELAX).is_null()
    }
    /// [glClearNamedBufferSubData](http://docs.gl/gl4/glClearNamedBufferSubData)(buffer, internalformat, offset, size, format, type_, data)
    /// * `internalformat` group: InternalFormat
    /// * `size` group: BufferSize
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearNamedBufferSubData(
      &self,
      buffer: GLuint,
      internalformat: GLenum,
      offset: GLintptr,
      size: GLsizeiptr,
      format: GLenum,
      type_: GLenum,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ClearNamedBufferSubData({:?}, {:#X}, {:?}, {:?}, {:#X}, {:#X}, {:p});", buffer, internalformat, offset, size, format, type_, data);
      }
      let p = self.glClearNamedBufferSubData_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLenum,
            GLintptr,
            GLsizeiptr,
            GLenum,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(buffer, internalformat, offset, size, format, type_, data)
        }
        None => go_panic_because_fn_not_loaded("glClearNamedBufferSubData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearNamedBufferSubData" != "glGetError" {
          report_error_as_necessary_from(
            "ClearNamedBufferSubData",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearNamedBufferSubData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glClearNamedBufferSubData\0");
      self.glClearNamedBufferSubData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearNamedBufferSubData_is_loaded(&self) -> bool {
      !self.glClearNamedBufferSubData_p.load(RELAX).is_null()
    }
    /// [glClearNamedFramebufferfi](http://docs.gl/gl4/glClearNamedFramebufferfi)(framebuffer, buffer, drawbuffer, depth, stencil)
    /// * `buffer` group: Buffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearNamedFramebufferfi(
      &self,
      framebuffer: GLuint,
      buffer: GLenum,
      drawbuffer: GLint,
      depth: GLfloat,
      stencil: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearNamedFramebufferfi({:?}, {:#X}, {:?}, {:?}, {:?});",
          framebuffer,
          buffer,
          drawbuffer,
          depth,
          stencil
        );
      }
      let p = self.glClearNamedFramebufferfi_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLint, GLfloat, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(framebuffer, buffer, drawbuffer, depth, stencil),
        None => go_panic_because_fn_not_loaded("glClearNamedFramebufferfi"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearNamedFramebufferfi" != "glGetError" {
          report_error_as_necessary_from(
            "ClearNamedFramebufferfi",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearNamedFramebufferfi_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glClearNamedFramebufferfi\0");
      self.glClearNamedFramebufferfi_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearNamedFramebufferfi_is_loaded(&self) -> bool {
      !self.glClearNamedFramebufferfi_p.load(RELAX).is_null()
    }
    /// [glClearNamedFramebufferfv](http://docs.gl/gl4/glClearNamedFramebufferfv)(framebuffer, buffer, drawbuffer, value)
    /// * `buffer` group: Buffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearNamedFramebufferfv(
      &self,
      framebuffer: GLuint,
      buffer: GLenum,
      drawbuffer: GLint,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearNamedFramebufferfv({:?}, {:#X}, {:?}, {:p});",
          framebuffer,
          buffer,
          drawbuffer,
          value
        );
      }
      let p = self.glClearNamedFramebufferfv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLint, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(framebuffer, buffer, drawbuffer, value),
        None => go_panic_because_fn_not_loaded("glClearNamedFramebufferfv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearNamedFramebufferfv" != "glGetError" {
          report_error_as_necessary_from(
            "ClearNamedFramebufferfv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearNamedFramebufferfv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glClearNamedFramebufferfv\0");
      self.glClearNamedFramebufferfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearNamedFramebufferfv_is_loaded(&self) -> bool {
      !self.glClearNamedFramebufferfv_p.load(RELAX).is_null()
    }
    /// [glClearNamedFramebufferiv](http://docs.gl/gl4/glClearNamedFramebufferiv)(framebuffer, buffer, drawbuffer, value)
    /// * `buffer` group: Buffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearNamedFramebufferiv(
      &self,
      framebuffer: GLuint,
      buffer: GLenum,
      drawbuffer: GLint,
      value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearNamedFramebufferiv({:?}, {:#X}, {:?}, {:p});",
          framebuffer,
          buffer,
          drawbuffer,
          value
        );
      }
      let p = self.glClearNamedFramebufferiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLint, *const GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(framebuffer, buffer, drawbuffer, value),
        None => go_panic_because_fn_not_loaded("glClearNamedFramebufferiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearNamedFramebufferiv" != "glGetError" {
          report_error_as_necessary_from(
            "ClearNamedFramebufferiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearNamedFramebufferiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glClearNamedFramebufferiv\0");
      self.glClearNamedFramebufferiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearNamedFramebufferiv_is_loaded(&self) -> bool {
      !self.glClearNamedFramebufferiv_p.load(RELAX).is_null()
    }
    /// [glClearNamedFramebufferuiv](http://docs.gl/gl4/glClearNamedFramebufferuiv)(framebuffer, buffer, drawbuffer, value)
    /// * `buffer` group: Buffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearNamedFramebufferuiv(
      &self,
      framebuffer: GLuint,
      buffer: GLenum,
      drawbuffer: GLint,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearNamedFramebufferuiv({:?}, {:#X}, {:?}, {:p});",
          framebuffer,
          buffer,
          drawbuffer,
          value
        );
      }
      let p = self.glClearNamedFramebufferuiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLint, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(framebuffer, buffer, drawbuffer, value),
        None => go_panic_because_fn_not_loaded("glClearNamedFramebufferuiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearNamedFramebufferuiv" != "glGetError" {
          report_error_as_necessary_from(
            "ClearNamedFramebufferuiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearNamedFramebufferuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glClearNamedFramebufferuiv\0");
      self.glClearNamedFramebufferuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearNamedFramebufferuiv_is_loaded(&self) -> bool {
      !self.glClearNamedFramebufferuiv_p.load(RELAX).is_null()
    }
    /// [glClearStencil](http://docs.gl/gl4/glClearStencil)(s)
    /// * `s` group: StencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearStencil(&self, s: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ClearStencil({:?});", s);
      }
      let p = self.glClearStencil_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLint)>>(p) {
        Some(fn_p) => fn_p(s),
        None => go_panic_because_fn_not_loaded("glClearStencil"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearStencil" != "glGetError" {
          report_error_as_necessary_from("ClearStencil", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearStencil_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClearStencil\0");
      self.glClearStencil_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearStencil_is_loaded(&self) -> bool {
      !self.glClearStencil_p.load(RELAX).is_null()
    }
    /// [glClearTexImage](http://docs.gl/gl4/glClearTexImage)(texture, level, format, type_, data)
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `data` len: COMPSIZE(format,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearTexImage(
      &self,
      texture: GLuint,
      level: GLint,
      format: GLenum,
      type_: GLenum,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClearTexImage({:?}, {:?}, {:#X}, {:#X}, {:p});",
          texture,
          level,
          format,
          type_,
          data
        );
      }
      let p = self.glClearTexImage_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLenum, GLenum, *const c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(texture, level, format, type_, data),
        None => go_panic_because_fn_not_loaded("glClearTexImage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearTexImage" != "glGetError" {
          report_error_as_necessary_from("ClearTexImage", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearTexImage_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClearTexImage\0");
      self.glClearTexImage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearTexImage_is_loaded(&self) -> bool {
      !self.glClearTexImage_p.load(RELAX).is_null()
    }
    /// [glClearTexSubImage](http://docs.gl/gl4/glClearTexSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, data)
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `data` len: COMPSIZE(format,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClearTexSubImage(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      zoffset: GLint,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
      format: GLenum,
      type_: GLenum,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ClearTexSubImage({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, data);
      }
      let p = self.glClearTexSubImage_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLsizei,
            GLenum,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          texture, level, xoffset, yoffset, zoffset, width, height, depth,
          format, type_, data,
        ),
        None => go_panic_because_fn_not_loaded("glClearTexSubImage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClearTexSubImage" != "glGetError" {
          report_error_as_necessary_from("ClearTexSubImage", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClearTexSubImage_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glClearTexSubImage\0");
      self.glClearTexSubImage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClearTexSubImage_is_loaded(&self) -> bool {
      !self.glClearTexSubImage_p.load(RELAX).is_null()
    }
    /// [glClientWaitSync](http://docs.gl/gl4/glClientWaitSync)(sync, flags, timeout)
    /// * `sync` group: sync
    /// * `flags` group: SyncObjectMask
    /// * return value group: SyncStatus
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClientWaitSync(
      &self,
      sync: GLsync,
      flags: GLbitfield,
      timeout: GLuint64,
    ) -> GLenum {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ClientWaitSync({:p}, {:?}, {:?});",
          sync,
          flags,
          timeout
        );
      }
      let p = self.glClientWaitSync_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLsync, GLbitfield, GLuint64) -> GLenum>,
      >(p)
      {
        Some(fn_p) => fn_p(sync, flags, timeout),
        None => go_panic_because_fn_not_loaded("glClientWaitSync"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClientWaitSync" != "glGetError" {
          report_error_as_necessary_from("ClientWaitSync", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClientWaitSync_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClientWaitSync\0");
      self.glClientWaitSync_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClientWaitSync_is_loaded(&self) -> bool {
      !self.glClientWaitSync_p.load(RELAX).is_null()
    }
    /// [glClipControl](http://docs.gl/gl4/glClipControl)(origin, depth)
    /// * `origin` group: ClipControlOrigin
    /// * `depth` group: ClipControlDepth
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ClipControl(&self, origin: GLenum, depth: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ClipControl({:#X}, {:#X});", origin, depth);
      }
      let p = self.glClipControl_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLenum)>>(p) {
        Some(fn_p) => fn_p(origin, depth),
        None => go_panic_because_fn_not_loaded("glClipControl"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glClipControl" != "glGetError" {
          report_error_as_necessary_from("ClipControl", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ClipControl_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glClipControl\0");
      self.glClipControl_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ClipControl_is_loaded(&self) -> bool {
      !self.glClipControl_p.load(RELAX).is_null()
    }
    /// [glColorMask](http://docs.gl/gl4/glColorMask)(red, green, blue, alpha)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ColorMask(
      &self,
      red: GLboolean,
      green: GLboolean,
      blue: GLboolean,
      alpha: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ColorMask({:?}, {:?}, {:?}, {:?});",
          red,
          green,
          blue,
          alpha
        );
      }
      let p = self.glColorMask_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLboolean, GLboolean, GLboolean, GLboolean)>,
      >(p)
      {
        Some(fn_p) => fn_p(red, green, blue, alpha),
        None => go_panic_because_fn_not_loaded("glColorMask"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glColorMask" != "glGetError" {
          report_error_as_necessary_from("ColorMask", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ColorMask_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glColorMask\0");
      self.glColorMask_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ColorMask_is_loaded(&self) -> bool {
      !self.glColorMask_p.load(RELAX).is_null()
    }
    /// [glColorMaski](http://docs.gl/gl4/glColorMaski)(index, r, g, b, a)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ColorMaski(
      &self,
      index: GLuint,
      r: GLboolean,
      g: GLboolean,
      b: GLboolean,
      a: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ColorMaski({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          r,
          g,
          b,
          a
        );
      }
      let p = self.glColorMaski_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLboolean,
            GLboolean,
            GLboolean,
            GLboolean,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(index, r, g, b, a),
        None => go_panic_because_fn_not_loaded("glColorMaski"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glColorMaski" != "glGetError" {
          report_error_as_necessary_from("ColorMaski", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ColorMaski_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glColorMaski\0");
      self.glColorMaski_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ColorMaski_is_loaded(&self) -> bool {
      !self.glColorMaski_p.load(RELAX).is_null()
    }
    /// [glCompileShader](http://docs.gl/gl4/glCompileShader)(shader)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompileShader(&self, shader: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompileShader({:?});", shader);
      }
      let p = self.glCompileShader_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(shader),
        None => go_panic_because_fn_not_loaded("glCompileShader"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCompileShader" != "glGetError" {
          report_error_as_necessary_from("CompileShader", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CompileShader_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glCompileShader\0");
      self.glCompileShader_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompileShader_is_loaded(&self) -> bool {
      !self.glCompileShader_p.load(RELAX).is_null()
    }
    /// [glCompressedTexImage1D](http://docs.gl/gl4/glCompressedTexImage1D)(target, level, internalformat, width, border, imageSize, data)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `border` group: CheckedInt32
    /// * `data` group: CompressedTextureARB
    /// * `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTexImage1D(
      &self,
      target: GLenum,
      level: GLint,
      internalformat: GLenum,
      width: GLsizei,
      border: GLint,
      imageSize: GLsizei,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTexImage1D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, border, imageSize, data);
      }
      let p = self.glCompressedTexImage1D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLenum,
            GLsizei,
            GLint,
            GLsizei,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(target, level, internalformat, width, border, imageSize, data)
        }
        None => go_panic_because_fn_not_loaded("glCompressedTexImage1D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCompressedTexImage1D" != "glGetError" {
          report_error_as_necessary_from(
            "CompressedTexImage1D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CompressedTexImage1D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCompressedTexImage1D\0");
      self.glCompressedTexImage1D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTexImage1D_is_loaded(&self) -> bool {
      !self.glCompressedTexImage1D_p.load(RELAX).is_null()
    }
    /// [glCompressedTexImage2D](http://docs.gl/gl4/glCompressedTexImage2D)(target, level, internalformat, width, height, border, imageSize, data)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `border` group: CheckedInt32
    /// * `data` group: CompressedTextureARB
    /// * `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTexImage2D(
      &self,
      target: GLenum,
      level: GLint,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
      border: GLint,
      imageSize: GLsizei,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTexImage2D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, height, border, imageSize, data);
      }
      let p = self.glCompressedTexImage2D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLenum,
            GLsizei,
            GLsizei,
            GLint,
            GLsizei,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target,
          level,
          internalformat,
          width,
          height,
          border,
          imageSize,
          data,
        ),
        None => go_panic_because_fn_not_loaded("glCompressedTexImage2D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCompressedTexImage2D" != "glGetError" {
          report_error_as_necessary_from(
            "CompressedTexImage2D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CompressedTexImage2D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCompressedTexImage2D\0");
      self.glCompressedTexImage2D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTexImage2D_is_loaded(&self) -> bool {
      !self.glCompressedTexImage2D_p.load(RELAX).is_null()
    }
    /// [glCompressedTexImage3D](http://docs.gl/gl4/glCompressedTexImage3D)(target, level, internalformat, width, height, depth, border, imageSize, data)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `border` group: CheckedInt32
    /// * `data` group: CompressedTextureARB
    /// * `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTexImage3D(
      &self,
      target: GLenum,
      level: GLint,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
      border: GLint,
      imageSize: GLsizei,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTexImage3D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:p});", target, level, internalformat, width, height, depth, border, imageSize, data);
      }
      let p = self.glCompressedTexImage3D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLenum,
            GLsizei,
            GLsizei,
            GLsizei,
            GLint,
            GLsizei,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target,
          level,
          internalformat,
          width,
          height,
          depth,
          border,
          imageSize,
          data,
        ),
        None => go_panic_because_fn_not_loaded("glCompressedTexImage3D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCompressedTexImage3D" != "glGetError" {
          report_error_as_necessary_from(
            "CompressedTexImage3D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CompressedTexImage3D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCompressedTexImage3D\0");
      self.glCompressedTexImage3D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTexImage3D_is_loaded(&self) -> bool {
      !self.glCompressedTexImage3D_p.load(RELAX).is_null()
    }
    /// [glCompressedTexSubImage1D](http://docs.gl/gl4/glCompressedTexSubImage1D)(target, level, xoffset, width, format, imageSize, data)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `data` group: CompressedTextureARB
    /// * `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTexSubImage1D(
      &self,
      target: GLenum,
      level: GLint,
      xoffset: GLint,
      width: GLsizei,
      format: GLenum,
      imageSize: GLsizei,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, width, format, imageSize, data);
      }
      let p = self.glCompressedTexSubImage1D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLint,
            GLsizei,
            GLenum,
            GLsizei,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(target, level, xoffset, width, format, imageSize, data)
        }
        None => go_panic_because_fn_not_loaded("glCompressedTexSubImage1D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCompressedTexSubImage1D" != "glGetError" {
          report_error_as_necessary_from(
            "CompressedTexSubImage1D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CompressedTexSubImage1D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCompressedTexSubImage1D\0");
      self.glCompressedTexSubImage1D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTexSubImage1D_is_loaded(&self) -> bool {
      !self.glCompressedTexSubImage1D_p.load(RELAX).is_null()
    }
    /// [glCompressedTexSubImage2D](http://docs.gl/gl4/glCompressedTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, imageSize, data)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `yoffset` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `data` group: CompressedTextureARB
    /// * `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTexSubImage2D(
      &self,
      target: GLenum,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      width: GLsizei,
      height: GLsizei,
      format: GLenum,
      imageSize: GLsizei,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, yoffset, width, height, format, imageSize, data);
      }
      let p = self.glCompressedTexSubImage2D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLenum,
            GLsizei,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target, level, xoffset, yoffset, width, height, format, imageSize,
          data,
        ),
        None => go_panic_because_fn_not_loaded("glCompressedTexSubImage2D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCompressedTexSubImage2D" != "glGetError" {
          report_error_as_necessary_from(
            "CompressedTexSubImage2D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CompressedTexSubImage2D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCompressedTexSubImage2D\0");
      self.glCompressedTexSubImage2D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTexSubImage2D_is_loaded(&self) -> bool {
      !self.glCompressedTexSubImage2D_p.load(RELAX).is_null()
    }
    /// [glCompressedTexSubImage3D](http://docs.gl/gl4/glCompressedTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `yoffset` group: CheckedInt32
    /// * `zoffset` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `data` group: CompressedTextureARB
    /// * `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTexSubImage3D(
      &self,
      target: GLenum,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      zoffset: GLint,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
      format: GLenum,
      imageSize: GLsizei,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
      }
      let p = self.glCompressedTexSubImage3D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLsizei,
            GLenum,
            GLsizei,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target, level, xoffset, yoffset, zoffset, width, height, depth,
          format, imageSize, data,
        ),
        None => go_panic_because_fn_not_loaded("glCompressedTexSubImage3D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCompressedTexSubImage3D" != "glGetError" {
          report_error_as_necessary_from(
            "CompressedTexSubImage3D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CompressedTexSubImage3D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCompressedTexSubImage3D\0");
      self.glCompressedTexSubImage3D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTexSubImage3D_is_loaded(&self) -> bool {
      !self.glCompressedTexSubImage3D_p.load(RELAX).is_null()
    }
    /// [glCompressedTextureSubImage1D](http://docs.gl/gl4/glCompressedTextureSubImage1D)(texture, level, xoffset, width, format, imageSize, data)
    /// * `format` group: PixelFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTextureSubImage1D(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      width: GLsizei,
      format: GLenum,
      imageSize: GLsizei,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTextureSubImage1D({:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", texture, level, xoffset, width, format, imageSize, data);
      }
      let p = self.glCompressedTextureSubImage1D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLint,
            GLsizei,
            GLenum,
            GLsizei,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(texture, level, xoffset, width, format, imageSize, data)
        }
        None => go_panic_because_fn_not_loaded("glCompressedTextureSubImage1D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCompressedTextureSubImage1D" != "glGetError" {
          report_error_as_necessary_from(
            "CompressedTextureSubImage1D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CompressedTextureSubImage1D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCompressedTextureSubImage1D\0");
      self.glCompressedTextureSubImage1D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTextureSubImage1D_is_loaded(&self) -> bool {
      !self.glCompressedTextureSubImage1D_p.load(RELAX).is_null()
    }
    /// [glCompressedTextureSubImage2D](http://docs.gl/gl4/glCompressedTextureSubImage2D)(texture, level, xoffset, yoffset, width, height, format, imageSize, data)
    /// * `format` group: PixelFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTextureSubImage2D(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      width: GLsizei,
      height: GLsizei,
      format: GLenum,
      imageSize: GLsizei,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTextureSubImage2D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", texture, level, xoffset, yoffset, width, height, format, imageSize, data);
      }
      let p = self.glCompressedTextureSubImage2D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLenum,
            GLsizei,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          texture, level, xoffset, yoffset, width, height, format, imageSize,
          data,
        ),
        None => go_panic_because_fn_not_loaded("glCompressedTextureSubImage2D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCompressedTextureSubImage2D" != "glGetError" {
          report_error_as_necessary_from(
            "CompressedTextureSubImage2D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CompressedTextureSubImage2D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCompressedTextureSubImage2D\0");
      self.glCompressedTextureSubImage2D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTextureSubImage2D_is_loaded(&self) -> bool {
      !self.glCompressedTextureSubImage2D_p.load(RELAX).is_null()
    }
    /// [glCompressedTextureSubImage3D](http://docs.gl/gl4/glCompressedTextureSubImage3D)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)
    /// * `format` group: PixelFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CompressedTextureSubImage3D(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      zoffset: GLint,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
      format: GLenum,
      imageSize: GLsizei,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CompressedTextureSubImage3D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
      }
      let p = self.glCompressedTextureSubImage3D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLsizei,
            GLenum,
            GLsizei,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          texture, level, xoffset, yoffset, zoffset, width, height, depth,
          format, imageSize, data,
        ),
        None => go_panic_because_fn_not_loaded("glCompressedTextureSubImage3D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCompressedTextureSubImage3D" != "glGetError" {
          report_error_as_necessary_from(
            "CompressedTextureSubImage3D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CompressedTextureSubImage3D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCompressedTextureSubImage3D\0");
      self.glCompressedTextureSubImage3D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CompressedTextureSubImage3D_is_loaded(&self) -> bool {
      !self.glCompressedTextureSubImage3D_p.load(RELAX).is_null()
    }
    /// [glCopyBufferSubData](http://docs.gl/gl4/glCopyBufferSubData)(readTarget, writeTarget, readOffset, writeOffset, size)
    /// * `readTarget` group: CopyBufferSubDataTarget
    /// * `writeTarget` group: CopyBufferSubDataTarget
    /// * `readOffset` group: BufferOffset
    /// * `writeOffset` group: BufferOffset
    /// * `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyBufferSubData(
      &self,
      readTarget: GLenum,
      writeTarget: GLenum,
      readOffset: GLintptr,
      writeOffset: GLintptr,
      size: GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.CopyBufferSubData({:#X}, {:#X}, {:?}, {:?}, {:?});",
          readTarget,
          writeTarget,
          readOffset,
          writeOffset,
          size
        );
      }
      let p = self.glCopyBufferSubData_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr)>,
      >(p)
      {
        Some(fn_p) => {
          fn_p(readTarget, writeTarget, readOffset, writeOffset, size)
        }
        None => go_panic_because_fn_not_loaded("glCopyBufferSubData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCopyBufferSubData" != "glGetError" {
          report_error_as_necessary_from("CopyBufferSubData", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CopyBufferSubData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCopyBufferSubData\0");
      self.glCopyBufferSubData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyBufferSubData_is_loaded(&self) -> bool {
      !self.glCopyBufferSubData_p.load(RELAX).is_null()
    }
    /// [glCopyImageSubData](http://docs.gl/gl4/glCopyImageSubData)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)
    /// * `srcTarget` group: CopyImageSubDataTarget
    /// * `dstTarget` group: CopyImageSubDataTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyImageSubData(
      &self,
      srcName: GLuint,
      srcTarget: GLenum,
      srcLevel: GLint,
      srcX: GLint,
      srcY: GLint,
      srcZ: GLint,
      dstName: GLuint,
      dstTarget: GLenum,
      dstLevel: GLint,
      dstX: GLint,
      dstY: GLint,
      dstZ: GLint,
      srcWidth: GLsizei,
      srcHeight: GLsizei,
      srcDepth: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CopyImageSubData({:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
      }
      let p = self.glCopyImageSubData_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLenum,
            GLint,
            GLint,
            GLint,
            GLint,
            GLuint,
            GLenum,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget,
          dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth,
        ),
        None => go_panic_because_fn_not_loaded("glCopyImageSubData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCopyImageSubData" != "glGetError" {
          report_error_as_necessary_from("CopyImageSubData", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CopyImageSubData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCopyImageSubData\0");
      self.glCopyImageSubData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyImageSubData_is_loaded(&self) -> bool {
      !self.glCopyImageSubData_p.load(RELAX).is_null()
    }
    /// [glCopyNamedBufferSubData](http://docs.gl/gl4/glCopyNamedBufferSubData)(readBuffer, writeBuffer, readOffset, writeOffset, size)
    /// * `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyNamedBufferSubData(
      &self,
      readBuffer: GLuint,
      writeBuffer: GLuint,
      readOffset: GLintptr,
      writeOffset: GLintptr,
      size: GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.CopyNamedBufferSubData({:?}, {:?}, {:?}, {:?}, {:?});",
          readBuffer,
          writeBuffer,
          readOffset,
          writeOffset,
          size
        );
      }
      let p = self.glCopyNamedBufferSubData_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLintptr, GLintptr, GLsizeiptr)>,
      >(p)
      {
        Some(fn_p) => {
          fn_p(readBuffer, writeBuffer, readOffset, writeOffset, size)
        }
        None => go_panic_because_fn_not_loaded("glCopyNamedBufferSubData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCopyNamedBufferSubData" != "glGetError" {
          report_error_as_necessary_from(
            "CopyNamedBufferSubData",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CopyNamedBufferSubData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCopyNamedBufferSubData\0");
      self.glCopyNamedBufferSubData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyNamedBufferSubData_is_loaded(&self) -> bool {
      !self.glCopyNamedBufferSubData_p.load(RELAX).is_null()
    }
    /// [glCopyTexImage1D](http://docs.gl/gl4/glCopyTexImage1D)(target, level, internalformat, x, y, width, border)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    /// * `border` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTexImage1D(
      &self,
      target: GLenum,
      level: GLint,
      internalformat: GLenum,
      x: GLint,
      y: GLint,
      width: GLsizei,
      border: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CopyTexImage1D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", target, level, internalformat, x, y, width, border);
      }
      let p = self.glCopyTexImage1D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLenum,
            GLint,
            GLint,
            GLsizei,
            GLint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(target, level, internalformat, x, y, width, border),
        None => go_panic_because_fn_not_loaded("glCopyTexImage1D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCopyTexImage1D" != "glGetError" {
          report_error_as_necessary_from("CopyTexImage1D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CopyTexImage1D_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glCopyTexImage1D\0");
      self.glCopyTexImage1D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTexImage1D_is_loaded(&self) -> bool {
      !self.glCopyTexImage1D_p.load(RELAX).is_null()
    }
    /// [glCopyTexImage2D](http://docs.gl/gl4/glCopyTexImage2D)(target, level, internalformat, x, y, width, height, border)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    /// * `border` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTexImage2D(
      &self,
      target: GLenum,
      level: GLint,
      internalformat: GLenum,
      x: GLint,
      y: GLint,
      width: GLsizei,
      height: GLsizei,
      border: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CopyTexImage2D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, internalformat, x, y, width, height, border);
      }
      let p = self.glCopyTexImage2D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLenum,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(target, level, internalformat, x, y, width, height, border)
        }
        None => go_panic_because_fn_not_loaded("glCopyTexImage2D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCopyTexImage2D" != "glGetError" {
          report_error_as_necessary_from("CopyTexImage2D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CopyTexImage2D_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glCopyTexImage2D\0");
      self.glCopyTexImage2D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTexImage2D_is_loaded(&self) -> bool {
      !self.glCopyTexImage2D_p.load(RELAX).is_null()
    }
    /// [glCopyTexSubImage1D](http://docs.gl/gl4/glCopyTexSubImage1D)(target, level, xoffset, x, y, width)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTexSubImage1D(
      &self,
      target: GLenum,
      level: GLint,
      xoffset: GLint,
      x: GLint,
      y: GLint,
      width: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.CopyTexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
          target,
          level,
          xoffset,
          x,
          y,
          width
        );
      }
      let p = self.glCopyTexSubImage1D_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, level, xoffset, x, y, width),
        None => go_panic_because_fn_not_loaded("glCopyTexSubImage1D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCopyTexSubImage1D" != "glGetError" {
          report_error_as_necessary_from("CopyTexSubImage1D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CopyTexSubImage1D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCopyTexSubImage1D\0");
      self.glCopyTexSubImage1D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTexSubImage1D_is_loaded(&self) -> bool {
      !self.glCopyTexSubImage1D_p.load(RELAX).is_null()
    }
    /// [glCopyTexSubImage2D](http://docs.gl/gl4/glCopyTexSubImage2D)(target, level, xoffset, yoffset, x, y, width, height)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `yoffset` group: CheckedInt32
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTexSubImage2D(
      &self,
      target: GLenum,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      x: GLint,
      y: GLint,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CopyTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, xoffset, yoffset, x, y, width, height);
      }
      let p = self.glCopyTexSubImage2D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(target, level, xoffset, yoffset, x, y, width, height)
        }
        None => go_panic_because_fn_not_loaded("glCopyTexSubImage2D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCopyTexSubImage2D" != "glGetError" {
          report_error_as_necessary_from("CopyTexSubImage2D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CopyTexSubImage2D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCopyTexSubImage2D\0");
      self.glCopyTexSubImage2D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTexSubImage2D_is_loaded(&self) -> bool {
      !self.glCopyTexSubImage2D_p.load(RELAX).is_null()
    }
    /// [glCopyTexSubImage3D](http://docs.gl/gl4/glCopyTexSubImage3D)(target, level, xoffset, yoffset, zoffset, x, y, width, height)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `yoffset` group: CheckedInt32
    /// * `zoffset` group: CheckedInt32
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTexSubImage3D(
      &self,
      target: GLenum,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      zoffset: GLint,
      x: GLint,
      y: GLint,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CopyTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", target, level, xoffset, yoffset, zoffset, x, y, width, height);
      }
      let p = self.glCopyTexSubImage3D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(target, level, xoffset, yoffset, zoffset, x, y, width, height)
        }
        None => go_panic_because_fn_not_loaded("glCopyTexSubImage3D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCopyTexSubImage3D" != "glGetError" {
          report_error_as_necessary_from("CopyTexSubImage3D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CopyTexSubImage3D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCopyTexSubImage3D\0");
      self.glCopyTexSubImage3D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTexSubImage3D_is_loaded(&self) -> bool {
      !self.glCopyTexSubImage3D_p.load(RELAX).is_null()
    }
    /// [glCopyTextureSubImage1D](http://docs.gl/gl4/glCopyTextureSubImage1D)(texture, level, xoffset, x, y, width)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTextureSubImage1D(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      x: GLint,
      y: GLint,
      width: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CopyTextureSubImage1D({:?}, {:?}, {:?}, {:?}, {:?}, {:?});", texture, level, xoffset, x, y, width);
      }
      let p = self.glCopyTextureSubImage1D_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(texture, level, xoffset, x, y, width),
        None => go_panic_because_fn_not_loaded("glCopyTextureSubImage1D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCopyTextureSubImage1D" != "glGetError" {
          report_error_as_necessary_from(
            "CopyTextureSubImage1D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CopyTextureSubImage1D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCopyTextureSubImage1D\0");
      self.glCopyTextureSubImage1D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTextureSubImage1D_is_loaded(&self) -> bool {
      !self.glCopyTextureSubImage1D_p.load(RELAX).is_null()
    }
    /// [glCopyTextureSubImage2D](http://docs.gl/gl4/glCopyTextureSubImage2D)(texture, level, xoffset, yoffset, x, y, width, height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTextureSubImage2D(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      x: GLint,
      y: GLint,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CopyTextureSubImage2D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", texture, level, xoffset, yoffset, x, y, width, height);
      }
      let p = self.glCopyTextureSubImage2D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(texture, level, xoffset, yoffset, x, y, width, height)
        }
        None => go_panic_because_fn_not_loaded("glCopyTextureSubImage2D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCopyTextureSubImage2D" != "glGetError" {
          report_error_as_necessary_from(
            "CopyTextureSubImage2D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CopyTextureSubImage2D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCopyTextureSubImage2D\0");
      self.glCopyTextureSubImage2D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTextureSubImage2D_is_loaded(&self) -> bool {
      !self.glCopyTextureSubImage2D_p.load(RELAX).is_null()
    }
    /// [glCopyTextureSubImage3D](http://docs.gl/gl4/glCopyTextureSubImage3D)(texture, level, xoffset, yoffset, zoffset, x, y, width, height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CopyTextureSubImage3D(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      zoffset: GLint,
      x: GLint,
      y: GLint,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CopyTextureSubImage3D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", texture, level, xoffset, yoffset, zoffset, x, y, width, height);
      }
      let p = self.glCopyTextureSubImage3D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(texture, level, xoffset, yoffset, zoffset, x, y, width, height)
        }
        None => go_panic_because_fn_not_loaded("glCopyTextureSubImage3D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCopyTextureSubImage3D" != "glGetError" {
          report_error_as_necessary_from(
            "CopyTextureSubImage3D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CopyTextureSubImage3D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCopyTextureSubImage3D\0");
      self.glCopyTextureSubImage3D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CopyTextureSubImage3D_is_loaded(&self) -> bool {
      !self.glCopyTextureSubImage3D_p.load(RELAX).is_null()
    }
    /// [glCreateBuffers](http://docs.gl/gl4/glCreateBuffers)(n, buffers)
    /// * `buffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateBuffers(&self, n: GLsizei, buffers: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CreateBuffers({:?}, {:p});", n, buffers);
      }
      let p = self.glCreateBuffers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, buffers),
        None => go_panic_because_fn_not_loaded("glCreateBuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCreateBuffers" != "glGetError" {
          report_error_as_necessary_from("CreateBuffers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CreateBuffers_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glCreateBuffers\0");
      self.glCreateBuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateBuffers_is_loaded(&self) -> bool {
      !self.glCreateBuffers_p.load(RELAX).is_null()
    }
    /// [glCreateFramebuffers](http://docs.gl/gl4/glCreateFramebuffers)(n, framebuffers)
    /// * `framebuffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateFramebuffers(
      &self,
      n: GLsizei,
      framebuffers: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CreateFramebuffers({:?}, {:p});", n, framebuffers);
      }
      let p = self.glCreateFramebuffers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, framebuffers),
        None => go_panic_because_fn_not_loaded("glCreateFramebuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCreateFramebuffers" != "glGetError" {
          report_error_as_necessary_from("CreateFramebuffers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CreateFramebuffers_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCreateFramebuffers\0");
      self.glCreateFramebuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateFramebuffers_is_loaded(&self) -> bool {
      !self.glCreateFramebuffers_p.load(RELAX).is_null()
    }
    /// [glCreateProgram](http://docs.gl/gl4/glCreateProgram)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateProgram(&self) -> GLuint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CreateProgram();",);
      }
      let p = self.glCreateProgram_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn() -> GLuint>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded("glCreateProgram"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCreateProgram" != "glGetError" {
          report_error_as_necessary_from("CreateProgram", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CreateProgram_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glCreateProgram\0");
      self.glCreateProgram_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateProgram_is_loaded(&self) -> bool {
      !self.glCreateProgram_p.load(RELAX).is_null()
    }
    /// [glCreateProgramPipelines](http://docs.gl/gl4/glCreateProgramPipelines)(n, pipelines)
    /// * `pipelines` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateProgramPipelines(
      &self,
      n: GLsizei,
      pipelines: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CreateProgramPipelines({:?}, {:p});", n, pipelines);
      }
      let p = self.glCreateProgramPipelines_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, pipelines),
        None => go_panic_because_fn_not_loaded("glCreateProgramPipelines"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCreateProgramPipelines" != "glGetError" {
          report_error_as_necessary_from(
            "CreateProgramPipelines",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CreateProgramPipelines_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCreateProgramPipelines\0");
      self.glCreateProgramPipelines_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateProgramPipelines_is_loaded(&self) -> bool {
      !self.glCreateProgramPipelines_p.load(RELAX).is_null()
    }
    /// [glCreateQueries](http://docs.gl/gl4/glCreateQueries)(target, n, ids)
    /// * `target` group: QueryTarget
    /// * `ids` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateQueries(
      &self,
      target: GLenum,
      n: GLsizei,
      ids: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CreateQueries({:#X}, {:?}, {:p});", target, n, ids);
      }
      let p = self.glCreateQueries_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLsizei, *mut GLuint)>>(p) {
          Some(fn_p) => fn_p(target, n, ids),
          None => go_panic_because_fn_not_loaded("glCreateQueries"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCreateQueries" != "glGetError" {
          report_error_as_necessary_from("CreateQueries", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CreateQueries_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glCreateQueries\0");
      self.glCreateQueries_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateQueries_is_loaded(&self) -> bool {
      !self.glCreateQueries_p.load(RELAX).is_null()
    }
    /// [glCreateRenderbuffers](http://docs.gl/gl4/glCreateRenderbuffers)(n, renderbuffers)
    /// * `renderbuffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateRenderbuffers(
      &self,
      n: GLsizei,
      renderbuffers: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CreateRenderbuffers({:?}, {:p});", n, renderbuffers);
      }
      let p = self.glCreateRenderbuffers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, renderbuffers),
        None => go_panic_because_fn_not_loaded("glCreateRenderbuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCreateRenderbuffers" != "glGetError" {
          report_error_as_necessary_from(
            "CreateRenderbuffers",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CreateRenderbuffers_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCreateRenderbuffers\0");
      self.glCreateRenderbuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateRenderbuffers_is_loaded(&self) -> bool {
      !self.glCreateRenderbuffers_p.load(RELAX).is_null()
    }
    /// [glCreateSamplers](http://docs.gl/gl4/glCreateSamplers)(n, samplers)
    /// * `samplers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateSamplers(&self, n: GLsizei, samplers: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CreateSamplers({:?}, {:p});", n, samplers);
      }
      let p = self.glCreateSamplers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, samplers),
        None => go_panic_because_fn_not_loaded("glCreateSamplers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCreateSamplers" != "glGetError" {
          report_error_as_necessary_from("CreateSamplers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CreateSamplers_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glCreateSamplers\0");
      self.glCreateSamplers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateSamplers_is_loaded(&self) -> bool {
      !self.glCreateSamplers_p.load(RELAX).is_null()
    }
    /// [glCreateShader](http://docs.gl/gl4/glCreateShader)(type_)
    /// * `type_` group: ShaderType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateShader(&self, type_: GLenum) -> GLuint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CreateShader({:#X});", type_);
      }
      let p = self.glCreateShader_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum) -> GLuint>>(p) {
        Some(fn_p) => fn_p(type_),
        None => go_panic_because_fn_not_loaded("glCreateShader"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCreateShader" != "glGetError" {
          report_error_as_necessary_from("CreateShader", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CreateShader_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glCreateShader\0");
      self.glCreateShader_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateShader_is_loaded(&self) -> bool {
      !self.glCreateShader_p.load(RELAX).is_null()
    }
    /// [glCreateShaderProgramv](http://docs.gl/gl4/glCreateShaderProgramv)(type_, count, strings)
    /// * `type_` group: ShaderType
    /// * `strings` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateShaderProgramv(
      &self,
      type_: GLenum,
      count: GLsizei,
      strings: *const *const GLchar,
    ) -> GLuint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.CreateShaderProgramv({:#X}, {:?}, {:p});",
          type_,
          count,
          strings
        );
      }
      let p = self.glCreateShaderProgramv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLsizei, *const *const GLchar) -> GLuint>,
      >(p)
      {
        Some(fn_p) => fn_p(type_, count, strings),
        None => go_panic_because_fn_not_loaded("glCreateShaderProgramv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCreateShaderProgramv" != "glGetError" {
          report_error_as_necessary_from(
            "CreateShaderProgramv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CreateShaderProgramv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCreateShaderProgramv\0");
      self.glCreateShaderProgramv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateShaderProgramv_is_loaded(&self) -> bool {
      !self.glCreateShaderProgramv_p.load(RELAX).is_null()
    }
    /// [glCreateTextures](http://docs.gl/gl4/glCreateTextures)(target, n, textures)
    /// * `target` group: TextureTarget
    /// * `textures` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateTextures(
      &self,
      target: GLenum,
      n: GLsizei,
      textures: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.CreateTextures({:#X}, {:?}, {:p});",
          target,
          n,
          textures
        );
      }
      let p = self.glCreateTextures_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLsizei, *mut GLuint)>>(p) {
          Some(fn_p) => fn_p(target, n, textures),
          None => go_panic_because_fn_not_loaded("glCreateTextures"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCreateTextures" != "glGetError" {
          report_error_as_necessary_from("CreateTextures", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CreateTextures_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glCreateTextures\0");
      self.glCreateTextures_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateTextures_is_loaded(&self) -> bool {
      !self.glCreateTextures_p.load(RELAX).is_null()
    }
    /// [glCreateTransformFeedbacks](http://docs.gl/gl4/glCreateTransformFeedbacks)(n, ids)
    /// * `ids` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateTransformFeedbacks(
      &self,
      n: GLsizei,
      ids: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CreateTransformFeedbacks({:?}, {:p});", n, ids);
      }
      let p = self.glCreateTransformFeedbacks_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, ids),
        None => go_panic_because_fn_not_loaded("glCreateTransformFeedbacks"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCreateTransformFeedbacks" != "glGetError" {
          report_error_as_necessary_from(
            "CreateTransformFeedbacks",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CreateTransformFeedbacks_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCreateTransformFeedbacks\0");
      self.glCreateTransformFeedbacks_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateTransformFeedbacks_is_loaded(&self) -> bool {
      !self.glCreateTransformFeedbacks_p.load(RELAX).is_null()
    }
    /// [glCreateVertexArrays](http://docs.gl/gl4/glCreateVertexArrays)(n, arrays)
    /// * `arrays` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CreateVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CreateVertexArrays({:?}, {:p});", n, arrays);
      }
      let p = self.glCreateVertexArrays_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, arrays),
        None => go_panic_because_fn_not_loaded("glCreateVertexArrays"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCreateVertexArrays" != "glGetError" {
          report_error_as_necessary_from("CreateVertexArrays", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CreateVertexArrays_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glCreateVertexArrays\0");
      self.glCreateVertexArrays_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CreateVertexArrays_is_loaded(&self) -> bool {
      !self.glCreateVertexArrays_p.load(RELAX).is_null()
    }
    /// [glCullFace](http://docs.gl/gl4/glCullFace)(mode)
    /// * `mode` group: CullFaceMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn CullFace(&self, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.CullFace({:#X});", mode);
      }
      let p = self.glCullFace_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(mode),
        None => go_panic_because_fn_not_loaded("glCullFace"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glCullFace" != "glGetError" {
          report_error_as_necessary_from("CullFace", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn CullFace_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glCullFace\0");
      self.glCullFace_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn CullFace_is_loaded(&self) -> bool {
      !self.glCullFace_p.load(RELAX).is_null()
    }
    /// [glDebugMessageCallback](http://docs.gl/gl4/glDebugMessageCallback)(callback, userParam)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DebugMessageCallback(
      &self,
      callback: GLDEBUGPROC,
      userParam: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DebugMessageCallback({:?}, {:p});",
          t_::<_, O<fn()>>(callback),
          userParam
        );
      }
      let p = self.glDebugMessageCallback_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLDEBUGPROC, *const c_void)>>(p) {
          Some(fn_p) => fn_p(callback, userParam),
          None => go_panic_because_fn_not_loaded("glDebugMessageCallback"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDebugMessageCallback" != "glGetError" {
          report_error_as_necessary_from(
            "DebugMessageCallback",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DebugMessageCallback_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDebugMessageCallback\0");
      self.glDebugMessageCallback_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DebugMessageCallback_is_loaded(&self) -> bool {
      !self.glDebugMessageCallback_p.load(RELAX).is_null()
    }
    /// [glDebugMessageControl](http://docs.gl/gl4/glDebugMessageControl)(source, type_, severity, count, ids, enabled)
    /// * `source` group: DebugSource
    /// * `type_` group: DebugType
    /// * `severity` group: DebugSeverity
    /// * `ids` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DebugMessageControl(
      &self,
      source: GLenum,
      type_: GLenum,
      severity: GLenum,
      count: GLsizei,
      ids: *const GLuint,
      enabled: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DebugMessageControl({:#X}, {:#X}, {:#X}, {:?}, {:p}, {:?});", source, type_, severity, count, ids, enabled);
      }
      let p = self.glDebugMessageControl_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLenum,
            GLenum,
            GLsizei,
            *const GLuint,
            GLboolean,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(source, type_, severity, count, ids, enabled),
        None => go_panic_because_fn_not_loaded("glDebugMessageControl"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDebugMessageControl" != "glGetError" {
          report_error_as_necessary_from(
            "DebugMessageControl",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DebugMessageControl_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDebugMessageControl\0");
      self.glDebugMessageControl_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DebugMessageControl_is_loaded(&self) -> bool {
      !self.glDebugMessageControl_p.load(RELAX).is_null()
    }
    /// [glDebugMessageInsert](http://docs.gl/gl4/glDebugMessageInsert)(source, type_, id, severity, length, buf)
    /// * `source` group: DebugSource
    /// * `type_` group: DebugType
    /// * `severity` group: DebugSeverity
    /// * `buf` len: COMPSIZE(buf,length)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DebugMessageInsert(
      &self,
      source: GLenum,
      type_: GLenum,
      id: GLuint,
      severity: GLenum,
      length: GLsizei,
      buf: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DebugMessageInsert({:#X}, {:#X}, {:?}, {:#X}, {:?}, {:p});", source, type_, id, severity, length, buf);
      }
      let p = self.glDebugMessageInsert_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLenum,
            GLuint,
            GLenum,
            GLsizei,
            *const GLchar,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(source, type_, id, severity, length, buf),
        None => go_panic_because_fn_not_loaded("glDebugMessageInsert"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDebugMessageInsert" != "glGetError" {
          report_error_as_necessary_from("DebugMessageInsert", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DebugMessageInsert_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDebugMessageInsert\0");
      self.glDebugMessageInsert_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DebugMessageInsert_is_loaded(&self) -> bool {
      !self.glDebugMessageInsert_p.load(RELAX).is_null()
    }
    /// [glDeleteBuffers](http://docs.gl/gl4/glDeleteBuffers)(n, buffers)
    /// * `buffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteBuffers(&self, n: GLsizei, buffers: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteBuffers({:?}, {:p});", n, buffers);
      }
      let p = self.glDeleteBuffers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p)
      {
        Some(fn_p) => fn_p(n, buffers),
        None => go_panic_because_fn_not_loaded("glDeleteBuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDeleteBuffers" != "glGetError" {
          report_error_as_necessary_from("DeleteBuffers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DeleteBuffers_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDeleteBuffers\0");
      self.glDeleteBuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteBuffers_is_loaded(&self) -> bool {
      !self.glDeleteBuffers_p.load(RELAX).is_null()
    }
    /// [glDeleteFramebuffers](http://docs.gl/gl4/glDeleteFramebuffers)(n, framebuffers)
    /// * `framebuffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteFramebuffers(
      &self,
      n: GLsizei,
      framebuffers: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteFramebuffers({:?}, {:p});", n, framebuffers);
      }
      let p = self.glDeleteFramebuffers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p)
      {
        Some(fn_p) => fn_p(n, framebuffers),
        None => go_panic_because_fn_not_loaded("glDeleteFramebuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDeleteFramebuffers" != "glGetError" {
          report_error_as_necessary_from("DeleteFramebuffers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DeleteFramebuffers_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDeleteFramebuffers\0");
      self.glDeleteFramebuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteFramebuffers_is_loaded(&self) -> bool {
      !self.glDeleteFramebuffers_p.load(RELAX).is_null()
    }
    /// [glDeleteProgram](http://docs.gl/gl4/glDeleteProgram)(program)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteProgram(&self, program: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteProgram({:?});", program);
      }
      let p = self.glDeleteProgram_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(program),
        None => go_panic_because_fn_not_loaded("glDeleteProgram"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDeleteProgram" != "glGetError" {
          report_error_as_necessary_from("DeleteProgram", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DeleteProgram_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDeleteProgram\0");
      self.glDeleteProgram_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteProgram_is_loaded(&self) -> bool {
      !self.glDeleteProgram_p.load(RELAX).is_null()
    }
    /// [glDeleteProgramPipelines](http://docs.gl/gl4/glDeleteProgramPipelines)(n, pipelines)
    /// * `pipelines` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteProgramPipelines(
      &self,
      n: GLsizei,
      pipelines: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteProgramPipelines({:?}, {:p});", n, pipelines);
      }
      let p = self.glDeleteProgramPipelines_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p)
      {
        Some(fn_p) => fn_p(n, pipelines),
        None => go_panic_because_fn_not_loaded("glDeleteProgramPipelines"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDeleteProgramPipelines" != "glGetError" {
          report_error_as_necessary_from(
            "DeleteProgramPipelines",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DeleteProgramPipelines_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDeleteProgramPipelines\0");
      self.glDeleteProgramPipelines_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteProgramPipelines_is_loaded(&self) -> bool {
      !self.glDeleteProgramPipelines_p.load(RELAX).is_null()
    }
    /// [glDeleteQueries](http://docs.gl/gl4/glDeleteQueries)(n, ids)
    /// * `ids` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteQueries(&self, n: GLsizei, ids: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteQueries({:?}, {:p});", n, ids);
      }
      let p = self.glDeleteQueries_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p)
      {
        Some(fn_p) => fn_p(n, ids),
        None => go_panic_because_fn_not_loaded("glDeleteQueries"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDeleteQueries" != "glGetError" {
          report_error_as_necessary_from("DeleteQueries", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DeleteQueries_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDeleteQueries\0");
      self.glDeleteQueries_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteQueries_is_loaded(&self) -> bool {
      !self.glDeleteQueries_p.load(RELAX).is_null()
    }
    /// [glDeleteRenderbuffers](http://docs.gl/gl4/glDeleteRenderbuffers)(n, renderbuffers)
    /// * `renderbuffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteRenderbuffers(
      &self,
      n: GLsizei,
      renderbuffers: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteRenderbuffers({:?}, {:p});", n, renderbuffers);
      }
      let p = self.glDeleteRenderbuffers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p)
      {
        Some(fn_p) => fn_p(n, renderbuffers),
        None => go_panic_because_fn_not_loaded("glDeleteRenderbuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDeleteRenderbuffers" != "glGetError" {
          report_error_as_necessary_from(
            "DeleteRenderbuffers",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DeleteRenderbuffers_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDeleteRenderbuffers\0");
      self.glDeleteRenderbuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteRenderbuffers_is_loaded(&self) -> bool {
      !self.glDeleteRenderbuffers_p.load(RELAX).is_null()
    }
    /// [glDeleteSamplers](http://docs.gl/gl4/glDeleteSamplers)(count, samplers)
    /// * `samplers` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteSamplers(
      &self,
      count: GLsizei,
      samplers: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteSamplers({:?}, {:p});", count, samplers);
      }
      let p = self.glDeleteSamplers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p)
      {
        Some(fn_p) => fn_p(count, samplers),
        None => go_panic_because_fn_not_loaded("glDeleteSamplers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDeleteSamplers" != "glGetError" {
          report_error_as_necessary_from("DeleteSamplers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DeleteSamplers_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDeleteSamplers\0");
      self.glDeleteSamplers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteSamplers_is_loaded(&self) -> bool {
      !self.glDeleteSamplers_p.load(RELAX).is_null()
    }
    /// [glDeleteShader](http://docs.gl/gl4/glDeleteShader)(shader)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteShader(&self, shader: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteShader({:?});", shader);
      }
      let p = self.glDeleteShader_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(shader),
        None => go_panic_because_fn_not_loaded("glDeleteShader"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDeleteShader" != "glGetError" {
          report_error_as_necessary_from("DeleteShader", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DeleteShader_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDeleteShader\0");
      self.glDeleteShader_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteShader_is_loaded(&self) -> bool {
      !self.glDeleteShader_p.load(RELAX).is_null()
    }
    /// [glDeleteSync](http://docs.gl/gl4/glDeleteSync)(sync)
    /// * `sync` group: sync
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteSync(&self, sync: GLsync) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteSync({:p});", sync);
      }
      let p = self.glDeleteSync_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsync)>>(p) {
        Some(fn_p) => fn_p(sync),
        None => go_panic_because_fn_not_loaded("glDeleteSync"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDeleteSync" != "glGetError" {
          report_error_as_necessary_from("DeleteSync", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DeleteSync_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDeleteSync\0");
      self.glDeleteSync_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteSync_is_loaded(&self) -> bool {
      !self.glDeleteSync_p.load(RELAX).is_null()
    }
    /// [glDeleteTextures](http://docs.gl/gl4/glDeleteTextures)(n, textures)
    /// * `textures` group: Texture
    /// * `textures` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteTextures(&self, n: GLsizei, textures: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteTextures({:?}, {:p});", n, textures);
      }
      let p = self.glDeleteTextures_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p)
      {
        Some(fn_p) => fn_p(n, textures),
        None => go_panic_because_fn_not_loaded("glDeleteTextures"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDeleteTextures" != "glGetError" {
          report_error_as_necessary_from("DeleteTextures", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DeleteTextures_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDeleteTextures\0");
      self.glDeleteTextures_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteTextures_is_loaded(&self) -> bool {
      !self.glDeleteTextures_p.load(RELAX).is_null()
    }
    /// [glDeleteTransformFeedbacks](http://docs.gl/gl4/glDeleteTransformFeedbacks)(n, ids)
    /// * `ids` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteTransformFeedbacks(
      &self,
      n: GLsizei,
      ids: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteTransformFeedbacks({:?}, {:p});", n, ids);
      }
      let p = self.glDeleteTransformFeedbacks_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p)
      {
        Some(fn_p) => fn_p(n, ids),
        None => go_panic_because_fn_not_loaded("glDeleteTransformFeedbacks"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDeleteTransformFeedbacks" != "glGetError" {
          report_error_as_necessary_from(
            "DeleteTransformFeedbacks",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DeleteTransformFeedbacks_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDeleteTransformFeedbacks\0");
      self.glDeleteTransformFeedbacks_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteTransformFeedbacks_is_loaded(&self) -> bool {
      !self.glDeleteTransformFeedbacks_p.load(RELAX).is_null()
    }
    /// [glDeleteVertexArrays](http://docs.gl/gl4/glDeleteVertexArrays)(n, arrays)
    /// * `arrays` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DeleteVertexArrays(&self, n: GLsizei, arrays: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DeleteVertexArrays({:?}, {:p});", n, arrays);
      }
      let p = self.glDeleteVertexArrays_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLuint)>>(p)
      {
        Some(fn_p) => fn_p(n, arrays),
        None => go_panic_because_fn_not_loaded("glDeleteVertexArrays"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDeleteVertexArrays" != "glGetError" {
          report_error_as_necessary_from("DeleteVertexArrays", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DeleteVertexArrays_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDeleteVertexArrays\0");
      self.glDeleteVertexArrays_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DeleteVertexArrays_is_loaded(&self) -> bool {
      !self.glDeleteVertexArrays_p.load(RELAX).is_null()
    }
    /// [glDepthFunc](http://docs.gl/gl4/glDepthFunc)(func)
    /// * `func` group: DepthFunction
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DepthFunc(&self, func: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DepthFunc({:#X});", func);
      }
      let p = self.glDepthFunc_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(func),
        None => go_panic_because_fn_not_loaded("glDepthFunc"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDepthFunc" != "glGetError" {
          report_error_as_necessary_from("DepthFunc", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DepthFunc_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDepthFunc\0");
      self.glDepthFunc_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DepthFunc_is_loaded(&self) -> bool {
      !self.glDepthFunc_p.load(RELAX).is_null()
    }
    /// [glDepthMask](http://docs.gl/gl4/glDepthMask)(flag)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DepthMask(&self, flag: GLboolean) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DepthMask({:?});", flag);
      }
      let p = self.glDepthMask_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLboolean)>>(p) {
        Some(fn_p) => fn_p(flag),
        None => go_panic_because_fn_not_loaded("glDepthMask"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDepthMask" != "glGetError" {
          report_error_as_necessary_from("DepthMask", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DepthMask_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDepthMask\0");
      self.glDepthMask_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DepthMask_is_loaded(&self) -> bool {
      !self.glDepthMask_p.load(RELAX).is_null()
    }
    /// [glDepthRange](http://docs.gl/gl4/glDepthRange)(n, f)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DepthRange(&self, n: GLdouble, f: GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DepthRange({:?}, {:?});", n, f);
      }
      let p = self.glDepthRange_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLdouble, GLdouble)>>(p) {
        Some(fn_p) => fn_p(n, f),
        None => go_panic_because_fn_not_loaded("glDepthRange"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDepthRange" != "glGetError" {
          report_error_as_necessary_from("DepthRange", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DepthRange_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDepthRange\0");
      self.glDepthRange_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DepthRange_is_loaded(&self) -> bool {
      !self.glDepthRange_p.load(RELAX).is_null()
    }
    /// [glDepthRangeArrayv](http://docs.gl/gl4/glDepthRangeArrayv)(first, count, v)
    /// * `v` len: COMPSIZE(count)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DepthRangeArrayv(
      &self,
      first: GLuint,
      count: GLsizei,
      v: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DepthRangeArrayv({:?}, {:?}, {:p});",
          first,
          count,
          v
        );
      }
      let p = self.glDepthRangeArrayv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLsizei, *const GLdouble)>>(
          p,
        ) {
          Some(fn_p) => fn_p(first, count, v),
          None => go_panic_because_fn_not_loaded("glDepthRangeArrayv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDepthRangeArrayv" != "glGetError" {
          report_error_as_necessary_from("DepthRangeArrayv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DepthRangeArrayv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDepthRangeArrayv\0");
      self.glDepthRangeArrayv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DepthRangeArrayv_is_loaded(&self) -> bool {
      !self.glDepthRangeArrayv_p.load(RELAX).is_null()
    }
    /// [glDepthRangeIndexed](http://docs.gl/gl4/glDepthRangeIndexed)(index, n, f)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DepthRangeIndexed(
      &self,
      index: GLuint,
      n: GLdouble,
      f: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DepthRangeIndexed({:?}, {:?}, {:?});", index, n, f);
      }
      let p = self.glDepthRangeIndexed_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLdouble, GLdouble)>>(p) {
          Some(fn_p) => fn_p(index, n, f),
          None => go_panic_because_fn_not_loaded("glDepthRangeIndexed"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDepthRangeIndexed" != "glGetError" {
          report_error_as_necessary_from("DepthRangeIndexed", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DepthRangeIndexed_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDepthRangeIndexed\0");
      self.glDepthRangeIndexed_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DepthRangeIndexed_is_loaded(&self) -> bool {
      !self.glDepthRangeIndexed_p.load(RELAX).is_null()
    }
    /// [glDepthRangef](http://docs.gl/gl4/glDepthRangef)(n, f)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DepthRangef(&self, n: GLfloat, f: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DepthRangef({:?}, {:?});", n, f);
      }
      let p = self.glDepthRangef_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLfloat, GLfloat)>>(p) {
        Some(fn_p) => fn_p(n, f),
        None => go_panic_because_fn_not_loaded("glDepthRangef"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDepthRangef" != "glGetError" {
          report_error_as_necessary_from("DepthRangef", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DepthRangef_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDepthRangef\0");
      self.glDepthRangef_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DepthRangef_is_loaded(&self) -> bool {
      !self.glDepthRangef_p.load(RELAX).is_null()
    }
    /// [glDetachShader](http://docs.gl/gl4/glDetachShader)(program, shader)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DetachShader(&self, program: GLuint, shader: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DetachShader({:?}, {:?});", program, shader);
      }
      let p = self.glDetachShader_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(program, shader),
        None => go_panic_because_fn_not_loaded("glDetachShader"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDetachShader" != "glGetError" {
          report_error_as_necessary_from("DetachShader", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DetachShader_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDetachShader\0");
      self.glDetachShader_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DetachShader_is_loaded(&self) -> bool {
      !self.glDetachShader_p.load(RELAX).is_null()
    }
    /// [glDisable](http://docs.gl/gl4/glDisable)(cap)
    /// * `cap` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Disable(&self, cap: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Disable({:#X});", cap);
      }
      let p = self.glDisable_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(cap),
        None => go_panic_because_fn_not_loaded("glDisable"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDisable" != "glGetError" {
          report_error_as_necessary_from("Disable", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Disable_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDisable\0");
      self.glDisable_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Disable_is_loaded(&self) -> bool {
      !self.glDisable_p.load(RELAX).is_null()
    }
    /// [glDisableVertexArrayAttrib](http://docs.gl/gl4/glDisableVertexArrayAttrib)(vaobj, index)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DisableVertexArrayAttrib(
      &self,
      vaobj: GLuint,
      index: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DisableVertexArrayAttrib({:?}, {:?});",
          vaobj,
          index
        );
      }
      let p = self.glDisableVertexArrayAttrib_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(vaobj, index),
        None => go_panic_because_fn_not_loaded("glDisableVertexArrayAttrib"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDisableVertexArrayAttrib" != "glGetError" {
          report_error_as_necessary_from(
            "DisableVertexArrayAttrib",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DisableVertexArrayAttrib_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDisableVertexArrayAttrib\0");
      self.glDisableVertexArrayAttrib_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DisableVertexArrayAttrib_is_loaded(&self) -> bool {
      !self.glDisableVertexArrayAttrib_p.load(RELAX).is_null()
    }
    /// [glDisableVertexAttribArray](http://docs.gl/gl4/glDisableVertexAttribArray)(index)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DisableVertexAttribArray(&self, index: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DisableVertexAttribArray({:?});", index);
      }
      let p = self.glDisableVertexAttribArray_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(index),
        None => go_panic_because_fn_not_loaded("glDisableVertexAttribArray"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDisableVertexAttribArray" != "glGetError" {
          report_error_as_necessary_from(
            "DisableVertexAttribArray",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DisableVertexAttribArray_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDisableVertexAttribArray\0");
      self.glDisableVertexAttribArray_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DisableVertexAttribArray_is_loaded(&self) -> bool {
      !self.glDisableVertexAttribArray_p.load(RELAX).is_null()
    }
    /// [glDisablei](http://docs.gl/gl4/glDisablei)(target, index)
    /// * `target` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Disablei(&self, target: GLenum, index: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Disablei({:#X}, {:?});", target, index);
      }
      let p = self.glDisablei_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(target, index),
        None => go_panic_because_fn_not_loaded("glDisablei"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDisablei" != "glGetError" {
          report_error_as_necessary_from("Disablei", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Disablei_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDisablei\0");
      self.glDisablei_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Disablei_is_loaded(&self) -> bool {
      !self.glDisablei_p.load(RELAX).is_null()
    }
    /// [glDispatchCompute](http://docs.gl/gl4/glDispatchCompute)(num_groups_x, num_groups_y, num_groups_z)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DispatchCompute(
      &self,
      num_groups_x: GLuint,
      num_groups_y: GLuint,
      num_groups_z: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DispatchCompute({:?}, {:?}, {:?});",
          num_groups_x,
          num_groups_y,
          num_groups_z
        );
      }
      let p = self.glDispatchCompute_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p)
      {
        Some(fn_p) => fn_p(num_groups_x, num_groups_y, num_groups_z),
        None => go_panic_because_fn_not_loaded("glDispatchCompute"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDispatchCompute" != "glGetError" {
          report_error_as_necessary_from("DispatchCompute", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DispatchCompute_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDispatchCompute\0");
      self.glDispatchCompute_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DispatchCompute_is_loaded(&self) -> bool {
      !self.glDispatchCompute_p.load(RELAX).is_null()
    }
    /// [glDispatchComputeIndirect](http://docs.gl/gl4/glDispatchComputeIndirect)(indirect)
    /// * `indirect` group: BufferOffset
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DispatchComputeIndirect(&self, indirect: GLintptr) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DispatchComputeIndirect({:?});", indirect);
      }
      let p = self.glDispatchComputeIndirect_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLintptr)>>(p) {
        Some(fn_p) => fn_p(indirect),
        None => go_panic_because_fn_not_loaded("glDispatchComputeIndirect"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDispatchComputeIndirect" != "glGetError" {
          report_error_as_necessary_from(
            "DispatchComputeIndirect",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DispatchComputeIndirect_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDispatchComputeIndirect\0");
      self.glDispatchComputeIndirect_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DispatchComputeIndirect_is_loaded(&self) -> bool {
      !self.glDispatchComputeIndirect_p.load(RELAX).is_null()
    }
    /// [glDrawArrays](http://docs.gl/gl4/glDrawArrays)(mode, first, count)
    /// * `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawArrays(
      &self,
      mode: GLenum,
      first: GLint,
      count: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawArrays({:#X}, {:?}, {:?});", mode, first, count);
      }
      let p = self.glDrawArrays_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLint, GLsizei)>>(p)
      {
        Some(fn_p) => fn_p(mode, first, count),
        None => go_panic_because_fn_not_loaded("glDrawArrays"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawArrays" != "glGetError" {
          report_error_as_necessary_from("DrawArrays", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawArrays_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawArrays\0");
      self.glDrawArrays_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawArrays_is_loaded(&self) -> bool {
      !self.glDrawArrays_p.load(RELAX).is_null()
    }
    /// [glDrawArraysIndirect](http://docs.gl/gl4/glDrawArraysIndirect)(mode, indirect)
    /// * `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawArraysIndirect(
      &self,
      mode: GLenum,
      indirect: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawArraysIndirect({:#X}, {:p});", mode, indirect);
      }
      let p = self.glDrawArraysIndirect_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, *const c_void)>>(p) {
        Some(fn_p) => fn_p(mode, indirect),
        None => go_panic_because_fn_not_loaded("glDrawArraysIndirect"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawArraysIndirect" != "glGetError" {
          report_error_as_necessary_from("DrawArraysIndirect", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawArraysIndirect_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawArraysIndirect\0");
      self.glDrawArraysIndirect_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawArraysIndirect_is_loaded(&self) -> bool {
      !self.glDrawArraysIndirect_p.load(RELAX).is_null()
    }
    /// [glDrawArraysInstanced](http://docs.gl/gl4/glDrawArraysInstanced)(mode, first, count, instancecount)
    /// * `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawArraysInstanced(
      &self,
      mode: GLenum,
      first: GLint,
      count: GLsizei,
      instancecount: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawArraysInstanced({:#X}, {:?}, {:?}, {:?});",
          mode,
          first,
          count,
          instancecount
        );
      }
      let p = self.glDrawArraysInstanced_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLint, GLsizei, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(mode, first, count, instancecount),
        None => go_panic_because_fn_not_loaded("glDrawArraysInstanced"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawArraysInstanced" != "glGetError" {
          report_error_as_necessary_from(
            "DrawArraysInstanced",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawArraysInstanced_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawArraysInstanced\0");
      self.glDrawArraysInstanced_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawArraysInstanced_is_loaded(&self) -> bool {
      !self.glDrawArraysInstanced_p.load(RELAX).is_null()
    }
    /// [glDrawArraysInstancedBaseInstance](http://docs.gl/gl4/glDrawArraysInstancedBaseInstance)(mode, first, count, instancecount, baseinstance)
    /// * `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawArraysInstancedBaseInstance(
      &self,
      mode: GLenum,
      first: GLint,
      count: GLsizei,
      instancecount: GLsizei,
      baseinstance: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawArraysInstancedBaseInstance({:#X}, {:?}, {:?}, {:?}, {:?});", mode, first, count, instancecount, baseinstance);
      }
      let p = self.glDrawArraysInstancedBaseInstance_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLint, GLsizei, GLsizei, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(mode, first, count, instancecount, baseinstance),
        None => {
          go_panic_because_fn_not_loaded("glDrawArraysInstancedBaseInstance")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawArraysInstancedBaseInstance" != "glGetError" {
          report_error_as_necessary_from(
            "DrawArraysInstancedBaseInstance",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawArraysInstancedBaseInstance_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glDrawArraysInstancedBaseInstance\0");
      self.glDrawArraysInstancedBaseInstance_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawArraysInstancedBaseInstance_is_loaded(&self) -> bool {
      !self.glDrawArraysInstancedBaseInstance_p.load(RELAX).is_null()
    }
    /// [glDrawBuffer](http://docs.gl/gl4/glDrawBuffer)(buf)
    /// * `buf` group: DrawBufferMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawBuffer(&self, buf: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawBuffer({:#X});", buf);
      }
      let p = self.glDrawBuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(buf),
        None => go_panic_because_fn_not_loaded("glDrawBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawBuffer" != "glGetError" {
          report_error_as_necessary_from("DrawBuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawBuffer_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawBuffer\0");
      self.glDrawBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawBuffer_is_loaded(&self) -> bool {
      !self.glDrawBuffer_p.load(RELAX).is_null()
    }
    /// [glDrawBuffers](http://docs.gl/gl4/glDrawBuffers)(n, bufs)
    /// * `bufs` group: DrawBufferMode
    /// * `bufs` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawBuffers(&self, n: GLsizei, bufs: *const GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawBuffers({:?}, {:p});", n, bufs);
      }
      let p = self.glDrawBuffers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *const GLenum)>>(p)
      {
        Some(fn_p) => fn_p(n, bufs),
        None => go_panic_because_fn_not_loaded("glDrawBuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawBuffers" != "glGetError" {
          report_error_as_necessary_from("DrawBuffers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawBuffers_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawBuffers\0");
      self.glDrawBuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawBuffers_is_loaded(&self) -> bool {
      !self.glDrawBuffers_p.load(RELAX).is_null()
    }
    /// [glDrawElements](http://docs.gl/gl4/glDrawElements)(mode, count, type_, indices)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawElements(
      &self,
      mode: GLenum,
      count: GLsizei,
      type_: GLenum,
      indices: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawElements({:#X}, {:?}, {:#X}, {:p});",
          mode,
          count,
          type_,
          indices
        );
      }
      let p = self.glDrawElements_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLsizei, GLenum, *const c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(mode, count, type_, indices),
        None => go_panic_because_fn_not_loaded("glDrawElements"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawElements" != "glGetError" {
          report_error_as_necessary_from("DrawElements", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawElements_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawElements\0");
      self.glDrawElements_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawElements_is_loaded(&self) -> bool {
      !self.glDrawElements_p.load(RELAX).is_null()
    }
    /// [glDrawElementsBaseVertex](http://docs.gl/gl4/glDrawElementsBaseVertex)(mode, count, type_, indices, basevertex)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawElementsBaseVertex(
      &self,
      mode: GLenum,
      count: GLsizei,
      type_: GLenum,
      indices: *const c_void,
      basevertex: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawElementsBaseVertex({:#X}, {:?}, {:#X}, {:p}, {:?});",
          mode,
          count,
          type_,
          indices,
          basevertex
        );
      }
      let p = self.glDrawElementsBaseVertex_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(mode, count, type_, indices, basevertex),
        None => go_panic_because_fn_not_loaded("glDrawElementsBaseVertex"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawElementsBaseVertex" != "glGetError" {
          report_error_as_necessary_from(
            "DrawElementsBaseVertex",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawElementsBaseVertex_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawElementsBaseVertex\0");
      self.glDrawElementsBaseVertex_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawElementsBaseVertex_is_loaded(&self) -> bool {
      !self.glDrawElementsBaseVertex_p.load(RELAX).is_null()
    }
    /// [glDrawElementsIndirect](http://docs.gl/gl4/glDrawElementsIndirect)(mode, type_, indirect)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawElementsIndirect(
      &self,
      mode: GLenum,
      type_: GLenum,
      indirect: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawElementsIndirect({:#X}, {:#X}, {:p});",
          mode,
          type_,
          indirect
        );
      }
      let p = self.glDrawElementsIndirect_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, *const c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(mode, type_, indirect),
        None => go_panic_because_fn_not_loaded("glDrawElementsIndirect"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawElementsIndirect" != "glGetError" {
          report_error_as_necessary_from(
            "DrawElementsIndirect",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawElementsIndirect_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawElementsIndirect\0");
      self.glDrawElementsIndirect_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawElementsIndirect_is_loaded(&self) -> bool {
      !self.glDrawElementsIndirect_p.load(RELAX).is_null()
    }
    /// [glDrawElementsInstanced](http://docs.gl/gl4/glDrawElementsInstanced)(mode, count, type_, indices, instancecount)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawElementsInstanced(
      &self,
      mode: GLenum,
      count: GLsizei,
      type_: GLenum,
      indices: *const c_void,
      instancecount: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawElementsInstanced({:#X}, {:?}, {:#X}, {:p}, {:?});",
          mode,
          count,
          type_,
          indices,
          instancecount
        );
      }
      let p = self.glDrawElementsInstanced_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(mode, count, type_, indices, instancecount),
        None => go_panic_because_fn_not_loaded("glDrawElementsInstanced"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawElementsInstanced" != "glGetError" {
          report_error_as_necessary_from(
            "DrawElementsInstanced",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawElementsInstanced_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawElementsInstanced\0");
      self.glDrawElementsInstanced_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawElementsInstanced_is_loaded(&self) -> bool {
      !self.glDrawElementsInstanced_p.load(RELAX).is_null()
    }
    /// [glDrawElementsInstancedBaseInstance](http://docs.gl/gl4/glDrawElementsInstancedBaseInstance)(mode, count, type_, indices, instancecount, baseinstance)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: PrimitiveType
    /// * `indices` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawElementsInstancedBaseInstance(
      &self,
      mode: GLenum,
      count: GLsizei,
      type_: GLenum,
      indices: *const c_void,
      instancecount: GLsizei,
      baseinstance: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawElementsInstancedBaseInstance({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?});", mode, count, type_, indices, instancecount, baseinstance);
      }
      let p = self.glDrawElementsInstancedBaseInstance_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLsizei,
            GLenum,
            *const c_void,
            GLsizei,
            GLuint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(mode, count, type_, indices, instancecount, baseinstance)
        }
        None => {
          go_panic_because_fn_not_loaded("glDrawElementsInstancedBaseInstance")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawElementsInstancedBaseInstance" != "glGetError" {
          report_error_as_necessary_from(
            "DrawElementsInstancedBaseInstance",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawElementsInstancedBaseInstance_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glDrawElementsInstancedBaseInstance\0");
      self.glDrawElementsInstancedBaseInstance_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawElementsInstancedBaseInstance_is_loaded(&self) -> bool {
      !self.glDrawElementsInstancedBaseInstance_p.load(RELAX).is_null()
    }
    /// [glDrawElementsInstancedBaseVertex](http://docs.gl/gl4/glDrawElementsInstancedBaseVertex)(mode, count, type_, indices, instancecount, basevertex)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawElementsInstancedBaseVertex(
      &self,
      mode: GLenum,
      count: GLsizei,
      type_: GLenum,
      indices: *const c_void,
      instancecount: GLsizei,
      basevertex: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawElementsInstancedBaseVertex({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?});", mode, count, type_, indices, instancecount, basevertex);
      }
      let p = self.glDrawElementsInstancedBaseVertex_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLsizei,
            GLenum,
            *const c_void,
            GLsizei,
            GLint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(mode, count, type_, indices, instancecount, basevertex)
        }
        None => {
          go_panic_because_fn_not_loaded("glDrawElementsInstancedBaseVertex")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawElementsInstancedBaseVertex" != "glGetError" {
          report_error_as_necessary_from(
            "DrawElementsInstancedBaseVertex",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawElementsInstancedBaseVertex_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glDrawElementsInstancedBaseVertex\0");
      self.glDrawElementsInstancedBaseVertex_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawElementsInstancedBaseVertex_is_loaded(&self) -> bool {
      !self.glDrawElementsInstancedBaseVertex_p.load(RELAX).is_null()
    }
    /// [glDrawElementsInstancedBaseVertexBaseInstance](http://docs.gl/gl4/glDrawElementsInstancedBaseVertexBaseInstance)(mode, count, type_, indices, instancecount, basevertex, baseinstance)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawElementsInstancedBaseVertexBaseInstance(
      &self,
      mode: GLenum,
      count: GLsizei,
      type_: GLenum,
      indices: *const c_void,
      instancecount: GLsizei,
      basevertex: GLint,
      baseinstance: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawElementsInstancedBaseVertexBaseInstance({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?}, {:?});", mode, count, type_, indices, instancecount, basevertex, baseinstance);
      }
      let p = self.glDrawElementsInstancedBaseVertexBaseInstance_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLsizei,
            GLenum,
            *const c_void,
            GLsizei,
            GLint,
            GLuint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          mode,
          count,
          type_,
          indices,
          instancecount,
          basevertex,
          baseinstance,
        ),
        None => go_panic_because_fn_not_loaded(
          "glDrawElementsInstancedBaseVertexBaseInstance",
        ),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawElementsInstancedBaseVertexBaseInstance" != "glGetError" {
          report_error_as_necessary_from(
            "DrawElementsInstancedBaseVertexBaseInstance",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawElementsInstancedBaseVertexBaseInstance_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(
        get_proc_address,
        b"glDrawElementsInstancedBaseVertexBaseInstance\0",
      );
      self.glDrawElementsInstancedBaseVertexBaseInstance_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawElementsInstancedBaseVertexBaseInstance_is_loaded(
      &self,
    ) -> bool {
      !self
        .glDrawElementsInstancedBaseVertexBaseInstance_p
        .load(RELAX)
        .is_null()
    }
    /// [glDrawRangeElements](http://docs.gl/gl4/glDrawRangeElements)(mode, start, end, count, type_, indices)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawRangeElements(
      &self,
      mode: GLenum,
      start: GLuint,
      end: GLuint,
      count: GLsizei,
      type_: GLenum,
      indices: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawRangeElements({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p});",
          mode,
          start,
          end,
          count,
          type_,
          indices
        );
      }
      let p = self.glDrawRangeElements_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLuint,
            GLuint,
            GLsizei,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(mode, start, end, count, type_, indices),
        None => go_panic_because_fn_not_loaded("glDrawRangeElements"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawRangeElements" != "glGetError" {
          report_error_as_necessary_from("DrawRangeElements", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawRangeElements_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawRangeElements\0");
      self.glDrawRangeElements_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawRangeElements_is_loaded(&self) -> bool {
      !self.glDrawRangeElements_p.load(RELAX).is_null()
    }
    /// [glDrawRangeElementsBaseVertex](http://docs.gl/gl4/glDrawRangeElementsBaseVertex)(mode, start, end, count, type_, indices, basevertex)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawRangeElementsBaseVertex(
      &self,
      mode: GLenum,
      start: GLuint,
      end: GLuint,
      count: GLsizei,
      type_: GLenum,
      indices: *const c_void,
      basevertex: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawRangeElementsBaseVertex({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p}, {:?});", mode, start, end, count, type_, indices, basevertex);
      }
      let p = self.glDrawRangeElementsBaseVertex_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLuint,
            GLuint,
            GLsizei,
            GLenum,
            *const c_void,
            GLint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(mode, start, end, count, type_, indices, basevertex),
        None => go_panic_because_fn_not_loaded("glDrawRangeElementsBaseVertex"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawRangeElementsBaseVertex" != "glGetError" {
          report_error_as_necessary_from(
            "DrawRangeElementsBaseVertex",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawRangeElementsBaseVertex_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawRangeElementsBaseVertex\0");
      self.glDrawRangeElementsBaseVertex_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawRangeElementsBaseVertex_is_loaded(&self) -> bool {
      !self.glDrawRangeElementsBaseVertex_p.load(RELAX).is_null()
    }
    /// [glDrawTransformFeedback](http://docs.gl/gl4/glDrawTransformFeedback)(mode, id)
    /// * `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawTransformFeedback(&self, mode: GLenum, id: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawTransformFeedback({:#X}, {:?});", mode, id);
      }
      let p = self.glDrawTransformFeedback_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(mode, id),
        None => go_panic_because_fn_not_loaded("glDrawTransformFeedback"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawTransformFeedback" != "glGetError" {
          report_error_as_necessary_from(
            "DrawTransformFeedback",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawTransformFeedback_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawTransformFeedback\0");
      self.glDrawTransformFeedback_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawTransformFeedback_is_loaded(&self) -> bool {
      !self.glDrawTransformFeedback_p.load(RELAX).is_null()
    }
    /// [glDrawTransformFeedbackInstanced](http://docs.gl/gl4/glDrawTransformFeedbackInstanced)(mode, id, instancecount)
    /// * `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawTransformFeedbackInstanced(
      &self,
      mode: GLenum,
      id: GLuint,
      instancecount: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawTransformFeedbackInstanced({:#X}, {:?}, {:?});",
          mode,
          id,
          instancecount
        );
      }
      let p = self.glDrawTransformFeedbackInstanced_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint, GLsizei)>>(p)
      {
        Some(fn_p) => fn_p(mode, id, instancecount),
        None => {
          go_panic_because_fn_not_loaded("glDrawTransformFeedbackInstanced")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawTransformFeedbackInstanced" != "glGetError" {
          report_error_as_necessary_from(
            "DrawTransformFeedbackInstanced",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawTransformFeedbackInstanced_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glDrawTransformFeedbackInstanced\0");
      self.glDrawTransformFeedbackInstanced_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawTransformFeedbackInstanced_is_loaded(&self) -> bool {
      !self.glDrawTransformFeedbackInstanced_p.load(RELAX).is_null()
    }
    /// [glDrawTransformFeedbackStream](http://docs.gl/gl4/glDrawTransformFeedbackStream)(mode, id, stream)
    /// * `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawTransformFeedbackStream(
      &self,
      mode: GLenum,
      id: GLuint,
      stream: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.DrawTransformFeedbackStream({:#X}, {:?}, {:?});",
          mode,
          id,
          stream
        );
      }
      let p = self.glDrawTransformFeedbackStream_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint, GLuint)>>(p)
      {
        Some(fn_p) => fn_p(mode, id, stream),
        None => go_panic_because_fn_not_loaded("glDrawTransformFeedbackStream"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawTransformFeedbackStream" != "glGetError" {
          report_error_as_necessary_from(
            "DrawTransformFeedbackStream",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawTransformFeedbackStream_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glDrawTransformFeedbackStream\0");
      self.glDrawTransformFeedbackStream_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawTransformFeedbackStream_is_loaded(&self) -> bool {
      !self.glDrawTransformFeedbackStream_p.load(RELAX).is_null()
    }
    /// [glDrawTransformFeedbackStreamInstanced](http://docs.gl/gl4/glDrawTransformFeedbackStreamInstanced)(mode, id, stream, instancecount)
    /// * `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn DrawTransformFeedbackStreamInstanced(
      &self,
      mode: GLenum,
      id: GLuint,
      stream: GLuint,
      instancecount: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.DrawTransformFeedbackStreamInstanced({:#X}, {:?}, {:?}, {:?});", mode, id, stream, instancecount);
      }
      let p = self.glDrawTransformFeedbackStreamInstanced_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLuint, GLuint, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(mode, id, stream, instancecount),
        None => go_panic_because_fn_not_loaded(
          "glDrawTransformFeedbackStreamInstanced",
        ),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glDrawTransformFeedbackStreamInstanced" != "glGetError" {
          report_error_as_necessary_from(
            "DrawTransformFeedbackStreamInstanced",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn DrawTransformFeedbackStreamInstanced_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(
        get_proc_address,
        b"glDrawTransformFeedbackStreamInstanced\0",
      );
      self.glDrawTransformFeedbackStreamInstanced_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn DrawTransformFeedbackStreamInstanced_is_loaded(&self) -> bool {
      !self.glDrawTransformFeedbackStreamInstanced_p.load(RELAX).is_null()
    }
    /// [glEnable](http://docs.gl/gl4/glEnable)(cap)
    /// * `cap` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Enable(&self, cap: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Enable({:#X});", cap);
      }
      let p = self.glEnable_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(cap),
        None => go_panic_because_fn_not_loaded("glEnable"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glEnable" != "glGetError" {
          report_error_as_necessary_from("Enable", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Enable_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glEnable\0");
      self.glEnable_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Enable_is_loaded(&self) -> bool {
      !self.glEnable_p.load(RELAX).is_null()
    }
    /// [glEnableVertexArrayAttrib](http://docs.gl/gl4/glEnableVertexArrayAttrib)(vaobj, index)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn EnableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.EnableVertexArrayAttrib({:?}, {:?});", vaobj, index);
      }
      let p = self.glEnableVertexArrayAttrib_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(vaobj, index),
        None => go_panic_because_fn_not_loaded("glEnableVertexArrayAttrib"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glEnableVertexArrayAttrib" != "glGetError" {
          report_error_as_necessary_from(
            "EnableVertexArrayAttrib",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn EnableVertexArrayAttrib_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glEnableVertexArrayAttrib\0");
      self.glEnableVertexArrayAttrib_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn EnableVertexArrayAttrib_is_loaded(&self) -> bool {
      !self.glEnableVertexArrayAttrib_p.load(RELAX).is_null()
    }
    /// [glEnableVertexAttribArray](http://docs.gl/gl4/glEnableVertexAttribArray)(index)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn EnableVertexAttribArray(&self, index: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.EnableVertexAttribArray({:?});", index);
      }
      let p = self.glEnableVertexAttribArray_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(index),
        None => go_panic_because_fn_not_loaded("glEnableVertexAttribArray"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glEnableVertexAttribArray" != "glGetError" {
          report_error_as_necessary_from(
            "EnableVertexAttribArray",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn EnableVertexAttribArray_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glEnableVertexAttribArray\0");
      self.glEnableVertexAttribArray_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn EnableVertexAttribArray_is_loaded(&self) -> bool {
      !self.glEnableVertexAttribArray_p.load(RELAX).is_null()
    }
    /// [glEnablei](http://docs.gl/gl4/glEnablei)(target, index)
    /// * `target` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Enablei(&self, target: GLenum, index: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Enablei({:#X}, {:?});", target, index);
      }
      let p = self.glEnablei_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(target, index),
        None => go_panic_because_fn_not_loaded("glEnablei"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glEnablei" != "glGetError" {
          report_error_as_necessary_from("Enablei", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Enablei_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glEnablei\0");
      self.glEnablei_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Enablei_is_loaded(&self) -> bool {
      !self.glEnablei_p.load(RELAX).is_null()
    }
    /// [glEndConditionalRender](http://docs.gl/gl4/glEndConditionalRender)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn EndConditionalRender(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.EndConditionalRender();",);
      }
      let p = self.glEndConditionalRender_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn()>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded("glEndConditionalRender"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glEndConditionalRender" != "glGetError" {
          report_error_as_necessary_from(
            "EndConditionalRender",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn EndConditionalRender_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glEndConditionalRender\0");
      self.glEndConditionalRender_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn EndConditionalRender_is_loaded(&self) -> bool {
      !self.glEndConditionalRender_p.load(RELAX).is_null()
    }
    /// [glEndQuery](http://docs.gl/gl4/glEndQuery)(target)
    /// * `target` group: QueryTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn EndQuery(&self, target: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.EndQuery({:#X});", target);
      }
      let p = self.glEndQuery_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(target),
        None => go_panic_because_fn_not_loaded("glEndQuery"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glEndQuery" != "glGetError" {
          report_error_as_necessary_from("EndQuery", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn EndQuery_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glEndQuery\0");
      self.glEndQuery_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn EndQuery_is_loaded(&self) -> bool {
      !self.glEndQuery_p.load(RELAX).is_null()
    }
    /// [glEndQueryIndexed](http://docs.gl/gl4/glEndQueryIndexed)(target, index)
    /// * `target` group: QueryTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn EndQueryIndexed(&self, target: GLenum, index: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.EndQueryIndexed({:#X}, {:?});", target, index);
      }
      let p = self.glEndQueryIndexed_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(target, index),
        None => go_panic_because_fn_not_loaded("glEndQueryIndexed"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glEndQueryIndexed" != "glGetError" {
          report_error_as_necessary_from("EndQueryIndexed", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn EndQueryIndexed_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glEndQueryIndexed\0");
      self.glEndQueryIndexed_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn EndQueryIndexed_is_loaded(&self) -> bool {
      !self.glEndQueryIndexed_p.load(RELAX).is_null()
    }
    /// [glEndTransformFeedback](http://docs.gl/gl4/glEndTransformFeedback)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn EndTransformFeedback(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.EndTransformFeedback();",);
      }
      let p = self.glEndTransformFeedback_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn()>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded("glEndTransformFeedback"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glEndTransformFeedback" != "glGetError" {
          report_error_as_necessary_from(
            "EndTransformFeedback",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn EndTransformFeedback_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glEndTransformFeedback\0");
      self.glEndTransformFeedback_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn EndTransformFeedback_is_loaded(&self) -> bool {
      !self.glEndTransformFeedback_p.load(RELAX).is_null()
    }
    /// [glFenceSync](http://docs.gl/gl4/glFenceSync)(condition, flags)
    /// * `condition` group: SyncCondition
    /// * return value group: sync
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FenceSync(
      &self,
      condition: GLenum,
      flags: GLbitfield,
    ) -> GLsync {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.FenceSync({:#X}, {:?});", condition, flags);
      }
      let p = self.glFenceSync_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLbitfield) -> GLsync>>(p) {
          Some(fn_p) => fn_p(condition, flags),
          None => go_panic_because_fn_not_loaded("glFenceSync"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFenceSync" != "glGetError" {
          report_error_as_necessary_from("FenceSync", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn FenceSync_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glFenceSync\0");
      self.glFenceSync_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn FenceSync_is_loaded(&self) -> bool {
      !self.glFenceSync_p.load(RELAX).is_null()
    }
    /// [glFinish](http://docs.gl/gl4/glFinish)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Finish(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Finish();",);
      }
      let p = self.glFinish_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn()>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded("glFinish"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFinish" != "glGetError" {
          report_error_as_necessary_from("Finish", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Finish_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glFinish\0");
      self.glFinish_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Finish_is_loaded(&self) -> bool {
      !self.glFinish_p.load(RELAX).is_null()
    }
    /// [glFlush](http://docs.gl/gl4/glFlush)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Flush(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Flush();",);
      }
      let p = self.glFlush_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn()>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded("glFlush"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFlush" != "glGetError" {
          report_error_as_necessary_from("Flush", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Flush_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glFlush\0");
      self.glFlush_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Flush_is_loaded(&self) -> bool {
      !self.glFlush_p.load(RELAX).is_null()
    }
    /// [glFlushMappedBufferRange](http://docs.gl/gl4/glFlushMappedBufferRange)(target, offset, length)
    /// * `target` group: BufferTargetARB
    /// * `offset` group: BufferOffset
    /// * `length` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FlushMappedBufferRange(
      &self,
      target: GLenum,
      offset: GLintptr,
      length: GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FlushMappedBufferRange({:#X}, {:?}, {:?});",
          target,
          offset,
          length
        );
      }
      let p = self.glFlushMappedBufferRange_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLintptr, GLsizeiptr)>>(p) {
          Some(fn_p) => fn_p(target, offset, length),
          None => go_panic_because_fn_not_loaded("glFlushMappedBufferRange"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFlushMappedBufferRange" != "glGetError" {
          report_error_as_necessary_from(
            "FlushMappedBufferRange",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn FlushMappedBufferRange_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glFlushMappedBufferRange\0");
      self.glFlushMappedBufferRange_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn FlushMappedBufferRange_is_loaded(&self) -> bool {
      !self.glFlushMappedBufferRange_p.load(RELAX).is_null()
    }
    /// [glFlushMappedNamedBufferRange](http://docs.gl/gl4/glFlushMappedNamedBufferRange)(buffer, offset, length)
    /// * `length` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FlushMappedNamedBufferRange(
      &self,
      buffer: GLuint,
      offset: GLintptr,
      length: GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FlushMappedNamedBufferRange({:?}, {:?}, {:?});",
          buffer,
          offset,
          length
        );
      }
      let p = self.glFlushMappedNamedBufferRange_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLintptr, GLsizeiptr)>>(p) {
          Some(fn_p) => fn_p(buffer, offset, length),
          None => {
            go_panic_because_fn_not_loaded("glFlushMappedNamedBufferRange")
          }
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFlushMappedNamedBufferRange" != "glGetError" {
          report_error_as_necessary_from(
            "FlushMappedNamedBufferRange",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn FlushMappedNamedBufferRange_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glFlushMappedNamedBufferRange\0");
      self.glFlushMappedNamedBufferRange_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn FlushMappedNamedBufferRange_is_loaded(&self) -> bool {
      !self.glFlushMappedNamedBufferRange_p.load(RELAX).is_null()
    }
    /// [glFramebufferParameteri](http://docs.gl/gl4/glFramebufferParameteri)(target, pname, param)
    /// * `target` group: FramebufferTarget
    /// * `pname` group: FramebufferParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferParameteri(
      &self,
      target: GLenum,
      pname: GLenum,
      param: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FramebufferParameteri({:#X}, {:#X}, {:?});",
          target,
          pname,
          param
        );
      }
      let p = self.glFramebufferParameteri_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLenum, GLint)>>(p) {
        Some(fn_p) => fn_p(target, pname, param),
        None => go_panic_because_fn_not_loaded("glFramebufferParameteri"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFramebufferParameteri" != "glGetError" {
          report_error_as_necessary_from(
            "FramebufferParameteri",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn FramebufferParameteri_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glFramebufferParameteri\0");
      self.glFramebufferParameteri_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferParameteri_is_loaded(&self) -> bool {
      !self.glFramebufferParameteri_p.load(RELAX).is_null()
    }
    /// [glFramebufferRenderbuffer](http://docs.gl/gl4/glFramebufferRenderbuffer)(target, attachment, renderbuffertarget, renderbuffer)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    /// * `renderbuffertarget` group: RenderbufferTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferRenderbuffer(
      &self,
      target: GLenum,
      attachment: GLenum,
      renderbuffertarget: GLenum,
      renderbuffer: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FramebufferRenderbuffer({:#X}, {:#X}, {:#X}, {:?});",
          target,
          attachment,
          renderbuffertarget,
          renderbuffer
        );
      }
      let p = self.glFramebufferRenderbuffer_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, GLenum, GLuint)>>(p)
        {
          Some(fn_p) => {
            fn_p(target, attachment, renderbuffertarget, renderbuffer)
          }
          None => go_panic_because_fn_not_loaded("glFramebufferRenderbuffer"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFramebufferRenderbuffer" != "glGetError" {
          report_error_as_necessary_from(
            "FramebufferRenderbuffer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn FramebufferRenderbuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glFramebufferRenderbuffer\0");
      self.glFramebufferRenderbuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferRenderbuffer_is_loaded(&self) -> bool {
      !self.glFramebufferRenderbuffer_p.load(RELAX).is_null()
    }
    /// [glFramebufferTexture](http://docs.gl/gl4/glFramebufferTexture)(target, attachment, texture, level)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferTexture(
      &self,
      target: GLenum,
      attachment: GLenum,
      texture: GLuint,
      level: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FramebufferTexture({:#X}, {:#X}, {:?}, {:?});",
          target,
          attachment,
          texture,
          level
        );
      }
      let p = self.glFramebufferTexture_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLuint, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, attachment, texture, level),
        None => go_panic_because_fn_not_loaded("glFramebufferTexture"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFramebufferTexture" != "glGetError" {
          report_error_as_necessary_from("FramebufferTexture", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn FramebufferTexture_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glFramebufferTexture\0");
      self.glFramebufferTexture_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferTexture_is_loaded(&self) -> bool {
      !self.glFramebufferTexture_p.load(RELAX).is_null()
    }
    /// [glFramebufferTexture1D](http://docs.gl/gl4/glFramebufferTexture1D)(target, attachment, textarget, texture, level)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    /// * `textarget` group: TextureTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferTexture1D(
      &self,
      target: GLenum,
      attachment: GLenum,
      textarget: GLenum,
      texture: GLuint,
      level: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FramebufferTexture1D({:#X}, {:#X}, {:#X}, {:?}, {:?});",
          target,
          attachment,
          textarget,
          texture,
          level
        );
      }
      let p = self.glFramebufferTexture1D_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, attachment, textarget, texture, level),
        None => go_panic_because_fn_not_loaded("glFramebufferTexture1D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFramebufferTexture1D" != "glGetError" {
          report_error_as_necessary_from(
            "FramebufferTexture1D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn FramebufferTexture1D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glFramebufferTexture1D\0");
      self.glFramebufferTexture1D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferTexture1D_is_loaded(&self) -> bool {
      !self.glFramebufferTexture1D_p.load(RELAX).is_null()
    }
    /// [glFramebufferTexture2D](http://docs.gl/gl4/glFramebufferTexture2D)(target, attachment, textarget, texture, level)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    /// * `textarget` group: TextureTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferTexture2D(
      &self,
      target: GLenum,
      attachment: GLenum,
      textarget: GLenum,
      texture: GLuint,
      level: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FramebufferTexture2D({:#X}, {:#X}, {:#X}, {:?}, {:?});",
          target,
          attachment,
          textarget,
          texture,
          level
        );
      }
      let p = self.glFramebufferTexture2D_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, attachment, textarget, texture, level),
        None => go_panic_because_fn_not_loaded("glFramebufferTexture2D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFramebufferTexture2D" != "glGetError" {
          report_error_as_necessary_from(
            "FramebufferTexture2D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn FramebufferTexture2D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glFramebufferTexture2D\0");
      self.glFramebufferTexture2D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferTexture2D_is_loaded(&self) -> bool {
      !self.glFramebufferTexture2D_p.load(RELAX).is_null()
    }
    /// [glFramebufferTexture3D](http://docs.gl/gl4/glFramebufferTexture3D)(target, attachment, textarget, texture, level, zoffset)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    /// * `textarget` group: TextureTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferTexture3D(
      &self,
      target: GLenum,
      attachment: GLenum,
      textarget: GLenum,
      texture: GLuint,
      level: GLint,
      zoffset: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.FramebufferTexture3D({:#X}, {:#X}, {:#X}, {:?}, {:?}, {:?});", target, attachment, textarget, texture, level, zoffset);
      }
      let p = self.glFramebufferTexture3D_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint, GLint)>,
      >(p)
      {
        Some(fn_p) => {
          fn_p(target, attachment, textarget, texture, level, zoffset)
        }
        None => go_panic_because_fn_not_loaded("glFramebufferTexture3D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFramebufferTexture3D" != "glGetError" {
          report_error_as_necessary_from(
            "FramebufferTexture3D",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn FramebufferTexture3D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glFramebufferTexture3D\0");
      self.glFramebufferTexture3D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferTexture3D_is_loaded(&self) -> bool {
      !self.glFramebufferTexture3D_p.load(RELAX).is_null()
    }
    /// [glFramebufferTextureLayer](http://docs.gl/gl4/glFramebufferTextureLayer)(target, attachment, texture, level, layer)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    /// * `texture` group: Texture
    /// * `level` group: CheckedInt32
    /// * `layer` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FramebufferTextureLayer(
      &self,
      target: GLenum,
      attachment: GLenum,
      texture: GLuint,
      level: GLint,
      layer: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.FramebufferTextureLayer({:#X}, {:#X}, {:?}, {:?}, {:?});",
          target,
          attachment,
          texture,
          level,
          layer
        );
      }
      let p = self.glFramebufferTextureLayer_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLuint, GLint, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, attachment, texture, level, layer),
        None => go_panic_because_fn_not_loaded("glFramebufferTextureLayer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFramebufferTextureLayer" != "glGetError" {
          report_error_as_necessary_from(
            "FramebufferTextureLayer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn FramebufferTextureLayer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glFramebufferTextureLayer\0");
      self.glFramebufferTextureLayer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn FramebufferTextureLayer_is_loaded(&self) -> bool {
      !self.glFramebufferTextureLayer_p.load(RELAX).is_null()
    }
    /// [glFrontFace](http://docs.gl/gl4/glFrontFace)(mode)
    /// * `mode` group: FrontFaceDirection
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn FrontFace(&self, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.FrontFace({:#X});", mode);
      }
      let p = self.glFrontFace_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(mode),
        None => go_panic_because_fn_not_loaded("glFrontFace"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glFrontFace" != "glGetError" {
          report_error_as_necessary_from("FrontFace", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn FrontFace_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glFrontFace\0");
      self.glFrontFace_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn FrontFace_is_loaded(&self) -> bool {
      !self.glFrontFace_p.load(RELAX).is_null()
    }
    /// [glGenBuffers](http://docs.gl/gl4/glGenBuffers)(n, buffers)
    /// * `buffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenBuffers(&self, n: GLsizei, buffers: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenBuffers({:?}, {:p});", n, buffers);
      }
      let p = self.glGenBuffers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, buffers),
        None => go_panic_because_fn_not_loaded("glGenBuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGenBuffers" != "glGetError" {
          report_error_as_necessary_from("GenBuffers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GenBuffers_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGenBuffers\0");
      self.glGenBuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenBuffers_is_loaded(&self) -> bool {
      !self.glGenBuffers_p.load(RELAX).is_null()
    }
    /// [glGenFramebuffers](http://docs.gl/gl4/glGenFramebuffers)(n, framebuffers)
    /// * `framebuffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenFramebuffers(
      &self,
      n: GLsizei,
      framebuffers: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenFramebuffers({:?}, {:p});", n, framebuffers);
      }
      let p = self.glGenFramebuffers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, framebuffers),
        None => go_panic_because_fn_not_loaded("glGenFramebuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGenFramebuffers" != "glGetError" {
          report_error_as_necessary_from("GenFramebuffers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GenFramebuffers_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGenFramebuffers\0");
      self.glGenFramebuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenFramebuffers_is_loaded(&self) -> bool {
      !self.glGenFramebuffers_p.load(RELAX).is_null()
    }
    /// [glGenProgramPipelines](http://docs.gl/gl4/glGenProgramPipelines)(n, pipelines)
    /// * `pipelines` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenProgramPipelines(
      &self,
      n: GLsizei,
      pipelines: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenProgramPipelines({:?}, {:p});", n, pipelines);
      }
      let p = self.glGenProgramPipelines_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, pipelines),
        None => go_panic_because_fn_not_loaded("glGenProgramPipelines"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGenProgramPipelines" != "glGetError" {
          report_error_as_necessary_from(
            "GenProgramPipelines",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GenProgramPipelines_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGenProgramPipelines\0");
      self.glGenProgramPipelines_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenProgramPipelines_is_loaded(&self) -> bool {
      !self.glGenProgramPipelines_p.load(RELAX).is_null()
    }
    /// [glGenQueries](http://docs.gl/gl4/glGenQueries)(n, ids)
    /// * `ids` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenQueries(&self, n: GLsizei, ids: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenQueries({:?}, {:p});", n, ids);
      }
      let p = self.glGenQueries_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, ids),
        None => go_panic_because_fn_not_loaded("glGenQueries"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGenQueries" != "glGetError" {
          report_error_as_necessary_from("GenQueries", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GenQueries_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGenQueries\0");
      self.glGenQueries_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenQueries_is_loaded(&self) -> bool {
      !self.glGenQueries_p.load(RELAX).is_null()
    }
    /// [glGenRenderbuffers](http://docs.gl/gl4/glGenRenderbuffers)(n, renderbuffers)
    /// * `renderbuffers` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenRenderbuffers(
      &self,
      n: GLsizei,
      renderbuffers: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenRenderbuffers({:?}, {:p});", n, renderbuffers);
      }
      let p = self.glGenRenderbuffers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, renderbuffers),
        None => go_panic_because_fn_not_loaded("glGenRenderbuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGenRenderbuffers" != "glGetError" {
          report_error_as_necessary_from("GenRenderbuffers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GenRenderbuffers_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGenRenderbuffers\0");
      self.glGenRenderbuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenRenderbuffers_is_loaded(&self) -> bool {
      !self.glGenRenderbuffers_p.load(RELAX).is_null()
    }
    /// [glGenSamplers](http://docs.gl/gl4/glGenSamplers)(count, samplers)
    /// * `samplers` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenSamplers(&self, count: GLsizei, samplers: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenSamplers({:?}, {:p});", count, samplers);
      }
      let p = self.glGenSamplers_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(count, samplers),
        None => go_panic_because_fn_not_loaded("glGenSamplers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGenSamplers" != "glGetError" {
          report_error_as_necessary_from("GenSamplers", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GenSamplers_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGenSamplers\0");
      self.glGenSamplers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenSamplers_is_loaded(&self) -> bool {
      !self.glGenSamplers_p.load(RELAX).is_null()
    }
    /// [glGenTextures](http://docs.gl/gl4/glGenTextures)(n, textures)
    /// * `textures` group: Texture
    /// * `textures` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenTextures(&self, n: GLsizei, textures: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenTextures({:?}, {:p});", n, textures);
      }
      let p = self.glGenTextures_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, textures),
        None => go_panic_because_fn_not_loaded("glGenTextures"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGenTextures" != "glGetError" {
          report_error_as_necessary_from("GenTextures", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GenTextures_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGenTextures\0");
      self.glGenTextures_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenTextures_is_loaded(&self) -> bool {
      !self.glGenTextures_p.load(RELAX).is_null()
    }
    /// [glGenTransformFeedbacks](http://docs.gl/gl4/glGenTransformFeedbacks)(n, ids)
    /// * `ids` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenTransformFeedbacks({:?}, {:p});", n, ids);
      }
      let p = self.glGenTransformFeedbacks_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, ids),
        None => go_panic_because_fn_not_loaded("glGenTransformFeedbacks"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGenTransformFeedbacks" != "glGetError" {
          report_error_as_necessary_from(
            "GenTransformFeedbacks",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GenTransformFeedbacks_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGenTransformFeedbacks\0");
      self.glGenTransformFeedbacks_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenTransformFeedbacks_is_loaded(&self) -> bool {
      !self.glGenTransformFeedbacks_p.load(RELAX).is_null()
    }
    /// [glGenVertexArrays](http://docs.gl/gl4/glGenVertexArrays)(n, arrays)
    /// * `arrays` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenVertexArrays({:?}, {:p});", n, arrays);
      }
      let p = self.glGenVertexArrays_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsizei, *mut GLuint)>>(p) {
        Some(fn_p) => fn_p(n, arrays),
        None => go_panic_because_fn_not_loaded("glGenVertexArrays"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGenVertexArrays" != "glGetError" {
          report_error_as_necessary_from("GenVertexArrays", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GenVertexArrays_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGenVertexArrays\0");
      self.glGenVertexArrays_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenVertexArrays_is_loaded(&self) -> bool {
      !self.glGenVertexArrays_p.load(RELAX).is_null()
    }
    /// [glGenerateMipmap](http://docs.gl/gl4/glGenerateMipmap)(target)
    /// * `target` group: TextureTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenerateMipmap(&self, target: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenerateMipmap({:#X});", target);
      }
      let p = self.glGenerateMipmap_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(target),
        None => go_panic_because_fn_not_loaded("glGenerateMipmap"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGenerateMipmap" != "glGetError" {
          report_error_as_necessary_from("GenerateMipmap", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GenerateMipmap_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGenerateMipmap\0");
      self.glGenerateMipmap_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenerateMipmap_is_loaded(&self) -> bool {
      !self.glGenerateMipmap_p.load(RELAX).is_null()
    }
    /// [glGenerateTextureMipmap](http://docs.gl/gl4/glGenerateTextureMipmap)(texture)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GenerateTextureMipmap(&self, texture: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GenerateTextureMipmap({:?});", texture);
      }
      let p = self.glGenerateTextureMipmap_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(texture),
        None => go_panic_because_fn_not_loaded("glGenerateTextureMipmap"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGenerateTextureMipmap" != "glGetError" {
          report_error_as_necessary_from(
            "GenerateTextureMipmap",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GenerateTextureMipmap_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGenerateTextureMipmap\0");
      self.glGenerateTextureMipmap_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GenerateTextureMipmap_is_loaded(&self) -> bool {
      !self.glGenerateTextureMipmap_p.load(RELAX).is_null()
    }
    /// [glGetActiveAtomicCounterBufferiv](http://docs.gl/gl4/glGetActiveAtomicCounterBufferiv)(program, bufferIndex, pname, params)
    /// * `pname` group: AtomicCounterBufferPName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveAtomicCounterBufferiv(
      &self,
      program: GLuint,
      bufferIndex: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetActiveAtomicCounterBufferiv({:?}, {:?}, {:#X}, {:p});",
          program,
          bufferIndex,
          pname,
          params
        );
      }
      let p = self.glGetActiveAtomicCounterBufferiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLenum, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, bufferIndex, pname, params),
        None => {
          go_panic_because_fn_not_loaded("glGetActiveAtomicCounterBufferiv")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetActiveAtomicCounterBufferiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetActiveAtomicCounterBufferiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetActiveAtomicCounterBufferiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glGetActiveAtomicCounterBufferiv\0");
      self.glGetActiveAtomicCounterBufferiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveAtomicCounterBufferiv_is_loaded(&self) -> bool {
      !self.glGetActiveAtomicCounterBufferiv_p.load(RELAX).is_null()
    }
    /// [glGetActiveAttrib](http://docs.gl/gl4/glGetActiveAttrib)(program, index, bufSize, length, size, type_, name)
    /// * `length` len: 1
    /// * `size` len: 1
    /// * `type_` group: AttributeType
    /// * `type_` len: 1
    /// * `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveAttrib(
      &self,
      program: GLuint,
      index: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      size: *mut GLint,
      type_: *mut GLenum,
      name: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetActiveAttrib({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});", program, index, bufSize, length, size, type_, name);
      }
      let p = self.glGetActiveAttrib_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLuint,
            GLsizei,
            *mut GLsizei,
            *mut GLint,
            *mut GLenum,
            *mut GLchar,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, index, bufSize, length, size, type_, name),
        None => go_panic_because_fn_not_loaded("glGetActiveAttrib"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetActiveAttrib" != "glGetError" {
          report_error_as_necessary_from("GetActiveAttrib", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetActiveAttrib_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetActiveAttrib\0");
      self.glGetActiveAttrib_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveAttrib_is_loaded(&self) -> bool {
      !self.glGetActiveAttrib_p.load(RELAX).is_null()
    }
    /// [glGetActiveSubroutineName](http://docs.gl/gl4/glGetActiveSubroutineName)(program, shadertype, index, bufSize, length, name)
    /// * `shadertype` group: ShaderType
    /// * `length` len: 1
    /// * `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveSubroutineName(
      &self,
      program: GLuint,
      shadertype: GLenum,
      index: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      name: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetActiveSubroutineName({:?}, {:#X}, {:?}, {:?}, {:p}, {:p});", program, shadertype, index, bufSize, length, name);
      }
      let p = self.glGetActiveSubroutineName_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLenum,
            GLuint,
            GLsizei,
            *mut GLsizei,
            *mut GLchar,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, shadertype, index, bufSize, length, name),
        None => go_panic_because_fn_not_loaded("glGetActiveSubroutineName"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetActiveSubroutineName" != "glGetError" {
          report_error_as_necessary_from(
            "GetActiveSubroutineName",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetActiveSubroutineName_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetActiveSubroutineName\0");
      self.glGetActiveSubroutineName_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveSubroutineName_is_loaded(&self) -> bool {
      !self.glGetActiveSubroutineName_p.load(RELAX).is_null()
    }
    /// [glGetActiveSubroutineUniformName](http://docs.gl/gl4/glGetActiveSubroutineUniformName)(program, shadertype, index, bufSize, length, name)
    /// * `shadertype` group: ShaderType
    /// * `length` len: 1
    /// * `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveSubroutineUniformName(
      &self,
      program: GLuint,
      shadertype: GLenum,
      index: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      name: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetActiveSubroutineUniformName({:?}, {:#X}, {:?}, {:?}, {:p}, {:p});", program, shadertype, index, bufSize, length, name);
      }
      let p = self.glGetActiveSubroutineUniformName_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLenum,
            GLuint,
            GLsizei,
            *mut GLsizei,
            *mut GLchar,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, shadertype, index, bufSize, length, name),
        None => {
          go_panic_because_fn_not_loaded("glGetActiveSubroutineUniformName")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetActiveSubroutineUniformName" != "glGetError" {
          report_error_as_necessary_from(
            "GetActiveSubroutineUniformName",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetActiveSubroutineUniformName_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glGetActiveSubroutineUniformName\0");
      self.glGetActiveSubroutineUniformName_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveSubroutineUniformName_is_loaded(&self) -> bool {
      !self.glGetActiveSubroutineUniformName_p.load(RELAX).is_null()
    }
    /// [glGetActiveSubroutineUniformiv](http://docs.gl/gl4/glGetActiveSubroutineUniformiv)(program, shadertype, index, pname, values)
    /// * `shadertype` group: ShaderType
    /// * `pname` group: SubroutineParameterName
    /// * `values` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveSubroutineUniformiv(
      &self,
      program: GLuint,
      shadertype: GLenum,
      index: GLuint,
      pname: GLenum,
      values: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetActiveSubroutineUniformiv({:?}, {:#X}, {:?}, {:#X}, {:p});", program, shadertype, index, pname, values);
      }
      let p = self.glGetActiveSubroutineUniformiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLuint, GLenum, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, shadertype, index, pname, values),
        None => {
          go_panic_because_fn_not_loaded("glGetActiveSubroutineUniformiv")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetActiveSubroutineUniformiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetActiveSubroutineUniformiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetActiveSubroutineUniformiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glGetActiveSubroutineUniformiv\0");
      self.glGetActiveSubroutineUniformiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveSubroutineUniformiv_is_loaded(&self) -> bool {
      !self.glGetActiveSubroutineUniformiv_p.load(RELAX).is_null()
    }
    /// [glGetActiveUniform](http://docs.gl/gl4/glGetActiveUniform)(program, index, bufSize, length, size, type_, name)
    /// * `length` len: 1
    /// * `size` len: 1
    /// * `type_` group: UniformType
    /// * `type_` len: 1
    /// * `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveUniform(
      &self,
      program: GLuint,
      index: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      size: *mut GLint,
      type_: *mut GLenum,
      name: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetActiveUniform({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});", program, index, bufSize, length, size, type_, name);
      }
      let p = self.glGetActiveUniform_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLuint,
            GLsizei,
            *mut GLsizei,
            *mut GLint,
            *mut GLenum,
            *mut GLchar,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, index, bufSize, length, size, type_, name),
        None => go_panic_because_fn_not_loaded("glGetActiveUniform"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetActiveUniform" != "glGetError" {
          report_error_as_necessary_from("GetActiveUniform", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetActiveUniform_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetActiveUniform\0");
      self.glGetActiveUniform_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveUniform_is_loaded(&self) -> bool {
      !self.glGetActiveUniform_p.load(RELAX).is_null()
    }
    /// [glGetActiveUniformBlockName](http://docs.gl/gl4/glGetActiveUniformBlockName)(program, uniformBlockIndex, bufSize, length, uniformBlockName)
    /// * `length` len: 1
    /// * `uniformBlockName` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveUniformBlockName(
      &self,
      program: GLuint,
      uniformBlockIndex: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      uniformBlockName: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetActiveUniformBlockName({:?}, {:?}, {:?}, {:p}, {:p});",
          program,
          uniformBlockIndex,
          bufSize,
          length,
          uniformBlockName
        );
      }
      let p = self.glGetActiveUniformBlockName_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLuint,
            GLsizei,
            *mut GLsizei,
            *mut GLchar,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(program, uniformBlockIndex, bufSize, length, uniformBlockName)
        }
        None => go_panic_because_fn_not_loaded("glGetActiveUniformBlockName"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetActiveUniformBlockName" != "glGetError" {
          report_error_as_necessary_from(
            "GetActiveUniformBlockName",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetActiveUniformBlockName_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetActiveUniformBlockName\0");
      self.glGetActiveUniformBlockName_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveUniformBlockName_is_loaded(&self) -> bool {
      !self.glGetActiveUniformBlockName_p.load(RELAX).is_null()
    }
    /// [glGetActiveUniformBlockiv](http://docs.gl/gl4/glGetActiveUniformBlockiv)(program, uniformBlockIndex, pname, params)
    /// * `pname` group: UniformBlockPName
    /// * `params` len: COMPSIZE(program,uniformBlockIndex,pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveUniformBlockiv(
      &self,
      program: GLuint,
      uniformBlockIndex: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetActiveUniformBlockiv({:?}, {:?}, {:#X}, {:p});",
          program,
          uniformBlockIndex,
          pname,
          params
        );
      }
      let p = self.glGetActiveUniformBlockiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLenum, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, uniformBlockIndex, pname, params),
        None => go_panic_because_fn_not_loaded("glGetActiveUniformBlockiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetActiveUniformBlockiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetActiveUniformBlockiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetActiveUniformBlockiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetActiveUniformBlockiv\0");
      self.glGetActiveUniformBlockiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveUniformBlockiv_is_loaded(&self) -> bool {
      !self.glGetActiveUniformBlockiv_p.load(RELAX).is_null()
    }
    /// [glGetActiveUniformName](http://docs.gl/gl4/glGetActiveUniformName)(program, uniformIndex, bufSize, length, uniformName)
    /// * `length` len: 1
    /// * `uniformName` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveUniformName(
      &self,
      program: GLuint,
      uniformIndex: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      uniformName: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetActiveUniformName({:?}, {:?}, {:?}, {:p}, {:p});",
          program,
          uniformIndex,
          bufSize,
          length,
          uniformName
        );
      }
      let p = self.glGetActiveUniformName_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLuint,
            GLsizei,
            *mut GLsizei,
            *mut GLchar,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, uniformIndex, bufSize, length, uniformName),
        None => go_panic_because_fn_not_loaded("glGetActiveUniformName"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetActiveUniformName" != "glGetError" {
          report_error_as_necessary_from(
            "GetActiveUniformName",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetActiveUniformName_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetActiveUniformName\0");
      self.glGetActiveUniformName_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveUniformName_is_loaded(&self) -> bool {
      !self.glGetActiveUniformName_p.load(RELAX).is_null()
    }
    /// [glGetActiveUniformsiv](http://docs.gl/gl4/glGetActiveUniformsiv)(program, uniformCount, uniformIndices, pname, params)
    /// * `uniformIndices` len: uniformCount
    /// * `pname` group: UniformPName
    /// * `params` len: COMPSIZE(uniformCount,pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetActiveUniformsiv(
      &self,
      program: GLuint,
      uniformCount: GLsizei,
      uniformIndices: *const GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetActiveUniformsiv({:?}, {:?}, {:p}, {:#X}, {:p});",
          program,
          uniformCount,
          uniformIndices,
          pname,
          params
        );
      }
      let p = self.glGetActiveUniformsiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLsizei,
            *const GLuint,
            GLenum,
            *mut GLint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(program, uniformCount, uniformIndices, pname, params)
        }
        None => go_panic_because_fn_not_loaded("glGetActiveUniformsiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetActiveUniformsiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetActiveUniformsiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetActiveUniformsiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetActiveUniformsiv\0");
      self.glGetActiveUniformsiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetActiveUniformsiv_is_loaded(&self) -> bool {
      !self.glGetActiveUniformsiv_p.load(RELAX).is_null()
    }
    /// [glGetAttachedShaders](http://docs.gl/gl4/glGetAttachedShaders)(program, maxCount, count, shaders)
    /// * `count` len: 1
    /// * `shaders` len: maxCount
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetAttachedShaders(
      &self,
      program: GLuint,
      maxCount: GLsizei,
      count: *mut GLsizei,
      shaders: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetAttachedShaders({:?}, {:?}, {:p}, {:p});",
          program,
          maxCount,
          count,
          shaders
        );
      }
      let p = self.glGetAttachedShaders_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, maxCount, count, shaders),
        None => go_panic_because_fn_not_loaded("glGetAttachedShaders"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetAttachedShaders" != "glGetError" {
          report_error_as_necessary_from("GetAttachedShaders", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetAttachedShaders_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetAttachedShaders\0");
      self.glGetAttachedShaders_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetAttachedShaders_is_loaded(&self) -> bool {
      !self.glGetAttachedShaders_p.load(RELAX).is_null()
    }
    /// [glGetAttribLocation](http://docs.gl/gl4/glGetAttribLocation)(program, name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetAttribLocation(
      &self,
      program: GLuint,
      name: *const GLchar,
    ) -> GLint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetAttribLocation({:?}, {:p});", program, name);
      }
      let p = self.glGetAttribLocation_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, *const GLchar) -> GLint>>(p)
        {
          Some(fn_p) => fn_p(program, name),
          None => go_panic_because_fn_not_loaded("glGetAttribLocation"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetAttribLocation" != "glGetError" {
          report_error_as_necessary_from("GetAttribLocation", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetAttribLocation_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetAttribLocation\0");
      self.glGetAttribLocation_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetAttribLocation_is_loaded(&self) -> bool {
      !self.glGetAttribLocation_p.load(RELAX).is_null()
    }
    /// [glGetBooleani_v](http://docs.gl/gl4/glGetBooleani_v)(target, index, data)
    /// * `target` group: BufferTargetARB
    /// * `data` len: COMPSIZE(target)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetBooleani_v(
      &self,
      target: GLenum,
      index: GLuint,
      data: *mut GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetBooleani_v({:#X}, {:?}, {:p});",
          target,
          index,
          data
        );
      }
      let p = self.glGetBooleani_v_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLuint, *mut GLboolean)>>(p)
        {
          Some(fn_p) => fn_p(target, index, data),
          None => go_panic_because_fn_not_loaded("glGetBooleani_v"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetBooleani_v" != "glGetError" {
          report_error_as_necessary_from("GetBooleani_v", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetBooleani_v_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetBooleani_v\0");
      self.glGetBooleani_v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetBooleani_v_is_loaded(&self) -> bool {
      !self.glGetBooleani_v_p.load(RELAX).is_null()
    }
    /// [glGetBooleanv](http://docs.gl/gl4/glGetBooleanv)(pname, data)
    /// * `pname` group: GetPName
    /// * `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetBooleanv(&self, pname: GLenum, data: *mut GLboolean) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetBooleanv({:#X}, {:p});", pname, data);
      }
      let p = self.glGetBooleanv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, *mut GLboolean)>>(p)
      {
        Some(fn_p) => fn_p(pname, data),
        None => go_panic_because_fn_not_loaded("glGetBooleanv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetBooleanv" != "glGetError" {
          report_error_as_necessary_from("GetBooleanv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetBooleanv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetBooleanv\0");
      self.glGetBooleanv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetBooleanv_is_loaded(&self) -> bool {
      !self.glGetBooleanv_p.load(RELAX).is_null()
    }
    /// [glGetBufferParameteri64v](http://docs.gl/gl4/glGetBufferParameter)(target, pname, params)
    /// * `target` group: BufferTargetARB
    /// * `pname` group: BufferPNameARB
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetBufferParameteri64v(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *mut GLint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetBufferParameteri64v({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glGetBufferParameteri64v_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint64)>>(p) {
          Some(fn_p) => fn_p(target, pname, params),
          None => go_panic_because_fn_not_loaded("glGetBufferParameteri64v"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetBufferParameteri64v" != "glGetError" {
          report_error_as_necessary_from(
            "GetBufferParameteri64v",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetBufferParameteri64v_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetBufferParameteri64v\0");
      self.glGetBufferParameteri64v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetBufferParameteri64v_is_loaded(&self) -> bool {
      !self.glGetBufferParameteri64v_p.load(RELAX).is_null()
    }
    /// [glGetBufferParameteriv](http://docs.gl/gl4/glGetBufferParameter)(target, pname, params)
    /// * `target` group: BufferTargetARB
    /// * `pname` group: BufferPNameARB
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetBufferParameteriv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetBufferParameteriv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glGetBufferParameteriv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(target, pname, params),
          None => go_panic_because_fn_not_loaded("glGetBufferParameteriv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetBufferParameteriv" != "glGetError" {
          report_error_as_necessary_from(
            "GetBufferParameteriv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetBufferParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetBufferParameteriv\0");
      self.glGetBufferParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetBufferParameteriv_is_loaded(&self) -> bool {
      !self.glGetBufferParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetBufferPointerv](http://docs.gl/gl4/glGetBufferPointerv)(target, pname, params)
    /// * `target` group: BufferTargetARB
    /// * `pname` group: BufferPointerNameARB
    /// * `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetBufferPointerv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *mut *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetBufferPointerv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glGetBufferPointerv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut *mut c_void)>>(
          p,
        ) {
          Some(fn_p) => fn_p(target, pname, params),
          None => go_panic_because_fn_not_loaded("glGetBufferPointerv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetBufferPointerv" != "glGetError" {
          report_error_as_necessary_from("GetBufferPointerv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetBufferPointerv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetBufferPointerv\0");
      self.glGetBufferPointerv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetBufferPointerv_is_loaded(&self) -> bool {
      !self.glGetBufferPointerv_p.load(RELAX).is_null()
    }
    /// [glGetBufferSubData](http://docs.gl/gl4/glGetBufferSubData)(target, offset, size, data)
    /// * `target` group: BufferTargetARB
    /// * `offset` group: BufferOffset
    /// * `size` group: BufferSize
    /// * `data` len: size
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetBufferSubData(
      &self,
      target: GLenum,
      offset: GLintptr,
      size: GLsizeiptr,
      data: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetBufferSubData({:#X}, {:?}, {:?}, {:p});",
          target,
          offset,
          size,
          data
        );
      }
      let p = self.glGetBufferSubData_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLintptr, GLsizeiptr, *mut c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, offset, size, data),
        None => go_panic_because_fn_not_loaded("glGetBufferSubData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetBufferSubData" != "glGetError" {
          report_error_as_necessary_from("GetBufferSubData", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetBufferSubData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetBufferSubData\0");
      self.glGetBufferSubData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetBufferSubData_is_loaded(&self) -> bool {
      !self.glGetBufferSubData_p.load(RELAX).is_null()
    }
    /// [glGetCompressedTexImage](http://docs.gl/gl4/glGetCompressedTexImage)(target, level, img)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `img` group: CompressedTextureARB
    /// * `img` len: COMPSIZE(target,level)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetCompressedTexImage(
      &self,
      target: GLenum,
      level: GLint,
      img: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetCompressedTexImage({:#X}, {:?}, {:p});",
          target,
          level,
          img
        );
      }
      let p = self.glGetCompressedTexImage_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLint, *mut c_void)>>(p) {
          Some(fn_p) => fn_p(target, level, img),
          None => go_panic_because_fn_not_loaded("glGetCompressedTexImage"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetCompressedTexImage" != "glGetError" {
          report_error_as_necessary_from(
            "GetCompressedTexImage",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetCompressedTexImage_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetCompressedTexImage\0");
      self.glGetCompressedTexImage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetCompressedTexImage_is_loaded(&self) -> bool {
      !self.glGetCompressedTexImage_p.load(RELAX).is_null()
    }
    /// [glGetCompressedTextureImage](http://docs.gl/gl4/glGetCompressedTextureImage)(texture, level, bufSize, pixels)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetCompressedTextureImage(
      &self,
      texture: GLuint,
      level: GLint,
      bufSize: GLsizei,
      pixels: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetCompressedTextureImage({:?}, {:?}, {:?}, {:p});",
          texture,
          level,
          bufSize,
          pixels
        );
      }
      let p = self.glGetCompressedTextureImage_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *mut c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(texture, level, bufSize, pixels),
        None => go_panic_because_fn_not_loaded("glGetCompressedTextureImage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetCompressedTextureImage" != "glGetError" {
          report_error_as_necessary_from(
            "GetCompressedTextureImage",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetCompressedTextureImage_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetCompressedTextureImage\0");
      self.glGetCompressedTextureImage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetCompressedTextureImage_is_loaded(&self) -> bool {
      !self.glGetCompressedTextureImage_p.load(RELAX).is_null()
    }
    /// [glGetCompressedTextureSubImage](http://docs.gl/gl4/glGetCompressedTextureSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetCompressedTextureSubImage(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      zoffset: GLint,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
      bufSize: GLsizei,
      pixels: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetCompressedTextureSubImage({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
      }
      let p = self.glGetCompressedTextureSubImage_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLsizei,
            GLsizei,
            *mut c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          texture, level, xoffset, yoffset, zoffset, width, height, depth,
          bufSize, pixels,
        ),
        None => {
          go_panic_because_fn_not_loaded("glGetCompressedTextureSubImage")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetCompressedTextureSubImage" != "glGetError" {
          report_error_as_necessary_from(
            "GetCompressedTextureSubImage",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetCompressedTextureSubImage_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glGetCompressedTextureSubImage\0");
      self.glGetCompressedTextureSubImage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetCompressedTextureSubImage_is_loaded(&self) -> bool {
      !self.glGetCompressedTextureSubImage_p.load(RELAX).is_null()
    }
    /// [glGetDebugMessageLog](http://docs.gl/gl4/glGetDebugMessageLog)(count, bufSize, sources, types, ids, severities, lengths, messageLog)
    /// * `sources` group: DebugSource
    /// * `sources` len: count
    /// * `types` group: DebugType
    /// * `types` len: count
    /// * `ids` len: count
    /// * `severities` group: DebugSeverity
    /// * `severities` len: count
    /// * `lengths` len: count
    /// * `messageLog` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetDebugMessageLog(
      &self,
      count: GLuint,
      bufSize: GLsizei,
      sources: *mut GLenum,
      types: *mut GLenum,
      ids: *mut GLuint,
      severities: *mut GLenum,
      lengths: *mut GLsizei,
      messageLog: *mut GLchar,
    ) -> GLuint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetDebugMessageLog({:?}, {:?}, {:p}, {:p}, {:p}, {:p}, {:p}, {:p});", count, bufSize, sources, types, ids, severities, lengths, messageLog);
      }
      let p = self.glGetDebugMessageLog_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLsizei,
            *mut GLenum,
            *mut GLenum,
            *mut GLuint,
            *mut GLenum,
            *mut GLsizei,
            *mut GLchar,
          ) -> GLuint,
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          count, bufSize, sources, types, ids, severities, lengths, messageLog,
        ),
        None => go_panic_because_fn_not_loaded("glGetDebugMessageLog"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetDebugMessageLog" != "glGetError" {
          report_error_as_necessary_from("GetDebugMessageLog", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetDebugMessageLog_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetDebugMessageLog\0");
      self.glGetDebugMessageLog_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetDebugMessageLog_is_loaded(&self) -> bool {
      !self.glGetDebugMessageLog_p.load(RELAX).is_null()
    }
    /// [glGetDoublei_v](http://docs.gl/gl4/glGetDoublei_v)(target, index, data)
    /// * `data` len: COMPSIZE(target)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetDoublei_v(
      &self,
      target: GLenum,
      index: GLuint,
      data: *mut GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetDoublei_v({:#X}, {:?}, {:p});",
          target,
          index,
          data
        );
      }
      let p = self.glGetDoublei_v_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLuint, *mut GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, index, data),
        None => go_panic_because_fn_not_loaded("glGetDoublei_v"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetDoublei_v" != "glGetError" {
          report_error_as_necessary_from("GetDoublei_v", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetDoublei_v_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetDoublei_v\0");
      self.glGetDoublei_v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetDoublei_v_is_loaded(&self) -> bool {
      !self.glGetDoublei_v_p.load(RELAX).is_null()
    }
    /// [glGetDoublev](http://docs.gl/gl4/glGetDoublev)(pname, data)
    /// * `pname` group: GetPName
    /// * `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetDoublev(&self, pname: GLenum, data: *mut GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetDoublev({:#X}, {:p});", pname, data);
      }
      let p = self.glGetDoublev_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, *mut GLdouble)>>(p) {
        Some(fn_p) => fn_p(pname, data),
        None => go_panic_because_fn_not_loaded("glGetDoublev"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetDoublev" != "glGetError" {
          report_error_as_necessary_from("GetDoublev", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetDoublev_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetDoublev\0");
      self.glGetDoublev_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetDoublev_is_loaded(&self) -> bool {
      !self.glGetDoublev_p.load(RELAX).is_null()
    }
    /// [glGetError](http://docs.gl/gl4/glGetError)()
    /// * return value group: ErrorCode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetError(&self) -> GLenum {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetError();",);
      }
      let p = self.glGetError_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn() -> GLenum>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded("glGetError"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetError" != "glGetError" {
          report_error_as_necessary_from("GetError", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetError_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetError\0");
      self.glGetError_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetError_is_loaded(&self) -> bool {
      !self.glGetError_p.load(RELAX).is_null()
    }
    /// [glGetFloati_v](http://docs.gl/gl4/glGetFloati_v)(target, index, data)
    /// * `data` len: COMPSIZE(target)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetFloati_v(
      &self,
      target: GLenum,
      index: GLuint,
      data: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetFloati_v({:#X}, {:?}, {:p});",
          target,
          index,
          data
        );
      }
      let p = self.glGetFloati_v_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLuint, *mut GLfloat)>>(p) {
          Some(fn_p) => fn_p(target, index, data),
          None => go_panic_because_fn_not_loaded("glGetFloati_v"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetFloati_v" != "glGetError" {
          report_error_as_necessary_from("GetFloati_v", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetFloati_v_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetFloati_v\0");
      self.glGetFloati_v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetFloati_v_is_loaded(&self) -> bool {
      !self.glGetFloati_v_p.load(RELAX).is_null()
    }
    /// [glGetFloatv](http://docs.gl/gl4/glGetFloatv)(pname, data)
    /// * `pname` group: GetPName
    /// * `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetFloatv(&self, pname: GLenum, data: *mut GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetFloatv({:#X}, {:p});", pname, data);
      }
      let p = self.glGetFloatv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, *mut GLfloat)>>(p) {
        Some(fn_p) => fn_p(pname, data),
        None => go_panic_because_fn_not_loaded("glGetFloatv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetFloatv" != "glGetError" {
          report_error_as_necessary_from("GetFloatv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetFloatv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetFloatv\0");
      self.glGetFloatv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetFloatv_is_loaded(&self) -> bool {
      !self.glGetFloatv_p.load(RELAX).is_null()
    }
    /// [glGetFragDataIndex](http://docs.gl/gl4/glGetFragDataIndex)(program, name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetFragDataIndex(
      &self,
      program: GLuint,
      name: *const GLchar,
    ) -> GLint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetFragDataIndex({:?}, {:p});", program, name);
      }
      let p = self.glGetFragDataIndex_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, *const GLchar) -> GLint>>(p)
        {
          Some(fn_p) => fn_p(program, name),
          None => go_panic_because_fn_not_loaded("glGetFragDataIndex"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetFragDataIndex" != "glGetError" {
          report_error_as_necessary_from("GetFragDataIndex", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetFragDataIndex_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetFragDataIndex\0");
      self.glGetFragDataIndex_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetFragDataIndex_is_loaded(&self) -> bool {
      !self.glGetFragDataIndex_p.load(RELAX).is_null()
    }
    /// [glGetFragDataLocation](http://docs.gl/gl4/glGetFragDataLocation)(program, name)
    /// * `name` len: COMPSIZE(name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetFragDataLocation(
      &self,
      program: GLuint,
      name: *const GLchar,
    ) -> GLint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetFragDataLocation({:?}, {:p});", program, name);
      }
      let p = self.glGetFragDataLocation_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, *const GLchar) -> GLint>>(p)
        {
          Some(fn_p) => fn_p(program, name),
          None => go_panic_because_fn_not_loaded("glGetFragDataLocation"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetFragDataLocation" != "glGetError" {
          report_error_as_necessary_from(
            "GetFragDataLocation",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetFragDataLocation_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetFragDataLocation\0");
      self.glGetFragDataLocation_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetFragDataLocation_is_loaded(&self) -> bool {
      !self.glGetFragDataLocation_p.load(RELAX).is_null()
    }
    /// [glGetFramebufferAttachmentParameteriv](http://docs.gl/gl4/glGetFramebufferAttachmentParameteriv)(target, attachment, pname, params)
    /// * `target` group: FramebufferTarget
    /// * `attachment` group: FramebufferAttachment
    /// * `pname` group: FramebufferAttachmentParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetFramebufferAttachmentParameteriv(
      &self,
      target: GLenum,
      attachment: GLenum,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetFramebufferAttachmentParameteriv({:#X}, {:#X}, {:#X}, {:p});", target, attachment, pname, params);
      }
      let p = self.glGetFramebufferAttachmentParameteriv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLenum, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, attachment, pname, params),
        None => go_panic_because_fn_not_loaded(
          "glGetFramebufferAttachmentParameteriv",
        ),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetFramebufferAttachmentParameteriv" != "glGetError" {
          report_error_as_necessary_from(
            "GetFramebufferAttachmentParameteriv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetFramebufferAttachmentParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(
        get_proc_address,
        b"glGetFramebufferAttachmentParameteriv\0",
      );
      self.glGetFramebufferAttachmentParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetFramebufferAttachmentParameteriv_is_loaded(&self) -> bool {
      !self.glGetFramebufferAttachmentParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetFramebufferParameteriv](http://docs.gl/gl4/glGetFramebufferParameteriv)(target, pname, params)
    /// * `target` group: FramebufferTarget
    /// * `pname` group: FramebufferAttachmentParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetFramebufferParameteriv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetFramebufferParameteriv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glGetFramebufferParameteriv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(target, pname, params),
          None => go_panic_because_fn_not_loaded("glGetFramebufferParameteriv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetFramebufferParameteriv" != "glGetError" {
          report_error_as_necessary_from(
            "GetFramebufferParameteriv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetFramebufferParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetFramebufferParameteriv\0");
      self.glGetFramebufferParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetFramebufferParameteriv_is_loaded(&self) -> bool {
      !self.glGetFramebufferParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetGraphicsResetStatus](http://docs.gl/gl4/glGetGraphicsResetStatus)()
    /// * return value group: GraphicsResetStatus
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetGraphicsResetStatus(&self) -> GLenum {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetGraphicsResetStatus();",);
      }
      let p = self.glGetGraphicsResetStatus_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn() -> GLenum>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded("glGetGraphicsResetStatus"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetGraphicsResetStatus" != "glGetError" {
          report_error_as_necessary_from(
            "GetGraphicsResetStatus",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetGraphicsResetStatus_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetGraphicsResetStatus\0");
      self.glGetGraphicsResetStatus_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetGraphicsResetStatus_is_loaded(&self) -> bool {
      !self.glGetGraphicsResetStatus_p.load(RELAX).is_null()
    }
    /// [glGetInteger64i_v](http://docs.gl/gl4/glGetInteger64i_v)(target, index, data)
    /// * `data` len: COMPSIZE(target)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetInteger64i_v(
      &self,
      target: GLenum,
      index: GLuint,
      data: *mut GLint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetInteger64i_v({:#X}, {:?}, {:p});",
          target,
          index,
          data
        );
      }
      let p = self.glGetInteger64i_v_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLuint, *mut GLint64)>>(p) {
          Some(fn_p) => fn_p(target, index, data),
          None => go_panic_because_fn_not_loaded("glGetInteger64i_v"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetInteger64i_v" != "glGetError" {
          report_error_as_necessary_from("GetInteger64i_v", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetInteger64i_v_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetInteger64i_v\0");
      self.glGetInteger64i_v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetInteger64i_v_is_loaded(&self) -> bool {
      !self.glGetInteger64i_v_p.load(RELAX).is_null()
    }
    /// [glGetInteger64v](http://docs.gl/gl4/glGetInteger64v)(pname, data)
    /// * `pname` group: GetPName
    /// * `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetInteger64v(&self, pname: GLenum, data: *mut GLint64) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetInteger64v({:#X}, {:p});", pname, data);
      }
      let p = self.glGetInteger64v_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, *mut GLint64)>>(p) {
        Some(fn_p) => fn_p(pname, data),
        None => go_panic_because_fn_not_loaded("glGetInteger64v"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetInteger64v" != "glGetError" {
          report_error_as_necessary_from("GetInteger64v", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetInteger64v_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetInteger64v\0");
      self.glGetInteger64v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetInteger64v_is_loaded(&self) -> bool {
      !self.glGetInteger64v_p.load(RELAX).is_null()
    }
    /// [glGetIntegeri_v](http://docs.gl/gl4/glGetIntegeri_v)(target, index, data)
    /// * `data` len: COMPSIZE(target)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetIntegeri_v(
      &self,
      target: GLenum,
      index: GLuint,
      data: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetIntegeri_v({:#X}, {:?}, {:p});",
          target,
          index,
          data
        );
      }
      let p = self.glGetIntegeri_v_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLuint, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(target, index, data),
          None => go_panic_because_fn_not_loaded("glGetIntegeri_v"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetIntegeri_v" != "glGetError" {
          report_error_as_necessary_from("GetIntegeri_v", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetIntegeri_v_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetIntegeri_v\0");
      self.glGetIntegeri_v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetIntegeri_v_is_loaded(&self) -> bool {
      !self.glGetIntegeri_v_p.load(RELAX).is_null()
    }
    /// [glGetIntegerv](http://docs.gl/gl4/glGetIntegerv)(pname, data)
    /// * `pname` group: GetPName
    /// * `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetIntegerv(&self, pname: GLenum, data: *mut GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetIntegerv({:#X}, {:p});", pname, data);
      }
      let p = self.glGetIntegerv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, *mut GLint)>>(p) {
        Some(fn_p) => fn_p(pname, data),
        None => go_panic_because_fn_not_loaded("glGetIntegerv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetIntegerv" != "glGetError" {
          report_error_as_necessary_from("GetIntegerv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetIntegerv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetIntegerv\0");
      self.glGetIntegerv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetIntegerv_is_loaded(&self) -> bool {
      !self.glGetIntegerv_p.load(RELAX).is_null()
    }
    /// [glGetInternalformati64v](http://docs.gl/gl4/glGetInternalformati64v)(target, internalformat, pname, count, params)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    /// * `pname` group: InternalFormatPName
    /// * `params` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetInternalformati64v(
      &self,
      target: GLenum,
      internalformat: GLenum,
      pname: GLenum,
      count: GLsizei,
      params: *mut GLint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetInternalformati64v({:#X}, {:#X}, {:#X}, {:?}, {:p});",
          target,
          internalformat,
          pname,
          count,
          params
        );
      }
      let p = self.glGetInternalformati64v_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut GLint64)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, internalformat, pname, count, params),
        None => go_panic_because_fn_not_loaded("glGetInternalformati64v"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetInternalformati64v" != "glGetError" {
          report_error_as_necessary_from(
            "GetInternalformati64v",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetInternalformati64v_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetInternalformati64v\0");
      self.glGetInternalformati64v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetInternalformati64v_is_loaded(&self) -> bool {
      !self.glGetInternalformati64v_p.load(RELAX).is_null()
    }
    /// [glGetInternalformativ](http://docs.gl/gl4/glGetInternalformativ)(target, internalformat, pname, count, params)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    /// * `pname` group: InternalFormatPName
    /// * `params` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetInternalformativ(
      &self,
      target: GLenum,
      internalformat: GLenum,
      pname: GLenum,
      count: GLsizei,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetInternalformativ({:#X}, {:#X}, {:#X}, {:?}, {:p});",
          target,
          internalformat,
          pname,
          count,
          params
        );
      }
      let p = self.glGetInternalformativ_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, internalformat, pname, count, params),
        None => go_panic_because_fn_not_loaded("glGetInternalformativ"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetInternalformativ" != "glGetError" {
          report_error_as_necessary_from(
            "GetInternalformativ",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetInternalformativ_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetInternalformativ\0");
      self.glGetInternalformativ_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetInternalformativ_is_loaded(&self) -> bool {
      !self.glGetInternalformativ_p.load(RELAX).is_null()
    }
    /// [glGetMultisamplefv](http://docs.gl/gl4/glGetMultisamplefv)(pname, index, val)
    /// * `pname` group: GetMultisamplePNameNV
    /// * `val` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetMultisamplefv(
      &self,
      pname: GLenum,
      index: GLuint,
      val: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetMultisamplefv({:#X}, {:?}, {:p});",
          pname,
          index,
          val
        );
      }
      let p = self.glGetMultisamplefv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLuint, *mut GLfloat)>>(p) {
          Some(fn_p) => fn_p(pname, index, val),
          None => go_panic_because_fn_not_loaded("glGetMultisamplefv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetMultisamplefv" != "glGetError" {
          report_error_as_necessary_from("GetMultisamplefv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetMultisamplefv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetMultisamplefv\0");
      self.glGetMultisamplefv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetMultisamplefv_is_loaded(&self) -> bool {
      !self.glGetMultisamplefv_p.load(RELAX).is_null()
    }
    /// [glGetNamedBufferParameteri64v](http://docs.gl/gl4/glGetBufferParameter)(buffer, pname, params)
    /// * `pname` group: BufferPNameARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetNamedBufferParameteri64v(
      &self,
      buffer: GLuint,
      pname: GLenum,
      params: *mut GLint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetNamedBufferParameteri64v({:?}, {:#X}, {:p});",
          buffer,
          pname,
          params
        );
      }
      let p = self.glGetNamedBufferParameteri64v_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint64)>>(p) {
          Some(fn_p) => fn_p(buffer, pname, params),
          None => {
            go_panic_because_fn_not_loaded("glGetNamedBufferParameteri64v")
          }
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetNamedBufferParameteri64v" != "glGetError" {
          report_error_as_necessary_from(
            "GetNamedBufferParameteri64v",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetNamedBufferParameteri64v_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetNamedBufferParameteri64v\0");
      self.glGetNamedBufferParameteri64v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetNamedBufferParameteri64v_is_loaded(&self) -> bool {
      !self.glGetNamedBufferParameteri64v_p.load(RELAX).is_null()
    }
    /// [glGetNamedBufferParameteriv](http://docs.gl/gl4/glGetBufferParameter)(buffer, pname, params)
    /// * `pname` group: BufferPNameARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetNamedBufferParameteriv(
      &self,
      buffer: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetNamedBufferParameteriv({:?}, {:#X}, {:p});",
          buffer,
          pname,
          params
        );
      }
      let p = self.glGetNamedBufferParameteriv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(buffer, pname, params),
          None => go_panic_because_fn_not_loaded("glGetNamedBufferParameteriv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetNamedBufferParameteriv" != "glGetError" {
          report_error_as_necessary_from(
            "GetNamedBufferParameteriv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetNamedBufferParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetNamedBufferParameteriv\0");
      self.glGetNamedBufferParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetNamedBufferParameteriv_is_loaded(&self) -> bool {
      !self.glGetNamedBufferParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetNamedBufferPointerv](http://docs.gl/gl4/glGetNamedBufferPointerv)(buffer, pname, params)
    /// * `pname` group: BufferPointerNameARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetNamedBufferPointerv(
      &self,
      buffer: GLuint,
      pname: GLenum,
      params: *mut *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetNamedBufferPointerv({:?}, {:#X}, {:p});",
          buffer,
          pname,
          params
        );
      }
      let p = self.glGetNamedBufferPointerv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut *mut c_void)>>(
          p,
        ) {
          Some(fn_p) => fn_p(buffer, pname, params),
          None => go_panic_because_fn_not_loaded("glGetNamedBufferPointerv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetNamedBufferPointerv" != "glGetError" {
          report_error_as_necessary_from(
            "GetNamedBufferPointerv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetNamedBufferPointerv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetNamedBufferPointerv\0");
      self.glGetNamedBufferPointerv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetNamedBufferPointerv_is_loaded(&self) -> bool {
      !self.glGetNamedBufferPointerv_p.load(RELAX).is_null()
    }
    /// [glGetNamedBufferSubData](http://docs.gl/gl4/glGetNamedBufferSubData)(buffer, offset, size, data)
    /// * `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetNamedBufferSubData(
      &self,
      buffer: GLuint,
      offset: GLintptr,
      size: GLsizeiptr,
      data: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetNamedBufferSubData({:?}, {:?}, {:?}, {:p});",
          buffer,
          offset,
          size,
          data
        );
      }
      let p = self.glGetNamedBufferSubData_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLintptr, GLsizeiptr, *mut c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(buffer, offset, size, data),
        None => go_panic_because_fn_not_loaded("glGetNamedBufferSubData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetNamedBufferSubData" != "glGetError" {
          report_error_as_necessary_from(
            "GetNamedBufferSubData",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetNamedBufferSubData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetNamedBufferSubData\0");
      self.glGetNamedBufferSubData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetNamedBufferSubData_is_loaded(&self) -> bool {
      !self.glGetNamedBufferSubData_p.load(RELAX).is_null()
    }
    /// [glGetNamedFramebufferAttachmentParameteriv](http://docs.gl/gl4/glGetNamedFramebufferAttachmentParameteriv)(framebuffer, attachment, pname, params)
    /// * `attachment` group: FramebufferAttachment
    /// * `pname` group: FramebufferAttachmentParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetNamedFramebufferAttachmentParameteriv(
      &self,
      framebuffer: GLuint,
      attachment: GLenum,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetNamedFramebufferAttachmentParameteriv({:?}, {:#X}, {:#X}, {:p});", framebuffer, attachment, pname, params);
      }
      let p = self.glGetNamedFramebufferAttachmentParameteriv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLenum, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(framebuffer, attachment, pname, params),
        None => go_panic_because_fn_not_loaded(
          "glGetNamedFramebufferAttachmentParameteriv",
        ),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetNamedFramebufferAttachmentParameteriv" != "glGetError" {
          report_error_as_necessary_from(
            "GetNamedFramebufferAttachmentParameteriv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetNamedFramebufferAttachmentParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(
        get_proc_address,
        b"glGetNamedFramebufferAttachmentParameteriv\0",
      );
      self.glGetNamedFramebufferAttachmentParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetNamedFramebufferAttachmentParameteriv_is_loaded(&self) -> bool {
      !self.glGetNamedFramebufferAttachmentParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetNamedFramebufferParameteriv](http://docs.gl/gl4/glGetNamedFramebufferParameteriv)(framebuffer, pname, param)
    /// * `pname` group: GetFramebufferParameter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetNamedFramebufferParameteriv(
      &self,
      framebuffer: GLuint,
      pname: GLenum,
      param: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetNamedFramebufferParameteriv({:?}, {:#X}, {:p});",
          framebuffer,
          pname,
          param
        );
      }
      let p = self.glGetNamedFramebufferParameteriv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(framebuffer, pname, param),
          None => {
            go_panic_because_fn_not_loaded("glGetNamedFramebufferParameteriv")
          }
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetNamedFramebufferParameteriv" != "glGetError" {
          report_error_as_necessary_from(
            "GetNamedFramebufferParameteriv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetNamedFramebufferParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glGetNamedFramebufferParameteriv\0");
      self.glGetNamedFramebufferParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetNamedFramebufferParameteriv_is_loaded(&self) -> bool {
      !self.glGetNamedFramebufferParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetNamedRenderbufferParameteriv](http://docs.gl/gl4/glGetNamedRenderbufferParameteriv)(renderbuffer, pname, params)
    /// * `pname` group: RenderbufferParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetNamedRenderbufferParameteriv(
      &self,
      renderbuffer: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetNamedRenderbufferParameteriv({:?}, {:#X}, {:p});",
          renderbuffer,
          pname,
          params
        );
      }
      let p = self.glGetNamedRenderbufferParameteriv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(renderbuffer, pname, params),
          None => {
            go_panic_because_fn_not_loaded("glGetNamedRenderbufferParameteriv")
          }
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetNamedRenderbufferParameteriv" != "glGetError" {
          report_error_as_necessary_from(
            "GetNamedRenderbufferParameteriv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetNamedRenderbufferParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glGetNamedRenderbufferParameteriv\0");
      self.glGetNamedRenderbufferParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetNamedRenderbufferParameteriv_is_loaded(&self) -> bool {
      !self.glGetNamedRenderbufferParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetObjectLabel](http://docs.gl/gl4/glGetObjectLabel)(identifier, name, bufSize, length, label)
    /// * `identifier` group: ObjectIdentifier
    /// * `length` len: 1
    /// * `label` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetObjectLabel(
      &self,
      identifier: GLenum,
      name: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      label: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetObjectLabel({:#X}, {:?}, {:?}, {:p}, {:p});",
          identifier,
          name,
          bufSize,
          length,
          label
        );
      }
      let p = self.glGetObjectLabel_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLuint,
            GLsizei,
            *mut GLsizei,
            *mut GLchar,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(identifier, name, bufSize, length, label),
        None => go_panic_because_fn_not_loaded("glGetObjectLabel"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetObjectLabel" != "glGetError" {
          report_error_as_necessary_from("GetObjectLabel", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetObjectLabel_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetObjectLabel\0");
      self.glGetObjectLabel_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetObjectLabel_is_loaded(&self) -> bool {
      !self.glGetObjectLabel_p.load(RELAX).is_null()
    }
    /// [glGetObjectPtrLabel](http://docs.gl/gl4/glGetObjectPtrLabel)(ptr, bufSize, length, label)
    /// * `length` len: 1
    /// * `label` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetObjectPtrLabel(
      &self,
      ptr: *const c_void,
      bufSize: GLsizei,
      length: *mut GLsizei,
      label: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetObjectPtrLabel({:p}, {:?}, {:p}, {:p});",
          ptr,
          bufSize,
          length,
          label
        );
      }
      let p = self.glGetObjectPtrLabel_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(*const c_void, GLsizei, *mut GLsizei, *mut GLchar),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(ptr, bufSize, length, label),
        None => go_panic_because_fn_not_loaded("glGetObjectPtrLabel"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetObjectPtrLabel" != "glGetError" {
          report_error_as_necessary_from("GetObjectPtrLabel", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetObjectPtrLabel_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetObjectPtrLabel\0");
      self.glGetObjectPtrLabel_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetObjectPtrLabel_is_loaded(&self) -> bool {
      !self.glGetObjectPtrLabel_p.load(RELAX).is_null()
    }
    /// [glGetPointerv](http://docs.gl/gl4/glGetPointerv)(pname, params)
    /// * `pname` group: GetPointervPName
    /// * `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetPointerv(&self, pname: GLenum, params: *mut *mut c_void) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetPointerv({:#X}, {:p});", pname, params);
      }
      let p = self.glGetPointerv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, *mut *mut c_void)>>(p) {
          Some(fn_p) => fn_p(pname, params),
          None => go_panic_because_fn_not_loaded("glGetPointerv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetPointerv" != "glGetError" {
          report_error_as_necessary_from("GetPointerv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetPointerv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetPointerv\0");
      self.glGetPointerv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetPointerv_is_loaded(&self) -> bool {
      !self.glGetPointerv_p.load(RELAX).is_null()
    }
    /// [glGetProgramBinary](http://docs.gl/gl4/glGetProgramBinary)(program, bufSize, length, binaryFormat, binary)
    /// * `length` len: 1
    /// * `binaryFormat` len: 1
    /// * `binary` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramBinary(
      &self,
      program: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      binaryFormat: *mut GLenum,
      binary: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetProgramBinary({:?}, {:?}, {:p}, {:p}, {:p});",
          program,
          bufSize,
          length,
          binaryFormat,
          binary
        );
      }
      let p = self.glGetProgramBinary_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLsizei,
            *mut GLsizei,
            *mut GLenum,
            *mut c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, bufSize, length, binaryFormat, binary),
        None => go_panic_because_fn_not_loaded("glGetProgramBinary"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetProgramBinary" != "glGetError" {
          report_error_as_necessary_from("GetProgramBinary", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetProgramBinary_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetProgramBinary\0");
      self.glGetProgramBinary_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramBinary_is_loaded(&self) -> bool {
      !self.glGetProgramBinary_p.load(RELAX).is_null()
    }
    /// [glGetProgramInfoLog](http://docs.gl/gl4/glGetProgramInfoLog)(program, bufSize, length, infoLog)
    /// * `length` len: 1
    /// * `infoLog` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramInfoLog(
      &self,
      program: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      infoLog: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetProgramInfoLog({:?}, {:?}, {:p}, {:p});",
          program,
          bufSize,
          length,
          infoLog
        );
      }
      let p = self.glGetProgramInfoLog_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, bufSize, length, infoLog),
        None => go_panic_because_fn_not_loaded("glGetProgramInfoLog"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetProgramInfoLog" != "glGetError" {
          report_error_as_necessary_from("GetProgramInfoLog", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetProgramInfoLog_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetProgramInfoLog\0");
      self.glGetProgramInfoLog_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramInfoLog_is_loaded(&self) -> bool {
      !self.glGetProgramInfoLog_p.load(RELAX).is_null()
    }
    /// [glGetProgramInterfaceiv](http://docs.gl/gl4/glGetProgramInterfaceiv)(program, programInterface, pname, params)
    /// * `programInterface` group: ProgramInterface
    /// * `pname` group: ProgramInterfacePName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramInterfaceiv(
      &self,
      program: GLuint,
      programInterface: GLenum,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetProgramInterfaceiv({:?}, {:#X}, {:#X}, {:p});",
          program,
          programInterface,
          pname,
          params
        );
      }
      let p = self.glGetProgramInterfaceiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLenum, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, programInterface, pname, params),
        None => go_panic_because_fn_not_loaded("glGetProgramInterfaceiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetProgramInterfaceiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetProgramInterfaceiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetProgramInterfaceiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetProgramInterfaceiv\0");
      self.glGetProgramInterfaceiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramInterfaceiv_is_loaded(&self) -> bool {
      !self.glGetProgramInterfaceiv_p.load(RELAX).is_null()
    }
    /// [glGetProgramPipelineInfoLog](http://docs.gl/gl4/glGetProgramPipelineInfoLog)(pipeline, bufSize, length, infoLog)
    /// * `length` len: 1
    /// * `infoLog` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramPipelineInfoLog(
      &self,
      pipeline: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      infoLog: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetProgramPipelineInfoLog({:?}, {:?}, {:p}, {:p});",
          pipeline,
          bufSize,
          length,
          infoLog
        );
      }
      let p = self.glGetProgramPipelineInfoLog_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar)>,
      >(p)
      {
        Some(fn_p) => fn_p(pipeline, bufSize, length, infoLog),
        None => go_panic_because_fn_not_loaded("glGetProgramPipelineInfoLog"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetProgramPipelineInfoLog" != "glGetError" {
          report_error_as_necessary_from(
            "GetProgramPipelineInfoLog",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetProgramPipelineInfoLog_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetProgramPipelineInfoLog\0");
      self.glGetProgramPipelineInfoLog_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramPipelineInfoLog_is_loaded(&self) -> bool {
      !self.glGetProgramPipelineInfoLog_p.load(RELAX).is_null()
    }
    /// [glGetProgramPipelineiv](http://docs.gl/gl4/glGetProgramPipelineiv)(pipeline, pname, params)
    /// * `pname` group: PipelineParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramPipelineiv(
      &self,
      pipeline: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetProgramPipelineiv({:?}, {:#X}, {:p});",
          pipeline,
          pname,
          params
        );
      }
      let p = self.glGetProgramPipelineiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(pipeline, pname, params),
          None => go_panic_because_fn_not_loaded("glGetProgramPipelineiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetProgramPipelineiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetProgramPipelineiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetProgramPipelineiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetProgramPipelineiv\0");
      self.glGetProgramPipelineiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramPipelineiv_is_loaded(&self) -> bool {
      !self.glGetProgramPipelineiv_p.load(RELAX).is_null()
    }
    /// [glGetProgramResourceIndex](http://docs.gl/gl4/glGetProgramResourceIndex)(program, programInterface, name)
    /// * `programInterface` group: ProgramInterface
    /// * `name` len: COMPSIZE(name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramResourceIndex(
      &self,
      program: GLuint,
      programInterface: GLenum,
      name: *const GLchar,
    ) -> GLuint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetProgramResourceIndex({:?}, {:#X}, {:p});",
          program,
          programInterface,
          name
        );
      }
      let p = self.glGetProgramResourceIndex_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, *const GLchar) -> GLuint>,
      >(p)
      {
        Some(fn_p) => fn_p(program, programInterface, name),
        None => go_panic_because_fn_not_loaded("glGetProgramResourceIndex"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetProgramResourceIndex" != "glGetError" {
          report_error_as_necessary_from(
            "GetProgramResourceIndex",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetProgramResourceIndex_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetProgramResourceIndex\0");
      self.glGetProgramResourceIndex_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramResourceIndex_is_loaded(&self) -> bool {
      !self.glGetProgramResourceIndex_p.load(RELAX).is_null()
    }
    /// [glGetProgramResourceLocation](http://docs.gl/gl4/glGetProgramResourceLocation)(program, programInterface, name)
    /// * `programInterface` group: ProgramInterface
    /// * `name` len: COMPSIZE(name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramResourceLocation(
      &self,
      program: GLuint,
      programInterface: GLenum,
      name: *const GLchar,
    ) -> GLint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetProgramResourceLocation({:?}, {:#X}, {:p});",
          program,
          programInterface,
          name
        );
      }
      let p = self.glGetProgramResourceLocation_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint>,
      >(p)
      {
        Some(fn_p) => fn_p(program, programInterface, name),
        None => go_panic_because_fn_not_loaded("glGetProgramResourceLocation"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetProgramResourceLocation" != "glGetError" {
          report_error_as_necessary_from(
            "GetProgramResourceLocation",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetProgramResourceLocation_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetProgramResourceLocation\0");
      self.glGetProgramResourceLocation_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramResourceLocation_is_loaded(&self) -> bool {
      !self.glGetProgramResourceLocation_p.load(RELAX).is_null()
    }
    /// [glGetProgramResourceLocationIndex](http://docs.gl/gl4/glGetProgramResourceLocationIndex)(program, programInterface, name)
    /// * `programInterface` group: ProgramInterface
    /// * `name` len: COMPSIZE(name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramResourceLocationIndex(
      &self,
      program: GLuint,
      programInterface: GLenum,
      name: *const GLchar,
    ) -> GLint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetProgramResourceLocationIndex({:?}, {:#X}, {:p});",
          program,
          programInterface,
          name
        );
      }
      let p = self.glGetProgramResourceLocationIndex_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint>,
      >(p)
      {
        Some(fn_p) => fn_p(program, programInterface, name),
        None => {
          go_panic_because_fn_not_loaded("glGetProgramResourceLocationIndex")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetProgramResourceLocationIndex" != "glGetError" {
          report_error_as_necessary_from(
            "GetProgramResourceLocationIndex",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetProgramResourceLocationIndex_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glGetProgramResourceLocationIndex\0");
      self.glGetProgramResourceLocationIndex_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramResourceLocationIndex_is_loaded(&self) -> bool {
      !self.glGetProgramResourceLocationIndex_p.load(RELAX).is_null()
    }
    /// [glGetProgramResourceName](http://docs.gl/gl4/glGetProgramResourceName)(program, programInterface, index, bufSize, length, name)
    /// * `programInterface` group: ProgramInterface
    /// * `length` len: 1
    /// * `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramResourceName(
      &self,
      program: GLuint,
      programInterface: GLenum,
      index: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      name: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetProgramResourceName({:?}, {:#X}, {:?}, {:?}, {:p}, {:p});", program, programInterface, index, bufSize, length, name);
      }
      let p = self.glGetProgramResourceName_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLenum,
            GLuint,
            GLsizei,
            *mut GLsizei,
            *mut GLchar,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(program, programInterface, index, bufSize, length, name)
        }
        None => go_panic_because_fn_not_loaded("glGetProgramResourceName"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetProgramResourceName" != "glGetError" {
          report_error_as_necessary_from(
            "GetProgramResourceName",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetProgramResourceName_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetProgramResourceName\0");
      self.glGetProgramResourceName_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramResourceName_is_loaded(&self) -> bool {
      !self.glGetProgramResourceName_p.load(RELAX).is_null()
    }
    /// [glGetProgramResourceiv](http://docs.gl/gl4/glGetProgramResourceiv)(program, programInterface, index, propCount, props, count, length, params)
    /// * `programInterface` group: ProgramInterface
    /// * `props` group: ProgramResourceProperty
    /// * `props` len: propCount
    /// * `length` len: 1
    /// * `params` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramResourceiv(
      &self,
      program: GLuint,
      programInterface: GLenum,
      index: GLuint,
      propCount: GLsizei,
      props: *const GLenum,
      count: GLsizei,
      length: *mut GLsizei,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetProgramResourceiv({:?}, {:#X}, {:?}, {:?}, {:p}, {:?}, {:p}, {:p});", program, programInterface, index, propCount, props, count, length, params);
      }
      let p = self.glGetProgramResourceiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLenum,
            GLuint,
            GLsizei,
            *const GLenum,
            GLsizei,
            *mut GLsizei,
            *mut GLint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          program,
          programInterface,
          index,
          propCount,
          props,
          count,
          length,
          params,
        ),
        None => go_panic_because_fn_not_loaded("glGetProgramResourceiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetProgramResourceiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetProgramResourceiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetProgramResourceiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetProgramResourceiv\0");
      self.glGetProgramResourceiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramResourceiv_is_loaded(&self) -> bool {
      !self.glGetProgramResourceiv_p.load(RELAX).is_null()
    }
    /// [glGetProgramStageiv](http://docs.gl/gl4/glGetProgramStageiv)(program, shadertype, pname, values)
    /// * `shadertype` group: ShaderType
    /// * `pname` group: ProgramStagePName
    /// * `values` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramStageiv(
      &self,
      program: GLuint,
      shadertype: GLenum,
      pname: GLenum,
      values: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetProgramStageiv({:?}, {:#X}, {:#X}, {:p});",
          program,
          shadertype,
          pname,
          values
        );
      }
      let p = self.glGetProgramStageiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLenum, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, shadertype, pname, values),
        None => go_panic_because_fn_not_loaded("glGetProgramStageiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetProgramStageiv" != "glGetError" {
          report_error_as_necessary_from("GetProgramStageiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetProgramStageiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetProgramStageiv\0");
      self.glGetProgramStageiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramStageiv_is_loaded(&self) -> bool {
      !self.glGetProgramStageiv_p.load(RELAX).is_null()
    }
    /// [glGetProgramiv](http://docs.gl/gl4/glGetProgramiv)(program, pname, params)
    /// * `pname` group: ProgramPropertyARB
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetProgramiv(
      &self,
      program: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetProgramiv({:?}, {:#X}, {:p});",
          program,
          pname,
          params
        );
      }
      let p = self.glGetProgramiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(program, pname, params),
          None => go_panic_because_fn_not_loaded("glGetProgramiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetProgramiv" != "glGetError" {
          report_error_as_necessary_from("GetProgramiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetProgramiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetProgramiv\0");
      self.glGetProgramiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetProgramiv_is_loaded(&self) -> bool {
      !self.glGetProgramiv_p.load(RELAX).is_null()
    }
    /// [glGetQueryBufferObjecti64v](http://docs.gl/gl4/glGetQueryBufferObjecti64v)(id, buffer, pname, offset)
    /// * `pname` group: QueryObjectParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryBufferObjecti64v(
      &self,
      id: GLuint,
      buffer: GLuint,
      pname: GLenum,
      offset: GLintptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryBufferObjecti64v({:?}, {:?}, {:#X}, {:?});",
          id,
          buffer,
          pname,
          offset
        );
      }
      let p = self.glGetQueryBufferObjecti64v_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLuint, GLenum, GLintptr)>>(
          p,
        ) {
          Some(fn_p) => fn_p(id, buffer, pname, offset),
          None => go_panic_because_fn_not_loaded("glGetQueryBufferObjecti64v"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetQueryBufferObjecti64v" != "glGetError" {
          report_error_as_necessary_from(
            "GetQueryBufferObjecti64v",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetQueryBufferObjecti64v_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetQueryBufferObjecti64v\0");
      self.glGetQueryBufferObjecti64v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryBufferObjecti64v_is_loaded(&self) -> bool {
      !self.glGetQueryBufferObjecti64v_p.load(RELAX).is_null()
    }
    /// [glGetQueryBufferObjectiv](http://docs.gl/gl4/glGetQueryBufferObjectiv)(id, buffer, pname, offset)
    /// * `pname` group: QueryObjectParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryBufferObjectiv(
      &self,
      id: GLuint,
      buffer: GLuint,
      pname: GLenum,
      offset: GLintptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryBufferObjectiv({:?}, {:?}, {:#X}, {:?});",
          id,
          buffer,
          pname,
          offset
        );
      }
      let p = self.glGetQueryBufferObjectiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLuint, GLenum, GLintptr)>>(
          p,
        ) {
          Some(fn_p) => fn_p(id, buffer, pname, offset),
          None => go_panic_because_fn_not_loaded("glGetQueryBufferObjectiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetQueryBufferObjectiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetQueryBufferObjectiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetQueryBufferObjectiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetQueryBufferObjectiv\0");
      self.glGetQueryBufferObjectiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryBufferObjectiv_is_loaded(&self) -> bool {
      !self.glGetQueryBufferObjectiv_p.load(RELAX).is_null()
    }
    /// [glGetQueryBufferObjectui64v](http://docs.gl/gl4/glGetQueryBufferObjectui64v)(id, buffer, pname, offset)
    /// * `pname` group: QueryObjectParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryBufferObjectui64v(
      &self,
      id: GLuint,
      buffer: GLuint,
      pname: GLenum,
      offset: GLintptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryBufferObjectui64v({:?}, {:?}, {:#X}, {:?});",
          id,
          buffer,
          pname,
          offset
        );
      }
      let p = self.glGetQueryBufferObjectui64v_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLuint, GLenum, GLintptr)>>(
          p,
        ) {
          Some(fn_p) => fn_p(id, buffer, pname, offset),
          None => go_panic_because_fn_not_loaded("glGetQueryBufferObjectui64v"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetQueryBufferObjectui64v" != "glGetError" {
          report_error_as_necessary_from(
            "GetQueryBufferObjectui64v",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetQueryBufferObjectui64v_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetQueryBufferObjectui64v\0");
      self.glGetQueryBufferObjectui64v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryBufferObjectui64v_is_loaded(&self) -> bool {
      !self.glGetQueryBufferObjectui64v_p.load(RELAX).is_null()
    }
    /// [glGetQueryBufferObjectuiv](http://docs.gl/gl4/glGetQueryBufferObjectuiv)(id, buffer, pname, offset)
    /// * `pname` group: QueryObjectParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryBufferObjectuiv(
      &self,
      id: GLuint,
      buffer: GLuint,
      pname: GLenum,
      offset: GLintptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryBufferObjectuiv({:?}, {:?}, {:#X}, {:?});",
          id,
          buffer,
          pname,
          offset
        );
      }
      let p = self.glGetQueryBufferObjectuiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLuint, GLenum, GLintptr)>>(
          p,
        ) {
          Some(fn_p) => fn_p(id, buffer, pname, offset),
          None => go_panic_because_fn_not_loaded("glGetQueryBufferObjectuiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetQueryBufferObjectuiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetQueryBufferObjectuiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetQueryBufferObjectuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetQueryBufferObjectuiv\0");
      self.glGetQueryBufferObjectuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryBufferObjectuiv_is_loaded(&self) -> bool {
      !self.glGetQueryBufferObjectuiv_p.load(RELAX).is_null()
    }
    /// [glGetQueryIndexediv](http://docs.gl/gl4/glGetQueryIndexediv)(target, index, pname, params)
    /// * `target` group: QueryTarget
    /// * `pname` group: QueryParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryIndexediv(
      &self,
      target: GLenum,
      index: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryIndexediv({:#X}, {:?}, {:#X}, {:p});",
          target,
          index,
          pname,
          params
        );
      }
      let p = self.glGetQueryIndexediv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLuint, GLenum, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, index, pname, params),
        None => go_panic_because_fn_not_loaded("glGetQueryIndexediv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetQueryIndexediv" != "glGetError" {
          report_error_as_necessary_from("GetQueryIndexediv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetQueryIndexediv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetQueryIndexediv\0");
      self.glGetQueryIndexediv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryIndexediv_is_loaded(&self) -> bool {
      !self.glGetQueryIndexediv_p.load(RELAX).is_null()
    }
    /// [glGetQueryObjecti64v](http://docs.gl/gl4/glGetQueryObjecti64v)(id, pname, params)
    /// * `pname` group: QueryObjectParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryObjecti64v(
      &self,
      id: GLuint,
      pname: GLenum,
      params: *mut GLint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryObjecti64v({:?}, {:#X}, {:p});",
          id,
          pname,
          params
        );
      }
      let p = self.glGetQueryObjecti64v_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint64)>>(p) {
          Some(fn_p) => fn_p(id, pname, params),
          None => go_panic_because_fn_not_loaded("glGetQueryObjecti64v"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetQueryObjecti64v" != "glGetError" {
          report_error_as_necessary_from("GetQueryObjecti64v", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetQueryObjecti64v_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetQueryObjecti64v\0");
      self.glGetQueryObjecti64v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryObjecti64v_is_loaded(&self) -> bool {
      !self.glGetQueryObjecti64v_p.load(RELAX).is_null()
    }
    /// [glGetQueryObjectiv](http://docs.gl/gl4/glGetQueryObjectiv)(id, pname, params)
    /// * `pname` group: QueryObjectParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryObjectiv(
      &self,
      id: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryObjectiv({:?}, {:#X}, {:p});",
          id,
          pname,
          params
        );
      }
      let p = self.glGetQueryObjectiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(id, pname, params),
          None => go_panic_because_fn_not_loaded("glGetQueryObjectiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetQueryObjectiv" != "glGetError" {
          report_error_as_necessary_from("GetQueryObjectiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetQueryObjectiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetQueryObjectiv\0");
      self.glGetQueryObjectiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryObjectiv_is_loaded(&self) -> bool {
      !self.glGetQueryObjectiv_p.load(RELAX).is_null()
    }
    /// [glGetQueryObjectui64v](http://docs.gl/gl4/glGetQueryObjectui64v)(id, pname, params)
    /// * `pname` group: QueryObjectParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryObjectui64v(
      &self,
      id: GLuint,
      pname: GLenum,
      params: *mut GLuint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryObjectui64v({:?}, {:#X}, {:p});",
          id,
          pname,
          params
        );
      }
      let p = self.glGetQueryObjectui64v_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, *mut GLuint64)>,
      >(p)
      {
        Some(fn_p) => fn_p(id, pname, params),
        None => go_panic_because_fn_not_loaded("glGetQueryObjectui64v"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetQueryObjectui64v" != "glGetError" {
          report_error_as_necessary_from(
            "GetQueryObjectui64v",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetQueryObjectui64v_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetQueryObjectui64v\0");
      self.glGetQueryObjectui64v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryObjectui64v_is_loaded(&self) -> bool {
      !self.glGetQueryObjectui64v_p.load(RELAX).is_null()
    }
    /// [glGetQueryObjectuiv](http://docs.gl/gl4/glGetQueryObjectuiv)(id, pname, params)
    /// * `pname` group: QueryObjectParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryObjectuiv(
      &self,
      id: GLuint,
      pname: GLenum,
      params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryObjectuiv({:?}, {:#X}, {:p});",
          id,
          pname,
          params
        );
      }
      let p = self.glGetQueryObjectuiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLuint)>>(p) {
          Some(fn_p) => fn_p(id, pname, params),
          None => go_panic_because_fn_not_loaded("glGetQueryObjectuiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetQueryObjectuiv" != "glGetError" {
          report_error_as_necessary_from("GetQueryObjectuiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetQueryObjectuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetQueryObjectuiv\0");
      self.glGetQueryObjectuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryObjectuiv_is_loaded(&self) -> bool {
      !self.glGetQueryObjectuiv_p.load(RELAX).is_null()
    }
    /// [glGetQueryiv](http://docs.gl/gl4/glGetQueryiv)(target, pname, params)
    /// * `target` group: QueryTarget
    /// * `pname` group: QueryParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetQueryiv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetQueryiv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glGetQueryiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(target, pname, params),
          None => go_panic_because_fn_not_loaded("glGetQueryiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetQueryiv" != "glGetError" {
          report_error_as_necessary_from("GetQueryiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetQueryiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetQueryiv\0");
      self.glGetQueryiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetQueryiv_is_loaded(&self) -> bool {
      !self.glGetQueryiv_p.load(RELAX).is_null()
    }
    /// [glGetRenderbufferParameteriv](http://docs.gl/gl4/glGetRenderbufferParameteriv)(target, pname, params)
    /// * `target` group: RenderbufferTarget
    /// * `pname` group: RenderbufferParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetRenderbufferParameteriv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetRenderbufferParameteriv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glGetRenderbufferParameteriv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(target, pname, params),
          None => {
            go_panic_because_fn_not_loaded("glGetRenderbufferParameteriv")
          }
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetRenderbufferParameteriv" != "glGetError" {
          report_error_as_necessary_from(
            "GetRenderbufferParameteriv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetRenderbufferParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetRenderbufferParameteriv\0");
      self.glGetRenderbufferParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetRenderbufferParameteriv_is_loaded(&self) -> bool {
      !self.glGetRenderbufferParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetSamplerParameterIiv](http://docs.gl/gl4/glGetSamplerParameterIiv)(sampler, pname, params)
    /// * `pname` group: SamplerParameterI
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetSamplerParameterIiv(
      &self,
      sampler: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetSamplerParameterIiv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          params
        );
      }
      let p = self.glGetSamplerParameterIiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(sampler, pname, params),
          None => go_panic_because_fn_not_loaded("glGetSamplerParameterIiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetSamplerParameterIiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetSamplerParameterIiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetSamplerParameterIiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetSamplerParameterIiv\0");
      self.glGetSamplerParameterIiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetSamplerParameterIiv_is_loaded(&self) -> bool {
      !self.glGetSamplerParameterIiv_p.load(RELAX).is_null()
    }
    /// [glGetSamplerParameterIuiv](http://docs.gl/gl4/glGetSamplerParameterIuiv)(sampler, pname, params)
    /// * `pname` group: SamplerParameterI
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetSamplerParameterIuiv(
      &self,
      sampler: GLuint,
      pname: GLenum,
      params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetSamplerParameterIuiv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          params
        );
      }
      let p = self.glGetSamplerParameterIuiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLuint)>>(p) {
          Some(fn_p) => fn_p(sampler, pname, params),
          None => go_panic_because_fn_not_loaded("glGetSamplerParameterIuiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetSamplerParameterIuiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetSamplerParameterIuiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetSamplerParameterIuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetSamplerParameterIuiv\0");
      self.glGetSamplerParameterIuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetSamplerParameterIuiv_is_loaded(&self) -> bool {
      !self.glGetSamplerParameterIuiv_p.load(RELAX).is_null()
    }
    /// [glGetSamplerParameterfv](http://docs.gl/gl4/glGetSamplerParameterfv)(sampler, pname, params)
    /// * `pname` group: SamplerParameterF
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetSamplerParameterfv(
      &self,
      sampler: GLuint,
      pname: GLenum,
      params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetSamplerParameterfv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          params
        );
      }
      let p = self.glGetSamplerParameterfv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLfloat)>>(p) {
          Some(fn_p) => fn_p(sampler, pname, params),
          None => go_panic_because_fn_not_loaded("glGetSamplerParameterfv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetSamplerParameterfv" != "glGetError" {
          report_error_as_necessary_from(
            "GetSamplerParameterfv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetSamplerParameterfv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetSamplerParameterfv\0");
      self.glGetSamplerParameterfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetSamplerParameterfv_is_loaded(&self) -> bool {
      !self.glGetSamplerParameterfv_p.load(RELAX).is_null()
    }
    /// [glGetSamplerParameteriv](http://docs.gl/gl4/glGetSamplerParameteriv)(sampler, pname, params)
    /// * `pname` group: SamplerParameterI
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetSamplerParameteriv(
      &self,
      sampler: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetSamplerParameteriv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          params
        );
      }
      let p = self.glGetSamplerParameteriv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(sampler, pname, params),
          None => go_panic_because_fn_not_loaded("glGetSamplerParameteriv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetSamplerParameteriv" != "glGetError" {
          report_error_as_necessary_from(
            "GetSamplerParameteriv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetSamplerParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetSamplerParameteriv\0");
      self.glGetSamplerParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetSamplerParameteriv_is_loaded(&self) -> bool {
      !self.glGetSamplerParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetShaderInfoLog](http://docs.gl/gl4/glGetShaderInfoLog)(shader, bufSize, length, infoLog)
    /// * `length` len: 1
    /// * `infoLog` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetShaderInfoLog(
      &self,
      shader: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      infoLog: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetShaderInfoLog({:?}, {:?}, {:p}, {:p});",
          shader,
          bufSize,
          length,
          infoLog
        );
      }
      let p = self.glGetShaderInfoLog_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar)>,
      >(p)
      {
        Some(fn_p) => fn_p(shader, bufSize, length, infoLog),
        None => go_panic_because_fn_not_loaded("glGetShaderInfoLog"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetShaderInfoLog" != "glGetError" {
          report_error_as_necessary_from("GetShaderInfoLog", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetShaderInfoLog_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetShaderInfoLog\0");
      self.glGetShaderInfoLog_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetShaderInfoLog_is_loaded(&self) -> bool {
      !self.glGetShaderInfoLog_p.load(RELAX).is_null()
    }
    /// [glGetShaderPrecisionFormat](http://docs.gl/gl4/glGetShaderPrecisionFormat)(shadertype, precisiontype, range, precision)
    /// * `shadertype` group: ShaderType
    /// * `precisiontype` group: PrecisionType
    /// * `range` len: 2
    /// * `precision` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetShaderPrecisionFormat(
      &self,
      shadertype: GLenum,
      precisiontype: GLenum,
      range: *mut GLint,
      precision: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetShaderPrecisionFormat({:#X}, {:#X}, {:p}, {:p});",
          shadertype,
          precisiontype,
          range,
          precision
        );
      }
      let p = self.glGetShaderPrecisionFormat_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, *mut GLint, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(shadertype, precisiontype, range, precision),
        None => go_panic_because_fn_not_loaded("glGetShaderPrecisionFormat"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetShaderPrecisionFormat" != "glGetError" {
          report_error_as_necessary_from(
            "GetShaderPrecisionFormat",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetShaderPrecisionFormat_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetShaderPrecisionFormat\0");
      self.glGetShaderPrecisionFormat_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetShaderPrecisionFormat_is_loaded(&self) -> bool {
      !self.glGetShaderPrecisionFormat_p.load(RELAX).is_null()
    }
    /// [glGetShaderSource](http://docs.gl/gl4/glGetShaderSource)(shader, bufSize, length, source)
    /// * `length` len: 1
    /// * `source` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetShaderSource(
      &self,
      shader: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      source: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetShaderSource({:?}, {:?}, {:p}, {:p});",
          shader,
          bufSize,
          length,
          source
        );
      }
      let p = self.glGetShaderSource_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar)>,
      >(p)
      {
        Some(fn_p) => fn_p(shader, bufSize, length, source),
        None => go_panic_because_fn_not_loaded("glGetShaderSource"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetShaderSource" != "glGetError" {
          report_error_as_necessary_from("GetShaderSource", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetShaderSource_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetShaderSource\0");
      self.glGetShaderSource_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetShaderSource_is_loaded(&self) -> bool {
      !self.glGetShaderSource_p.load(RELAX).is_null()
    }
    /// [glGetShaderiv](http://docs.gl/gl4/glGetShaderiv)(shader, pname, params)
    /// * `pname` group: ShaderParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetShaderiv(
      &self,
      shader: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetShaderiv({:?}, {:#X}, {:p});",
          shader,
          pname,
          params
        );
      }
      let p = self.glGetShaderiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(shader, pname, params),
          None => go_panic_because_fn_not_loaded("glGetShaderiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetShaderiv" != "glGetError" {
          report_error_as_necessary_from("GetShaderiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetShaderiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetShaderiv\0");
      self.glGetShaderiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetShaderiv_is_loaded(&self) -> bool {
      !self.glGetShaderiv_p.load(RELAX).is_null()
    }
    /// [glGetString](http://docs.gl/gl4/glGetString)(name)
    /// * `name` group: StringName
    /// * return value group: String
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetString(&self, name: GLenum) -> *const GLubyte {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetString({:#X});", name);
      }
      let p = self.glGetString_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum) -> *const GLubyte>>(p) {
          Some(fn_p) => fn_p(name),
          None => go_panic_because_fn_not_loaded("glGetString"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetString" != "glGetError" {
          report_error_as_necessary_from("GetString", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetString_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetString\0");
      self.glGetString_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetString_is_loaded(&self) -> bool {
      !self.glGetString_p.load(RELAX).is_null()
    }
    /// [glGetStringi](http://docs.gl/gl4/glGetStringi)(name, index)
    /// * `name` group: StringName
    /// * return value group: String
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetStringi(
      &self,
      name: GLenum,
      index: GLuint,
    ) -> *const GLubyte {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetStringi({:#X}, {:?});", name, index);
      }
      let p = self.glGetStringi_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLuint) -> *const GLubyte>>(
          p,
        ) {
          Some(fn_p) => fn_p(name, index),
          None => go_panic_because_fn_not_loaded("glGetStringi"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetStringi" != "glGetError" {
          report_error_as_necessary_from("GetStringi", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetStringi_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetStringi\0");
      self.glGetStringi_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetStringi_is_loaded(&self) -> bool {
      !self.glGetStringi_p.load(RELAX).is_null()
    }
    /// [glGetSubroutineIndex](http://docs.gl/gl4/glGetSubroutineIndex)(program, shadertype, name)
    /// * `shadertype` group: ShaderType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetSubroutineIndex(
      &self,
      program: GLuint,
      shadertype: GLenum,
      name: *const GLchar,
    ) -> GLuint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetSubroutineIndex({:?}, {:#X}, {:p});",
          program,
          shadertype,
          name
        );
      }
      let p = self.glGetSubroutineIndex_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, *const GLchar) -> GLuint>,
      >(p)
      {
        Some(fn_p) => fn_p(program, shadertype, name),
        None => go_panic_because_fn_not_loaded("glGetSubroutineIndex"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetSubroutineIndex" != "glGetError" {
          report_error_as_necessary_from("GetSubroutineIndex", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetSubroutineIndex_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetSubroutineIndex\0");
      self.glGetSubroutineIndex_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetSubroutineIndex_is_loaded(&self) -> bool {
      !self.glGetSubroutineIndex_p.load(RELAX).is_null()
    }
    /// [glGetSubroutineUniformLocation](http://docs.gl/gl4/glGetSubroutineUniformLocation)(program, shadertype, name)
    /// * `shadertype` group: ShaderType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetSubroutineUniformLocation(
      &self,
      program: GLuint,
      shadertype: GLenum,
      name: *const GLchar,
    ) -> GLint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetSubroutineUniformLocation({:?}, {:#X}, {:p});",
          program,
          shadertype,
          name
        );
      }
      let p = self.glGetSubroutineUniformLocation_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint>,
      >(p)
      {
        Some(fn_p) => fn_p(program, shadertype, name),
        None => {
          go_panic_because_fn_not_loaded("glGetSubroutineUniformLocation")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetSubroutineUniformLocation" != "glGetError" {
          report_error_as_necessary_from(
            "GetSubroutineUniformLocation",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetSubroutineUniformLocation_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glGetSubroutineUniformLocation\0");
      self.glGetSubroutineUniformLocation_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetSubroutineUniformLocation_is_loaded(&self) -> bool {
      !self.glGetSubroutineUniformLocation_p.load(RELAX).is_null()
    }
    /// [glGetSynciv](http://docs.gl/gl4/glGetSynciv)(sync, pname, count, length, values)
    /// * `sync` group: sync
    /// * `pname` group: SyncParameterName
    /// * `length` len: 1
    /// * `values` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetSynciv(
      &self,
      sync: GLsync,
      pname: GLenum,
      count: GLsizei,
      length: *mut GLsizei,
      values: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetSynciv({:p}, {:#X}, {:?}, {:p}, {:p});",
          sync,
          pname,
          count,
          length,
          values
        );
      }
      let p = self.glGetSynciv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(GLsync, GLenum, GLsizei, *mut GLsizei, *mut GLint),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(sync, pname, count, length, values),
        None => go_panic_because_fn_not_loaded("glGetSynciv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetSynciv" != "glGetError" {
          report_error_as_necessary_from("GetSynciv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetSynciv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetSynciv\0");
      self.glGetSynciv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetSynciv_is_loaded(&self) -> bool {
      !self.glGetSynciv_p.load(RELAX).is_null()
    }
    /// [glGetTexImage](http://docs.gl/gl4/glGetTexImage)(target, level, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(target,level,format,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexImage(
      &self,
      target: GLenum,
      level: GLint,
      format: GLenum,
      type_: GLenum,
      pixels: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexImage({:#X}, {:?}, {:#X}, {:#X}, {:p});",
          target,
          level,
          format,
          type_,
          pixels
        );
      }
      let p = self.glGetTexImage_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLint, GLenum, GLenum, *mut c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, level, format, type_, pixels),
        None => go_panic_because_fn_not_loaded("glGetTexImage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTexImage" != "glGetError" {
          report_error_as_necessary_from("GetTexImage", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTexImage_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTexImage\0");
      self.glGetTexImage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexImage_is_loaded(&self) -> bool {
      !self.glGetTexImage_p.load(RELAX).is_null()
    }
    /// [glGetTexLevelParameterfv](http://docs.gl/gl4/glGetTexLevelParameterfv)(target, level, pname, params)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `pname` group: GetTextureParameter
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexLevelParameterfv(
      &self,
      target: GLenum,
      level: GLint,
      pname: GLenum,
      params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexLevelParameterfv({:#X}, {:?}, {:#X}, {:p});",
          target,
          level,
          pname,
          params
        );
      }
      let p = self.glGetTexLevelParameterfv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLint, GLenum, *mut GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, level, pname, params),
        None => go_panic_because_fn_not_loaded("glGetTexLevelParameterfv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTexLevelParameterfv" != "glGetError" {
          report_error_as_necessary_from(
            "GetTexLevelParameterfv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTexLevelParameterfv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTexLevelParameterfv\0");
      self.glGetTexLevelParameterfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexLevelParameterfv_is_loaded(&self) -> bool {
      !self.glGetTexLevelParameterfv_p.load(RELAX).is_null()
    }
    /// [glGetTexLevelParameteriv](http://docs.gl/gl4/glGetTexLevelParameteriv)(target, level, pname, params)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `pname` group: GetTextureParameter
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexLevelParameteriv(
      &self,
      target: GLenum,
      level: GLint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexLevelParameteriv({:#X}, {:?}, {:#X}, {:p});",
          target,
          level,
          pname,
          params
        );
      }
      let p = self.glGetTexLevelParameteriv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLint, GLenum, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, level, pname, params),
        None => go_panic_because_fn_not_loaded("glGetTexLevelParameteriv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTexLevelParameteriv" != "glGetError" {
          report_error_as_necessary_from(
            "GetTexLevelParameteriv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTexLevelParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTexLevelParameteriv\0");
      self.glGetTexLevelParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexLevelParameteriv_is_loaded(&self) -> bool {
      !self.glGetTexLevelParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetTexParameterIiv](http://docs.gl/gl4/glGetTexParameterIiv)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: GetTextureParameter
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexParameterIiv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexParameterIiv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glGetTexParameterIiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(target, pname, params),
          None => go_panic_because_fn_not_loaded("glGetTexParameterIiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTexParameterIiv" != "glGetError" {
          report_error_as_necessary_from("GetTexParameterIiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTexParameterIiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTexParameterIiv\0");
      self.glGetTexParameterIiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexParameterIiv_is_loaded(&self) -> bool {
      !self.glGetTexParameterIiv_p.load(RELAX).is_null()
    }
    /// [glGetTexParameterIuiv](http://docs.gl/gl4/glGetTexParameterIuiv)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: GetTextureParameter
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexParameterIuiv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexParameterIuiv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glGetTexParameterIuiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLuint)>>(p) {
          Some(fn_p) => fn_p(target, pname, params),
          None => go_panic_because_fn_not_loaded("glGetTexParameterIuiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTexParameterIuiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetTexParameterIuiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTexParameterIuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTexParameterIuiv\0");
      self.glGetTexParameterIuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexParameterIuiv_is_loaded(&self) -> bool {
      !self.glGetTexParameterIuiv_p.load(RELAX).is_null()
    }
    /// [glGetTexParameterfv](http://docs.gl/gl4/glGetTexParameterfv)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: GetTextureParameter
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexParameterfv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexParameterfv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glGetTexParameterfv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLfloat)>>(p) {
          Some(fn_p) => fn_p(target, pname, params),
          None => go_panic_because_fn_not_loaded("glGetTexParameterfv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTexParameterfv" != "glGetError" {
          report_error_as_necessary_from("GetTexParameterfv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTexParameterfv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTexParameterfv\0");
      self.glGetTexParameterfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexParameterfv_is_loaded(&self) -> bool {
      !self.glGetTexParameterfv_p.load(RELAX).is_null()
    }
    /// [glGetTexParameteriv](http://docs.gl/gl4/glGetTexParameteriv)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: GetTextureParameter
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTexParameteriv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTexParameteriv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glGetTexParameteriv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(target, pname, params),
          None => go_panic_because_fn_not_loaded("glGetTexParameteriv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTexParameteriv" != "glGetError" {
          report_error_as_necessary_from("GetTexParameteriv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTexParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTexParameteriv\0");
      self.glGetTexParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTexParameteriv_is_loaded(&self) -> bool {
      !self.glGetTexParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetTextureImage](http://docs.gl/gl4/glGetTextureImage)(texture, level, format, type_, bufSize, pixels)
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTextureImage(
      &self,
      texture: GLuint,
      level: GLint,
      format: GLenum,
      type_: GLenum,
      bufSize: GLsizei,
      pixels: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTextureImage({:?}, {:?}, {:#X}, {:#X}, {:?}, {:p});",
          texture,
          level,
          format,
          type_,
          bufSize,
          pixels
        );
      }
      let p = self.glGetTextureImage_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLenum,
            GLenum,
            GLsizei,
            *mut c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(texture, level, format, type_, bufSize, pixels),
        None => go_panic_because_fn_not_loaded("glGetTextureImage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTextureImage" != "glGetError" {
          report_error_as_necessary_from("GetTextureImage", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTextureImage_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTextureImage\0");
      self.glGetTextureImage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTextureImage_is_loaded(&self) -> bool {
      !self.glGetTextureImage_p.load(RELAX).is_null()
    }
    /// [glGetTextureLevelParameterfv](http://docs.gl/gl4/glGetTextureLevelParameterfv)(texture, level, pname, params)
    /// * `pname` group: GetTextureParameter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTextureLevelParameterfv(
      &self,
      texture: GLuint,
      level: GLint,
      pname: GLenum,
      params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTextureLevelParameterfv({:?}, {:?}, {:#X}, {:p});",
          texture,
          level,
          pname,
          params
        );
      }
      let p = self.glGetTextureLevelParameterfv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLenum, *mut GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(texture, level, pname, params),
        None => go_panic_because_fn_not_loaded("glGetTextureLevelParameterfv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTextureLevelParameterfv" != "glGetError" {
          report_error_as_necessary_from(
            "GetTextureLevelParameterfv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTextureLevelParameterfv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTextureLevelParameterfv\0");
      self.glGetTextureLevelParameterfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTextureLevelParameterfv_is_loaded(&self) -> bool {
      !self.glGetTextureLevelParameterfv_p.load(RELAX).is_null()
    }
    /// [glGetTextureLevelParameteriv](http://docs.gl/gl4/glGetTextureLevelParameteriv)(texture, level, pname, params)
    /// * `pname` group: GetTextureParameter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTextureLevelParameteriv(
      &self,
      texture: GLuint,
      level: GLint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTextureLevelParameteriv({:?}, {:?}, {:#X}, {:p});",
          texture,
          level,
          pname,
          params
        );
      }
      let p = self.glGetTextureLevelParameteriv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLenum, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(texture, level, pname, params),
        None => go_panic_because_fn_not_loaded("glGetTextureLevelParameteriv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTextureLevelParameteriv" != "glGetError" {
          report_error_as_necessary_from(
            "GetTextureLevelParameteriv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTextureLevelParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTextureLevelParameteriv\0");
      self.glGetTextureLevelParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTextureLevelParameteriv_is_loaded(&self) -> bool {
      !self.glGetTextureLevelParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetTextureParameterIiv](http://docs.gl/gl4/glGetTextureParameterIiv)(texture, pname, params)
    /// * `pname` group: GetTextureParameter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTextureParameterIiv(
      &self,
      texture: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTextureParameterIiv({:?}, {:#X}, {:p});",
          texture,
          pname,
          params
        );
      }
      let p = self.glGetTextureParameterIiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(texture, pname, params),
          None => go_panic_because_fn_not_loaded("glGetTextureParameterIiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTextureParameterIiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetTextureParameterIiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTextureParameterIiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTextureParameterIiv\0");
      self.glGetTextureParameterIiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTextureParameterIiv_is_loaded(&self) -> bool {
      !self.glGetTextureParameterIiv_p.load(RELAX).is_null()
    }
    /// [glGetTextureParameterIuiv](http://docs.gl/gl4/glGetTextureParameterIuiv)(texture, pname, params)
    /// * `pname` group: GetTextureParameter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTextureParameterIuiv(
      &self,
      texture: GLuint,
      pname: GLenum,
      params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTextureParameterIuiv({:?}, {:#X}, {:p});",
          texture,
          pname,
          params
        );
      }
      let p = self.glGetTextureParameterIuiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLuint)>>(p) {
          Some(fn_p) => fn_p(texture, pname, params),
          None => go_panic_because_fn_not_loaded("glGetTextureParameterIuiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTextureParameterIuiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetTextureParameterIuiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTextureParameterIuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTextureParameterIuiv\0");
      self.glGetTextureParameterIuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTextureParameterIuiv_is_loaded(&self) -> bool {
      !self.glGetTextureParameterIuiv_p.load(RELAX).is_null()
    }
    /// [glGetTextureParameterfv](http://docs.gl/gl4/glGetTextureParameterfv)(texture, pname, params)
    /// * `pname` group: GetTextureParameter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTextureParameterfv(
      &self,
      texture: GLuint,
      pname: GLenum,
      params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTextureParameterfv({:?}, {:#X}, {:p});",
          texture,
          pname,
          params
        );
      }
      let p = self.glGetTextureParameterfv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLfloat)>>(p) {
          Some(fn_p) => fn_p(texture, pname, params),
          None => go_panic_because_fn_not_loaded("glGetTextureParameterfv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTextureParameterfv" != "glGetError" {
          report_error_as_necessary_from(
            "GetTextureParameterfv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTextureParameterfv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTextureParameterfv\0");
      self.glGetTextureParameterfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTextureParameterfv_is_loaded(&self) -> bool {
      !self.glGetTextureParameterfv_p.load(RELAX).is_null()
    }
    /// [glGetTextureParameteriv](http://docs.gl/gl4/glGetTextureParameteriv)(texture, pname, params)
    /// * `pname` group: GetTextureParameter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTextureParameteriv(
      &self,
      texture: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTextureParameteriv({:?}, {:#X}, {:p});",
          texture,
          pname,
          params
        );
      }
      let p = self.glGetTextureParameteriv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(texture, pname, params),
          None => go_panic_because_fn_not_loaded("glGetTextureParameteriv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTextureParameteriv" != "glGetError" {
          report_error_as_necessary_from(
            "GetTextureParameteriv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTextureParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTextureParameteriv\0");
      self.glGetTextureParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTextureParameteriv_is_loaded(&self) -> bool {
      !self.glGetTextureParameteriv_p.load(RELAX).is_null()
    }
    /// [glGetTextureSubImage](http://docs.gl/gl4/glGetTextureSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, bufSize, pixels)
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTextureSubImage(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      zoffset: GLint,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
      format: GLenum,
      type_: GLenum,
      bufSize: GLsizei,
      pixels: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetTextureSubImage({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:?}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, bufSize, pixels);
      }
      let p = self.glGetTextureSubImage_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLsizei,
            GLenum,
            GLenum,
            GLsizei,
            *mut c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          texture, level, xoffset, yoffset, zoffset, width, height, depth,
          format, type_, bufSize, pixels,
        ),
        None => go_panic_because_fn_not_loaded("glGetTextureSubImage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTextureSubImage" != "glGetError" {
          report_error_as_necessary_from("GetTextureSubImage", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTextureSubImage_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTextureSubImage\0");
      self.glGetTextureSubImage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTextureSubImage_is_loaded(&self) -> bool {
      !self.glGetTextureSubImage_p.load(RELAX).is_null()
    }
    /// [glGetTransformFeedbackVarying](http://docs.gl/gl4/glGetTransformFeedbackVarying)(program, index, bufSize, length, size, type_, name)
    /// * `length` len: 1
    /// * `size` len: 1
    /// * `type_` group: AttributeType
    /// * `type_` len: 1
    /// * `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTransformFeedbackVarying(
      &self,
      program: GLuint,
      index: GLuint,
      bufSize: GLsizei,
      length: *mut GLsizei,
      size: *mut GLsizei,
      type_: *mut GLenum,
      name: *mut GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetTransformFeedbackVarying({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});", program, index, bufSize, length, size, type_, name);
      }
      let p = self.glGetTransformFeedbackVarying_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLuint,
            GLsizei,
            *mut GLsizei,
            *mut GLsizei,
            *mut GLenum,
            *mut GLchar,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, index, bufSize, length, size, type_, name),
        None => go_panic_because_fn_not_loaded("glGetTransformFeedbackVarying"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTransformFeedbackVarying" != "glGetError" {
          report_error_as_necessary_from(
            "GetTransformFeedbackVarying",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTransformFeedbackVarying_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTransformFeedbackVarying\0");
      self.glGetTransformFeedbackVarying_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTransformFeedbackVarying_is_loaded(&self) -> bool {
      !self.glGetTransformFeedbackVarying_p.load(RELAX).is_null()
    }
    /// [glGetTransformFeedbacki64_v](http://docs.gl/gl4/glGetTransformFeedbacki64_v)(xfb, pname, index, param)
    /// * `pname` group: TransformFeedbackPName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTransformFeedbacki64_v(
      &self,
      xfb: GLuint,
      pname: GLenum,
      index: GLuint,
      param: *mut GLint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTransformFeedbacki64_v({:?}, {:#X}, {:?}, {:p});",
          xfb,
          pname,
          index,
          param
        );
      }
      let p = self.glGetTransformFeedbacki64_v_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLuint, *mut GLint64)>,
      >(p)
      {
        Some(fn_p) => fn_p(xfb, pname, index, param),
        None => go_panic_because_fn_not_loaded("glGetTransformFeedbacki64_v"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTransformFeedbacki64_v" != "glGetError" {
          report_error_as_necessary_from(
            "GetTransformFeedbacki64_v",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTransformFeedbacki64_v_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTransformFeedbacki64_v\0");
      self.glGetTransformFeedbacki64_v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTransformFeedbacki64_v_is_loaded(&self) -> bool {
      !self.glGetTransformFeedbacki64_v_p.load(RELAX).is_null()
    }
    /// [glGetTransformFeedbacki_v](http://docs.gl/gl4/glGetTransformFeedbacki_v)(xfb, pname, index, param)
    /// * `pname` group: TransformFeedbackPName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTransformFeedbacki_v(
      &self,
      xfb: GLuint,
      pname: GLenum,
      index: GLuint,
      param: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTransformFeedbacki_v({:?}, {:#X}, {:?}, {:p});",
          xfb,
          pname,
          index,
          param
        );
      }
      let p = self.glGetTransformFeedbacki_v_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLuint, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(xfb, pname, index, param),
        None => go_panic_because_fn_not_loaded("glGetTransformFeedbacki_v"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTransformFeedbacki_v" != "glGetError" {
          report_error_as_necessary_from(
            "GetTransformFeedbacki_v",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTransformFeedbacki_v_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTransformFeedbacki_v\0");
      self.glGetTransformFeedbacki_v_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTransformFeedbacki_v_is_loaded(&self) -> bool {
      !self.glGetTransformFeedbacki_v_p.load(RELAX).is_null()
    }
    /// [glGetTransformFeedbackiv](http://docs.gl/gl4/glGetTransformFeedbackiv)(xfb, pname, param)
    /// * `pname` group: TransformFeedbackPName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetTransformFeedbackiv(
      &self,
      xfb: GLuint,
      pname: GLenum,
      param: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetTransformFeedbackiv({:?}, {:#X}, {:p});",
          xfb,
          pname,
          param
        );
      }
      let p = self.glGetTransformFeedbackiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(xfb, pname, param),
          None => go_panic_because_fn_not_loaded("glGetTransformFeedbackiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetTransformFeedbackiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetTransformFeedbackiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetTransformFeedbackiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetTransformFeedbackiv\0");
      self.glGetTransformFeedbackiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetTransformFeedbackiv_is_loaded(&self) -> bool {
      !self.glGetTransformFeedbackiv_p.load(RELAX).is_null()
    }
    /// [glGetUniformBlockIndex](http://docs.gl/gl4/glGetUniformBlockIndex)(program, uniformBlockName)
    /// * `uniformBlockName` len: COMPSIZE()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformBlockIndex(
      &self,
      program: GLuint,
      uniformBlockName: *const GLchar,
    ) -> GLuint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetUniformBlockIndex({:?}, {:p});",
          program,
          uniformBlockName
        );
      }
      let p = self.glGetUniformBlockIndex_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, *const GLchar) -> GLuint>,
      >(p)
      {
        Some(fn_p) => fn_p(program, uniformBlockName),
        None => go_panic_because_fn_not_loaded("glGetUniformBlockIndex"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetUniformBlockIndex" != "glGetError" {
          report_error_as_necessary_from(
            "GetUniformBlockIndex",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetUniformBlockIndex_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetUniformBlockIndex\0");
      self.glGetUniformBlockIndex_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformBlockIndex_is_loaded(&self) -> bool {
      !self.glGetUniformBlockIndex_p.load(RELAX).is_null()
    }
    /// [glGetUniformIndices](http://docs.gl/gl4/glGetUniformIndices)(program, uniformCount, uniformNames, uniformIndices)
    /// * `uniformNames` len: COMPSIZE(uniformCount)
    /// * `uniformIndices` len: COMPSIZE(uniformCount)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformIndices(
      &self,
      program: GLuint,
      uniformCount: GLsizei,
      uniformNames: *const *const GLchar,
      uniformIndices: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetUniformIndices({:?}, {:?}, {:p}, {:p});",
          program,
          uniformCount,
          uniformNames,
          uniformIndices
        );
      }
      let p = self.glGetUniformIndices_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLsizei,
            *const *const GLchar,
            *mut GLuint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, uniformCount, uniformNames, uniformIndices),
        None => go_panic_because_fn_not_loaded("glGetUniformIndices"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetUniformIndices" != "glGetError" {
          report_error_as_necessary_from("GetUniformIndices", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetUniformIndices_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetUniformIndices\0");
      self.glGetUniformIndices_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformIndices_is_loaded(&self) -> bool {
      !self.glGetUniformIndices_p.load(RELAX).is_null()
    }
    /// [glGetUniformLocation](http://docs.gl/gl4/glGetUniformLocation)(program, name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformLocation(
      &self,
      program: GLuint,
      name: *const GLchar,
    ) -> GLint {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.GetUniformLocation({:?}, {:p});", program, name);
      }
      let p = self.glGetUniformLocation_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, *const GLchar) -> GLint>>(p)
        {
          Some(fn_p) => fn_p(program, name),
          None => go_panic_because_fn_not_loaded("glGetUniformLocation"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetUniformLocation" != "glGetError" {
          report_error_as_necessary_from("GetUniformLocation", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetUniformLocation_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetUniformLocation\0");
      self.glGetUniformLocation_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformLocation_is_loaded(&self) -> bool {
      !self.glGetUniformLocation_p.load(RELAX).is_null()
    }
    /// [glGetUniformSubroutineuiv](http://docs.gl/gl4/glGetUniformSubroutineuiv)(shadertype, location, params)
    /// * `shadertype` group: ShaderType
    /// * `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformSubroutineuiv(
      &self,
      shadertype: GLenum,
      location: GLint,
      params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetUniformSubroutineuiv({:#X}, {:?}, {:p});",
          shadertype,
          location,
          params
        );
      }
      let p = self.glGetUniformSubroutineuiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLint, *mut GLuint)>>(p) {
          Some(fn_p) => fn_p(shadertype, location, params),
          None => go_panic_because_fn_not_loaded("glGetUniformSubroutineuiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetUniformSubroutineuiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetUniformSubroutineuiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetUniformSubroutineuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetUniformSubroutineuiv\0");
      self.glGetUniformSubroutineuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformSubroutineuiv_is_loaded(&self) -> bool {
      !self.glGetUniformSubroutineuiv_p.load(RELAX).is_null()
    }
    /// [glGetUniformdv](http://docs.gl/gl4/glGetUniformdv)(program, location, params)
    /// * `params` len: COMPSIZE(program,location)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformdv(
      &self,
      program: GLuint,
      location: GLint,
      params: *mut GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetUniformdv({:?}, {:?}, {:p});",
          program,
          location,
          params
        );
      }
      let p = self.glGetUniformdv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLint, *mut GLdouble)>>(p) {
          Some(fn_p) => fn_p(program, location, params),
          None => go_panic_because_fn_not_loaded("glGetUniformdv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetUniformdv" != "glGetError" {
          report_error_as_necessary_from("GetUniformdv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetUniformdv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetUniformdv\0");
      self.glGetUniformdv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformdv_is_loaded(&self) -> bool {
      !self.glGetUniformdv_p.load(RELAX).is_null()
    }
    /// [glGetUniformfv](http://docs.gl/gl4/glGetUniformfv)(program, location, params)
    /// * `params` len: COMPSIZE(program,location)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformfv(
      &self,
      program: GLuint,
      location: GLint,
      params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetUniformfv({:?}, {:?}, {:p});",
          program,
          location,
          params
        );
      }
      let p = self.glGetUniformfv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLint, *mut GLfloat)>>(p) {
          Some(fn_p) => fn_p(program, location, params),
          None => go_panic_because_fn_not_loaded("glGetUniformfv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetUniformfv" != "glGetError" {
          report_error_as_necessary_from("GetUniformfv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetUniformfv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetUniformfv\0");
      self.glGetUniformfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformfv_is_loaded(&self) -> bool {
      !self.glGetUniformfv_p.load(RELAX).is_null()
    }
    /// [glGetUniformiv](http://docs.gl/gl4/glGetUniformiv)(program, location, params)
    /// * `params` len: COMPSIZE(program,location)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformiv(
      &self,
      program: GLuint,
      location: GLint,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetUniformiv({:?}, {:?}, {:p});",
          program,
          location,
          params
        );
      }
      let p = self.glGetUniformiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLint, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(program, location, params),
          None => go_panic_because_fn_not_loaded("glGetUniformiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetUniformiv" != "glGetError" {
          report_error_as_necessary_from("GetUniformiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetUniformiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetUniformiv\0");
      self.glGetUniformiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformiv_is_loaded(&self) -> bool {
      !self.glGetUniformiv_p.load(RELAX).is_null()
    }
    /// [glGetUniformuiv](http://docs.gl/gl4/glGetUniformuiv)(program, location, params)
    /// * `params` len: COMPSIZE(program,location)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetUniformuiv(
      &self,
      program: GLuint,
      location: GLint,
      params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetUniformuiv({:?}, {:?}, {:p});",
          program,
          location,
          params
        );
      }
      let p = self.glGetUniformuiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLint, *mut GLuint)>>(p) {
          Some(fn_p) => fn_p(program, location, params),
          None => go_panic_because_fn_not_loaded("glGetUniformuiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetUniformuiv" != "glGetError" {
          report_error_as_necessary_from("GetUniformuiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetUniformuiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetUniformuiv\0");
      self.glGetUniformuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetUniformuiv_is_loaded(&self) -> bool {
      !self.glGetUniformuiv_p.load(RELAX).is_null()
    }
    /// [glGetVertexArrayIndexed64iv](http://docs.gl/gl4/glGetVertexArrayIndexed64iv)(vaobj, index, pname, param)
    /// * `pname` group: VertexArrayPName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexArrayIndexed64iv(
      &self,
      vaobj: GLuint,
      index: GLuint,
      pname: GLenum,
      param: *mut GLint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexArrayIndexed64iv({:?}, {:?}, {:#X}, {:p});",
          vaobj,
          index,
          pname,
          param
        );
      }
      let p = self.glGetVertexArrayIndexed64iv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLenum, *mut GLint64)>,
      >(p)
      {
        Some(fn_p) => fn_p(vaobj, index, pname, param),
        None => go_panic_because_fn_not_loaded("glGetVertexArrayIndexed64iv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetVertexArrayIndexed64iv" != "glGetError" {
          report_error_as_necessary_from(
            "GetVertexArrayIndexed64iv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetVertexArrayIndexed64iv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetVertexArrayIndexed64iv\0");
      self.glGetVertexArrayIndexed64iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexArrayIndexed64iv_is_loaded(&self) -> bool {
      !self.glGetVertexArrayIndexed64iv_p.load(RELAX).is_null()
    }
    /// [glGetVertexArrayIndexediv](http://docs.gl/gl4/glGetVertexArrayIndexediv)(vaobj, index, pname, param)
    /// * `pname` group: VertexArrayPName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexArrayIndexediv(
      &self,
      vaobj: GLuint,
      index: GLuint,
      pname: GLenum,
      param: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexArrayIndexediv({:?}, {:?}, {:#X}, {:p});",
          vaobj,
          index,
          pname,
          param
        );
      }
      let p = self.glGetVertexArrayIndexediv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLenum, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(vaobj, index, pname, param),
        None => go_panic_because_fn_not_loaded("glGetVertexArrayIndexediv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetVertexArrayIndexediv" != "glGetError" {
          report_error_as_necessary_from(
            "GetVertexArrayIndexediv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetVertexArrayIndexediv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetVertexArrayIndexediv\0");
      self.glGetVertexArrayIndexediv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexArrayIndexediv_is_loaded(&self) -> bool {
      !self.glGetVertexArrayIndexediv_p.load(RELAX).is_null()
    }
    /// [glGetVertexArrayiv](http://docs.gl/gl4/glGetVertexArrayiv)(vaobj, pname, param)
    /// * `pname` group: VertexArrayPName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexArrayiv(
      &self,
      vaobj: GLuint,
      pname: GLenum,
      param: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexArrayiv({:?}, {:#X}, {:p});",
          vaobj,
          pname,
          param
        );
      }
      let p = self.glGetVertexArrayiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(vaobj, pname, param),
          None => go_panic_because_fn_not_loaded("glGetVertexArrayiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetVertexArrayiv" != "glGetError" {
          report_error_as_necessary_from("GetVertexArrayiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetVertexArrayiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetVertexArrayiv\0");
      self.glGetVertexArrayiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexArrayiv_is_loaded(&self) -> bool {
      !self.glGetVertexArrayiv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribIiv](http://docs.gl/gl4/glGetVertexAttribIiv)(index, pname, params)
    /// * `pname` group: VertexAttribEnum
    /// * `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribIiv(
      &self,
      index: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribIiv({:?}, {:#X}, {:p});",
          index,
          pname,
          params
        );
      }
      let p = self.glGetVertexAttribIiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(index, pname, params),
          None => go_panic_because_fn_not_loaded("glGetVertexAttribIiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetVertexAttribIiv" != "glGetError" {
          report_error_as_necessary_from("GetVertexAttribIiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetVertexAttribIiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetVertexAttribIiv\0");
      self.glGetVertexAttribIiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribIiv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribIiv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribIuiv](http://docs.gl/gl4/glGetVertexAttribIuiv)(index, pname, params)
    /// * `pname` group: VertexAttribEnum
    /// * `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribIuiv(
      &self,
      index: GLuint,
      pname: GLenum,
      params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribIuiv({:?}, {:#X}, {:p});",
          index,
          pname,
          params
        );
      }
      let p = self.glGetVertexAttribIuiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLuint)>>(p) {
          Some(fn_p) => fn_p(index, pname, params),
          None => go_panic_because_fn_not_loaded("glGetVertexAttribIuiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetVertexAttribIuiv" != "glGetError" {
          report_error_as_necessary_from(
            "GetVertexAttribIuiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetVertexAttribIuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetVertexAttribIuiv\0");
      self.glGetVertexAttribIuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribIuiv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribIuiv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribLdv](http://docs.gl/gl4/glGetVertexAttribLdv)(index, pname, params)
    /// * `pname` group: VertexAttribEnum
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribLdv(
      &self,
      index: GLuint,
      pname: GLenum,
      params: *mut GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribLdv({:?}, {:#X}, {:p});",
          index,
          pname,
          params
        );
      }
      let p = self.glGetVertexAttribLdv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, *mut GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, pname, params),
        None => go_panic_because_fn_not_loaded("glGetVertexAttribLdv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetVertexAttribLdv" != "glGetError" {
          report_error_as_necessary_from("GetVertexAttribLdv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetVertexAttribLdv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetVertexAttribLdv\0");
      self.glGetVertexAttribLdv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribLdv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribLdv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribPointerv](http://docs.gl/gl4/glGetVertexAttribPointerv)(index, pname, pointer)
    /// * `pname` group: VertexAttribPointerPropertyARB
    /// * `pointer` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribPointerv(
      &self,
      index: GLuint,
      pname: GLenum,
      pointer: *mut *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribPointerv({:?}, {:#X}, {:p});",
          index,
          pname,
          pointer
        );
      }
      let p = self.glGetVertexAttribPointerv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut *mut c_void)>>(
          p,
        ) {
          Some(fn_p) => fn_p(index, pname, pointer),
          None => go_panic_because_fn_not_loaded("glGetVertexAttribPointerv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetVertexAttribPointerv" != "glGetError" {
          report_error_as_necessary_from(
            "GetVertexAttribPointerv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetVertexAttribPointerv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetVertexAttribPointerv\0");
      self.glGetVertexAttribPointerv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribPointerv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribPointerv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribdv](http://docs.gl/gl4/glGetVertexAttribdv)(index, pname, params)
    /// * `pname` group: VertexAttribPropertyARB
    /// * `params` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribdv(
      &self,
      index: GLuint,
      pname: GLenum,
      params: *mut GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribdv({:?}, {:#X}, {:p});",
          index,
          pname,
          params
        );
      }
      let p = self.glGetVertexAttribdv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, *mut GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, pname, params),
        None => go_panic_because_fn_not_loaded("glGetVertexAttribdv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetVertexAttribdv" != "glGetError" {
          report_error_as_necessary_from("GetVertexAttribdv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetVertexAttribdv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetVertexAttribdv\0");
      self.glGetVertexAttribdv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribdv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribdv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribfv](http://docs.gl/gl4/glGetVertexAttribfv)(index, pname, params)
    /// * `pname` group: VertexAttribPropertyARB
    /// * `params` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribfv(
      &self,
      index: GLuint,
      pname: GLenum,
      params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribfv({:?}, {:#X}, {:p});",
          index,
          pname,
          params
        );
      }
      let p = self.glGetVertexAttribfv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLfloat)>>(p) {
          Some(fn_p) => fn_p(index, pname, params),
          None => go_panic_because_fn_not_loaded("glGetVertexAttribfv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetVertexAttribfv" != "glGetError" {
          report_error_as_necessary_from("GetVertexAttribfv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetVertexAttribfv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetVertexAttribfv\0");
      self.glGetVertexAttribfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribfv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribfv_p.load(RELAX).is_null()
    }
    /// [glGetVertexAttribiv](http://docs.gl/gl4/glGetVertexAttribiv)(index, pname, params)
    /// * `pname` group: VertexAttribPropertyARB
    /// * `params` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetVertexAttribiv(
      &self,
      index: GLuint,
      pname: GLenum,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetVertexAttribiv({:?}, {:#X}, {:p});",
          index,
          pname,
          params
        );
      }
      let p = self.glGetVertexAttribiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *mut GLint)>>(p) {
          Some(fn_p) => fn_p(index, pname, params),
          None => go_panic_because_fn_not_loaded("glGetVertexAttribiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetVertexAttribiv" != "glGetError" {
          report_error_as_necessary_from("GetVertexAttribiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetVertexAttribiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetVertexAttribiv\0");
      self.glGetVertexAttribiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetVertexAttribiv_is_loaded(&self) -> bool {
      !self.glGetVertexAttribiv_p.load(RELAX).is_null()
    }
    /// [glGetnCompressedTexImage](http://docs.gl/gl4/glGetnCompressedTexImage)(target, lod, bufSize, pixels)
    /// * `target` group: TextureTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetnCompressedTexImage(
      &self,
      target: GLenum,
      lod: GLint,
      bufSize: GLsizei,
      pixels: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetnCompressedTexImage({:#X}, {:?}, {:?}, {:p});",
          target,
          lod,
          bufSize,
          pixels
        );
      }
      let p = self.glGetnCompressedTexImage_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLint, GLsizei, *mut c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, lod, bufSize, pixels),
        None => go_panic_because_fn_not_loaded("glGetnCompressedTexImage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetnCompressedTexImage" != "glGetError" {
          report_error_as_necessary_from(
            "GetnCompressedTexImage",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetnCompressedTexImage_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glGetnCompressedTexImage\0");
      self.glGetnCompressedTexImage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetnCompressedTexImage_is_loaded(&self) -> bool {
      !self.glGetnCompressedTexImage_p.load(RELAX).is_null()
    }
    /// [glGetnTexImage](http://docs.gl/gl4/glGetnTexImage)(target, level, format, type_, bufSize, pixels)
    /// * `target` group: TextureTarget
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetnTexImage(
      &self,
      target: GLenum,
      level: GLint,
      format: GLenum,
      type_: GLenum,
      bufSize: GLsizei,
      pixels: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetnTexImage({:#X}, {:?}, {:#X}, {:#X}, {:?}, {:p});",
          target,
          level,
          format,
          type_,
          bufSize,
          pixels
        );
      }
      let p = self.glGetnTexImage_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLenum,
            GLenum,
            GLsizei,
            *mut c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(target, level, format, type_, bufSize, pixels),
        None => go_panic_because_fn_not_loaded("glGetnTexImage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetnTexImage" != "glGetError" {
          report_error_as_necessary_from("GetnTexImage", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetnTexImage_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetnTexImage\0");
      self.glGetnTexImage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetnTexImage_is_loaded(&self) -> bool {
      !self.glGetnTexImage_p.load(RELAX).is_null()
    }
    /// [glGetnUniformdv](http://docs.gl/gl4/glGetnUniformdv)(program, location, bufSize, params)
    /// * `params` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetnUniformdv(
      &self,
      program: GLuint,
      location: GLint,
      bufSize: GLsizei,
      params: *mut GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetnUniformdv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          bufSize,
          params
        );
      }
      let p = self.glGetnUniformdv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *mut GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, bufSize, params),
        None => go_panic_because_fn_not_loaded("glGetnUniformdv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetnUniformdv" != "glGetError" {
          report_error_as_necessary_from("GetnUniformdv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetnUniformdv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetnUniformdv\0");
      self.glGetnUniformdv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetnUniformdv_is_loaded(&self) -> bool {
      !self.glGetnUniformdv_p.load(RELAX).is_null()
    }
    /// [glGetnUniformfv](http://docs.gl/gl4/glGetnUniformfv)(program, location, bufSize, params)
    /// * `params` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetnUniformfv(
      &self,
      program: GLuint,
      location: GLint,
      bufSize: GLsizei,
      params: *mut GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetnUniformfv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          bufSize,
          params
        );
      }
      let p = self.glGetnUniformfv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *mut GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, bufSize, params),
        None => go_panic_because_fn_not_loaded("glGetnUniformfv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetnUniformfv" != "glGetError" {
          report_error_as_necessary_from("GetnUniformfv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetnUniformfv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetnUniformfv\0");
      self.glGetnUniformfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetnUniformfv_is_loaded(&self) -> bool {
      !self.glGetnUniformfv_p.load(RELAX).is_null()
    }
    /// [glGetnUniformiv](http://docs.gl/gl4/glGetnUniformiv)(program, location, bufSize, params)
    /// * `params` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetnUniformiv(
      &self,
      program: GLuint,
      location: GLint,
      bufSize: GLsizei,
      params: *mut GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetnUniformiv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          bufSize,
          params
        );
      }
      let p = self.glGetnUniformiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *mut GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, bufSize, params),
        None => go_panic_because_fn_not_loaded("glGetnUniformiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetnUniformiv" != "glGetError" {
          report_error_as_necessary_from("GetnUniformiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetnUniformiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetnUniformiv\0");
      self.glGetnUniformiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetnUniformiv_is_loaded(&self) -> bool {
      !self.glGetnUniformiv_p.load(RELAX).is_null()
    }
    /// [glGetnUniformuiv](http://docs.gl/gl4/glGetnUniformuiv)(program, location, bufSize, params)
    /// * `params` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn GetnUniformuiv(
      &self,
      program: GLuint,
      location: GLint,
      bufSize: GLsizei,
      params: *mut GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.GetnUniformuiv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          bufSize,
          params
        );
      }
      let p = self.glGetnUniformuiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *mut GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, bufSize, params),
        None => go_panic_because_fn_not_loaded("glGetnUniformuiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glGetnUniformuiv" != "glGetError" {
          report_error_as_necessary_from("GetnUniformuiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn GetnUniformuiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glGetnUniformuiv\0");
      self.glGetnUniformuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn GetnUniformuiv_is_loaded(&self) -> bool {
      !self.glGetnUniformuiv_p.load(RELAX).is_null()
    }
    /// [glHint](http://docs.gl/gl4/glHint)(target, mode)
    /// * `target` group: HintTarget
    /// * `mode` group: HintMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Hint(&self, target: GLenum, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Hint({:#X}, {:#X});", target, mode);
      }
      let p = self.glHint_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLenum)>>(p) {
        Some(fn_p) => fn_p(target, mode),
        None => go_panic_because_fn_not_loaded("glHint"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glHint" != "glGetError" {
          report_error_as_necessary_from("Hint", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Hint_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glHint\0");
      self.glHint_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Hint_is_loaded(&self) -> bool {
      !self.glHint_p.load(RELAX).is_null()
    }
    /// [glInvalidateBufferData](http://docs.gl/gl4/glInvalidateBufferData)(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn InvalidateBufferData(&self, buffer: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.InvalidateBufferData({:?});", buffer);
      }
      let p = self.glInvalidateBufferData_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(buffer),
        None => go_panic_because_fn_not_loaded("glInvalidateBufferData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glInvalidateBufferData" != "glGetError" {
          report_error_as_necessary_from(
            "InvalidateBufferData",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn InvalidateBufferData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glInvalidateBufferData\0");
      self.glInvalidateBufferData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn InvalidateBufferData_is_loaded(&self) -> bool {
      !self.glInvalidateBufferData_p.load(RELAX).is_null()
    }
    /// [glInvalidateBufferSubData](http://docs.gl/gl4/glInvalidateBufferSubData)(buffer, offset, length)
    /// * `offset` group: BufferOffset
    /// * `length` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn InvalidateBufferSubData(
      &self,
      buffer: GLuint,
      offset: GLintptr,
      length: GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.InvalidateBufferSubData({:?}, {:?}, {:?});",
          buffer,
          offset,
          length
        );
      }
      let p = self.glInvalidateBufferSubData_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLintptr, GLsizeiptr)>>(p) {
          Some(fn_p) => fn_p(buffer, offset, length),
          None => go_panic_because_fn_not_loaded("glInvalidateBufferSubData"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glInvalidateBufferSubData" != "glGetError" {
          report_error_as_necessary_from(
            "InvalidateBufferSubData",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn InvalidateBufferSubData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glInvalidateBufferSubData\0");
      self.glInvalidateBufferSubData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn InvalidateBufferSubData_is_loaded(&self) -> bool {
      !self.glInvalidateBufferSubData_p.load(RELAX).is_null()
    }
    /// [glInvalidateFramebuffer](http://docs.gl/gl4/glInvalidateFramebuffer)(target, numAttachments, attachments)
    /// * `target` group: FramebufferTarget
    /// * `attachments` group: InvalidateFramebufferAttachment
    /// * `attachments` len: numAttachments
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn InvalidateFramebuffer(
      &self,
      target: GLenum,
      numAttachments: GLsizei,
      attachments: *const GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.InvalidateFramebuffer({:#X}, {:?}, {:p});",
          target,
          numAttachments,
          attachments
        );
      }
      let p = self.glInvalidateFramebuffer_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLsizei, *const GLenum)>>(p)
        {
          Some(fn_p) => fn_p(target, numAttachments, attachments),
          None => go_panic_because_fn_not_loaded("glInvalidateFramebuffer"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glInvalidateFramebuffer" != "glGetError" {
          report_error_as_necessary_from(
            "InvalidateFramebuffer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn InvalidateFramebuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glInvalidateFramebuffer\0");
      self.glInvalidateFramebuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn InvalidateFramebuffer_is_loaded(&self) -> bool {
      !self.glInvalidateFramebuffer_p.load(RELAX).is_null()
    }
    /// [glInvalidateNamedFramebufferData](http://docs.gl/gl4/glInvalidateNamedFramebufferData)(framebuffer, numAttachments, attachments)
    /// * `attachments` group: FramebufferAttachment
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn InvalidateNamedFramebufferData(
      &self,
      framebuffer: GLuint,
      numAttachments: GLsizei,
      attachments: *const GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.InvalidateNamedFramebufferData({:?}, {:?}, {:p});",
          framebuffer,
          numAttachments,
          attachments
        );
      }
      let p = self.glInvalidateNamedFramebufferData_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLsizei, *const GLenum)>>(p)
        {
          Some(fn_p) => fn_p(framebuffer, numAttachments, attachments),
          None => {
            go_panic_because_fn_not_loaded("glInvalidateNamedFramebufferData")
          }
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glInvalidateNamedFramebufferData" != "glGetError" {
          report_error_as_necessary_from(
            "InvalidateNamedFramebufferData",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn InvalidateNamedFramebufferData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glInvalidateNamedFramebufferData\0");
      self.glInvalidateNamedFramebufferData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn InvalidateNamedFramebufferData_is_loaded(&self) -> bool {
      !self.glInvalidateNamedFramebufferData_p.load(RELAX).is_null()
    }
    /// [glInvalidateNamedFramebufferSubData](http://docs.gl/gl4/glInvalidateNamedFramebufferSubData)(framebuffer, numAttachments, attachments, x, y, width, height)
    /// * `attachments` group: FramebufferAttachment
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn InvalidateNamedFramebufferSubData(
      &self,
      framebuffer: GLuint,
      numAttachments: GLsizei,
      attachments: *const GLenum,
      x: GLint,
      y: GLint,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.InvalidateNamedFramebufferSubData({:?}, {:?}, {:p}, {:?}, {:?}, {:?}, {:?});", framebuffer, numAttachments, attachments, x, y, width, height);
      }
      let p = self.glInvalidateNamedFramebufferSubData_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLsizei,
            *const GLenum,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(framebuffer, numAttachments, attachments, x, y, width, height)
        }
        None => {
          go_panic_because_fn_not_loaded("glInvalidateNamedFramebufferSubData")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glInvalidateNamedFramebufferSubData" != "glGetError" {
          report_error_as_necessary_from(
            "InvalidateNamedFramebufferSubData",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn InvalidateNamedFramebufferSubData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glInvalidateNamedFramebufferSubData\0");
      self.glInvalidateNamedFramebufferSubData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn InvalidateNamedFramebufferSubData_is_loaded(&self) -> bool {
      !self.glInvalidateNamedFramebufferSubData_p.load(RELAX).is_null()
    }
    /// [glInvalidateSubFramebuffer](http://docs.gl/gl4/glInvalidateSubFramebuffer)(target, numAttachments, attachments, x, y, width, height)
    /// * `target` group: FramebufferTarget
    /// * `attachments` group: InvalidateFramebufferAttachment
    /// * `attachments` len: numAttachments
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn InvalidateSubFramebuffer(
      &self,
      target: GLenum,
      numAttachments: GLsizei,
      attachments: *const GLenum,
      x: GLint,
      y: GLint,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.InvalidateSubFramebuffer({:#X}, {:?}, {:p}, {:?}, {:?}, {:?}, {:?});", target, numAttachments, attachments, x, y, width, height);
      }
      let p = self.glInvalidateSubFramebuffer_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLsizei,
            *const GLenum,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(target, numAttachments, attachments, x, y, width, height)
        }
        None => go_panic_because_fn_not_loaded("glInvalidateSubFramebuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glInvalidateSubFramebuffer" != "glGetError" {
          report_error_as_necessary_from(
            "InvalidateSubFramebuffer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn InvalidateSubFramebuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glInvalidateSubFramebuffer\0");
      self.glInvalidateSubFramebuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn InvalidateSubFramebuffer_is_loaded(&self) -> bool {
      !self.glInvalidateSubFramebuffer_p.load(RELAX).is_null()
    }
    /// [glInvalidateTexImage](http://docs.gl/gl4/glInvalidateTexImage)(texture, level)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn InvalidateTexImage(&self, texture: GLuint, level: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.InvalidateTexImage({:?}, {:?});", texture, level);
      }
      let p = self.glInvalidateTexImage_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLint)>>(p) {
        Some(fn_p) => fn_p(texture, level),
        None => go_panic_because_fn_not_loaded("glInvalidateTexImage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glInvalidateTexImage" != "glGetError" {
          report_error_as_necessary_from("InvalidateTexImage", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn InvalidateTexImage_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glInvalidateTexImage\0");
      self.glInvalidateTexImage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn InvalidateTexImage_is_loaded(&self) -> bool {
      !self.glInvalidateTexImage_p.load(RELAX).is_null()
    }
    /// [glInvalidateTexSubImage](http://docs.gl/gl4/glInvalidateTexSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn InvalidateTexSubImage(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      zoffset: GLint,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.InvalidateTexSubImage({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", texture, level, xoffset, yoffset, zoffset, width, height, depth);
      }
      let p = self.glInvalidateTexSubImage_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(texture, level, xoffset, yoffset, zoffset, width, height, depth)
        }
        None => go_panic_because_fn_not_loaded("glInvalidateTexSubImage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glInvalidateTexSubImage" != "glGetError" {
          report_error_as_necessary_from(
            "InvalidateTexSubImage",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn InvalidateTexSubImage_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glInvalidateTexSubImage\0");
      self.glInvalidateTexSubImage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn InvalidateTexSubImage_is_loaded(&self) -> bool {
      !self.glInvalidateTexSubImage_p.load(RELAX).is_null()
    }
    /// [glIsBuffer](http://docs.gl/gl4/glIsBuffer)(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsBuffer(&self, buffer: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsBuffer({:?});", buffer);
      }
      let p = self.glIsBuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(buffer),
        None => go_panic_because_fn_not_loaded("glIsBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsBuffer" != "glGetError" {
          report_error_as_necessary_from("IsBuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsBuffer_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glIsBuffer\0");
      self.glIsBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsBuffer_is_loaded(&self) -> bool {
      !self.glIsBuffer_p.load(RELAX).is_null()
    }
    /// [glIsEnabled](http://docs.gl/gl4/glIsEnabled)(cap)
    /// * `cap` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsEnabled(&self, cap: GLenum) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsEnabled({:#X});", cap);
      }
      let p = self.glIsEnabled_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(cap),
        None => go_panic_because_fn_not_loaded("glIsEnabled"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsEnabled" != "glGetError" {
          report_error_as_necessary_from("IsEnabled", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsEnabled_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glIsEnabled\0");
      self.glIsEnabled_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsEnabled_is_loaded(&self) -> bool {
      !self.glIsEnabled_p.load(RELAX).is_null()
    }
    /// [glIsEnabledi](http://docs.gl/gl4/glIsEnabledi)(target, index)
    /// * `target` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsEnabledi(
      &self,
      target: GLenum,
      index: GLuint,
    ) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsEnabledi({:#X}, {:?});", target, index);
      }
      let p = self.glIsEnabledi_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLuint) -> GLboolean>>(p) {
          Some(fn_p) => fn_p(target, index),
          None => go_panic_because_fn_not_loaded("glIsEnabledi"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsEnabledi" != "glGetError" {
          report_error_as_necessary_from("IsEnabledi", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsEnabledi_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glIsEnabledi\0");
      self.glIsEnabledi_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsEnabledi_is_loaded(&self) -> bool {
      !self.glIsEnabledi_p.load(RELAX).is_null()
    }
    /// [glIsFramebuffer](http://docs.gl/gl4/glIsFramebuffer)(framebuffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsFramebuffer(&self, framebuffer: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsFramebuffer({:?});", framebuffer);
      }
      let p = self.glIsFramebuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(framebuffer),
        None => go_panic_because_fn_not_loaded("glIsFramebuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsFramebuffer" != "glGetError" {
          report_error_as_necessary_from("IsFramebuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsFramebuffer_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glIsFramebuffer\0");
      self.glIsFramebuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsFramebuffer_is_loaded(&self) -> bool {
      !self.glIsFramebuffer_p.load(RELAX).is_null()
    }
    /// [glIsProgram](http://docs.gl/gl4/glIsProgram)(program)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsProgram(&self, program: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsProgram({:?});", program);
      }
      let p = self.glIsProgram_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(program),
        None => go_panic_because_fn_not_loaded("glIsProgram"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsProgram" != "glGetError" {
          report_error_as_necessary_from("IsProgram", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsProgram_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glIsProgram\0");
      self.glIsProgram_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsProgram_is_loaded(&self) -> bool {
      !self.glIsProgram_p.load(RELAX).is_null()
    }
    /// [glIsProgramPipeline](http://docs.gl/gl4/glIsProgramPipeline)(pipeline)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsProgramPipeline(&self, pipeline: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsProgramPipeline({:?});", pipeline);
      }
      let p = self.glIsProgramPipeline_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(pipeline),
        None => go_panic_because_fn_not_loaded("glIsProgramPipeline"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsProgramPipeline" != "glGetError" {
          report_error_as_necessary_from("IsProgramPipeline", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsProgramPipeline_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glIsProgramPipeline\0");
      self.glIsProgramPipeline_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsProgramPipeline_is_loaded(&self) -> bool {
      !self.glIsProgramPipeline_p.load(RELAX).is_null()
    }
    /// [glIsQuery](http://docs.gl/gl4/glIsQuery)(id)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsQuery(&self, id: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsQuery({:?});", id);
      }
      let p = self.glIsQuery_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(id),
        None => go_panic_because_fn_not_loaded("glIsQuery"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsQuery" != "glGetError" {
          report_error_as_necessary_from("IsQuery", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsQuery_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glIsQuery\0");
      self.glIsQuery_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsQuery_is_loaded(&self) -> bool {
      !self.glIsQuery_p.load(RELAX).is_null()
    }
    /// [glIsRenderbuffer](http://docs.gl/gl4/glIsRenderbuffer)(renderbuffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsRenderbuffer(&self, renderbuffer: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsRenderbuffer({:?});", renderbuffer);
      }
      let p = self.glIsRenderbuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(renderbuffer),
        None => go_panic_because_fn_not_loaded("glIsRenderbuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsRenderbuffer" != "glGetError" {
          report_error_as_necessary_from("IsRenderbuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsRenderbuffer_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glIsRenderbuffer\0");
      self.glIsRenderbuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsRenderbuffer_is_loaded(&self) -> bool {
      !self.glIsRenderbuffer_p.load(RELAX).is_null()
    }
    /// [glIsSampler](http://docs.gl/gl4/glIsSampler)(sampler)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsSampler(&self, sampler: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsSampler({:?});", sampler);
      }
      let p = self.glIsSampler_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(sampler),
        None => go_panic_because_fn_not_loaded("glIsSampler"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsSampler" != "glGetError" {
          report_error_as_necessary_from("IsSampler", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsSampler_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glIsSampler\0");
      self.glIsSampler_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsSampler_is_loaded(&self) -> bool {
      !self.glIsSampler_p.load(RELAX).is_null()
    }
    /// [glIsShader](http://docs.gl/gl4/glIsShader)(shader)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsShader(&self, shader: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsShader({:?});", shader);
      }
      let p = self.glIsShader_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(shader),
        None => go_panic_because_fn_not_loaded("glIsShader"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsShader" != "glGetError" {
          report_error_as_necessary_from("IsShader", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsShader_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glIsShader\0");
      self.glIsShader_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsShader_is_loaded(&self) -> bool {
      !self.glIsShader_p.load(RELAX).is_null()
    }
    /// [glIsSync](http://docs.gl/gl4/glIsSync)(sync)
    /// * `sync` group: sync
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsSync(&self, sync: GLsync) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsSync({:p});", sync);
      }
      let p = self.glIsSync_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLsync) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(sync),
        None => go_panic_because_fn_not_loaded("glIsSync"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsSync" != "glGetError" {
          report_error_as_necessary_from("IsSync", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsSync_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glIsSync\0");
      self.glIsSync_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsSync_is_loaded(&self) -> bool {
      !self.glIsSync_p.load(RELAX).is_null()
    }
    /// [glIsTexture](http://docs.gl/gl4/glIsTexture)(texture)
    /// * `texture` group: Texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsTexture(&self, texture: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsTexture({:?});", texture);
      }
      let p = self.glIsTexture_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(texture),
        None => go_panic_because_fn_not_loaded("glIsTexture"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsTexture" != "glGetError" {
          report_error_as_necessary_from("IsTexture", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsTexture_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glIsTexture\0");
      self.glIsTexture_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsTexture_is_loaded(&self) -> bool {
      !self.glIsTexture_p.load(RELAX).is_null()
    }
    /// [glIsTransformFeedback](http://docs.gl/gl4/glIsTransformFeedback)(id)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsTransformFeedback(&self, id: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsTransformFeedback({:?});", id);
      }
      let p = self.glIsTransformFeedback_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(id),
        None => go_panic_because_fn_not_loaded("glIsTransformFeedback"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsTransformFeedback" != "glGetError" {
          report_error_as_necessary_from(
            "IsTransformFeedback",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsTransformFeedback_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glIsTransformFeedback\0");
      self.glIsTransformFeedback_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsTransformFeedback_is_loaded(&self) -> bool {
      !self.glIsTransformFeedback_p.load(RELAX).is_null()
    }
    /// [glIsVertexArray](http://docs.gl/gl4/glIsVertexArray)(array)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn IsVertexArray(&self, array: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.IsVertexArray({:?});", array);
      }
      let p = self.glIsVertexArray_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(array),
        None => go_panic_because_fn_not_loaded("glIsVertexArray"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glIsVertexArray" != "glGetError" {
          report_error_as_necessary_from("IsVertexArray", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn IsVertexArray_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glIsVertexArray\0");
      self.glIsVertexArray_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn IsVertexArray_is_loaded(&self) -> bool {
      !self.glIsVertexArray_p.load(RELAX).is_null()
    }
    /// [glLineWidth](http://docs.gl/gl4/glLineWidth)(width)
    /// * `width` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn LineWidth(&self, width: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.LineWidth({:?});", width);
      }
      let p = self.glLineWidth_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLfloat)>>(p) {
        Some(fn_p) => fn_p(width),
        None => go_panic_because_fn_not_loaded("glLineWidth"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glLineWidth" != "glGetError" {
          report_error_as_necessary_from("LineWidth", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn LineWidth_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glLineWidth\0");
      self.glLineWidth_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn LineWidth_is_loaded(&self) -> bool {
      !self.glLineWidth_p.load(RELAX).is_null()
    }
    /// [glLinkProgram](http://docs.gl/gl4/glLinkProgram)(program)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn LinkProgram(&self, program: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.LinkProgram({:?});", program);
      }
      let p = self.glLinkProgram_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(program),
        None => go_panic_because_fn_not_loaded("glLinkProgram"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glLinkProgram" != "glGetError" {
          report_error_as_necessary_from("LinkProgram", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn LinkProgram_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glLinkProgram\0");
      self.glLinkProgram_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn LinkProgram_is_loaded(&self) -> bool {
      !self.glLinkProgram_p.load(RELAX).is_null()
    }
    /// [glLogicOp](http://docs.gl/gl4/glLogicOp)(opcode)
    /// * `opcode` group: LogicOp
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn LogicOp(&self, opcode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.LogicOp({:#X});", opcode);
      }
      let p = self.glLogicOp_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(opcode),
        None => go_panic_because_fn_not_loaded("glLogicOp"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glLogicOp" != "glGetError" {
          report_error_as_necessary_from("LogicOp", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn LogicOp_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glLogicOp\0");
      self.glLogicOp_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn LogicOp_is_loaded(&self) -> bool {
      !self.glLogicOp_p.load(RELAX).is_null()
    }
    /// [glMapBuffer](http://docs.gl/gl4/glMapBuffer)(target, access)
    /// * `target` group: BufferTargetARB
    /// * `access` group: BufferAccessARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MapBuffer(
      &self,
      target: GLenum,
      access: GLenum,
    ) -> *mut c_void {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.MapBuffer({:#X}, {:#X});", target, access);
      }
      let p = self.glMapBuffer_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum) -> *mut c_void>,
      >(p)
      {
        Some(fn_p) => fn_p(target, access),
        None => go_panic_because_fn_not_loaded("glMapBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMapBuffer" != "glGetError" {
          report_error_as_necessary_from("MapBuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MapBuffer_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glMapBuffer\0");
      self.glMapBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MapBuffer_is_loaded(&self) -> bool {
      !self.glMapBuffer_p.load(RELAX).is_null()
    }
    /// [glMapBufferRange](http://docs.gl/gl4/glMapBufferRange)(target, offset, length, access)
    /// * `target` group: BufferTargetARB
    /// * `offset` group: BufferOffset
    /// * `length` group: BufferSize
    /// * `access` group: MapBufferAccessMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MapBufferRange(
      &self,
      target: GLenum,
      offset: GLintptr,
      length: GLsizeiptr,
      access: GLbitfield,
    ) -> *mut c_void {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.MapBufferRange({:#X}, {:?}, {:?}, {:?});",
          target,
          offset,
          length,
          access
        );
      }
      let p = self.glMapBufferRange_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLintptr,
            GLsizeiptr,
            GLbitfield,
          ) -> *mut c_void,
        >,
      >(p)
      {
        Some(fn_p) => fn_p(target, offset, length, access),
        None => go_panic_because_fn_not_loaded("glMapBufferRange"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMapBufferRange" != "glGetError" {
          report_error_as_necessary_from("MapBufferRange", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MapBufferRange_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glMapBufferRange\0");
      self.glMapBufferRange_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MapBufferRange_is_loaded(&self) -> bool {
      !self.glMapBufferRange_p.load(RELAX).is_null()
    }
    /// [glMapNamedBuffer](http://docs.gl/gl4/glMapNamedBuffer)(buffer, access)
    /// * `access` group: BufferAccessARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MapNamedBuffer(
      &self,
      buffer: GLuint,
      access: GLenum,
    ) -> *mut c_void {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.MapNamedBuffer({:?}, {:#X});", buffer, access);
      }
      let p = self.glMapNamedBuffer_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum) -> *mut c_void>,
      >(p)
      {
        Some(fn_p) => fn_p(buffer, access),
        None => go_panic_because_fn_not_loaded("glMapNamedBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMapNamedBuffer" != "glGetError" {
          report_error_as_necessary_from("MapNamedBuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MapNamedBuffer_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glMapNamedBuffer\0");
      self.glMapNamedBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MapNamedBuffer_is_loaded(&self) -> bool {
      !self.glMapNamedBuffer_p.load(RELAX).is_null()
    }
    /// [glMapNamedBufferRange](http://docs.gl/gl4/glMapNamedBufferRange)(buffer, offset, length, access)
    /// * `length` group: BufferSize
    /// * `access` group: MapBufferAccessMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MapNamedBufferRange(
      &self,
      buffer: GLuint,
      offset: GLintptr,
      length: GLsizeiptr,
      access: GLbitfield,
    ) -> *mut c_void {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.MapNamedBufferRange({:?}, {:?}, {:?}, {:?});",
          buffer,
          offset,
          length,
          access
        );
      }
      let p = self.glMapNamedBufferRange_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLintptr,
            GLsizeiptr,
            GLbitfield,
          ) -> *mut c_void,
        >,
      >(p)
      {
        Some(fn_p) => fn_p(buffer, offset, length, access),
        None => go_panic_because_fn_not_loaded("glMapNamedBufferRange"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMapNamedBufferRange" != "glGetError" {
          report_error_as_necessary_from(
            "MapNamedBufferRange",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MapNamedBufferRange_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glMapNamedBufferRange\0");
      self.glMapNamedBufferRange_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MapNamedBufferRange_is_loaded(&self) -> bool {
      !self.glMapNamedBufferRange_p.load(RELAX).is_null()
    }
    /// [glMemoryBarrier](http://docs.gl/gl4/glMemoryBarrier)(barriers)
    /// * `barriers` group: MemoryBarrierMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MemoryBarrier(&self, barriers: GLbitfield) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.MemoryBarrier({:?});", barriers);
      }
      let p = self.glMemoryBarrier_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLbitfield)>>(p) {
        Some(fn_p) => fn_p(barriers),
        None => go_panic_because_fn_not_loaded("glMemoryBarrier"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMemoryBarrier" != "glGetError" {
          report_error_as_necessary_from("MemoryBarrier", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MemoryBarrier_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glMemoryBarrier\0");
      self.glMemoryBarrier_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MemoryBarrier_is_loaded(&self) -> bool {
      !self.glMemoryBarrier_p.load(RELAX).is_null()
    }
    /// [glMemoryBarrierByRegion](http://docs.gl/gl4/glMemoryBarrierByRegion)(barriers)
    /// * `barriers` group: MemoryBarrierMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MemoryBarrierByRegion(&self, barriers: GLbitfield) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.MemoryBarrierByRegion({:?});", barriers);
      }
      let p = self.glMemoryBarrierByRegion_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLbitfield)>>(p) {
        Some(fn_p) => fn_p(barriers),
        None => go_panic_because_fn_not_loaded("glMemoryBarrierByRegion"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMemoryBarrierByRegion" != "glGetError" {
          report_error_as_necessary_from(
            "MemoryBarrierByRegion",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MemoryBarrierByRegion_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glMemoryBarrierByRegion\0");
      self.glMemoryBarrierByRegion_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MemoryBarrierByRegion_is_loaded(&self) -> bool {
      !self.glMemoryBarrierByRegion_p.load(RELAX).is_null()
    }
    /// [glMinSampleShading](http://docs.gl/gl4/glMinSampleShading)(value)
    /// * `value` group: ColorF
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MinSampleShading(&self, value: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.MinSampleShading({:?});", value);
      }
      let p = self.glMinSampleShading_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLfloat)>>(p) {
        Some(fn_p) => fn_p(value),
        None => go_panic_because_fn_not_loaded("glMinSampleShading"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMinSampleShading" != "glGetError" {
          report_error_as_necessary_from("MinSampleShading", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MinSampleShading_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glMinSampleShading\0");
      self.glMinSampleShading_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MinSampleShading_is_loaded(&self) -> bool {
      !self.glMinSampleShading_p.load(RELAX).is_null()
    }
    /// [glMultiDrawArrays](http://docs.gl/gl4/glMultiDrawArrays)(mode, first, count, drawcount)
    /// * `mode` group: PrimitiveType
    /// * `first` len: COMPSIZE(drawcount)
    /// * `count` len: COMPSIZE(drawcount)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MultiDrawArrays(
      &self,
      mode: GLenum,
      first: *const GLint,
      count: *const GLsizei,
      drawcount: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.MultiDrawArrays({:#X}, {:p}, {:p}, {:?});",
          mode,
          first,
          count,
          drawcount
        );
      }
      let p = self.glMultiDrawArrays_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, *const GLint, *const GLsizei, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(mode, first, count, drawcount),
        None => go_panic_because_fn_not_loaded("glMultiDrawArrays"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMultiDrawArrays" != "glGetError" {
          report_error_as_necessary_from("MultiDrawArrays", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MultiDrawArrays_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glMultiDrawArrays\0");
      self.glMultiDrawArrays_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MultiDrawArrays_is_loaded(&self) -> bool {
      !self.glMultiDrawArrays_p.load(RELAX).is_null()
    }
    /// [glMultiDrawArraysIndirect](http://docs.gl/gl4/glMultiDrawArraysIndirect)(mode, indirect, drawcount, stride)
    /// * `mode` group: PrimitiveType
    /// * `indirect` len: COMPSIZE(drawcount,stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MultiDrawArraysIndirect(
      &self,
      mode: GLenum,
      indirect: *const c_void,
      drawcount: GLsizei,
      stride: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.MultiDrawArraysIndirect({:#X}, {:p}, {:?}, {:?});",
          mode,
          indirect,
          drawcount,
          stride
        );
      }
      let p = self.glMultiDrawArraysIndirect_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, *const c_void, GLsizei, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(mode, indirect, drawcount, stride),
        None => go_panic_because_fn_not_loaded("glMultiDrawArraysIndirect"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMultiDrawArraysIndirect" != "glGetError" {
          report_error_as_necessary_from(
            "MultiDrawArraysIndirect",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MultiDrawArraysIndirect_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glMultiDrawArraysIndirect\0");
      self.glMultiDrawArraysIndirect_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MultiDrawArraysIndirect_is_loaded(&self) -> bool {
      !self.glMultiDrawArraysIndirect_p.load(RELAX).is_null()
    }
    /// [glMultiDrawArraysIndirectCount](http://docs.gl/gl4/glMultiDrawArraysIndirectCount)(mode, indirect, drawcount, maxdrawcount, stride)
    /// * `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MultiDrawArraysIndirectCount(
      &self,
      mode: GLenum,
      indirect: *const c_void,
      drawcount: GLintptr,
      maxdrawcount: GLsizei,
      stride: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.MultiDrawArraysIndirectCount({:#X}, {:p}, {:?}, {:?}, {:?});", mode, indirect, drawcount, maxdrawcount, stride);
      }
      let p = self.glMultiDrawArraysIndirectCount_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(GLenum, *const c_void, GLintptr, GLsizei, GLsizei),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(mode, indirect, drawcount, maxdrawcount, stride),
        None => {
          go_panic_because_fn_not_loaded("glMultiDrawArraysIndirectCount")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMultiDrawArraysIndirectCount" != "glGetError" {
          report_error_as_necessary_from(
            "MultiDrawArraysIndirectCount",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MultiDrawArraysIndirectCount_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glMultiDrawArraysIndirectCount\0");
      self.glMultiDrawArraysIndirectCount_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MultiDrawArraysIndirectCount_is_loaded(&self) -> bool {
      !self.glMultiDrawArraysIndirectCount_p.load(RELAX).is_null()
    }
    /// [glMultiDrawElements](http://docs.gl/gl4/glMultiDrawElements)(mode, count, type_, indices, drawcount)
    /// * `mode` group: PrimitiveType
    /// * `count` len: COMPSIZE(drawcount)
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(drawcount)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MultiDrawElements(
      &self,
      mode: GLenum,
      count: *const GLsizei,
      type_: GLenum,
      indices: *const *const c_void,
      drawcount: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.MultiDrawElements({:#X}, {:p}, {:#X}, {:p}, {:?});",
          mode,
          count,
          type_,
          indices,
          drawcount
        );
      }
      let p = self.glMultiDrawElements_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            *const GLsizei,
            GLenum,
            *const *const c_void,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(mode, count, type_, indices, drawcount),
        None => go_panic_because_fn_not_loaded("glMultiDrawElements"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMultiDrawElements" != "glGetError" {
          report_error_as_necessary_from("MultiDrawElements", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MultiDrawElements_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glMultiDrawElements\0");
      self.glMultiDrawElements_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MultiDrawElements_is_loaded(&self) -> bool {
      !self.glMultiDrawElements_p.load(RELAX).is_null()
    }
    /// [glMultiDrawElementsBaseVertex](http://docs.gl/gl4/glMultiDrawElementsBaseVertex)(mode, count, type_, indices, drawcount, basevertex)
    /// * `mode` group: PrimitiveType
    /// * `count` len: COMPSIZE(drawcount)
    /// * `type_` group: DrawElementsType
    /// * `indices` len: COMPSIZE(drawcount)
    /// * `basevertex` len: COMPSIZE(drawcount)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MultiDrawElementsBaseVertex(
      &self,
      mode: GLenum,
      count: *const GLsizei,
      type_: GLenum,
      indices: *const *const c_void,
      drawcount: GLsizei,
      basevertex: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.MultiDrawElementsBaseVertex({:#X}, {:p}, {:#X}, {:p}, {:?}, {:p});", mode, count, type_, indices, drawcount, basevertex);
      }
      let p = self.glMultiDrawElementsBaseVertex_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            *const GLsizei,
            GLenum,
            *const *const c_void,
            GLsizei,
            *const GLint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(mode, count, type_, indices, drawcount, basevertex),
        None => go_panic_because_fn_not_loaded("glMultiDrawElementsBaseVertex"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMultiDrawElementsBaseVertex" != "glGetError" {
          report_error_as_necessary_from(
            "MultiDrawElementsBaseVertex",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MultiDrawElementsBaseVertex_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glMultiDrawElementsBaseVertex\0");
      self.glMultiDrawElementsBaseVertex_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MultiDrawElementsBaseVertex_is_loaded(&self) -> bool {
      !self.glMultiDrawElementsBaseVertex_p.load(RELAX).is_null()
    }
    /// [glMultiDrawElementsIndirect](http://docs.gl/gl4/glMultiDrawElementsIndirect)(mode, type_, indirect, drawcount, stride)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    /// * `indirect` len: COMPSIZE(drawcount,stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MultiDrawElementsIndirect(
      &self,
      mode: GLenum,
      type_: GLenum,
      indirect: *const c_void,
      drawcount: GLsizei,
      stride: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.MultiDrawElementsIndirect({:#X}, {:#X}, {:p}, {:?}, {:?});", mode, type_, indirect, drawcount, stride);
      }
      let p = self.glMultiDrawElementsIndirect_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, *const c_void, GLsizei, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(mode, type_, indirect, drawcount, stride),
        None => go_panic_because_fn_not_loaded("glMultiDrawElementsIndirect"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMultiDrawElementsIndirect" != "glGetError" {
          report_error_as_necessary_from(
            "MultiDrawElementsIndirect",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MultiDrawElementsIndirect_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glMultiDrawElementsIndirect\0");
      self.glMultiDrawElementsIndirect_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MultiDrawElementsIndirect_is_loaded(&self) -> bool {
      !self.glMultiDrawElementsIndirect_p.load(RELAX).is_null()
    }
    /// [glMultiDrawElementsIndirectCount](http://docs.gl/gl4/glMultiDrawElementsIndirectCount)(mode, type_, indirect, drawcount, maxdrawcount, stride)
    /// * `mode` group: PrimitiveType
    /// * `type_` group: DrawElementsType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn MultiDrawElementsIndirectCount(
      &self,
      mode: GLenum,
      type_: GLenum,
      indirect: *const c_void,
      drawcount: GLintptr,
      maxdrawcount: GLsizei,
      stride: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.MultiDrawElementsIndirectCount({:#X}, {:#X}, {:p}, {:?}, {:?}, {:?});", mode, type_, indirect, drawcount, maxdrawcount, stride);
      }
      let p = self.glMultiDrawElementsIndirectCount_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLenum,
            *const c_void,
            GLintptr,
            GLsizei,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(mode, type_, indirect, drawcount, maxdrawcount, stride)
        }
        None => {
          go_panic_because_fn_not_loaded("glMultiDrawElementsIndirectCount")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glMultiDrawElementsIndirectCount" != "glGetError" {
          report_error_as_necessary_from(
            "MultiDrawElementsIndirectCount",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn MultiDrawElementsIndirectCount_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glMultiDrawElementsIndirectCount\0");
      self.glMultiDrawElementsIndirectCount_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn MultiDrawElementsIndirectCount_is_loaded(&self) -> bool {
      !self.glMultiDrawElementsIndirectCount_p.load(RELAX).is_null()
    }
    /// [glNamedBufferData](http://docs.gl/gl4/glNamedBufferData)(buffer, size, data, usage)
    /// * `size` group: BufferSize
    /// * `usage` group: VertexBufferObjectUsage
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn NamedBufferData(
      &self,
      buffer: GLuint,
      size: GLsizeiptr,
      data: *const c_void,
      usage: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.NamedBufferData({:?}, {:?}, {:p}, {:#X});",
          buffer,
          size,
          data,
          usage
        );
      }
      let p = self.glNamedBufferData_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizeiptr, *const c_void, GLenum)>,
      >(p)
      {
        Some(fn_p) => fn_p(buffer, size, data, usage),
        None => go_panic_because_fn_not_loaded("glNamedBufferData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glNamedBufferData" != "glGetError" {
          report_error_as_necessary_from("NamedBufferData", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn NamedBufferData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glNamedBufferData\0");
      self.glNamedBufferData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn NamedBufferData_is_loaded(&self) -> bool {
      !self.glNamedBufferData_p.load(RELAX).is_null()
    }
    /// [glNamedBufferStorage](http://docs.gl/gl4/glNamedBufferStorage)(buffer, size, data, flags)
    /// * `size` group: BufferSize
    /// * `data` len: size
    /// * `flags` group: BufferStorageMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn NamedBufferStorage(
      &self,
      buffer: GLuint,
      size: GLsizeiptr,
      data: *const c_void,
      flags: GLbitfield,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.NamedBufferStorage({:?}, {:?}, {:p}, {:?});",
          buffer,
          size,
          data,
          flags
        );
      }
      let p = self.glNamedBufferStorage_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizeiptr, *const c_void, GLbitfield)>,
      >(p)
      {
        Some(fn_p) => fn_p(buffer, size, data, flags),
        None => go_panic_because_fn_not_loaded("glNamedBufferStorage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glNamedBufferStorage" != "glGetError" {
          report_error_as_necessary_from("NamedBufferStorage", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn NamedBufferStorage_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glNamedBufferStorage\0");
      self.glNamedBufferStorage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn NamedBufferStorage_is_loaded(&self) -> bool {
      !self.glNamedBufferStorage_p.load(RELAX).is_null()
    }
    /// [glNamedBufferSubData](http://docs.gl/gl4/glNamedBufferSubData)(buffer, offset, size, data)
    /// * `size` group: BufferSize
    /// * `data` len: COMPSIZE(size)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn NamedBufferSubData(
      &self,
      buffer: GLuint,
      offset: GLintptr,
      size: GLsizeiptr,
      data: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.NamedBufferSubData({:?}, {:?}, {:?}, {:p});",
          buffer,
          offset,
          size,
          data
        );
      }
      let p = self.glNamedBufferSubData_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLintptr, GLsizeiptr, *const c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(buffer, offset, size, data),
        None => go_panic_because_fn_not_loaded("glNamedBufferSubData"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glNamedBufferSubData" != "glGetError" {
          report_error_as_necessary_from("NamedBufferSubData", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn NamedBufferSubData_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glNamedBufferSubData\0");
      self.glNamedBufferSubData_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn NamedBufferSubData_is_loaded(&self) -> bool {
      !self.glNamedBufferSubData_p.load(RELAX).is_null()
    }
    /// [glNamedFramebufferDrawBuffer](http://docs.gl/gl4/glNamedFramebufferDrawBuffer)(framebuffer, buf)
    /// * `buf` group: ColorBuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn NamedFramebufferDrawBuffer(
      &self,
      framebuffer: GLuint,
      buf: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.NamedFramebufferDrawBuffer({:?}, {:#X});",
          framebuffer,
          buf
        );
      }
      let p = self.glNamedFramebufferDrawBuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum)>>(p) {
        Some(fn_p) => fn_p(framebuffer, buf),
        None => go_panic_because_fn_not_loaded("glNamedFramebufferDrawBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glNamedFramebufferDrawBuffer" != "glGetError" {
          report_error_as_necessary_from(
            "NamedFramebufferDrawBuffer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn NamedFramebufferDrawBuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glNamedFramebufferDrawBuffer\0");
      self.glNamedFramebufferDrawBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn NamedFramebufferDrawBuffer_is_loaded(&self) -> bool {
      !self.glNamedFramebufferDrawBuffer_p.load(RELAX).is_null()
    }
    /// [glNamedFramebufferDrawBuffers](http://docs.gl/gl4/glNamedFramebufferDrawBuffers)(framebuffer, n, bufs)
    /// * `bufs` group: ColorBuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn NamedFramebufferDrawBuffers(
      &self,
      framebuffer: GLuint,
      n: GLsizei,
      bufs: *const GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.NamedFramebufferDrawBuffers({:?}, {:?}, {:p});",
          framebuffer,
          n,
          bufs
        );
      }
      let p = self.glNamedFramebufferDrawBuffers_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizei, *const GLenum)>,
      >(p)
      {
        Some(fn_p) => fn_p(framebuffer, n, bufs),
        None => go_panic_because_fn_not_loaded("glNamedFramebufferDrawBuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glNamedFramebufferDrawBuffers" != "glGetError" {
          report_error_as_necessary_from(
            "NamedFramebufferDrawBuffers",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn NamedFramebufferDrawBuffers_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glNamedFramebufferDrawBuffers\0");
      self.glNamedFramebufferDrawBuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn NamedFramebufferDrawBuffers_is_loaded(&self) -> bool {
      !self.glNamedFramebufferDrawBuffers_p.load(RELAX).is_null()
    }
    /// [glNamedFramebufferParameteri](http://docs.gl/gl4/glNamedFramebufferParameteri)(framebuffer, pname, param)
    /// * `pname` group: FramebufferParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn NamedFramebufferParameteri(
      &self,
      framebuffer: GLuint,
      pname: GLenum,
      param: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.NamedFramebufferParameteri({:?}, {:#X}, {:?});",
          framebuffer,
          pname,
          param
        );
      }
      let p = self.glNamedFramebufferParameteri_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLint)>>(p) {
        Some(fn_p) => fn_p(framebuffer, pname, param),
        None => go_panic_because_fn_not_loaded("glNamedFramebufferParameteri"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glNamedFramebufferParameteri" != "glGetError" {
          report_error_as_necessary_from(
            "NamedFramebufferParameteri",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn NamedFramebufferParameteri_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glNamedFramebufferParameteri\0");
      self.glNamedFramebufferParameteri_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn NamedFramebufferParameteri_is_loaded(&self) -> bool {
      !self.glNamedFramebufferParameteri_p.load(RELAX).is_null()
    }
    /// [glNamedFramebufferReadBuffer](http://docs.gl/gl4/glNamedFramebufferReadBuffer)(framebuffer, src)
    /// * `src` group: ColorBuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn NamedFramebufferReadBuffer(
      &self,
      framebuffer: GLuint,
      src: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.NamedFramebufferReadBuffer({:?}, {:#X});",
          framebuffer,
          src
        );
      }
      let p = self.glNamedFramebufferReadBuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum)>>(p) {
        Some(fn_p) => fn_p(framebuffer, src),
        None => go_panic_because_fn_not_loaded("glNamedFramebufferReadBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glNamedFramebufferReadBuffer" != "glGetError" {
          report_error_as_necessary_from(
            "NamedFramebufferReadBuffer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn NamedFramebufferReadBuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glNamedFramebufferReadBuffer\0");
      self.glNamedFramebufferReadBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn NamedFramebufferReadBuffer_is_loaded(&self) -> bool {
      !self.glNamedFramebufferReadBuffer_p.load(RELAX).is_null()
    }
    /// [glNamedFramebufferRenderbuffer](http://docs.gl/gl4/glNamedFramebufferRenderbuffer)(framebuffer, attachment, renderbuffertarget, renderbuffer)
    /// * `attachment` group: FramebufferAttachment
    /// * `renderbuffertarget` group: RenderbufferTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn NamedFramebufferRenderbuffer(
      &self,
      framebuffer: GLuint,
      attachment: GLenum,
      renderbuffertarget: GLenum,
      renderbuffer: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.NamedFramebufferRenderbuffer({:?}, {:#X}, {:#X}, {:?});",
          framebuffer,
          attachment,
          renderbuffertarget,
          renderbuffer
        );
      }
      let p = self.glNamedFramebufferRenderbuffer_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, GLenum, GLuint)>>(p)
        {
          Some(fn_p) => {
            fn_p(framebuffer, attachment, renderbuffertarget, renderbuffer)
          }
          None => {
            go_panic_because_fn_not_loaded("glNamedFramebufferRenderbuffer")
          }
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glNamedFramebufferRenderbuffer" != "glGetError" {
          report_error_as_necessary_from(
            "NamedFramebufferRenderbuffer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn NamedFramebufferRenderbuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glNamedFramebufferRenderbuffer\0");
      self.glNamedFramebufferRenderbuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn NamedFramebufferRenderbuffer_is_loaded(&self) -> bool {
      !self.glNamedFramebufferRenderbuffer_p.load(RELAX).is_null()
    }
    /// [glNamedFramebufferTexture](http://docs.gl/gl4/glNamedFramebufferTexture)(framebuffer, attachment, texture, level)
    /// * `attachment` group: FramebufferAttachment
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn NamedFramebufferTexture(
      &self,
      framebuffer: GLuint,
      attachment: GLenum,
      texture: GLuint,
      level: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.NamedFramebufferTexture({:?}, {:#X}, {:?}, {:?});",
          framebuffer,
          attachment,
          texture,
          level
        );
      }
      let p = self.glNamedFramebufferTexture_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLuint, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(framebuffer, attachment, texture, level),
        None => go_panic_because_fn_not_loaded("glNamedFramebufferTexture"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glNamedFramebufferTexture" != "glGetError" {
          report_error_as_necessary_from(
            "NamedFramebufferTexture",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn NamedFramebufferTexture_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glNamedFramebufferTexture\0");
      self.glNamedFramebufferTexture_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn NamedFramebufferTexture_is_loaded(&self) -> bool {
      !self.glNamedFramebufferTexture_p.load(RELAX).is_null()
    }
    /// [glNamedFramebufferTextureLayer](http://docs.gl/gl4/glNamedFramebufferTextureLayer)(framebuffer, attachment, texture, level, layer)
    /// * `attachment` group: FramebufferAttachment
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn NamedFramebufferTextureLayer(
      &self,
      framebuffer: GLuint,
      attachment: GLenum,
      texture: GLuint,
      level: GLint,
      layer: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.NamedFramebufferTextureLayer({:?}, {:#X}, {:?}, {:?}, {:?});", framebuffer, attachment, texture, level, layer);
      }
      let p = self.glNamedFramebufferTextureLayer_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLuint, GLint, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(framebuffer, attachment, texture, level, layer),
        None => {
          go_panic_because_fn_not_loaded("glNamedFramebufferTextureLayer")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glNamedFramebufferTextureLayer" != "glGetError" {
          report_error_as_necessary_from(
            "NamedFramebufferTextureLayer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn NamedFramebufferTextureLayer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glNamedFramebufferTextureLayer\0");
      self.glNamedFramebufferTextureLayer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn NamedFramebufferTextureLayer_is_loaded(&self) -> bool {
      !self.glNamedFramebufferTextureLayer_p.load(RELAX).is_null()
    }
    /// [glNamedRenderbufferStorage](http://docs.gl/gl4/glNamedRenderbufferStorage)(renderbuffer, internalformat, width, height)
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn NamedRenderbufferStorage(
      &self,
      renderbuffer: GLuint,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.NamedRenderbufferStorage({:?}, {:#X}, {:?}, {:?});",
          renderbuffer,
          internalformat,
          width,
          height
        );
      }
      let p = self.glNamedRenderbufferStorage_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, GLsizei, GLsizei)>>(
          p,
        ) {
          Some(fn_p) => fn_p(renderbuffer, internalformat, width, height),
          None => go_panic_because_fn_not_loaded("glNamedRenderbufferStorage"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glNamedRenderbufferStorage" != "glGetError" {
          report_error_as_necessary_from(
            "NamedRenderbufferStorage",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn NamedRenderbufferStorage_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glNamedRenderbufferStorage\0");
      self.glNamedRenderbufferStorage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn NamedRenderbufferStorage_is_loaded(&self) -> bool {
      !self.glNamedRenderbufferStorage_p.load(RELAX).is_null()
    }
    /// [glNamedRenderbufferStorageMultisample](http://docs.gl/gl4/glNamedRenderbufferStorageMultisample)(renderbuffer, samples, internalformat, width, height)
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn NamedRenderbufferStorageMultisample(
      &self,
      renderbuffer: GLuint,
      samples: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.NamedRenderbufferStorageMultisample({:?}, {:?}, {:#X}, {:?}, {:?});", renderbuffer, samples, internalformat, width, height);
      }
      let p = self.glNamedRenderbufferStorageMultisample_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei)>,
      >(p)
      {
        Some(fn_p) => {
          fn_p(renderbuffer, samples, internalformat, width, height)
        }
        None => go_panic_because_fn_not_loaded(
          "glNamedRenderbufferStorageMultisample",
        ),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glNamedRenderbufferStorageMultisample" != "glGetError" {
          report_error_as_necessary_from(
            "NamedRenderbufferStorageMultisample",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn NamedRenderbufferStorageMultisample_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(
        get_proc_address,
        b"glNamedRenderbufferStorageMultisample\0",
      );
      self.glNamedRenderbufferStorageMultisample_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn NamedRenderbufferStorageMultisample_is_loaded(&self) -> bool {
      !self.glNamedRenderbufferStorageMultisample_p.load(RELAX).is_null()
    }
    /// [glObjectLabel](http://docs.gl/gl4/glObjectLabel)(identifier, name, length, label)
    /// * `identifier` group: ObjectIdentifier
    /// * `label` len: COMPSIZE(label,length)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ObjectLabel(
      &self,
      identifier: GLenum,
      name: GLuint,
      length: GLsizei,
      label: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ObjectLabel({:#X}, {:?}, {:?}, {:p});",
          identifier,
          name,
          length,
          label
        );
      }
      let p = self.glObjectLabel_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLuint, GLsizei, *const GLchar)>,
      >(p)
      {
        Some(fn_p) => fn_p(identifier, name, length, label),
        None => go_panic_because_fn_not_loaded("glObjectLabel"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glObjectLabel" != "glGetError" {
          report_error_as_necessary_from("ObjectLabel", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ObjectLabel_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glObjectLabel\0");
      self.glObjectLabel_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ObjectLabel_is_loaded(&self) -> bool {
      !self.glObjectLabel_p.load(RELAX).is_null()
    }
    /// [glObjectPtrLabel](http://docs.gl/gl4/glObjectPtrLabel)(ptr, length, label)
    /// * `label` len: COMPSIZE(label,length)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ObjectPtrLabel(
      &self,
      ptr: *const c_void,
      length: GLsizei,
      label: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ObjectPtrLabel({:p}, {:?}, {:p});",
          ptr,
          length,
          label
        );
      }
      let p = self.glObjectPtrLabel_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(*const c_void, GLsizei, *const GLchar)>,
      >(p)
      {
        Some(fn_p) => fn_p(ptr, length, label),
        None => go_panic_because_fn_not_loaded("glObjectPtrLabel"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glObjectPtrLabel" != "glGetError" {
          report_error_as_necessary_from("ObjectPtrLabel", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ObjectPtrLabel_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glObjectPtrLabel\0");
      self.glObjectPtrLabel_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ObjectPtrLabel_is_loaded(&self) -> bool {
      !self.glObjectPtrLabel_p.load(RELAX).is_null()
    }
    /// [glPatchParameterfv](http://docs.gl/gl4/glPatchParameterfv)(pname, values)
    /// * `pname` group: PatchParameterName
    /// * `values` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PatchParameterfv(
      &self,
      pname: GLenum,
      values: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PatchParameterfv({:#X}, {:p});", pname, values);
      }
      let p = self.glPatchParameterfv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, *const GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(pname, values),
        None => go_panic_because_fn_not_loaded("glPatchParameterfv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPatchParameterfv" != "glGetError" {
          report_error_as_necessary_from("PatchParameterfv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PatchParameterfv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glPatchParameterfv\0");
      self.glPatchParameterfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PatchParameterfv_is_loaded(&self) -> bool {
      !self.glPatchParameterfv_p.load(RELAX).is_null()
    }
    /// [glPatchParameteri](http://docs.gl/gl4/glPatchParameteri)(pname, value)
    /// * `pname` group: PatchParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PatchParameteri(&self, pname: GLenum, value: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PatchParameteri({:#X}, {:?});", pname, value);
      }
      let p = self.glPatchParameteri_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLint)>>(p) {
        Some(fn_p) => fn_p(pname, value),
        None => go_panic_because_fn_not_loaded("glPatchParameteri"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPatchParameteri" != "glGetError" {
          report_error_as_necessary_from("PatchParameteri", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PatchParameteri_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glPatchParameteri\0");
      self.glPatchParameteri_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PatchParameteri_is_loaded(&self) -> bool {
      !self.glPatchParameteri_p.load(RELAX).is_null()
    }
    /// [glPauseTransformFeedback](http://docs.gl/gl4/glPauseTransformFeedback)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PauseTransformFeedback(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PauseTransformFeedback();",);
      }
      let p = self.glPauseTransformFeedback_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn()>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded("glPauseTransformFeedback"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPauseTransformFeedback" != "glGetError" {
          report_error_as_necessary_from(
            "PauseTransformFeedback",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PauseTransformFeedback_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glPauseTransformFeedback\0");
      self.glPauseTransformFeedback_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PauseTransformFeedback_is_loaded(&self) -> bool {
      !self.glPauseTransformFeedback_p.load(RELAX).is_null()
    }
    /// [glPixelStoref](http://docs.gl/gl4/glPixelStoref)(pname, param)
    /// * `pname` group: PixelStoreParameter
    /// * `param` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PixelStoref(&self, pname: GLenum, param: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PixelStoref({:#X}, {:?});", pname, param);
      }
      let p = self.glPixelStoref_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLfloat)>>(p) {
        Some(fn_p) => fn_p(pname, param),
        None => go_panic_because_fn_not_loaded("glPixelStoref"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPixelStoref" != "glGetError" {
          report_error_as_necessary_from("PixelStoref", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PixelStoref_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glPixelStoref\0");
      self.glPixelStoref_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PixelStoref_is_loaded(&self) -> bool {
      !self.glPixelStoref_p.load(RELAX).is_null()
    }
    /// [glPixelStorei](http://docs.gl/gl4/glPixelStorei)(pname, param)
    /// * `pname` group: PixelStoreParameter
    /// * `param` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PixelStorei(&self, pname: GLenum, param: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PixelStorei({:#X}, {:?});", pname, param);
      }
      let p = self.glPixelStorei_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLint)>>(p) {
        Some(fn_p) => fn_p(pname, param),
        None => go_panic_because_fn_not_loaded("glPixelStorei"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPixelStorei" != "glGetError" {
          report_error_as_necessary_from("PixelStorei", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PixelStorei_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glPixelStorei\0");
      self.glPixelStorei_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PixelStorei_is_loaded(&self) -> bool {
      !self.glPixelStorei_p.load(RELAX).is_null()
    }
    /// [glPointParameterf](http://docs.gl/gl4/glPointParameterf)(pname, param)
    /// * `pname` group: PointParameterNameARB
    /// * `param` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PointParameterf(&self, pname: GLenum, param: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PointParameterf({:#X}, {:?});", pname, param);
      }
      let p = self.glPointParameterf_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLfloat)>>(p) {
        Some(fn_p) => fn_p(pname, param),
        None => go_panic_because_fn_not_loaded("glPointParameterf"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPointParameterf" != "glGetError" {
          report_error_as_necessary_from("PointParameterf", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PointParameterf_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glPointParameterf\0");
      self.glPointParameterf_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PointParameterf_is_loaded(&self) -> bool {
      !self.glPointParameterf_p.load(RELAX).is_null()
    }
    /// [glPointParameterfv](http://docs.gl/gl4/glPointParameterfv)(pname, params)
    /// * `pname` group: PointParameterNameARB
    /// * `params` group: CheckedFloat32
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PointParameterfv(
      &self,
      pname: GLenum,
      params: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PointParameterfv({:#X}, {:p});", pname, params);
      }
      let p = self.glPointParameterfv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, *const GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(pname, params),
        None => go_panic_because_fn_not_loaded("glPointParameterfv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPointParameterfv" != "glGetError" {
          report_error_as_necessary_from("PointParameterfv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PointParameterfv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glPointParameterfv\0");
      self.glPointParameterfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PointParameterfv_is_loaded(&self) -> bool {
      !self.glPointParameterfv_p.load(RELAX).is_null()
    }
    /// [glPointParameteri](http://docs.gl/gl4/glPointParameteri)(pname, param)
    /// * `pname` group: PointParameterNameARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PointParameteri(&self, pname: GLenum, param: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PointParameteri({:#X}, {:?});", pname, param);
      }
      let p = self.glPointParameteri_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLint)>>(p) {
        Some(fn_p) => fn_p(pname, param),
        None => go_panic_because_fn_not_loaded("glPointParameteri"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPointParameteri" != "glGetError" {
          report_error_as_necessary_from("PointParameteri", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PointParameteri_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glPointParameteri\0");
      self.glPointParameteri_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PointParameteri_is_loaded(&self) -> bool {
      !self.glPointParameteri_p.load(RELAX).is_null()
    }
    /// [glPointParameteriv](http://docs.gl/gl4/glPointParameteriv)(pname, params)
    /// * `pname` group: PointParameterNameARB
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PointParameteriv(&self, pname: GLenum, params: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PointParameteriv({:#X}, {:p});", pname, params);
      }
      let p = self.glPointParameteriv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, *const GLint)>>(p) {
        Some(fn_p) => fn_p(pname, params),
        None => go_panic_because_fn_not_loaded("glPointParameteriv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPointParameteriv" != "glGetError" {
          report_error_as_necessary_from("PointParameteriv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PointParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glPointParameteriv\0");
      self.glPointParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PointParameteriv_is_loaded(&self) -> bool {
      !self.glPointParameteriv_p.load(RELAX).is_null()
    }
    /// [glPointSize](http://docs.gl/gl4/glPointSize)(size)
    /// * `size` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PointSize(&self, size: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PointSize({:?});", size);
      }
      let p = self.glPointSize_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLfloat)>>(p) {
        Some(fn_p) => fn_p(size),
        None => go_panic_because_fn_not_loaded("glPointSize"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPointSize" != "glGetError" {
          report_error_as_necessary_from("PointSize", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PointSize_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glPointSize\0");
      self.glPointSize_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PointSize_is_loaded(&self) -> bool {
      !self.glPointSize_p.load(RELAX).is_null()
    }
    /// [glPolygonMode](http://docs.gl/gl4/glPolygonMode)(face, mode)
    /// * `face` group: MaterialFace
    /// * `mode` group: PolygonMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PolygonMode(&self, face: GLenum, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PolygonMode({:#X}, {:#X});", face, mode);
      }
      let p = self.glPolygonMode_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLenum)>>(p) {
        Some(fn_p) => fn_p(face, mode),
        None => go_panic_because_fn_not_loaded("glPolygonMode"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPolygonMode" != "glGetError" {
          report_error_as_necessary_from("PolygonMode", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PolygonMode_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glPolygonMode\0");
      self.glPolygonMode_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PolygonMode_is_loaded(&self) -> bool {
      !self.glPolygonMode_p.load(RELAX).is_null()
    }
    /// [glPolygonOffset](http://docs.gl/gl4/glPolygonOffset)(factor, units)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PolygonOffset(&self, factor: GLfloat, units: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PolygonOffset({:?}, {:?});", factor, units);
      }
      let p = self.glPolygonOffset_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLfloat, GLfloat)>>(p) {
        Some(fn_p) => fn_p(factor, units),
        None => go_panic_because_fn_not_loaded("glPolygonOffset"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPolygonOffset" != "glGetError" {
          report_error_as_necessary_from("PolygonOffset", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PolygonOffset_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glPolygonOffset\0");
      self.glPolygonOffset_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PolygonOffset_is_loaded(&self) -> bool {
      !self.glPolygonOffset_p.load(RELAX).is_null()
    }
    /// [glPolygonOffsetClamp](http://docs.gl/gl4/glPolygonOffsetClamp)(factor, units, clamp)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PolygonOffsetClamp(
      &self,
      factor: GLfloat,
      units: GLfloat,
      clamp: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.PolygonOffsetClamp({:?}, {:?}, {:?});",
          factor,
          units,
          clamp
        );
      }
      let p = self.glPolygonOffsetClamp_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLfloat, GLfloat, GLfloat)>>(p) {
          Some(fn_p) => fn_p(factor, units, clamp),
          None => go_panic_because_fn_not_loaded("glPolygonOffsetClamp"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPolygonOffsetClamp" != "glGetError" {
          report_error_as_necessary_from("PolygonOffsetClamp", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PolygonOffsetClamp_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glPolygonOffsetClamp\0");
      self.glPolygonOffsetClamp_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PolygonOffsetClamp_is_loaded(&self) -> bool {
      !self.glPolygonOffsetClamp_p.load(RELAX).is_null()
    }
    /// [glPopDebugGroup](http://docs.gl/gl4/glPopDebugGroup)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PopDebugGroup(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PopDebugGroup();",);
      }
      let p = self.glPopDebugGroup_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn()>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded("glPopDebugGroup"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPopDebugGroup" != "glGetError" {
          report_error_as_necessary_from("PopDebugGroup", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PopDebugGroup_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glPopDebugGroup\0");
      self.glPopDebugGroup_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PopDebugGroup_is_loaded(&self) -> bool {
      !self.glPopDebugGroup_p.load(RELAX).is_null()
    }
    /// [glPrimitiveRestartIndex](http://docs.gl/gl4/glPrimitiveRestartIndex)(index)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PrimitiveRestartIndex(&self, index: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.PrimitiveRestartIndex({:?});", index);
      }
      let p = self.glPrimitiveRestartIndex_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(index),
        None => go_panic_because_fn_not_loaded("glPrimitiveRestartIndex"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPrimitiveRestartIndex" != "glGetError" {
          report_error_as_necessary_from(
            "PrimitiveRestartIndex",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PrimitiveRestartIndex_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glPrimitiveRestartIndex\0");
      self.glPrimitiveRestartIndex_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PrimitiveRestartIndex_is_loaded(&self) -> bool {
      !self.glPrimitiveRestartIndex_p.load(RELAX).is_null()
    }
    /// [glProgramBinary](http://docs.gl/gl4/glProgramBinary)(program, binaryFormat, binary, length)
    /// * `binary` len: length
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramBinary(
      &self,
      program: GLuint,
      binaryFormat: GLenum,
      binary: *const c_void,
      length: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramBinary({:?}, {:#X}, {:p}, {:?});",
          program,
          binaryFormat,
          binary,
          length
        );
      }
      let p = self.glProgramBinary_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, *const c_void, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, binaryFormat, binary, length),
        None => go_panic_because_fn_not_loaded("glProgramBinary"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramBinary" != "glGetError" {
          report_error_as_necessary_from("ProgramBinary", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramBinary_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramBinary\0");
      self.glProgramBinary_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramBinary_is_loaded(&self) -> bool {
      !self.glProgramBinary_p.load(RELAX).is_null()
    }
    /// [glProgramParameteri](http://docs.gl/gl4/glProgramParameteri)(program, pname, value)
    /// * `pname` group: ProgramParameterPName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramParameteri(
      &self,
      program: GLuint,
      pname: GLenum,
      value: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramParameteri({:?}, {:#X}, {:?});",
          program,
          pname,
          value
        );
      }
      let p = self.glProgramParameteri_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLint)>>(p) {
        Some(fn_p) => fn_p(program, pname, value),
        None => go_panic_because_fn_not_loaded("glProgramParameteri"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramParameteri" != "glGetError" {
          report_error_as_necessary_from("ProgramParameteri", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramParameteri_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramParameteri\0");
      self.glProgramParameteri_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramParameteri_is_loaded(&self) -> bool {
      !self.glProgramParameteri_p.load(RELAX).is_null()
    }
    /// [glProgramUniform1d](http://docs.gl/gl4/glProgramUniform1d)(program, location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform1d(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform1d({:?}, {:?}, {:?});",
          program,
          location,
          v0
        );
      }
      let p = self.glProgramUniform1d_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLint, GLdouble)>>(p)
      {
        Some(fn_p) => fn_p(program, location, v0),
        None => go_panic_because_fn_not_loaded("glProgramUniform1d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform1d" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform1d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform1d_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform1d\0");
      self.glProgramUniform1d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform1d_is_loaded(&self) -> bool {
      !self.glProgramUniform1d_p.load(RELAX).is_null()
    }
    /// [glProgramUniform1dv](http://docs.gl/gl4/glProgramUniform1dv)(program, location, count, value)
    /// * `value` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform1dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform1dv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform1dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform1dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform1dv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform1dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform1dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform1dv\0");
      self.glProgramUniform1dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform1dv_is_loaded(&self) -> bool {
      !self.glProgramUniform1dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform1f](http://docs.gl/gl4/glProgramUniform1f)(program, location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform1f(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform1f({:?}, {:?}, {:?});",
          program,
          location,
          v0
        );
      }
      let p = self.glProgramUniform1f_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLint, GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(program, location, v0),
        None => go_panic_because_fn_not_loaded("glProgramUniform1f"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform1f" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform1f", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform1f_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform1f\0");
      self.glProgramUniform1f_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform1f_is_loaded(&self) -> bool {
      !self.glProgramUniform1f_p.load(RELAX).is_null()
    }
    /// [glProgramUniform1fv](http://docs.gl/gl4/glProgramUniform1fv)(program, location, count, value)
    /// * `value` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform1fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform1fv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform1fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform1fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform1fv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform1fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform1fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform1fv\0");
      self.glProgramUniform1fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform1fv_is_loaded(&self) -> bool {
      !self.glProgramUniform1fv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform1i](http://docs.gl/gl4/glProgramUniform1i)(program, location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform1i(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform1i({:?}, {:?}, {:?});",
          program,
          location,
          v0
        );
      }
      let p = self.glProgramUniform1i_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLint, GLint)>>(p) {
        Some(fn_p) => fn_p(program, location, v0),
        None => go_panic_because_fn_not_loaded("glProgramUniform1i"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform1i" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform1i", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform1i_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform1i\0");
      self.glProgramUniform1i_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform1i_is_loaded(&self) -> bool {
      !self.glProgramUniform1i_p.load(RELAX).is_null()
    }
    /// [glProgramUniform1iv](http://docs.gl/gl4/glProgramUniform1iv)(program, location, count, value)
    /// * `value` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform1iv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform1iv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform1iv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform1iv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform1iv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform1iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform1iv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform1iv\0");
      self.glProgramUniform1iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform1iv_is_loaded(&self) -> bool {
      !self.glProgramUniform1iv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform1ui](http://docs.gl/gl4/glProgramUniform1ui)(program, location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform1ui(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform1ui({:?}, {:?}, {:?});",
          program,
          location,
          v0
        );
      }
      let p = self.glProgramUniform1ui_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLint, GLuint)>>(p) {
        Some(fn_p) => fn_p(program, location, v0),
        None => go_panic_because_fn_not_loaded("glProgramUniform1ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform1ui" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform1ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform1ui_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform1ui\0");
      self.glProgramUniform1ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform1ui_is_loaded(&self) -> bool {
      !self.glProgramUniform1ui_p.load(RELAX).is_null()
    }
    /// [glProgramUniform1uiv](http://docs.gl/gl4/glProgramUniform1uiv)(program, location, count, value)
    /// * `value` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform1uiv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform1uiv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform1uiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform1uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform1uiv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform1uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform1uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform1uiv\0");
      self.glProgramUniform1uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform1uiv_is_loaded(&self) -> bool {
      !self.glProgramUniform1uiv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform2d](http://docs.gl/gl4/glProgramUniform2d)(program, location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform2d(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLdouble,
      v1: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform2d({:?}, {:?}, {:?}, {:?});",
          program,
          location,
          v0,
          v1
        );
      }
      let p = self.glProgramUniform2d_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLdouble, GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, v0, v1),
        None => go_panic_because_fn_not_loaded("glProgramUniform2d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform2d" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform2d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform2d_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform2d\0");
      self.glProgramUniform2d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform2d_is_loaded(&self) -> bool {
      !self.glProgramUniform2d_p.load(RELAX).is_null()
    }
    /// [glProgramUniform2dv](http://docs.gl/gl4/glProgramUniform2dv)(program, location, count, value)
    /// * `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform2dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform2dv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform2dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform2dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform2dv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform2dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform2dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform2dv\0");
      self.glProgramUniform2dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform2dv_is_loaded(&self) -> bool {
      !self.glProgramUniform2dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform2f](http://docs.gl/gl4/glProgramUniform2f)(program, location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform2f(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLfloat,
      v1: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform2f({:?}, {:?}, {:?}, {:?});",
          program,
          location,
          v0,
          v1
        );
      }
      let p = self.glProgramUniform2f_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLfloat, GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, v0, v1),
        None => go_panic_because_fn_not_loaded("glProgramUniform2f"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform2f" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform2f", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform2f_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform2f\0");
      self.glProgramUniform2f_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform2f_is_loaded(&self) -> bool {
      !self.glProgramUniform2f_p.load(RELAX).is_null()
    }
    /// [glProgramUniform2fv](http://docs.gl/gl4/glProgramUniform2fv)(program, location, count, value)
    /// * `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform2fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform2fv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform2fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform2fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform2fv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform2fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform2fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform2fv\0");
      self.glProgramUniform2fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform2fv_is_loaded(&self) -> bool {
      !self.glProgramUniform2fv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform2i](http://docs.gl/gl4/glProgramUniform2i)(program, location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform2i(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLint,
      v1: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform2i({:?}, {:?}, {:?}, {:?});",
          program,
          location,
          v0,
          v1
        );
      }
      let p = self.glProgramUniform2i_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLint, GLint, GLint)>>(p) {
          Some(fn_p) => fn_p(program, location, v0, v1),
          None => go_panic_because_fn_not_loaded("glProgramUniform2i"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform2i" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform2i", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform2i_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform2i\0");
      self.glProgramUniform2i_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform2i_is_loaded(&self) -> bool {
      !self.glProgramUniform2i_p.load(RELAX).is_null()
    }
    /// [glProgramUniform2iv](http://docs.gl/gl4/glProgramUniform2iv)(program, location, count, value)
    /// * `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform2iv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform2iv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform2iv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform2iv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform2iv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform2iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform2iv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform2iv\0");
      self.glProgramUniform2iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform2iv_is_loaded(&self) -> bool {
      !self.glProgramUniform2iv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform2ui](http://docs.gl/gl4/glProgramUniform2ui)(program, location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform2ui(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLuint,
      v1: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform2ui({:?}, {:?}, {:?}, {:?});",
          program,
          location,
          v0,
          v1
        );
      }
      let p = self.glProgramUniform2ui_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLuint, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, v0, v1),
        None => go_panic_because_fn_not_loaded("glProgramUniform2ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform2ui" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform2ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform2ui_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform2ui\0");
      self.glProgramUniform2ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform2ui_is_loaded(&self) -> bool {
      !self.glProgramUniform2ui_p.load(RELAX).is_null()
    }
    /// [glProgramUniform2uiv](http://docs.gl/gl4/glProgramUniform2uiv)(program, location, count, value)
    /// * `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform2uiv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform2uiv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform2uiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform2uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform2uiv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform2uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform2uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform2uiv\0");
      self.glProgramUniform2uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform2uiv_is_loaded(&self) -> bool {
      !self.glProgramUniform2uiv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform3d](http://docs.gl/gl4/glProgramUniform3d)(program, location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform3d(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLdouble,
      v1: GLdouble,
      v2: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform3d({:?}, {:?}, {:?}, {:?}, {:?});",
          program,
          location,
          v0,
          v1,
          v2
        );
      }
      let p = self.glProgramUniform3d_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLdouble, GLdouble, GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, v0, v1, v2),
        None => go_panic_because_fn_not_loaded("glProgramUniform3d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform3d" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform3d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform3d_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform3d\0");
      self.glProgramUniform3d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform3d_is_loaded(&self) -> bool {
      !self.glProgramUniform3d_p.load(RELAX).is_null()
    }
    /// [glProgramUniform3dv](http://docs.gl/gl4/glProgramUniform3dv)(program, location, count, value)
    /// * `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform3dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform3dv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform3dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform3dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform3dv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform3dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform3dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform3dv\0");
      self.glProgramUniform3dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform3dv_is_loaded(&self) -> bool {
      !self.glProgramUniform3dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform3f](http://docs.gl/gl4/glProgramUniform3f)(program, location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform3f(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLfloat,
      v1: GLfloat,
      v2: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform3f({:?}, {:?}, {:?}, {:?}, {:?});",
          program,
          location,
          v0,
          v1,
          v2
        );
      }
      let p = self.glProgramUniform3f_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLfloat, GLfloat, GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, v0, v1, v2),
        None => go_panic_because_fn_not_loaded("glProgramUniform3f"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform3f" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform3f", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform3f_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform3f\0");
      self.glProgramUniform3f_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform3f_is_loaded(&self) -> bool {
      !self.glProgramUniform3f_p.load(RELAX).is_null()
    }
    /// [glProgramUniform3fv](http://docs.gl/gl4/glProgramUniform3fv)(program, location, count, value)
    /// * `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform3fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform3fv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform3fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform3fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform3fv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform3fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform3fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform3fv\0");
      self.glProgramUniform3fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform3fv_is_loaded(&self) -> bool {
      !self.glProgramUniform3fv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform3i](http://docs.gl/gl4/glProgramUniform3i)(program, location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform3i(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLint,
      v1: GLint,
      v2: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform3i({:?}, {:?}, {:?}, {:?}, {:?});",
          program,
          location,
          v0,
          v1,
          v2
        );
      }
      let p = self.glProgramUniform3i_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLint, GLint, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, v0, v1, v2),
        None => go_panic_because_fn_not_loaded("glProgramUniform3i"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform3i" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform3i", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform3i_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform3i\0");
      self.glProgramUniform3i_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform3i_is_loaded(&self) -> bool {
      !self.glProgramUniform3i_p.load(RELAX).is_null()
    }
    /// [glProgramUniform3iv](http://docs.gl/gl4/glProgramUniform3iv)(program, location, count, value)
    /// * `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform3iv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform3iv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform3iv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform3iv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform3iv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform3iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform3iv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform3iv\0");
      self.glProgramUniform3iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform3iv_is_loaded(&self) -> bool {
      !self.glProgramUniform3iv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform3ui](http://docs.gl/gl4/glProgramUniform3ui)(program, location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform3ui(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLuint,
      v1: GLuint,
      v2: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform3ui({:?}, {:?}, {:?}, {:?}, {:?});",
          program,
          location,
          v0,
          v1,
          v2
        );
      }
      let p = self.glProgramUniform3ui_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLuint, GLuint, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, v0, v1, v2),
        None => go_panic_because_fn_not_loaded("glProgramUniform3ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform3ui" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform3ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform3ui_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform3ui\0");
      self.glProgramUniform3ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform3ui_is_loaded(&self) -> bool {
      !self.glProgramUniform3ui_p.load(RELAX).is_null()
    }
    /// [glProgramUniform3uiv](http://docs.gl/gl4/glProgramUniform3uiv)(program, location, count, value)
    /// * `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform3uiv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform3uiv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform3uiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform3uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform3uiv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform3uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform3uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform3uiv\0");
      self.glProgramUniform3uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform3uiv_is_loaded(&self) -> bool {
      !self.glProgramUniform3uiv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform4d](http://docs.gl/gl4/glProgramUniform4d)(program, location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform4d(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLdouble,
      v1: GLdouble,
      v2: GLdouble,
      v3: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform4d({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
          program,
          location,
          v0,
          v1,
          v2,
          v3
        );
      }
      let p = self.glProgramUniform4d_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLdouble,
            GLdouble,
            GLdouble,
            GLdouble,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, v0, v1, v2, v3),
        None => go_panic_because_fn_not_loaded("glProgramUniform4d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform4d" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform4d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform4d_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform4d\0");
      self.glProgramUniform4d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform4d_is_loaded(&self) -> bool {
      !self.glProgramUniform4d_p.load(RELAX).is_null()
    }
    /// [glProgramUniform4dv](http://docs.gl/gl4/glProgramUniform4dv)(program, location, count, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform4dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform4dv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform4dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform4dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform4dv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform4dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform4dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform4dv\0");
      self.glProgramUniform4dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform4dv_is_loaded(&self) -> bool {
      !self.glProgramUniform4dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform4f](http://docs.gl/gl4/glProgramUniform4f)(program, location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform4f(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLfloat,
      v1: GLfloat,
      v2: GLfloat,
      v3: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform4f({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
          program,
          location,
          v0,
          v1,
          v2,
          v3
        );
      }
      let p = self.glProgramUniform4f_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(GLuint, GLint, GLfloat, GLfloat, GLfloat, GLfloat),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, v0, v1, v2, v3),
        None => go_panic_because_fn_not_loaded("glProgramUniform4f"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform4f" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform4f", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform4f_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform4f\0");
      self.glProgramUniform4f_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform4f_is_loaded(&self) -> bool {
      !self.glProgramUniform4f_p.load(RELAX).is_null()
    }
    /// [glProgramUniform4fv](http://docs.gl/gl4/glProgramUniform4fv)(program, location, count, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform4fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform4fv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform4fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform4fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform4fv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform4fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform4fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform4fv\0");
      self.glProgramUniform4fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform4fv_is_loaded(&self) -> bool {
      !self.glProgramUniform4fv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform4i](http://docs.gl/gl4/glProgramUniform4i)(program, location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform4i(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLint,
      v1: GLint,
      v2: GLint,
      v3: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform4i({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
          program,
          location,
          v0,
          v1,
          v2,
          v3
        );
      }
      let p = self.glProgramUniform4i_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, v0, v1, v2, v3),
        None => go_panic_because_fn_not_loaded("glProgramUniform4i"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform4i" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform4i", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform4i_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform4i\0");
      self.glProgramUniform4i_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform4i_is_loaded(&self) -> bool {
      !self.glProgramUniform4i_p.load(RELAX).is_null()
    }
    /// [glProgramUniform4iv](http://docs.gl/gl4/glProgramUniform4iv)(program, location, count, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform4iv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform4iv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform4iv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform4iv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform4iv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform4iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform4iv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform4iv\0");
      self.glProgramUniform4iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform4iv_is_loaded(&self) -> bool {
      !self.glProgramUniform4iv_p.load(RELAX).is_null()
    }
    /// [glProgramUniform4ui](http://docs.gl/gl4/glProgramUniform4ui)(program, location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform4ui(
      &self,
      program: GLuint,
      location: GLint,
      v0: GLuint,
      v1: GLuint,
      v2: GLuint,
      v3: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform4ui({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
          program,
          location,
          v0,
          v1,
          v2,
          v3
        );
      }
      let p = self.glProgramUniform4ui_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLuint, GLuint, GLuint, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, v0, v1, v2, v3),
        None => go_panic_because_fn_not_loaded("glProgramUniform4ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform4ui" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform4ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform4ui_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform4ui\0");
      self.glProgramUniform4ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform4ui_is_loaded(&self) -> bool {
      !self.glProgramUniform4ui_p.load(RELAX).is_null()
    }
    /// [glProgramUniform4uiv](http://docs.gl/gl4/glProgramUniform4uiv)(program, location, count, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniform4uiv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniform4uiv({:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          value
        );
      }
      let p = self.glProgramUniform4uiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLsizei, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, value),
        None => go_panic_because_fn_not_loaded("glProgramUniform4uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniform4uiv" != "glGetError" {
          report_error_as_necessary_from("ProgramUniform4uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniform4uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniform4uiv\0");
      self.glProgramUniform4uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniform4uiv_is_loaded(&self) -> bool {
      !self.glProgramUniform4uiv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix2dv](http://docs.gl/gl4/glProgramUniformMatrix2dv)(program, location, count, transpose, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix2dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix2dv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix2dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLsizei,
            GLboolean,
            *const GLdouble,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix2dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix2dv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix2dv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix2dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix2dv\0");
      self.glProgramUniformMatrix2dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix2dv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix2dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix2fv](http://docs.gl/gl4/glProgramUniformMatrix2fv)(program, location, count, transpose, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix2fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix2fv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix2fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix2fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix2fv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix2fv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix2fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix2fv\0");
      self.glProgramUniformMatrix2fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix2fv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix2fv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix2x3dv](http://docs.gl/gl4/glProgramUniformMatrix2x3dv)(program, location, count, transpose, value)
    /// * `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix2x3dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix2x3dv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix2x3dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLsizei,
            GLboolean,
            *const GLdouble,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix2x3dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix2x3dv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix2x3dv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix2x3dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix2x3dv\0");
      self.glProgramUniformMatrix2x3dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix2x3dv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix2x3dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix2x3fv](http://docs.gl/gl4/glProgramUniformMatrix2x3fv)(program, location, count, transpose, value)
    /// * `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix2x3fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix2x3fv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix2x3fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix2x3fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix2x3fv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix2x3fv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix2x3fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix2x3fv\0");
      self.glProgramUniformMatrix2x3fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix2x3fv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix2x3fv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix2x4dv](http://docs.gl/gl4/glProgramUniformMatrix2x4dv)(program, location, count, transpose, value)
    /// * `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix2x4dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix2x4dv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix2x4dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLsizei,
            GLboolean,
            *const GLdouble,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix2x4dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix2x4dv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix2x4dv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix2x4dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix2x4dv\0");
      self.glProgramUniformMatrix2x4dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix2x4dv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix2x4dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix2x4fv](http://docs.gl/gl4/glProgramUniformMatrix2x4fv)(program, location, count, transpose, value)
    /// * `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix2x4fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix2x4fv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix2x4fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix2x4fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix2x4fv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix2x4fv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix2x4fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix2x4fv\0");
      self.glProgramUniformMatrix2x4fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix2x4fv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix2x4fv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix3dv](http://docs.gl/gl4/glProgramUniformMatrix3dv)(program, location, count, transpose, value)
    /// * `value` len: count*9
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix3dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix3dv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix3dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLsizei,
            GLboolean,
            *const GLdouble,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix3dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix3dv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix3dv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix3dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix3dv\0");
      self.glProgramUniformMatrix3dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix3dv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix3dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix3fv](http://docs.gl/gl4/glProgramUniformMatrix3fv)(program, location, count, transpose, value)
    /// * `value` len: count*9
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix3fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix3fv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix3fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix3fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix3fv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix3fv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix3fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix3fv\0");
      self.glProgramUniformMatrix3fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix3fv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix3fv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix3x2dv](http://docs.gl/gl4/glProgramUniformMatrix3x2dv)(program, location, count, transpose, value)
    /// * `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix3x2dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix3x2dv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix3x2dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLsizei,
            GLboolean,
            *const GLdouble,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix3x2dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix3x2dv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix3x2dv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix3x2dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix3x2dv\0");
      self.glProgramUniformMatrix3x2dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix3x2dv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix3x2dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix3x2fv](http://docs.gl/gl4/glProgramUniformMatrix3x2fv)(program, location, count, transpose, value)
    /// * `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix3x2fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix3x2fv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix3x2fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix3x2fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix3x2fv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix3x2fv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix3x2fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix3x2fv\0");
      self.glProgramUniformMatrix3x2fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix3x2fv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix3x2fv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix3x4dv](http://docs.gl/gl4/glProgramUniformMatrix3x4dv)(program, location, count, transpose, value)
    /// * `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix3x4dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix3x4dv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix3x4dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLsizei,
            GLboolean,
            *const GLdouble,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix3x4dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix3x4dv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix3x4dv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix3x4dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix3x4dv\0");
      self.glProgramUniformMatrix3x4dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix3x4dv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix3x4dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix3x4fv](http://docs.gl/gl4/glProgramUniformMatrix3x4fv)(program, location, count, transpose, value)
    /// * `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix3x4fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix3x4fv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix3x4fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix3x4fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix3x4fv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix3x4fv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix3x4fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix3x4fv\0");
      self.glProgramUniformMatrix3x4fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix3x4fv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix3x4fv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix4dv](http://docs.gl/gl4/glProgramUniformMatrix4dv)(program, location, count, transpose, value)
    /// * `value` len: count*16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix4dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix4dv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix4dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLsizei,
            GLboolean,
            *const GLdouble,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix4dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix4dv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix4dv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix4dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix4dv\0");
      self.glProgramUniformMatrix4dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix4dv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix4dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix4fv](http://docs.gl/gl4/glProgramUniformMatrix4fv)(program, location, count, transpose, value)
    /// * `value` len: count*16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix4fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix4fv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix4fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix4fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix4fv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix4fv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix4fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix4fv\0");
      self.glProgramUniformMatrix4fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix4fv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix4fv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix4x2dv](http://docs.gl/gl4/glProgramUniformMatrix4x2dv)(program, location, count, transpose, value)
    /// * `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix4x2dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix4x2dv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix4x2dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLsizei,
            GLboolean,
            *const GLdouble,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix4x2dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix4x2dv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix4x2dv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix4x2dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix4x2dv\0");
      self.glProgramUniformMatrix4x2dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix4x2dv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix4x2dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix4x2fv](http://docs.gl/gl4/glProgramUniformMatrix4x2fv)(program, location, count, transpose, value)
    /// * `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix4x2fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix4x2fv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix4x2fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix4x2fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix4x2fv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix4x2fv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix4x2fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix4x2fv\0");
      self.glProgramUniformMatrix4x2fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix4x2fv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix4x2fv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix4x3dv](http://docs.gl/gl4/glProgramUniformMatrix4x3dv)(program, location, count, transpose, value)
    /// * `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix4x3dv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix4x3dv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix4x3dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLsizei,
            GLboolean,
            *const GLdouble,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix4x3dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix4x3dv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix4x3dv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix4x3dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix4x3dv\0");
      self.glProgramUniformMatrix4x3dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix4x3dv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix4x3dv_p.load(RELAX).is_null()
    }
    /// [glProgramUniformMatrix4x3fv](http://docs.gl/gl4/glProgramUniformMatrix4x3fv)(program, location, count, transpose, value)
    /// * `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProgramUniformMatrix4x3fv(
      &self,
      program: GLuint,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ProgramUniformMatrix4x3fv({:?}, {:?}, {:?}, {:?}, {:p});",
          program,
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glProgramUniformMatrix4x3fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(program, location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glProgramUniformMatrix4x3fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProgramUniformMatrix4x3fv" != "glGetError" {
          report_error_as_necessary_from(
            "ProgramUniformMatrix4x3fv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProgramUniformMatrix4x3fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProgramUniformMatrix4x3fv\0");
      self.glProgramUniformMatrix4x3fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProgramUniformMatrix4x3fv_is_loaded(&self) -> bool {
      !self.glProgramUniformMatrix4x3fv_p.load(RELAX).is_null()
    }
    /// [glProvokingVertex](http://docs.gl/gl4/glProvokingVertex)(mode)
    /// * `mode` group: VertexProvokingMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ProvokingVertex(&self, mode: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ProvokingVertex({:#X});", mode);
      }
      let p = self.glProvokingVertex_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(mode),
        None => go_panic_because_fn_not_loaded("glProvokingVertex"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glProvokingVertex" != "glGetError" {
          report_error_as_necessary_from("ProvokingVertex", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ProvokingVertex_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glProvokingVertex\0");
      self.glProvokingVertex_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ProvokingVertex_is_loaded(&self) -> bool {
      !self.glProvokingVertex_p.load(RELAX).is_null()
    }
    /// [glPushDebugGroup](http://docs.gl/gl4/glPushDebugGroup)(source, id, length, message)
    /// * `source` group: DebugSource
    /// * `message` len: COMPSIZE(message,length)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn PushDebugGroup(
      &self,
      source: GLenum,
      id: GLuint,
      length: GLsizei,
      message: *const GLchar,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.PushDebugGroup({:#X}, {:?}, {:?}, {:p});",
          source,
          id,
          length,
          message
        );
      }
      let p = self.glPushDebugGroup_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLuint, GLsizei, *const GLchar)>,
      >(p)
      {
        Some(fn_p) => fn_p(source, id, length, message),
        None => go_panic_because_fn_not_loaded("glPushDebugGroup"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glPushDebugGroup" != "glGetError" {
          report_error_as_necessary_from("PushDebugGroup", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn PushDebugGroup_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glPushDebugGroup\0");
      self.glPushDebugGroup_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn PushDebugGroup_is_loaded(&self) -> bool {
      !self.glPushDebugGroup_p.load(RELAX).is_null()
    }
    /// [glQueryCounter](http://docs.gl/gl4/glQueryCounter)(id, target)
    /// * `target` group: QueryCounterTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn QueryCounter(&self, id: GLuint, target: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.QueryCounter({:?}, {:#X});", id, target);
      }
      let p = self.glQueryCounter_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum)>>(p) {
        Some(fn_p) => fn_p(id, target),
        None => go_panic_because_fn_not_loaded("glQueryCounter"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glQueryCounter" != "glGetError" {
          report_error_as_necessary_from("QueryCounter", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn QueryCounter_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glQueryCounter\0");
      self.glQueryCounter_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn QueryCounter_is_loaded(&self) -> bool {
      !self.glQueryCounter_p.load(RELAX).is_null()
    }
    /// [glReadBuffer](http://docs.gl/gl4/glReadBuffer)(src)
    /// * `src` group: ReadBufferMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ReadBuffer(&self, src: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ReadBuffer({:#X});", src);
      }
      let p = self.glReadBuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum)>>(p) {
        Some(fn_p) => fn_p(src),
        None => go_panic_because_fn_not_loaded("glReadBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glReadBuffer" != "glGetError" {
          report_error_as_necessary_from("ReadBuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ReadBuffer_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glReadBuffer\0");
      self.glReadBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ReadBuffer_is_loaded(&self) -> bool {
      !self.glReadBuffer_p.load(RELAX).is_null()
    }
    /// [glReadPixels](http://docs.gl/gl4/glReadPixels)(x, y, width, height, format, type_, pixels)
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width,height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ReadPixels(
      &self,
      x: GLint,
      y: GLint,
      width: GLsizei,
      height: GLsizei,
      format: GLenum,
      type_: GLenum,
      pixels: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ReadPixels({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
          x,
          y,
          width,
          height,
          format,
          type_,
          pixels
        );
      }
      let p = self.glReadPixels_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLenum,
            GLenum,
            *mut c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(x, y, width, height, format, type_, pixels),
        None => go_panic_because_fn_not_loaded("glReadPixels"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glReadPixels" != "glGetError" {
          report_error_as_necessary_from("ReadPixels", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ReadPixels_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glReadPixels\0");
      self.glReadPixels_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ReadPixels_is_loaded(&self) -> bool {
      !self.glReadPixels_p.load(RELAX).is_null()
    }
    /// [glReadnPixels](http://docs.gl/gl4/glReadnPixels)(x, y, width, height, format, type_, bufSize, data)
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `data` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ReadnPixels(
      &self,
      x: GLint,
      y: GLint,
      width: GLsizei,
      height: GLsizei,
      format: GLenum,
      type_: GLenum,
      bufSize: GLsizei,
      data: *mut c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ReadnPixels({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:?}, {:p});", x, y, width, height, format, type_, bufSize, data);
      }
      let p = self.glReadnPixels_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLenum,
            GLenum,
            GLsizei,
            *mut c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(x, y, width, height, format, type_, bufSize, data),
        None => go_panic_because_fn_not_loaded("glReadnPixels"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glReadnPixels" != "glGetError" {
          report_error_as_necessary_from("ReadnPixels", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ReadnPixels_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glReadnPixels\0");
      self.glReadnPixels_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ReadnPixels_is_loaded(&self) -> bool {
      !self.glReadnPixels_p.load(RELAX).is_null()
    }
    /// [glReleaseShaderCompiler](http://docs.gl/gl4/glReleaseShaderCompiler)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ReleaseShaderCompiler(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ReleaseShaderCompiler();",);
      }
      let p = self.glReleaseShaderCompiler_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn()>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded("glReleaseShaderCompiler"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glReleaseShaderCompiler" != "glGetError" {
          report_error_as_necessary_from(
            "ReleaseShaderCompiler",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ReleaseShaderCompiler_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glReleaseShaderCompiler\0");
      self.glReleaseShaderCompiler_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ReleaseShaderCompiler_is_loaded(&self) -> bool {
      !self.glReleaseShaderCompiler_p.load(RELAX).is_null()
    }
    /// [glRenderbufferStorage](http://docs.gl/gl4/glRenderbufferStorage)(target, internalformat, width, height)
    /// * `target` group: RenderbufferTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn RenderbufferStorage(
      &self,
      target: GLenum,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.RenderbufferStorage({:#X}, {:#X}, {:?}, {:?});",
          target,
          internalformat,
          width,
          height
        );
      }
      let p = self.glRenderbufferStorage_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, GLsizei, GLsizei)>>(
          p,
        ) {
          Some(fn_p) => fn_p(target, internalformat, width, height),
          None => go_panic_because_fn_not_loaded("glRenderbufferStorage"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glRenderbufferStorage" != "glGetError" {
          report_error_as_necessary_from(
            "RenderbufferStorage",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn RenderbufferStorage_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glRenderbufferStorage\0");
      self.glRenderbufferStorage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn RenderbufferStorage_is_loaded(&self) -> bool {
      !self.glRenderbufferStorage_p.load(RELAX).is_null()
    }
    /// [glRenderbufferStorageMultisample](http://docs.gl/gl4/glRenderbufferStorageMultisample)(target, samples, internalformat, width, height)
    /// * `target` group: RenderbufferTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn RenderbufferStorageMultisample(
      &self,
      target: GLenum,
      samples: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.RenderbufferStorageMultisample({:#X}, {:?}, {:#X}, {:?}, {:?});", target, samples, internalformat, width, height);
      }
      let p = self.glRenderbufferStorageMultisample_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, samples, internalformat, width, height),
        None => {
          go_panic_because_fn_not_loaded("glRenderbufferStorageMultisample")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glRenderbufferStorageMultisample" != "glGetError" {
          report_error_as_necessary_from(
            "RenderbufferStorageMultisample",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn RenderbufferStorageMultisample_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glRenderbufferStorageMultisample\0");
      self.glRenderbufferStorageMultisample_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn RenderbufferStorageMultisample_is_loaded(&self) -> bool {
      !self.glRenderbufferStorageMultisample_p.load(RELAX).is_null()
    }
    /// [glResumeTransformFeedback](http://docs.gl/gl4/glResumeTransformFeedback)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ResumeTransformFeedback(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ResumeTransformFeedback();",);
      }
      let p = self.glResumeTransformFeedback_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn()>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded("glResumeTransformFeedback"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glResumeTransformFeedback" != "glGetError" {
          report_error_as_necessary_from(
            "ResumeTransformFeedback",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ResumeTransformFeedback_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glResumeTransformFeedback\0");
      self.glResumeTransformFeedback_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ResumeTransformFeedback_is_loaded(&self) -> bool {
      !self.glResumeTransformFeedback_p.load(RELAX).is_null()
    }
    /// [glSampleCoverage](http://docs.gl/gl4/glSampleCoverage)(value, invert)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SampleCoverage(&self, value: GLfloat, invert: GLboolean) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.SampleCoverage({:?}, {:?});", value, invert);
      }
      let p = self.glSampleCoverage_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLfloat, GLboolean)>>(p) {
        Some(fn_p) => fn_p(value, invert),
        None => go_panic_because_fn_not_loaded("glSampleCoverage"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glSampleCoverage" != "glGetError" {
          report_error_as_necessary_from("SampleCoverage", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn SampleCoverage_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glSampleCoverage\0");
      self.glSampleCoverage_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn SampleCoverage_is_loaded(&self) -> bool {
      !self.glSampleCoverage_p.load(RELAX).is_null()
    }
    /// [glSampleMaski](http://docs.gl/gl4/glSampleMaski)(maskNumber, mask)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SampleMaski(&self, maskNumber: GLuint, mask: GLbitfield) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.SampleMaski({:?}, {:?});", maskNumber, mask);
      }
      let p = self.glSampleMaski_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLbitfield)>>(p) {
        Some(fn_p) => fn_p(maskNumber, mask),
        None => go_panic_because_fn_not_loaded("glSampleMaski"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glSampleMaski" != "glGetError" {
          report_error_as_necessary_from("SampleMaski", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn SampleMaski_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glSampleMaski\0");
      self.glSampleMaski_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn SampleMaski_is_loaded(&self) -> bool {
      !self.glSampleMaski_p.load(RELAX).is_null()
    }
    /// [glSamplerParameterIiv](http://docs.gl/gl4/glSamplerParameterIiv)(sampler, pname, param)
    /// * `pname` group: SamplerParameterI
    /// * `param` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SamplerParameterIiv(
      &self,
      sampler: GLuint,
      pname: GLenum,
      param: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SamplerParameterIiv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          param
        );
      }
      let p = self.glSamplerParameterIiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLint)>>(p) {
          Some(fn_p) => fn_p(sampler, pname, param),
          None => go_panic_because_fn_not_loaded("glSamplerParameterIiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glSamplerParameterIiv" != "glGetError" {
          report_error_as_necessary_from(
            "SamplerParameterIiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn SamplerParameterIiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glSamplerParameterIiv\0");
      self.glSamplerParameterIiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn SamplerParameterIiv_is_loaded(&self) -> bool {
      !self.glSamplerParameterIiv_p.load(RELAX).is_null()
    }
    /// [glSamplerParameterIuiv](http://docs.gl/gl4/glSamplerParameterIuiv)(sampler, pname, param)
    /// * `pname` group: SamplerParameterI
    /// * `param` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SamplerParameterIuiv(
      &self,
      sampler: GLuint,
      pname: GLenum,
      param: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SamplerParameterIuiv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          param
        );
      }
      let p = self.glSamplerParameterIuiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(sampler, pname, param),
        None => go_panic_because_fn_not_loaded("glSamplerParameterIuiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glSamplerParameterIuiv" != "glGetError" {
          report_error_as_necessary_from(
            "SamplerParameterIuiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn SamplerParameterIuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glSamplerParameterIuiv\0");
      self.glSamplerParameterIuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn SamplerParameterIuiv_is_loaded(&self) -> bool {
      !self.glSamplerParameterIuiv_p.load(RELAX).is_null()
    }
    /// [glSamplerParameterf](http://docs.gl/gl4/glSamplerParameterf)(sampler, pname, param)
    /// * `pname` group: SamplerParameterF
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SamplerParameterf(
      &self,
      sampler: GLuint,
      pname: GLenum,
      param: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SamplerParameterf({:?}, {:#X}, {:?});",
          sampler,
          pname,
          param
        );
      }
      let p = self.glSamplerParameterf_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(sampler, pname, param),
        None => go_panic_because_fn_not_loaded("glSamplerParameterf"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glSamplerParameterf" != "glGetError" {
          report_error_as_necessary_from("SamplerParameterf", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn SamplerParameterf_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glSamplerParameterf\0");
      self.glSamplerParameterf_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn SamplerParameterf_is_loaded(&self) -> bool {
      !self.glSamplerParameterf_p.load(RELAX).is_null()
    }
    /// [glSamplerParameterfv](http://docs.gl/gl4/glSamplerParameterfv)(sampler, pname, param)
    /// * `pname` group: SamplerParameterF
    /// * `param` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SamplerParameterfv(
      &self,
      sampler: GLuint,
      pname: GLenum,
      param: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SamplerParameterfv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          param
        );
      }
      let p = self.glSamplerParameterfv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLfloat)>>(p)
        {
          Some(fn_p) => fn_p(sampler, pname, param),
          None => go_panic_because_fn_not_loaded("glSamplerParameterfv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glSamplerParameterfv" != "glGetError" {
          report_error_as_necessary_from("SamplerParameterfv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn SamplerParameterfv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glSamplerParameterfv\0");
      self.glSamplerParameterfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn SamplerParameterfv_is_loaded(&self) -> bool {
      !self.glSamplerParameterfv_p.load(RELAX).is_null()
    }
    /// [glSamplerParameteri](http://docs.gl/gl4/glSamplerParameteri)(sampler, pname, param)
    /// * `pname` group: SamplerParameterI
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SamplerParameteri(
      &self,
      sampler: GLuint,
      pname: GLenum,
      param: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SamplerParameteri({:?}, {:#X}, {:?});",
          sampler,
          pname,
          param
        );
      }
      let p = self.glSamplerParameteri_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLint)>>(p) {
        Some(fn_p) => fn_p(sampler, pname, param),
        None => go_panic_because_fn_not_loaded("glSamplerParameteri"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glSamplerParameteri" != "glGetError" {
          report_error_as_necessary_from("SamplerParameteri", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn SamplerParameteri_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glSamplerParameteri\0");
      self.glSamplerParameteri_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn SamplerParameteri_is_loaded(&self) -> bool {
      !self.glSamplerParameteri_p.load(RELAX).is_null()
    }
    /// [glSamplerParameteriv](http://docs.gl/gl4/glSamplerParameteriv)(sampler, pname, param)
    /// * `pname` group: SamplerParameterI
    /// * `param` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SamplerParameteriv(
      &self,
      sampler: GLuint,
      pname: GLenum,
      param: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SamplerParameteriv({:?}, {:#X}, {:p});",
          sampler,
          pname,
          param
        );
      }
      let p = self.glSamplerParameteriv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLint)>>(p) {
          Some(fn_p) => fn_p(sampler, pname, param),
          None => go_panic_because_fn_not_loaded("glSamplerParameteriv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glSamplerParameteriv" != "glGetError" {
          report_error_as_necessary_from("SamplerParameteriv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn SamplerParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glSamplerParameteriv\0");
      self.glSamplerParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn SamplerParameteriv_is_loaded(&self) -> bool {
      !self.glSamplerParameteriv_p.load(RELAX).is_null()
    }
    /// [glScissor](http://docs.gl/gl4/glScissor)(x, y, width, height)
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Scissor(
      &self,
      x: GLint,
      y: GLint,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Scissor({:?}, {:?}, {:?}, {:?});",
          x,
          y,
          width,
          height
        );
      }
      let p = self.glScissor_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLint, GLsizei, GLsizei)>>(p)
        {
          Some(fn_p) => fn_p(x, y, width, height),
          None => go_panic_because_fn_not_loaded("glScissor"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glScissor" != "glGetError" {
          report_error_as_necessary_from("Scissor", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Scissor_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glScissor\0");
      self.glScissor_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Scissor_is_loaded(&self) -> bool {
      !self.glScissor_p.load(RELAX).is_null()
    }
    /// [glScissorArrayv](http://docs.gl/gl4/glScissorArrayv)(first, count, v)
    /// * `v` len: COMPSIZE(count)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ScissorArrayv(
      &self,
      first: GLuint,
      count: GLsizei,
      v: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ScissorArrayv({:?}, {:?}, {:p});", first, count, v);
      }
      let p = self.glScissorArrayv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizei, *const GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(first, count, v),
        None => go_panic_because_fn_not_loaded("glScissorArrayv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glScissorArrayv" != "glGetError" {
          report_error_as_necessary_from("ScissorArrayv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ScissorArrayv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glScissorArrayv\0");
      self.glScissorArrayv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ScissorArrayv_is_loaded(&self) -> bool {
      !self.glScissorArrayv_p.load(RELAX).is_null()
    }
    /// [glScissorIndexed](http://docs.gl/gl4/glScissorIndexed)(index, left, bottom, width, height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ScissorIndexed(
      &self,
      index: GLuint,
      left: GLint,
      bottom: GLint,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ScissorIndexed({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          left,
          bottom,
          width,
          height
        );
      }
      let p = self.glScissorIndexed_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLint, GLsizei, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, left, bottom, width, height),
        None => go_panic_because_fn_not_loaded("glScissorIndexed"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glScissorIndexed" != "glGetError" {
          report_error_as_necessary_from("ScissorIndexed", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ScissorIndexed_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glScissorIndexed\0");
      self.glScissorIndexed_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ScissorIndexed_is_loaded(&self) -> bool {
      !self.glScissorIndexed_p.load(RELAX).is_null()
    }
    /// [glScissorIndexedv](http://docs.gl/gl4/glScissorIndexedv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ScissorIndexedv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ScissorIndexedv({:?}, {:p});", index, v);
      }
      let p = self.glScissorIndexedv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glScissorIndexedv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glScissorIndexedv" != "glGetError" {
          report_error_as_necessary_from("ScissorIndexedv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ScissorIndexedv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glScissorIndexedv\0");
      self.glScissorIndexedv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ScissorIndexedv_is_loaded(&self) -> bool {
      !self.glScissorIndexedv_p.load(RELAX).is_null()
    }
    /// [glShaderBinary](http://docs.gl/gl4/glShaderBinary)(count, shaders, binaryformat, binary, length)
    /// * `shaders` len: count
    /// * `binary` len: length
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ShaderBinary(
      &self,
      count: GLsizei,
      shaders: *const GLuint,
      binaryformat: GLenum,
      binary: *const c_void,
      length: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ShaderBinary({:?}, {:p}, {:#X}, {:p}, {:?});",
          count,
          shaders,
          binaryformat,
          binary,
          length
        );
      }
      let p = self.glShaderBinary_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLsizei,
            *const GLuint,
            GLenum,
            *const c_void,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(count, shaders, binaryformat, binary, length),
        None => go_panic_because_fn_not_loaded("glShaderBinary"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glShaderBinary" != "glGetError" {
          report_error_as_necessary_from("ShaderBinary", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ShaderBinary_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glShaderBinary\0");
      self.glShaderBinary_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ShaderBinary_is_loaded(&self) -> bool {
      !self.glShaderBinary_p.load(RELAX).is_null()
    }
    /// [glShaderSource](http://docs.gl/gl4/glShaderSource)(shader, count, string, length)
    /// * `string` len: count
    /// * `length` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ShaderSource(
      &self,
      shader: GLuint,
      count: GLsizei,
      string: *const *const GLchar,
      length: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ShaderSource({:?}, {:?}, {:p}, {:p});",
          shader,
          count,
          string,
          length
        );
      }
      let p = self.glShaderSource_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLsizei,
            *const *const GLchar,
            *const GLint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(shader, count, string, length),
        None => go_panic_because_fn_not_loaded("glShaderSource"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glShaderSource" != "glGetError" {
          report_error_as_necessary_from("ShaderSource", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ShaderSource_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glShaderSource\0");
      self.glShaderSource_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ShaderSource_is_loaded(&self) -> bool {
      !self.glShaderSource_p.load(RELAX).is_null()
    }
    /// [glShaderStorageBlockBinding](http://docs.gl/gl4/glShaderStorageBlockBinding)(program, storageBlockIndex, storageBlockBinding)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ShaderStorageBlockBinding(
      &self,
      program: GLuint,
      storageBlockIndex: GLuint,
      storageBlockBinding: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ShaderStorageBlockBinding({:?}, {:?}, {:?});",
          program,
          storageBlockIndex,
          storageBlockBinding
        );
      }
      let p = self.glShaderStorageBlockBinding_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p)
      {
        Some(fn_p) => fn_p(program, storageBlockIndex, storageBlockBinding),
        None => go_panic_because_fn_not_loaded("glShaderStorageBlockBinding"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glShaderStorageBlockBinding" != "glGetError" {
          report_error_as_necessary_from(
            "ShaderStorageBlockBinding",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ShaderStorageBlockBinding_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glShaderStorageBlockBinding\0");
      self.glShaderStorageBlockBinding_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ShaderStorageBlockBinding_is_loaded(&self) -> bool {
      !self.glShaderStorageBlockBinding_p.load(RELAX).is_null()
    }
    /// [glSpecializeShader](http://docs.gl/gl4/glSpecializeShader)(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn SpecializeShader(
      &self,
      shader: GLuint,
      pEntryPoint: *const GLchar,
      numSpecializationConstants: GLuint,
      pConstantIndex: *const GLuint,
      pConstantValue: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.SpecializeShader({:?}, {:p}, {:?}, {:p}, {:p});",
          shader,
          pEntryPoint,
          numSpecializationConstants,
          pConstantIndex,
          pConstantValue
        );
      }
      let p = self.glSpecializeShader_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            *const GLchar,
            GLuint,
            *const GLuint,
            *const GLuint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          shader,
          pEntryPoint,
          numSpecializationConstants,
          pConstantIndex,
          pConstantValue,
        ),
        None => go_panic_because_fn_not_loaded("glSpecializeShader"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glSpecializeShader" != "glGetError" {
          report_error_as_necessary_from("SpecializeShader", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn SpecializeShader_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glSpecializeShader\0");
      self.glSpecializeShader_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn SpecializeShader_is_loaded(&self) -> bool {
      !self.glSpecializeShader_p.load(RELAX).is_null()
    }
    /// [glStencilFunc](http://docs.gl/gl4/glStencilFunc)(func, ref_, mask)
    /// * `func` group: StencilFunction
    /// * `ref_` group: StencilValue
    /// * `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn StencilFunc(&self, func: GLenum, ref_: GLint, mask: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.StencilFunc({:#X}, {:?}, {:?});", func, ref_, mask);
      }
      let p = self.glStencilFunc_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLint, GLuint)>>(p) {
        Some(fn_p) => fn_p(func, ref_, mask),
        None => go_panic_because_fn_not_loaded("glStencilFunc"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glStencilFunc" != "glGetError" {
          report_error_as_necessary_from("StencilFunc", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn StencilFunc_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glStencilFunc\0");
      self.glStencilFunc_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn StencilFunc_is_loaded(&self) -> bool {
      !self.glStencilFunc_p.load(RELAX).is_null()
    }
    /// [glStencilFuncSeparate](http://docs.gl/gl4/glStencilFuncSeparate)(face, func, ref_, mask)
    /// * `face` group: StencilFaceDirection
    /// * `func` group: StencilFunction
    /// * `ref_` group: StencilValue
    /// * `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn StencilFuncSeparate(
      &self,
      face: GLenum,
      func: GLenum,
      ref_: GLint,
      mask: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.StencilFuncSeparate({:#X}, {:#X}, {:?}, {:?});",
          face,
          func,
          ref_,
          mask
        );
      }
      let p = self.glStencilFuncSeparate_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLint, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(face, func, ref_, mask),
        None => go_panic_because_fn_not_loaded("glStencilFuncSeparate"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glStencilFuncSeparate" != "glGetError" {
          report_error_as_necessary_from(
            "StencilFuncSeparate",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn StencilFuncSeparate_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glStencilFuncSeparate\0");
      self.glStencilFuncSeparate_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn StencilFuncSeparate_is_loaded(&self) -> bool {
      !self.glStencilFuncSeparate_p.load(RELAX).is_null()
    }
    /// [glStencilMask](http://docs.gl/gl4/glStencilMask)(mask)
    /// * `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn StencilMask(&self, mask: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.StencilMask({:?});", mask);
      }
      let p = self.glStencilMask_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(mask),
        None => go_panic_because_fn_not_loaded("glStencilMask"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glStencilMask" != "glGetError" {
          report_error_as_necessary_from("StencilMask", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn StencilMask_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glStencilMask\0");
      self.glStencilMask_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn StencilMask_is_loaded(&self) -> bool {
      !self.glStencilMask_p.load(RELAX).is_null()
    }
    /// [glStencilMaskSeparate](http://docs.gl/gl4/glStencilMaskSeparate)(face, mask)
    /// * `face` group: StencilFaceDirection
    /// * `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn StencilMaskSeparate(&self, face: GLenum, mask: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.StencilMaskSeparate({:#X}, {:?});", face, mask);
      }
      let p = self.glStencilMaskSeparate_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLuint)>>(p) {
        Some(fn_p) => fn_p(face, mask),
        None => go_panic_because_fn_not_loaded("glStencilMaskSeparate"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glStencilMaskSeparate" != "glGetError" {
          report_error_as_necessary_from(
            "StencilMaskSeparate",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn StencilMaskSeparate_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glStencilMaskSeparate\0");
      self.glStencilMaskSeparate_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn StencilMaskSeparate_is_loaded(&self) -> bool {
      !self.glStencilMaskSeparate_p.load(RELAX).is_null()
    }
    /// [glStencilOp](http://docs.gl/gl4/glStencilOp)(fail, zfail, zpass)
    /// * `fail` group: StencilOp
    /// * `zfail` group: StencilOp
    /// * `zpass` group: StencilOp
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn StencilOp(&self, fail: GLenum, zfail: GLenum, zpass: GLenum) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.StencilOp({:#X}, {:#X}, {:#X});",
          fail,
          zfail,
          zpass
        );
      }
      let p = self.glStencilOp_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLenum, GLenum)>>(p)
      {
        Some(fn_p) => fn_p(fail, zfail, zpass),
        None => go_panic_because_fn_not_loaded("glStencilOp"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glStencilOp" != "glGetError" {
          report_error_as_necessary_from("StencilOp", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn StencilOp_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glStencilOp\0");
      self.glStencilOp_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn StencilOp_is_loaded(&self) -> bool {
      !self.glStencilOp_p.load(RELAX).is_null()
    }
    /// [glStencilOpSeparate](http://docs.gl/gl4/glStencilOpSeparate)(face, sfail, dpfail, dppass)
    /// * `face` group: StencilFaceDirection
    /// * `sfail` group: StencilOp
    /// * `dpfail` group: StencilOp
    /// * `dppass` group: StencilOp
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn StencilOpSeparate(
      &self,
      face: GLenum,
      sfail: GLenum,
      dpfail: GLenum,
      dppass: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.StencilOpSeparate({:#X}, {:#X}, {:#X}, {:#X});",
          face,
          sfail,
          dpfail,
          dppass
        );
      }
      let p = self.glStencilOpSeparate_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, GLenum, GLenum)>>(p)
        {
          Some(fn_p) => fn_p(face, sfail, dpfail, dppass),
          None => go_panic_because_fn_not_loaded("glStencilOpSeparate"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glStencilOpSeparate" != "glGetError" {
          report_error_as_necessary_from("StencilOpSeparate", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn StencilOpSeparate_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glStencilOpSeparate\0");
      self.glStencilOpSeparate_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn StencilOpSeparate_is_loaded(&self) -> bool {
      !self.glStencilOpSeparate_p.load(RELAX).is_null()
    }
    /// [glTexBuffer](http://docs.gl/gl4/glTexBuffer)(target, internalformat, buffer)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexBuffer(
      &self,
      target: GLenum,
      internalformat: GLenum,
      buffer: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexBuffer({:#X}, {:#X}, {:?});",
          target,
          internalformat,
          buffer
        );
      }
      let p = self.glTexBuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLenum, GLuint)>>(p)
      {
        Some(fn_p) => fn_p(target, internalformat, buffer),
        None => go_panic_because_fn_not_loaded("glTexBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexBuffer" != "glGetError" {
          report_error_as_necessary_from("TexBuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexBuffer_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexBuffer\0");
      self.glTexBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexBuffer_is_loaded(&self) -> bool {
      !self.glTexBuffer_p.load(RELAX).is_null()
    }
    /// [glTexBufferRange](http://docs.gl/gl4/glTexBufferRange)(target, internalformat, buffer, offset, size)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    /// * `offset` group: BufferOffset
    /// * `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexBufferRange(
      &self,
      target: GLenum,
      internalformat: GLenum,
      buffer: GLuint,
      offset: GLintptr,
      size: GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexBufferRange({:#X}, {:#X}, {:?}, {:?}, {:?});",
          target,
          internalformat,
          buffer,
          offset,
          size
        );
      }
      let p = self.glTexBufferRange_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, GLuint, GLintptr, GLsizeiptr)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, internalformat, buffer, offset, size),
        None => go_panic_because_fn_not_loaded("glTexBufferRange"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexBufferRange" != "glGetError" {
          report_error_as_necessary_from("TexBufferRange", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexBufferRange_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexBufferRange\0");
      self.glTexBufferRange_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexBufferRange_is_loaded(&self) -> bool {
      !self.glTexBufferRange_p.load(RELAX).is_null()
    }
    /// [glTexImage1D](http://docs.gl/gl4/glTexImage1D)(target, level, internalformat, width, border, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `border` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexImage1D(
      &self,
      target: GLenum,
      level: GLint,
      internalformat: GLint,
      width: GLsizei,
      border: GLint,
      format: GLenum,
      type_: GLenum,
      pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexImage1D({:#X}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, border, format, type_, pixels);
      }
      let p = self.glTexImage1D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLint,
            GLsizei,
            GLint,
            GLenum,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target,
          level,
          internalformat,
          width,
          border,
          format,
          type_,
          pixels,
        ),
        None => go_panic_because_fn_not_loaded("glTexImage1D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexImage1D" != "glGetError" {
          report_error_as_necessary_from("TexImage1D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexImage1D_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexImage1D\0");
      self.glTexImage1D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexImage1D_is_loaded(&self) -> bool {
      !self.glTexImage1D_p.load(RELAX).is_null()
    }
    /// [glTexImage2D](http://docs.gl/gl4/glTexImage2D)(target, level, internalformat, width, height, border, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `border` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width,height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexImage2D(
      &self,
      target: GLenum,
      level: GLint,
      internalformat: GLint,
      width: GLsizei,
      height: GLsizei,
      border: GLint,
      format: GLenum,
      type_: GLenum,
      pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, height, border, format, type_, pixels);
      }
      let p = self.glTexImage2D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLint,
            GLenum,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target,
          level,
          internalformat,
          width,
          height,
          border,
          format,
          type_,
          pixels,
        ),
        None => go_panic_because_fn_not_loaded("glTexImage2D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexImage2D" != "glGetError" {
          report_error_as_necessary_from("TexImage2D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexImage2D_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexImage2D\0");
      self.glTexImage2D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexImage2D_is_loaded(&self) -> bool {
      !self.glTexImage2D_p.load(RELAX).is_null()
    }
    /// [glTexImage2DMultisample](http://docs.gl/gl4/glTexImage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexImage2DMultisample(
      &self,
      target: GLenum,
      samples: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
      fixedsamplelocations: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexImage2DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, fixedsamplelocations);
      }
      let p = self.glTexImage2DMultisample_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLsizei,
            GLenum,
            GLsizei,
            GLsizei,
            GLboolean,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target,
          samples,
          internalformat,
          width,
          height,
          fixedsamplelocations,
        ),
        None => go_panic_because_fn_not_loaded("glTexImage2DMultisample"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexImage2DMultisample" != "glGetError" {
          report_error_as_necessary_from(
            "TexImage2DMultisample",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexImage2DMultisample_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTexImage2DMultisample\0");
      self.glTexImage2DMultisample_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexImage2DMultisample_is_loaded(&self) -> bool {
      !self.glTexImage2DMultisample_p.load(RELAX).is_null()
    }
    /// [glTexImage3D](http://docs.gl/gl4/glTexImage3D)(target, level, internalformat, width, height, depth, border, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `internalformat` group: InternalFormat
    /// * `border` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width,height,depth)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexImage3D(
      &self,
      target: GLenum,
      level: GLint,
      internalformat: GLint,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
      border: GLint,
      format: GLenum,
      type_: GLenum,
      pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, internalformat, width, height, depth, border, format, type_, pixels);
      }
      let p = self.glTexImage3D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLsizei,
            GLint,
            GLenum,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target,
          level,
          internalformat,
          width,
          height,
          depth,
          border,
          format,
          type_,
          pixels,
        ),
        None => go_panic_because_fn_not_loaded("glTexImage3D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexImage3D" != "glGetError" {
          report_error_as_necessary_from("TexImage3D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexImage3D_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexImage3D\0");
      self.glTexImage3D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexImage3D_is_loaded(&self) -> bool {
      !self.glTexImage3D_p.load(RELAX).is_null()
    }
    /// [glTexImage3DMultisample](http://docs.gl/gl4/glTexImage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexImage3DMultisample(
      &self,
      target: GLenum,
      samples: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
      fixedsamplelocations: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexImage3DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, depth, fixedsamplelocations);
      }
      let p = self.glTexImage3DMultisample_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLsizei,
            GLenum,
            GLsizei,
            GLsizei,
            GLsizei,
            GLboolean,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target,
          samples,
          internalformat,
          width,
          height,
          depth,
          fixedsamplelocations,
        ),
        None => go_panic_because_fn_not_loaded("glTexImage3DMultisample"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexImage3DMultisample" != "glGetError" {
          report_error_as_necessary_from(
            "TexImage3DMultisample",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexImage3DMultisample_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTexImage3DMultisample\0");
      self.glTexImage3DMultisample_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexImage3DMultisample_is_loaded(&self) -> bool {
      !self.glTexImage3DMultisample_p.load(RELAX).is_null()
    }
    /// [glTexParameterIiv](http://docs.gl/gl4/glTexParameterIiv)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: TextureParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexParameterIiv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexParameterIiv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glTexParameterIiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *const GLint)>>(p) {
          Some(fn_p) => fn_p(target, pname, params),
          None => go_panic_because_fn_not_loaded("glTexParameterIiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexParameterIiv" != "glGetError" {
          report_error_as_necessary_from("TexParameterIiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexParameterIiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTexParameterIiv\0");
      self.glTexParameterIiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexParameterIiv_is_loaded(&self) -> bool {
      !self.glTexParameterIiv_p.load(RELAX).is_null()
    }
    /// [glTexParameterIuiv](http://docs.gl/gl4/glTexParameterIuiv)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: TextureParameterName
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexParameterIuiv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexParameterIuiv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glTexParameterIuiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLenum, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, pname, params),
        None => go_panic_because_fn_not_loaded("glTexParameterIuiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexParameterIuiv" != "glGetError" {
          report_error_as_necessary_from("TexParameterIuiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexParameterIuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTexParameterIuiv\0");
      self.glTexParameterIuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexParameterIuiv_is_loaded(&self) -> bool {
      !self.glTexParameterIuiv_p.load(RELAX).is_null()
    }
    /// [glTexParameterf](http://docs.gl/gl4/glTexParameterf)(target, pname, param)
    /// * `target` group: TextureTarget
    /// * `pname` group: TextureParameterName
    /// * `param` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexParameterf(
      &self,
      target: GLenum,
      pname: GLenum,
      param: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexParameterf({:#X}, {:#X}, {:?});",
          target,
          pname,
          param
        );
      }
      let p = self.glTexParameterf_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLenum, GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(target, pname, param),
        None => go_panic_because_fn_not_loaded("glTexParameterf"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexParameterf" != "glGetError" {
          report_error_as_necessary_from("TexParameterf", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexParameterf_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexParameterf\0");
      self.glTexParameterf_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexParameterf_is_loaded(&self) -> bool {
      !self.glTexParameterf_p.load(RELAX).is_null()
    }
    /// [glTexParameterfv](http://docs.gl/gl4/glTexParameterfv)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: TextureParameterName
    /// * `params` group: CheckedFloat32
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexParameterfv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexParameterfv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glTexParameterfv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *const GLfloat)>>(p)
        {
          Some(fn_p) => fn_p(target, pname, params),
          None => go_panic_because_fn_not_loaded("glTexParameterfv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexParameterfv" != "glGetError" {
          report_error_as_necessary_from("TexParameterfv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexParameterfv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexParameterfv\0");
      self.glTexParameterfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexParameterfv_is_loaded(&self) -> bool {
      !self.glTexParameterfv_p.load(RELAX).is_null()
    }
    /// [glTexParameteri](http://docs.gl/gl4/glTexParameteri)(target, pname, param)
    /// * `target` group: TextureTarget
    /// * `pname` group: TextureParameterName
    /// * `param` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexParameteri(
      &self,
      target: GLenum,
      pname: GLenum,
      param: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexParameteri({:#X}, {:#X}, {:?});",
          target,
          pname,
          param
        );
      }
      let p = self.glTexParameteri_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum, GLenum, GLint)>>(p) {
        Some(fn_p) => fn_p(target, pname, param),
        None => go_panic_because_fn_not_loaded("glTexParameteri"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexParameteri" != "glGetError" {
          report_error_as_necessary_from("TexParameteri", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexParameteri_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexParameteri\0");
      self.glTexParameteri_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexParameteri_is_loaded(&self) -> bool {
      !self.glTexParameteri_p.load(RELAX).is_null()
    }
    /// [glTexParameteriv](http://docs.gl/gl4/glTexParameteriv)(target, pname, params)
    /// * `target` group: TextureTarget
    /// * `pname` group: TextureParameterName
    /// * `params` group: CheckedInt32
    /// * `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexParameteriv(
      &self,
      target: GLenum,
      pname: GLenum,
      params: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexParameteriv({:#X}, {:#X}, {:p});",
          target,
          pname,
          params
        );
      }
      let p = self.glTexParameteriv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLenum, *const GLint)>>(p) {
          Some(fn_p) => fn_p(target, pname, params),
          None => go_panic_because_fn_not_loaded("glTexParameteriv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexParameteriv" != "glGetError" {
          report_error_as_necessary_from("TexParameteriv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexParameteriv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexParameteriv\0");
      self.glTexParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexParameteriv_is_loaded(&self) -> bool {
      !self.glTexParameteriv_p.load(RELAX).is_null()
    }
    /// [glTexStorage1D](http://docs.gl/gl4/glTexStorage1D)(target, levels, internalformat, width)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexStorage1D(
      &self,
      target: GLenum,
      levels: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexStorage1D({:#X}, {:?}, {:#X}, {:?});",
          target,
          levels,
          internalformat,
          width
        );
      }
      let p = self.glTexStorage1D_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLsizei, GLenum, GLsizei)>>(
          p,
        ) {
          Some(fn_p) => fn_p(target, levels, internalformat, width),
          None => go_panic_because_fn_not_loaded("glTexStorage1D"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexStorage1D" != "glGetError" {
          report_error_as_necessary_from("TexStorage1D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexStorage1D_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexStorage1D\0");
      self.glTexStorage1D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexStorage1D_is_loaded(&self) -> bool {
      !self.glTexStorage1D_p.load(RELAX).is_null()
    }
    /// [glTexStorage2D](http://docs.gl/gl4/glTexStorage2D)(target, levels, internalformat, width, height)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexStorage2D(
      &self,
      target: GLenum,
      levels: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexStorage2D({:#X}, {:?}, {:#X}, {:?}, {:?});",
          target,
          levels,
          internalformat,
          width,
          height
        );
      }
      let p = self.glTexStorage2D_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(target, levels, internalformat, width, height),
        None => go_panic_because_fn_not_loaded("glTexStorage2D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexStorage2D" != "glGetError" {
          report_error_as_necessary_from("TexStorage2D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexStorage2D_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexStorage2D\0");
      self.glTexStorage2D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexStorage2D_is_loaded(&self) -> bool {
      !self.glTexStorage2D_p.load(RELAX).is_null()
    }
    /// [glTexStorage2DMultisample](http://docs.gl/gl4/glTexStorage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexStorage2DMultisample(
      &self,
      target: GLenum,
      samples: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
      fixedsamplelocations: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexStorage2DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, fixedsamplelocations);
      }
      let p = self.glTexStorage2DMultisample_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLsizei,
            GLenum,
            GLsizei,
            GLsizei,
            GLboolean,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target,
          samples,
          internalformat,
          width,
          height,
          fixedsamplelocations,
        ),
        None => go_panic_because_fn_not_loaded("glTexStorage2DMultisample"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexStorage2DMultisample" != "glGetError" {
          report_error_as_necessary_from(
            "TexStorage2DMultisample",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexStorage2DMultisample_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTexStorage2DMultisample\0");
      self.glTexStorage2DMultisample_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexStorage2DMultisample_is_loaded(&self) -> bool {
      !self.glTexStorage2DMultisample_p.load(RELAX).is_null()
    }
    /// [glTexStorage3D](http://docs.gl/gl4/glTexStorage3D)(target, levels, internalformat, width, height, depth)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexStorage3D(
      &self,
      target: GLenum,
      levels: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TexStorage3D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});",
          target,
          levels,
          internalformat,
          width,
          height,
          depth
        );
      }
      let p = self.glTexStorage3D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLsizei,
            GLenum,
            GLsizei,
            GLsizei,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(target, levels, internalformat, width, height, depth)
        }
        None => go_panic_because_fn_not_loaded("glTexStorage3D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexStorage3D" != "glGetError" {
          report_error_as_necessary_from("TexStorage3D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexStorage3D_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexStorage3D\0");
      self.glTexStorage3D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexStorage3D_is_loaded(&self) -> bool {
      !self.glTexStorage3D_p.load(RELAX).is_null()
    }
    /// [glTexStorage3DMultisample](http://docs.gl/gl4/glTexStorage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexStorage3DMultisample(
      &self,
      target: GLenum,
      samples: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
      fixedsamplelocations: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexStorage3DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", target, samples, internalformat, width, height, depth, fixedsamplelocations);
      }
      let p = self.glTexStorage3DMultisample_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLsizei,
            GLenum,
            GLsizei,
            GLsizei,
            GLsizei,
            GLboolean,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target,
          samples,
          internalformat,
          width,
          height,
          depth,
          fixedsamplelocations,
        ),
        None => go_panic_because_fn_not_loaded("glTexStorage3DMultisample"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexStorage3DMultisample" != "glGetError" {
          report_error_as_necessary_from(
            "TexStorage3DMultisample",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexStorage3DMultisample_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTexStorage3DMultisample\0");
      self.glTexStorage3DMultisample_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexStorage3DMultisample_is_loaded(&self) -> bool {
      !self.glTexStorage3DMultisample_p.load(RELAX).is_null()
    }
    /// [glTexSubImage1D](http://docs.gl/gl4/glTexSubImage1D)(target, level, xoffset, width, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexSubImage1D(
      &self,
      target: GLenum,
      level: GLint,
      xoffset: GLint,
      width: GLsizei,
      format: GLenum,
      type_: GLenum,
      pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexSubImage1D({:#X}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, xoffset, width, format, type_, pixels);
      }
      let p = self.glTexSubImage1D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLint,
            GLsizei,
            GLenum,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(target, level, xoffset, width, format, type_, pixels)
        }
        None => go_panic_because_fn_not_loaded("glTexSubImage1D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexSubImage1D" != "glGetError" {
          report_error_as_necessary_from("TexSubImage1D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexSubImage1D_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexSubImage1D\0");
      self.glTexSubImage1D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexSubImage1D_is_loaded(&self) -> bool {
      !self.glTexSubImage1D_p.load(RELAX).is_null()
    }
    /// [glTexSubImage2D](http://docs.gl/gl4/glTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `yoffset` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width,height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexSubImage2D(
      &self,
      target: GLenum,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      width: GLsizei,
      height: GLsizei,
      format: GLenum,
      type_: GLenum,
      pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, xoffset, yoffset, width, height, format, type_, pixels);
      }
      let p = self.glTexSubImage2D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLenum,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target, level, xoffset, yoffset, width, height, format, type_, pixels,
        ),
        None => go_panic_because_fn_not_loaded("glTexSubImage2D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexSubImage2D" != "glGetError" {
          report_error_as_necessary_from("TexSubImage2D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexSubImage2D_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexSubImage2D\0");
      self.glTexSubImage2D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexSubImage2D_is_loaded(&self) -> bool {
      !self.glTexSubImage2D_p.load(RELAX).is_null()
    }
    /// [glTexSubImage3D](http://docs.gl/gl4/glTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)
    /// * `target` group: TextureTarget
    /// * `level` group: CheckedInt32
    /// * `xoffset` group: CheckedInt32
    /// * `yoffset` group: CheckedInt32
    /// * `zoffset` group: CheckedInt32
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    /// * `pixels` len: COMPSIZE(format,type,width,height,depth)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TexSubImage3D(
      &self,
      target: GLenum,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      zoffset: GLint,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
      format: GLenum,
      type_: GLenum,
      pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels);
      }
      let p = self.glTexSubImage3D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLenum,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLsizei,
            GLenum,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          target, level, xoffset, yoffset, zoffset, width, height, depth,
          format, type_, pixels,
        ),
        None => go_panic_because_fn_not_loaded("glTexSubImage3D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTexSubImage3D" != "glGetError" {
          report_error_as_necessary_from("TexSubImage3D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TexSubImage3D_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTexSubImage3D\0");
      self.glTexSubImage3D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TexSubImage3D_is_loaded(&self) -> bool {
      !self.glTexSubImage3D_p.load(RELAX).is_null()
    }
    /// [glTextureBarrier](http://docs.gl/gl4/glTextureBarrier)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureBarrier(&self) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TextureBarrier();",);
      }
      let p = self.glTextureBarrier_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn()>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded("glTextureBarrier"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureBarrier" != "glGetError" {
          report_error_as_necessary_from("TextureBarrier", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureBarrier_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureBarrier\0");
      self.glTextureBarrier_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureBarrier_is_loaded(&self) -> bool {
      !self.glTextureBarrier_p.load(RELAX).is_null()
    }
    /// [glTextureBuffer](http://docs.gl/gl4/glTextureBuffer)(texture, internalformat, buffer)
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureBuffer(
      &self,
      texture: GLuint,
      internalformat: GLenum,
      buffer: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TextureBuffer({:?}, {:#X}, {:?});",
          texture,
          internalformat,
          buffer
        );
      }
      let p = self.glTextureBuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLuint)>>(p)
      {
        Some(fn_p) => fn_p(texture, internalformat, buffer),
        None => go_panic_because_fn_not_loaded("glTextureBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureBuffer" != "glGetError" {
          report_error_as_necessary_from("TextureBuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureBuffer_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureBuffer\0");
      self.glTextureBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureBuffer_is_loaded(&self) -> bool {
      !self.glTextureBuffer_p.load(RELAX).is_null()
    }
    /// [glTextureBufferRange](http://docs.gl/gl4/glTextureBufferRange)(texture, internalformat, buffer, offset, size)
    /// * `internalformat` group: InternalFormat
    /// * `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureBufferRange(
      &self,
      texture: GLuint,
      internalformat: GLenum,
      buffer: GLuint,
      offset: GLintptr,
      size: GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TextureBufferRange({:?}, {:#X}, {:?}, {:?}, {:?});",
          texture,
          internalformat,
          buffer,
          offset,
          size
        );
      }
      let p = self.glTextureBufferRange_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLuint, GLintptr, GLsizeiptr)>,
      >(p)
      {
        Some(fn_p) => fn_p(texture, internalformat, buffer, offset, size),
        None => go_panic_because_fn_not_loaded("glTextureBufferRange"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureBufferRange" != "glGetError" {
          report_error_as_necessary_from("TextureBufferRange", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureBufferRange_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureBufferRange\0");
      self.glTextureBufferRange_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureBufferRange_is_loaded(&self) -> bool {
      !self.glTextureBufferRange_p.load(RELAX).is_null()
    }
    /// [glTextureParameterIiv](http://docs.gl/gl4/glTextureParameterIiv)(texture, pname, params)
    /// * `pname` group: TextureParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureParameterIiv(
      &self,
      texture: GLuint,
      pname: GLenum,
      params: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TextureParameterIiv({:?}, {:#X}, {:p});",
          texture,
          pname,
          params
        );
      }
      let p = self.glTextureParameterIiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLint)>>(p) {
          Some(fn_p) => fn_p(texture, pname, params),
          None => go_panic_because_fn_not_loaded("glTextureParameterIiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureParameterIiv" != "glGetError" {
          report_error_as_necessary_from(
            "TextureParameterIiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureParameterIiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureParameterIiv\0");
      self.glTextureParameterIiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureParameterIiv_is_loaded(&self) -> bool {
      !self.glTextureParameterIiv_p.load(RELAX).is_null()
    }
    /// [glTextureParameterIuiv](http://docs.gl/gl4/glTextureParameterIuiv)(texture, pname, params)
    /// * `pname` group: TextureParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureParameterIuiv(
      &self,
      texture: GLuint,
      pname: GLenum,
      params: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TextureParameterIuiv({:?}, {:#X}, {:p});",
          texture,
          pname,
          params
        );
      }
      let p = self.glTextureParameterIuiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(texture, pname, params),
        None => go_panic_because_fn_not_loaded("glTextureParameterIuiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureParameterIuiv" != "glGetError" {
          report_error_as_necessary_from(
            "TextureParameterIuiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureParameterIuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureParameterIuiv\0");
      self.glTextureParameterIuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureParameterIuiv_is_loaded(&self) -> bool {
      !self.glTextureParameterIuiv_p.load(RELAX).is_null()
    }
    /// [glTextureParameterf](http://docs.gl/gl4/glTextureParameterf)(texture, pname, param)
    /// * `pname` group: TextureParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureParameterf(
      &self,
      texture: GLuint,
      pname: GLenum,
      param: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TextureParameterf({:?}, {:#X}, {:?});",
          texture,
          pname,
          param
        );
      }
      let p = self.glTextureParameterf_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(texture, pname, param),
        None => go_panic_because_fn_not_loaded("glTextureParameterf"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureParameterf" != "glGetError" {
          report_error_as_necessary_from("TextureParameterf", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureParameterf_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureParameterf\0");
      self.glTextureParameterf_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureParameterf_is_loaded(&self) -> bool {
      !self.glTextureParameterf_p.load(RELAX).is_null()
    }
    /// [glTextureParameterfv](http://docs.gl/gl4/glTextureParameterfv)(texture, pname, param)
    /// * `pname` group: TextureParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureParameterfv(
      &self,
      texture: GLuint,
      pname: GLenum,
      param: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TextureParameterfv({:?}, {:#X}, {:p});",
          texture,
          pname,
          param
        );
      }
      let p = self.glTextureParameterfv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLfloat)>>(p)
        {
          Some(fn_p) => fn_p(texture, pname, param),
          None => go_panic_because_fn_not_loaded("glTextureParameterfv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureParameterfv" != "glGetError" {
          report_error_as_necessary_from("TextureParameterfv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureParameterfv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureParameterfv\0");
      self.glTextureParameterfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureParameterfv_is_loaded(&self) -> bool {
      !self.glTextureParameterfv_p.load(RELAX).is_null()
    }
    /// [glTextureParameteri](http://docs.gl/gl4/glTextureParameteri)(texture, pname, param)
    /// * `pname` group: TextureParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureParameteri(
      &self,
      texture: GLuint,
      pname: GLenum,
      param: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TextureParameteri({:?}, {:#X}, {:?});",
          texture,
          pname,
          param
        );
      }
      let p = self.glTextureParameteri_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLenum, GLint)>>(p) {
        Some(fn_p) => fn_p(texture, pname, param),
        None => go_panic_because_fn_not_loaded("glTextureParameteri"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureParameteri" != "glGetError" {
          report_error_as_necessary_from("TextureParameteri", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureParameteri_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureParameteri\0");
      self.glTextureParameteri_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureParameteri_is_loaded(&self) -> bool {
      !self.glTextureParameteri_p.load(RELAX).is_null()
    }
    /// [glTextureParameteriv](http://docs.gl/gl4/glTextureParameteriv)(texture, pname, param)
    /// * `pname` group: TextureParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureParameteriv(
      &self,
      texture: GLuint,
      pname: GLenum,
      param: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TextureParameteriv({:?}, {:#X}, {:p});",
          texture,
          pname,
          param
        );
      }
      let p = self.glTextureParameteriv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLenum, *const GLint)>>(p) {
          Some(fn_p) => fn_p(texture, pname, param),
          None => go_panic_because_fn_not_loaded("glTextureParameteriv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureParameteriv" != "glGetError" {
          report_error_as_necessary_from("TextureParameteriv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureParameteriv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureParameteriv\0");
      self.glTextureParameteriv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureParameteriv_is_loaded(&self) -> bool {
      !self.glTextureParameteriv_p.load(RELAX).is_null()
    }
    /// [glTextureStorage1D](http://docs.gl/gl4/glTextureStorage1D)(texture, levels, internalformat, width)
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureStorage1D(
      &self,
      texture: GLuint,
      levels: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TextureStorage1D({:?}, {:?}, {:#X}, {:?});",
          texture,
          levels,
          internalformat,
          width
        );
      }
      let p = self.glTextureStorage1D_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLsizei, GLenum, GLsizei)>>(
          p,
        ) {
          Some(fn_p) => fn_p(texture, levels, internalformat, width),
          None => go_panic_because_fn_not_loaded("glTextureStorage1D"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureStorage1D" != "glGetError" {
          report_error_as_necessary_from("TextureStorage1D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureStorage1D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureStorage1D\0");
      self.glTextureStorage1D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureStorage1D_is_loaded(&self) -> bool {
      !self.glTextureStorage1D_p.load(RELAX).is_null()
    }
    /// [glTextureStorage2D](http://docs.gl/gl4/glTextureStorage2D)(texture, levels, internalformat, width, height)
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureStorage2D(
      &self,
      texture: GLuint,
      levels: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TextureStorage2D({:?}, {:?}, {:#X}, {:?}, {:?});",
          texture,
          levels,
          internalformat,
          width,
          height
        );
      }
      let p = self.glTextureStorage2D_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(texture, levels, internalformat, width, height),
        None => go_panic_because_fn_not_loaded("glTextureStorage2D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureStorage2D" != "glGetError" {
          report_error_as_necessary_from("TextureStorage2D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureStorage2D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureStorage2D\0");
      self.glTextureStorage2D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureStorage2D_is_loaded(&self) -> bool {
      !self.glTextureStorage2D_p.load(RELAX).is_null()
    }
    /// [glTextureStorage2DMultisample](http://docs.gl/gl4/glTextureStorage2DMultisample)(texture, samples, internalformat, width, height, fixedsamplelocations)
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureStorage2DMultisample(
      &self,
      texture: GLuint,
      samples: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
      fixedsamplelocations: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TextureStorage2DMultisample({:?}, {:?}, {:#X}, {:?}, {:?}, {:?});", texture, samples, internalformat, width, height, fixedsamplelocations);
      }
      let p = self.glTextureStorage2DMultisample_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLsizei,
            GLenum,
            GLsizei,
            GLsizei,
            GLboolean,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          texture,
          samples,
          internalformat,
          width,
          height,
          fixedsamplelocations,
        ),
        None => go_panic_because_fn_not_loaded("glTextureStorage2DMultisample"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureStorage2DMultisample" != "glGetError" {
          report_error_as_necessary_from(
            "TextureStorage2DMultisample",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureStorage2DMultisample_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureStorage2DMultisample\0");
      self.glTextureStorage2DMultisample_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureStorage2DMultisample_is_loaded(&self) -> bool {
      !self.glTextureStorage2DMultisample_p.load(RELAX).is_null()
    }
    /// [glTextureStorage3D](http://docs.gl/gl4/glTextureStorage3D)(texture, levels, internalformat, width, height, depth)
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureStorage3D(
      &self,
      texture: GLuint,
      levels: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TextureStorage3D({:?}, {:?}, {:#X}, {:?}, {:?}, {:?});",
          texture,
          levels,
          internalformat,
          width,
          height,
          depth
        );
      }
      let p = self.glTextureStorage3D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLsizei,
            GLenum,
            GLsizei,
            GLsizei,
            GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(texture, levels, internalformat, width, height, depth)
        }
        None => go_panic_because_fn_not_loaded("glTextureStorage3D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureStorage3D" != "glGetError" {
          report_error_as_necessary_from("TextureStorage3D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureStorage3D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureStorage3D\0");
      self.glTextureStorage3D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureStorage3D_is_loaded(&self) -> bool {
      !self.glTextureStorage3D_p.load(RELAX).is_null()
    }
    /// [glTextureStorage3DMultisample](http://docs.gl/gl4/glTextureStorage3DMultisample)(texture, samples, internalformat, width, height, depth, fixedsamplelocations)
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureStorage3DMultisample(
      &self,
      texture: GLuint,
      samples: GLsizei,
      internalformat: GLenum,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
      fixedsamplelocations: GLboolean,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TextureStorage3DMultisample({:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", texture, samples, internalformat, width, height, depth, fixedsamplelocations);
      }
      let p = self.glTextureStorage3DMultisample_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLsizei,
            GLenum,
            GLsizei,
            GLsizei,
            GLsizei,
            GLboolean,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          texture,
          samples,
          internalformat,
          width,
          height,
          depth,
          fixedsamplelocations,
        ),
        None => go_panic_because_fn_not_loaded("glTextureStorage3DMultisample"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureStorage3DMultisample" != "glGetError" {
          report_error_as_necessary_from(
            "TextureStorage3DMultisample",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureStorage3DMultisample_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureStorage3DMultisample\0");
      self.glTextureStorage3DMultisample_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureStorage3DMultisample_is_loaded(&self) -> bool {
      !self.glTextureStorage3DMultisample_p.load(RELAX).is_null()
    }
    /// [glTextureSubImage1D](http://docs.gl/gl4/glTextureSubImage1D)(texture, level, xoffset, width, format, type_, pixels)
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureSubImage1D(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      width: GLsizei,
      format: GLenum,
      type_: GLenum,
      pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TextureSubImage1D({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", texture, level, xoffset, width, format, type_, pixels);
      }
      let p = self.glTextureSubImage1D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLint,
            GLsizei,
            GLenum,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => {
          fn_p(texture, level, xoffset, width, format, type_, pixels)
        }
        None => go_panic_because_fn_not_loaded("glTextureSubImage1D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureSubImage1D" != "glGetError" {
          report_error_as_necessary_from("TextureSubImage1D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureSubImage1D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureSubImage1D\0");
      self.glTextureSubImage1D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureSubImage1D_is_loaded(&self) -> bool {
      !self.glTextureSubImage1D_p.load(RELAX).is_null()
    }
    /// [glTextureSubImage2D](http://docs.gl/gl4/glTextureSubImage2D)(texture, level, xoffset, yoffset, width, height, format, type_, pixels)
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureSubImage2D(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      width: GLsizei,
      height: GLsizei,
      format: GLenum,
      type_: GLenum,
      pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TextureSubImage2D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", texture, level, xoffset, yoffset, width, height, format, type_, pixels);
      }
      let p = self.glTextureSubImage2D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLenum,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          texture, level, xoffset, yoffset, width, height, format, type_,
          pixels,
        ),
        None => go_panic_because_fn_not_loaded("glTextureSubImage2D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureSubImage2D" != "glGetError" {
          report_error_as_necessary_from("TextureSubImage2D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureSubImage2D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureSubImage2D\0");
      self.glTextureSubImage2D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureSubImage2D_is_loaded(&self) -> bool {
      !self.glTextureSubImage2D_p.load(RELAX).is_null()
    }
    /// [glTextureSubImage3D](http://docs.gl/gl4/glTextureSubImage3D)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)
    /// * `format` group: PixelFormat
    /// * `type_` group: PixelType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureSubImage3D(
      &self,
      texture: GLuint,
      level: GLint,
      xoffset: GLint,
      yoffset: GLint,
      zoffset: GLint,
      width: GLsizei,
      height: GLsizei,
      depth: GLsizei,
      format: GLenum,
      type_: GLenum,
      pixels: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TextureSubImage3D({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels);
      }
      let p = self.glTextureSubImage3D_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLint,
            GLint,
            GLint,
            GLsizei,
            GLsizei,
            GLsizei,
            GLenum,
            GLenum,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          texture, level, xoffset, yoffset, zoffset, width, height, depth,
          format, type_, pixels,
        ),
        None => go_panic_because_fn_not_loaded("glTextureSubImage3D"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureSubImage3D" != "glGetError" {
          report_error_as_necessary_from("TextureSubImage3D", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureSubImage3D_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureSubImage3D\0");
      self.glTextureSubImage3D_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureSubImage3D_is_loaded(&self) -> bool {
      !self.glTextureSubImage3D_p.load(RELAX).is_null()
    }
    /// [glTextureView](http://docs.gl/gl4/glTextureView)(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers)
    /// * `target` group: TextureTarget
    /// * `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TextureView(
      &self,
      texture: GLuint,
      target: GLenum,
      origtexture: GLuint,
      internalformat: GLenum,
      minlevel: GLuint,
      numlevels: GLuint,
      minlayer: GLuint,
      numlayers: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TextureView({:?}, {:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});", texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
      }
      let p = self.glTextureView_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLenum,
            GLuint,
            GLenum,
            GLuint,
            GLuint,
            GLuint,
            GLuint,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(
          texture,
          target,
          origtexture,
          internalformat,
          minlevel,
          numlevels,
          minlayer,
          numlayers,
        ),
        None => go_panic_because_fn_not_loaded("glTextureView"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTextureView" != "glGetError" {
          report_error_as_necessary_from("TextureView", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TextureView_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glTextureView\0");
      self.glTextureView_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TextureView_is_loaded(&self) -> bool {
      !self.glTextureView_p.load(RELAX).is_null()
    }
    /// [glTransformFeedbackBufferBase](http://docs.gl/gl4/glTransformFeedbackBufferBase)(xfb, index, buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TransformFeedbackBufferBase(
      &self,
      xfb: GLuint,
      index: GLuint,
      buffer: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TransformFeedbackBufferBase({:?}, {:?}, {:?});",
          xfb,
          index,
          buffer
        );
      }
      let p = self.glTransformFeedbackBufferBase_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p)
      {
        Some(fn_p) => fn_p(xfb, index, buffer),
        None => go_panic_because_fn_not_loaded("glTransformFeedbackBufferBase"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTransformFeedbackBufferBase" != "glGetError" {
          report_error_as_necessary_from(
            "TransformFeedbackBufferBase",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TransformFeedbackBufferBase_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTransformFeedbackBufferBase\0");
      self.glTransformFeedbackBufferBase_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TransformFeedbackBufferBase_is_loaded(&self) -> bool {
      !self.glTransformFeedbackBufferBase_p.load(RELAX).is_null()
    }
    /// [glTransformFeedbackBufferRange](http://docs.gl/gl4/glTransformFeedbackBufferRange)(xfb, index, buffer, offset, size)
    /// * `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TransformFeedbackBufferRange(
      &self,
      xfb: GLuint,
      index: GLuint,
      buffer: GLuint,
      offset: GLintptr,
      size: GLsizeiptr,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.TransformFeedbackBufferRange({:?}, {:?}, {:?}, {:?}, {:?});", xfb, index, buffer, offset, size);
      }
      let p = self.glTransformFeedbackBufferRange_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLuint, GLintptr, GLsizeiptr)>,
      >(p)
      {
        Some(fn_p) => fn_p(xfb, index, buffer, offset, size),
        None => {
          go_panic_because_fn_not_loaded("glTransformFeedbackBufferRange")
        }
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTransformFeedbackBufferRange" != "glGetError" {
          report_error_as_necessary_from(
            "TransformFeedbackBufferRange",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TransformFeedbackBufferRange_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p =
        do_the_load(get_proc_address, b"glTransformFeedbackBufferRange\0");
      self.glTransformFeedbackBufferRange_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TransformFeedbackBufferRange_is_loaded(&self) -> bool {
      !self.glTransformFeedbackBufferRange_p.load(RELAX).is_null()
    }
    /// [glTransformFeedbackVaryings](http://docs.gl/gl4/glTransformFeedbackVaryings)(program, count, varyings, bufferMode)
    /// * `varyings` len: count
    /// * `bufferMode` group: TransformFeedbackBufferMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn TransformFeedbackVaryings(
      &self,
      program: GLuint,
      count: GLsizei,
      varyings: *const *const GLchar,
      bufferMode: GLenum,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.TransformFeedbackVaryings({:?}, {:?}, {:p}, {:#X});",
          program,
          count,
          varyings,
          bufferMode
        );
      }
      let p = self.glTransformFeedbackVaryings_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizei, *const *const GLchar, GLenum)>,
      >(p)
      {
        Some(fn_p) => fn_p(program, count, varyings, bufferMode),
        None => go_panic_because_fn_not_loaded("glTransformFeedbackVaryings"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glTransformFeedbackVaryings" != "glGetError" {
          report_error_as_necessary_from(
            "TransformFeedbackVaryings",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn TransformFeedbackVaryings_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glTransformFeedbackVaryings\0");
      self.glTransformFeedbackVaryings_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn TransformFeedbackVaryings_is_loaded(&self) -> bool {
      !self.glTransformFeedbackVaryings_p.load(RELAX).is_null()
    }
    /// [glUniform1d](http://docs.gl/gl4/glUniform1d)(location, x)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1d(&self, location: GLint, x: GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform1d({:?}, {:?});", location, x);
      }
      let p = self.glUniform1d_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLint, GLdouble)>>(p) {
        Some(fn_p) => fn_p(location, x),
        None => go_panic_because_fn_not_loaded("glUniform1d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform1d" != "glGetError" {
          report_error_as_necessary_from("Uniform1d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform1d_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform1d\0");
      self.glUniform1d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1d_is_loaded(&self) -> bool {
      !self.glUniform1d_p.load(RELAX).is_null()
    }
    /// [glUniform1dv](http://docs.gl/gl4/glUniform1dv)(location, count, value)
    /// * `value` len: count*1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1dv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform1dv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform1dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform1dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform1dv" != "glGetError" {
          report_error_as_necessary_from("Uniform1dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform1dv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform1dv\0");
      self.glUniform1dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1dv_is_loaded(&self) -> bool {
      !self.glUniform1dv_p.load(RELAX).is_null()
    }
    /// [glUniform1f](http://docs.gl/gl4/glUniform1f)(location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1f(&self, location: GLint, v0: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform1f({:?}, {:?});", location, v0);
      }
      let p = self.glUniform1f_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLint, GLfloat)>>(p) {
        Some(fn_p) => fn_p(location, v0),
        None => go_panic_because_fn_not_loaded("glUniform1f"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform1f" != "glGetError" {
          report_error_as_necessary_from("Uniform1f", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform1f_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform1f\0");
      self.glUniform1f_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1f_is_loaded(&self) -> bool {
      !self.glUniform1f_p.load(RELAX).is_null()
    }
    /// [glUniform1fv](http://docs.gl/gl4/glUniform1fv)(location, count, value)
    /// * `value` len: count*1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1fv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform1fv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform1fv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLfloat)>>(p)
        {
          Some(fn_p) => fn_p(location, count, value),
          None => go_panic_because_fn_not_loaded("glUniform1fv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform1fv" != "glGetError" {
          report_error_as_necessary_from("Uniform1fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform1fv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform1fv\0");
      self.glUniform1fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1fv_is_loaded(&self) -> bool {
      !self.glUniform1fv_p.load(RELAX).is_null()
    }
    /// [glUniform1i](http://docs.gl/gl4/glUniform1i)(location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1i(&self, location: GLint, v0: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform1i({:?}, {:?});", location, v0);
      }
      let p = self.glUniform1i_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLint, GLint)>>(p) {
        Some(fn_p) => fn_p(location, v0),
        None => go_panic_because_fn_not_loaded("glUniform1i"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform1i" != "glGetError" {
          report_error_as_necessary_from("Uniform1i", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform1i_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform1i\0");
      self.glUniform1i_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1i_is_loaded(&self) -> bool {
      !self.glUniform1i_p.load(RELAX).is_null()
    }
    /// [glUniform1iv](http://docs.gl/gl4/glUniform1iv)(location, count, value)
    /// * `value` len: count*1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1iv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform1iv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform1iv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLint)>>(p) {
          Some(fn_p) => fn_p(location, count, value),
          None => go_panic_because_fn_not_loaded("glUniform1iv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform1iv" != "glGetError" {
          report_error_as_necessary_from("Uniform1iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform1iv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform1iv\0");
      self.glUniform1iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1iv_is_loaded(&self) -> bool {
      !self.glUniform1iv_p.load(RELAX).is_null()
    }
    /// [glUniform1ui](http://docs.gl/gl4/glUniform1ui)(location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1ui(&self, location: GLint, v0: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform1ui({:?}, {:?});", location, v0);
      }
      let p = self.glUniform1ui_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLint, GLuint)>>(p) {
        Some(fn_p) => fn_p(location, v0),
        None => go_panic_because_fn_not_loaded("glUniform1ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform1ui" != "glGetError" {
          report_error_as_necessary_from("Uniform1ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform1ui_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform1ui\0");
      self.glUniform1ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1ui_is_loaded(&self) -> bool {
      !self.glUniform1ui_p.load(RELAX).is_null()
    }
    /// [glUniform1uiv](http://docs.gl/gl4/glUniform1uiv)(location, count, value)
    /// * `value` len: count*1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform1uiv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform1uiv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform1uiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform1uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform1uiv" != "glGetError" {
          report_error_as_necessary_from("Uniform1uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform1uiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform1uiv\0");
      self.glUniform1uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform1uiv_is_loaded(&self) -> bool {
      !self.glUniform1uiv_p.load(RELAX).is_null()
    }
    /// [glUniform2d](http://docs.gl/gl4/glUniform2d)(location, x, y)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2d(&self, location: GLint, x: GLdouble, y: GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform2d({:?}, {:?}, {:?});", location, x, y);
      }
      let p = self.glUniform2d_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLdouble, GLdouble)>>(p) {
          Some(fn_p) => fn_p(location, x, y),
          None => go_panic_because_fn_not_loaded("glUniform2d"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform2d" != "glGetError" {
          report_error_as_necessary_from("Uniform2d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform2d_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform2d\0");
      self.glUniform2d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2d_is_loaded(&self) -> bool {
      !self.glUniform2d_p.load(RELAX).is_null()
    }
    /// [glUniform2dv](http://docs.gl/gl4/glUniform2dv)(location, count, value)
    /// * `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2dv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform2dv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform2dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform2dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform2dv" != "glGetError" {
          report_error_as_necessary_from("Uniform2dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform2dv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform2dv\0");
      self.glUniform2dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2dv_is_loaded(&self) -> bool {
      !self.glUniform2dv_p.load(RELAX).is_null()
    }
    /// [glUniform2f](http://docs.gl/gl4/glUniform2f)(location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2f(&self, location: GLint, v0: GLfloat, v1: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform2f({:?}, {:?}, {:?});", location, v0, v1);
      }
      let p = self.glUniform2f_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLint, GLfloat, GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(location, v0, v1),
        None => go_panic_because_fn_not_loaded("glUniform2f"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform2f" != "glGetError" {
          report_error_as_necessary_from("Uniform2f", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform2f_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform2f\0");
      self.glUniform2f_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2f_is_loaded(&self) -> bool {
      !self.glUniform2f_p.load(RELAX).is_null()
    }
    /// [glUniform2fv](http://docs.gl/gl4/glUniform2fv)(location, count, value)
    /// * `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2fv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform2fv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform2fv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLfloat)>>(p)
        {
          Some(fn_p) => fn_p(location, count, value),
          None => go_panic_because_fn_not_loaded("glUniform2fv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform2fv" != "glGetError" {
          report_error_as_necessary_from("Uniform2fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform2fv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform2fv\0");
      self.glUniform2fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2fv_is_loaded(&self) -> bool {
      !self.glUniform2fv_p.load(RELAX).is_null()
    }
    /// [glUniform2i](http://docs.gl/gl4/glUniform2i)(location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2i(&self, location: GLint, v0: GLint, v1: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform2i({:?}, {:?}, {:?});", location, v0, v1);
      }
      let p = self.glUniform2i_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLint, GLint, GLint)>>(p) {
        Some(fn_p) => fn_p(location, v0, v1),
        None => go_panic_because_fn_not_loaded("glUniform2i"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform2i" != "glGetError" {
          report_error_as_necessary_from("Uniform2i", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform2i_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform2i\0");
      self.glUniform2i_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2i_is_loaded(&self) -> bool {
      !self.glUniform2i_p.load(RELAX).is_null()
    }
    /// [glUniform2iv](http://docs.gl/gl4/glUniform2iv)(location, count, value)
    /// * `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2iv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform2iv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform2iv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLint)>>(p) {
          Some(fn_p) => fn_p(location, count, value),
          None => go_panic_because_fn_not_loaded("glUniform2iv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform2iv" != "glGetError" {
          report_error_as_necessary_from("Uniform2iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform2iv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform2iv\0");
      self.glUniform2iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2iv_is_loaded(&self) -> bool {
      !self.glUniform2iv_p.load(RELAX).is_null()
    }
    /// [glUniform2ui](http://docs.gl/gl4/glUniform2ui)(location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2ui(&self, location: GLint, v0: GLuint, v1: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.Uniform2ui({:?}, {:?}, {:?});", location, v0, v1);
      }
      let p = self.glUniform2ui_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLint, GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(location, v0, v1),
        None => go_panic_because_fn_not_loaded("glUniform2ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform2ui" != "glGetError" {
          report_error_as_necessary_from("Uniform2ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform2ui_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform2ui\0");
      self.glUniform2ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2ui_is_loaded(&self) -> bool {
      !self.glUniform2ui_p.load(RELAX).is_null()
    }
    /// [glUniform2uiv](http://docs.gl/gl4/glUniform2uiv)(location, count, value)
    /// * `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform2uiv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform2uiv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform2uiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform2uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform2uiv" != "glGetError" {
          report_error_as_necessary_from("Uniform2uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform2uiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform2uiv\0");
      self.glUniform2uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform2uiv_is_loaded(&self) -> bool {
      !self.glUniform2uiv_p.load(RELAX).is_null()
    }
    /// [glUniform3d](http://docs.gl/gl4/glUniform3d)(location, x, y, z)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3d(
      &self,
      location: GLint,
      x: GLdouble,
      y: GLdouble,
      z: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3d({:?}, {:?}, {:?}, {:?});",
          location,
          x,
          y,
          z
        );
      }
      let p = self.glUniform3d_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLdouble, GLdouble, GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, x, y, z),
        None => go_panic_because_fn_not_loaded("glUniform3d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform3d" != "glGetError" {
          report_error_as_necessary_from("Uniform3d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform3d_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform3d\0");
      self.glUniform3d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3d_is_loaded(&self) -> bool {
      !self.glUniform3d_p.load(RELAX).is_null()
    }
    /// [glUniform3dv](http://docs.gl/gl4/glUniform3dv)(location, count, value)
    /// * `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3dv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3dv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform3dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform3dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform3dv" != "glGetError" {
          report_error_as_necessary_from("Uniform3dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform3dv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform3dv\0");
      self.glUniform3dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3dv_is_loaded(&self) -> bool {
      !self.glUniform3dv_p.load(RELAX).is_null()
    }
    /// [glUniform3f](http://docs.gl/gl4/glUniform3f)(location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3f(
      &self,
      location: GLint,
      v0: GLfloat,
      v1: GLfloat,
      v2: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3f({:?}, {:?}, {:?}, {:?});",
          location,
          v0,
          v1,
          v2
        );
      }
      let p = self.glUniform3f_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLfloat, GLfloat, GLfloat)>>(
          p,
        ) {
          Some(fn_p) => fn_p(location, v0, v1, v2),
          None => go_panic_because_fn_not_loaded("glUniform3f"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform3f" != "glGetError" {
          report_error_as_necessary_from("Uniform3f", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform3f_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform3f\0");
      self.glUniform3f_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3f_is_loaded(&self) -> bool {
      !self.glUniform3f_p.load(RELAX).is_null()
    }
    /// [glUniform3fv](http://docs.gl/gl4/glUniform3fv)(location, count, value)
    /// * `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3fv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3fv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform3fv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLfloat)>>(p)
        {
          Some(fn_p) => fn_p(location, count, value),
          None => go_panic_because_fn_not_loaded("glUniform3fv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform3fv" != "glGetError" {
          report_error_as_necessary_from("Uniform3fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform3fv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform3fv\0");
      self.glUniform3fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3fv_is_loaded(&self) -> bool {
      !self.glUniform3fv_p.load(RELAX).is_null()
    }
    /// [glUniform3i](http://docs.gl/gl4/glUniform3i)(location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3i(
      &self,
      location: GLint,
      v0: GLint,
      v1: GLint,
      v2: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3i({:?}, {:?}, {:?}, {:?});",
          location,
          v0,
          v1,
          v2
        );
      }
      let p = self.glUniform3i_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLint, GLint, GLint)>>(p) {
          Some(fn_p) => fn_p(location, v0, v1, v2),
          None => go_panic_because_fn_not_loaded("glUniform3i"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform3i" != "glGetError" {
          report_error_as_necessary_from("Uniform3i", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform3i_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform3i\0");
      self.glUniform3i_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3i_is_loaded(&self) -> bool {
      !self.glUniform3i_p.load(RELAX).is_null()
    }
    /// [glUniform3iv](http://docs.gl/gl4/glUniform3iv)(location, count, value)
    /// * `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3iv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3iv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform3iv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLint)>>(p) {
          Some(fn_p) => fn_p(location, count, value),
          None => go_panic_because_fn_not_loaded("glUniform3iv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform3iv" != "glGetError" {
          report_error_as_necessary_from("Uniform3iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform3iv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform3iv\0");
      self.glUniform3iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3iv_is_loaded(&self) -> bool {
      !self.glUniform3iv_p.load(RELAX).is_null()
    }
    /// [glUniform3ui](http://docs.gl/gl4/glUniform3ui)(location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3ui(
      &self,
      location: GLint,
      v0: GLuint,
      v1: GLuint,
      v2: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3ui({:?}, {:?}, {:?}, {:?});",
          location,
          v0,
          v1,
          v2
        );
      }
      let p = self.glUniform3ui_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLuint, GLuint, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, v0, v1, v2),
        None => go_panic_because_fn_not_loaded("glUniform3ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform3ui" != "glGetError" {
          report_error_as_necessary_from("Uniform3ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform3ui_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform3ui\0");
      self.glUniform3ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3ui_is_loaded(&self) -> bool {
      !self.glUniform3ui_p.load(RELAX).is_null()
    }
    /// [glUniform3uiv](http://docs.gl/gl4/glUniform3uiv)(location, count, value)
    /// * `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform3uiv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform3uiv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform3uiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform3uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform3uiv" != "glGetError" {
          report_error_as_necessary_from("Uniform3uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform3uiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform3uiv\0");
      self.glUniform3uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform3uiv_is_loaded(&self) -> bool {
      !self.glUniform3uiv_p.load(RELAX).is_null()
    }
    /// [glUniform4d](http://docs.gl/gl4/glUniform4d)(location, x, y, z, w)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4d(
      &self,
      location: GLint,
      x: GLdouble,
      y: GLdouble,
      z: GLdouble,
      w: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4d({:?}, {:?}, {:?}, {:?}, {:?});",
          location,
          x,
          y,
          z,
          w
        );
      }
      let p = self.glUniform4d_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLdouble, GLdouble, GLdouble, GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, x, y, z, w),
        None => go_panic_because_fn_not_loaded("glUniform4d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform4d" != "glGetError" {
          report_error_as_necessary_from("Uniform4d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform4d_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform4d\0");
      self.glUniform4d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4d_is_loaded(&self) -> bool {
      !self.glUniform4d_p.load(RELAX).is_null()
    }
    /// [glUniform4dv](http://docs.gl/gl4/glUniform4dv)(location, count, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4dv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4dv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform4dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform4dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform4dv" != "glGetError" {
          report_error_as_necessary_from("Uniform4dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform4dv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform4dv\0");
      self.glUniform4dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4dv_is_loaded(&self) -> bool {
      !self.glUniform4dv_p.load(RELAX).is_null()
    }
    /// [glUniform4f](http://docs.gl/gl4/glUniform4f)(location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4f(
      &self,
      location: GLint,
      v0: GLfloat,
      v1: GLfloat,
      v2: GLfloat,
      v3: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4f({:?}, {:?}, {:?}, {:?}, {:?});",
          location,
          v0,
          v1,
          v2,
          v3
        );
      }
      let p = self.glUniform4f_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLfloat, GLfloat, GLfloat, GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, v0, v1, v2, v3),
        None => go_panic_because_fn_not_loaded("glUniform4f"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform4f" != "glGetError" {
          report_error_as_necessary_from("Uniform4f", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform4f_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform4f\0");
      self.glUniform4f_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4f_is_loaded(&self) -> bool {
      !self.glUniform4f_p.load(RELAX).is_null()
    }
    /// [glUniform4fv](http://docs.gl/gl4/glUniform4fv)(location, count, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4fv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4fv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform4fv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLfloat)>>(p)
        {
          Some(fn_p) => fn_p(location, count, value),
          None => go_panic_because_fn_not_loaded("glUniform4fv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform4fv" != "glGetError" {
          report_error_as_necessary_from("Uniform4fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform4fv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform4fv\0");
      self.glUniform4fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4fv_is_loaded(&self) -> bool {
      !self.glUniform4fv_p.load(RELAX).is_null()
    }
    /// [glUniform4i](http://docs.gl/gl4/glUniform4i)(location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4i(
      &self,
      location: GLint,
      v0: GLint,
      v1: GLint,
      v2: GLint,
      v3: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4i({:?}, {:?}, {:?}, {:?}, {:?});",
          location,
          v0,
          v1,
          v2,
          v3
        );
      }
      let p = self.glUniform4i_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLint, GLint, GLint, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, v0, v1, v2, v3),
        None => go_panic_because_fn_not_loaded("glUniform4i"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform4i" != "glGetError" {
          report_error_as_necessary_from("Uniform4i", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform4i_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform4i\0");
      self.glUniform4i_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4i_is_loaded(&self) -> bool {
      !self.glUniform4i_p.load(RELAX).is_null()
    }
    /// [glUniform4iv](http://docs.gl/gl4/glUniform4iv)(location, count, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4iv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4iv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform4iv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLsizei, *const GLint)>>(p) {
          Some(fn_p) => fn_p(location, count, value),
          None => go_panic_because_fn_not_loaded("glUniform4iv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform4iv" != "glGetError" {
          report_error_as_necessary_from("Uniform4iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform4iv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform4iv\0");
      self.glUniform4iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4iv_is_loaded(&self) -> bool {
      !self.glUniform4iv_p.load(RELAX).is_null()
    }
    /// [glUniform4ui](http://docs.gl/gl4/glUniform4ui)(location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4ui(
      &self,
      location: GLint,
      v0: GLuint,
      v1: GLuint,
      v2: GLuint,
      v3: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4ui({:?}, {:?}, {:?}, {:?}, {:?});",
          location,
          v0,
          v1,
          v2,
          v3
        );
      }
      let p = self.glUniform4ui_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLuint, GLuint, GLuint, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, v0, v1, v2, v3),
        None => go_panic_because_fn_not_loaded("glUniform4ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform4ui" != "glGetError" {
          report_error_as_necessary_from("Uniform4ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform4ui_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform4ui\0");
      self.glUniform4ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4ui_is_loaded(&self) -> bool {
      !self.glUniform4ui_p.load(RELAX).is_null()
    }
    /// [glUniform4uiv](http://docs.gl/gl4/glUniform4uiv)(location, count, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Uniform4uiv(
      &self,
      location: GLint,
      count: GLsizei,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Uniform4uiv({:?}, {:?}, {:p});",
          location,
          count,
          value
        );
      }
      let p = self.glUniform4uiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, value),
        None => go_panic_because_fn_not_loaded("glUniform4uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniform4uiv" != "glGetError" {
          report_error_as_necessary_from("Uniform4uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Uniform4uiv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUniform4uiv\0");
      self.glUniform4uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Uniform4uiv_is_loaded(&self) -> bool {
      !self.glUniform4uiv_p.load(RELAX).is_null()
    }
    /// [glUniformBlockBinding](http://docs.gl/gl4/glUniformBlockBinding)(program, uniformBlockIndex, uniformBlockBinding)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformBlockBinding(
      &self,
      program: GLuint,
      uniformBlockIndex: GLuint,
      uniformBlockBinding: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformBlockBinding({:?}, {:?}, {:?});",
          program,
          uniformBlockIndex,
          uniformBlockBinding
        );
      }
      let p = self.glUniformBlockBinding_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p)
      {
        Some(fn_p) => fn_p(program, uniformBlockIndex, uniformBlockBinding),
        None => go_panic_because_fn_not_loaded("glUniformBlockBinding"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformBlockBinding" != "glGetError" {
          report_error_as_necessary_from(
            "UniformBlockBinding",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformBlockBinding_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformBlockBinding\0");
      self.glUniformBlockBinding_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformBlockBinding_is_loaded(&self) -> bool {
      !self.glUniformBlockBinding_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix2dv](http://docs.gl/gl4/glUniformMatrix2dv)(location, count, transpose, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix2dv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix2dv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix2dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix2dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix2dv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix2dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix2dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix2dv\0");
      self.glUniformMatrix2dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix2dv_is_loaded(&self) -> bool {
      !self.glUniformMatrix2dv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix2fv](http://docs.gl/gl4/glUniformMatrix2fv)(location, count, transpose, value)
    /// * `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix2fv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix2fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix2fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix2fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix2fv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix2fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix2fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix2fv\0");
      self.glUniformMatrix2fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix2fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix2fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix2x3dv](http://docs.gl/gl4/glUniformMatrix2x3dv)(location, count, transpose, value)
    /// * `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix2x3dv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix2x3dv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix2x3dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix2x3dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix2x3dv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix2x3dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix2x3dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix2x3dv\0");
      self.glUniformMatrix2x3dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix2x3dv_is_loaded(&self) -> bool {
      !self.glUniformMatrix2x3dv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix2x3fv](http://docs.gl/gl4/glUniformMatrix2x3fv)(location, count, transpose, value)
    /// * `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix2x3fv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix2x3fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix2x3fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix2x3fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix2x3fv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix2x3fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix2x3fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix2x3fv\0");
      self.glUniformMatrix2x3fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix2x3fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix2x3fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix2x4dv](http://docs.gl/gl4/glUniformMatrix2x4dv)(location, count, transpose, value)
    /// * `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix2x4dv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix2x4dv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix2x4dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix2x4dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix2x4dv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix2x4dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix2x4dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix2x4dv\0");
      self.glUniformMatrix2x4dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix2x4dv_is_loaded(&self) -> bool {
      !self.glUniformMatrix2x4dv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix2x4fv](http://docs.gl/gl4/glUniformMatrix2x4fv)(location, count, transpose, value)
    /// * `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix2x4fv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix2x4fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix2x4fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix2x4fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix2x4fv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix2x4fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix2x4fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix2x4fv\0");
      self.glUniformMatrix2x4fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix2x4fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix2x4fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix3dv](http://docs.gl/gl4/glUniformMatrix3dv)(location, count, transpose, value)
    /// * `value` len: count*9
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix3dv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix3dv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix3dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix3dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix3dv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix3dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix3dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix3dv\0");
      self.glUniformMatrix3dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix3dv_is_loaded(&self) -> bool {
      !self.glUniformMatrix3dv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix3fv](http://docs.gl/gl4/glUniformMatrix3fv)(location, count, transpose, value)
    /// * `value` len: count*9
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix3fv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix3fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix3fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix3fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix3fv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix3fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix3fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix3fv\0");
      self.glUniformMatrix3fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix3fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix3fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix3x2dv](http://docs.gl/gl4/glUniformMatrix3x2dv)(location, count, transpose, value)
    /// * `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix3x2dv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix3x2dv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix3x2dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix3x2dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix3x2dv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix3x2dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix3x2dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix3x2dv\0");
      self.glUniformMatrix3x2dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix3x2dv_is_loaded(&self) -> bool {
      !self.glUniformMatrix3x2dv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix3x2fv](http://docs.gl/gl4/glUniformMatrix3x2fv)(location, count, transpose, value)
    /// * `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix3x2fv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix3x2fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix3x2fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix3x2fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix3x2fv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix3x2fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix3x2fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix3x2fv\0");
      self.glUniformMatrix3x2fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix3x2fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix3x2fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix3x4dv](http://docs.gl/gl4/glUniformMatrix3x4dv)(location, count, transpose, value)
    /// * `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix3x4dv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix3x4dv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix3x4dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix3x4dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix3x4dv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix3x4dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix3x4dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix3x4dv\0");
      self.glUniformMatrix3x4dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix3x4dv_is_loaded(&self) -> bool {
      !self.glUniformMatrix3x4dv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix3x4fv](http://docs.gl/gl4/glUniformMatrix3x4fv)(location, count, transpose, value)
    /// * `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix3x4fv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix3x4fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix3x4fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix3x4fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix3x4fv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix3x4fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix3x4fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix3x4fv\0");
      self.glUniformMatrix3x4fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix3x4fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix3x4fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix4dv](http://docs.gl/gl4/glUniformMatrix4dv)(location, count, transpose, value)
    /// * `value` len: count*16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix4dv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix4dv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix4dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix4dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix4dv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix4dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix4dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix4dv\0");
      self.glUniformMatrix4dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix4dv_is_loaded(&self) -> bool {
      !self.glUniformMatrix4dv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix4fv](http://docs.gl/gl4/glUniformMatrix4fv)(location, count, transpose, value)
    /// * `value` len: count*16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix4fv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix4fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix4fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix4fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix4fv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix4fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix4fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix4fv\0");
      self.glUniformMatrix4fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix4fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix4fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix4x2dv](http://docs.gl/gl4/glUniformMatrix4x2dv)(location, count, transpose, value)
    /// * `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix4x2dv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix4x2dv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix4x2dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix4x2dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix4x2dv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix4x2dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix4x2dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix4x2dv\0");
      self.glUniformMatrix4x2dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix4x2dv_is_loaded(&self) -> bool {
      !self.glUniformMatrix4x2dv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix4x2fv](http://docs.gl/gl4/glUniformMatrix4x2fv)(location, count, transpose, value)
    /// * `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix4x2fv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix4x2fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix4x2fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix4x2fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix4x2fv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix4x2fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix4x2fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix4x2fv\0");
      self.glUniformMatrix4x2fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix4x2fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix4x2fv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix4x3dv](http://docs.gl/gl4/glUniformMatrix4x3dv)(location, count, transpose, value)
    /// * `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix4x3dv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix4x3dv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix4x3dv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix4x3dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix4x3dv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix4x3dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix4x3dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix4x3dv\0");
      self.glUniformMatrix4x3dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix4x3dv_is_loaded(&self) -> bool {
      !self.glUniformMatrix4x3dv_p.load(RELAX).is_null()
    }
    /// [glUniformMatrix4x3fv](http://docs.gl/gl4/glUniformMatrix4x3fv)(location, count, transpose, value)
    /// * `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformMatrix4x3fv(
      &self,
      location: GLint,
      count: GLsizei,
      transpose: GLboolean,
      value: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformMatrix4x3fv({:?}, {:?}, {:?}, {:p});",
          location,
          count,
          transpose,
          value
        );
      }
      let p = self.glUniformMatrix4x3fv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(location, count, transpose, value),
        None => go_panic_because_fn_not_loaded("glUniformMatrix4x3fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformMatrix4x3fv" != "glGetError" {
          report_error_as_necessary_from("UniformMatrix4x3fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformMatrix4x3fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformMatrix4x3fv\0");
      self.glUniformMatrix4x3fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformMatrix4x3fv_is_loaded(&self) -> bool {
      !self.glUniformMatrix4x3fv_p.load(RELAX).is_null()
    }
    /// [glUniformSubroutinesuiv](http://docs.gl/gl4/glUniformSubroutinesuiv)(shadertype, count, indices)
    /// * `shadertype` group: ShaderType
    /// * `indices` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UniformSubroutinesuiv(
      &self,
      shadertype: GLenum,
      count: GLsizei,
      indices: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UniformSubroutinesuiv({:#X}, {:?}, {:p});",
          shadertype,
          count,
          indices
        );
      }
      let p = self.glUniformSubroutinesuiv_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLenum, GLsizei, *const GLuint)>>(p)
        {
          Some(fn_p) => fn_p(shadertype, count, indices),
          None => go_panic_because_fn_not_loaded("glUniformSubroutinesuiv"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUniformSubroutinesuiv" != "glGetError" {
          report_error_as_necessary_from(
            "UniformSubroutinesuiv",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UniformSubroutinesuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUniformSubroutinesuiv\0");
      self.glUniformSubroutinesuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UniformSubroutinesuiv_is_loaded(&self) -> bool {
      !self.glUniformSubroutinesuiv_p.load(RELAX).is_null()
    }
    /// [glUnmapBuffer](http://docs.gl/gl4/glUnmapBuffer)(target)
    /// * `target` group: BufferTargetARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UnmapBuffer(&self, target: GLenum) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.UnmapBuffer({:#X});", target);
      }
      let p = self.glUnmapBuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLenum) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(target),
        None => go_panic_because_fn_not_loaded("glUnmapBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUnmapBuffer" != "glGetError" {
          report_error_as_necessary_from("UnmapBuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UnmapBuffer_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUnmapBuffer\0");
      self.glUnmapBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UnmapBuffer_is_loaded(&self) -> bool {
      !self.glUnmapBuffer_p.load(RELAX).is_null()
    }
    /// [glUnmapNamedBuffer](http://docs.gl/gl4/glUnmapNamedBuffer)(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UnmapNamedBuffer(&self, buffer: GLuint) -> GLboolean {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.UnmapNamedBuffer({:?});", buffer);
      }
      let p = self.glUnmapNamedBuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint) -> GLboolean>>(p) {
        Some(fn_p) => fn_p(buffer),
        None => go_panic_because_fn_not_loaded("glUnmapNamedBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUnmapNamedBuffer" != "glGetError" {
          report_error_as_necessary_from("UnmapNamedBuffer", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UnmapNamedBuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUnmapNamedBuffer\0");
      self.glUnmapNamedBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UnmapNamedBuffer_is_loaded(&self) -> bool {
      !self.glUnmapNamedBuffer_p.load(RELAX).is_null()
    }
    /// [glUseProgram](http://docs.gl/gl4/glUseProgram)(program)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UseProgram(&self, program: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.UseProgram({:?});", program);
      }
      let p = self.glUseProgram_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(program),
        None => go_panic_because_fn_not_loaded("glUseProgram"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUseProgram" != "glGetError" {
          report_error_as_necessary_from("UseProgram", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UseProgram_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glUseProgram\0");
      self.glUseProgram_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UseProgram_is_loaded(&self) -> bool {
      !self.glUseProgram_p.load(RELAX).is_null()
    }
    /// [glUseProgramStages](http://docs.gl/gl4/glUseProgramStages)(pipeline, stages, program)
    /// * `stages` group: UseProgramStageMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn UseProgramStages(
      &self,
      pipeline: GLuint,
      stages: GLbitfield,
      program: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.UseProgramStages({:?}, {:?}, {:?});",
          pipeline,
          stages,
          program
        );
      }
      let p = self.glUseProgramStages_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLbitfield, GLuint)>>(p) {
          Some(fn_p) => fn_p(pipeline, stages, program),
          None => go_panic_because_fn_not_loaded("glUseProgramStages"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glUseProgramStages" != "glGetError" {
          report_error_as_necessary_from("UseProgramStages", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn UseProgramStages_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glUseProgramStages\0");
      self.glUseProgramStages_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn UseProgramStages_is_loaded(&self) -> bool {
      !self.glUseProgramStages_p.load(RELAX).is_null()
    }
    /// [glValidateProgram](http://docs.gl/gl4/glValidateProgram)(program)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ValidateProgram(&self, program: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ValidateProgram({:?});", program);
      }
      let p = self.glValidateProgram_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(program),
        None => go_panic_because_fn_not_loaded("glValidateProgram"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glValidateProgram" != "glGetError" {
          report_error_as_necessary_from("ValidateProgram", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ValidateProgram_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glValidateProgram\0");
      self.glValidateProgram_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ValidateProgram_is_loaded(&self) -> bool {
      !self.glValidateProgram_p.load(RELAX).is_null()
    }
    /// [glValidateProgramPipeline](http://docs.gl/gl4/glValidateProgramPipeline)(pipeline)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ValidateProgramPipeline(&self, pipeline: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ValidateProgramPipeline({:?});", pipeline);
      }
      let p = self.glValidateProgramPipeline_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint)>>(p) {
        Some(fn_p) => fn_p(pipeline),
        None => go_panic_because_fn_not_loaded("glValidateProgramPipeline"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glValidateProgramPipeline" != "glGetError" {
          report_error_as_necessary_from(
            "ValidateProgramPipeline",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ValidateProgramPipeline_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glValidateProgramPipeline\0");
      self.glValidateProgramPipeline_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ValidateProgramPipeline_is_loaded(&self) -> bool {
      !self.glValidateProgramPipeline_p.load(RELAX).is_null()
    }
    /// [glVertexArrayAttribBinding](http://docs.gl/gl4/glVertexArrayAttribBinding)(vaobj, attribindex, bindingindex)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexArrayAttribBinding(
      &self,
      vaobj: GLuint,
      attribindex: GLuint,
      bindingindex: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexArrayAttribBinding({:?}, {:?}, {:?});",
          vaobj,
          attribindex,
          bindingindex
        );
      }
      let p = self.glVertexArrayAttribBinding_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p)
      {
        Some(fn_p) => fn_p(vaobj, attribindex, bindingindex),
        None => go_panic_because_fn_not_loaded("glVertexArrayAttribBinding"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexArrayAttribBinding" != "glGetError" {
          report_error_as_necessary_from(
            "VertexArrayAttribBinding",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexArrayAttribBinding_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexArrayAttribBinding\0");
      self.glVertexArrayAttribBinding_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexArrayAttribBinding_is_loaded(&self) -> bool {
      !self.glVertexArrayAttribBinding_p.load(RELAX).is_null()
    }
    /// [glVertexArrayAttribFormat](http://docs.gl/gl4/glVertexArrayAttribFormat)(vaobj, attribindex, size, type_, normalized, relativeoffset)
    /// * `type_` group: VertexAttribType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexArrayAttribFormat(
      &self,
      vaobj: GLuint,
      attribindex: GLuint,
      size: GLint,
      type_: GLenum,
      normalized: GLboolean,
      relativeoffset: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexArrayAttribFormat({:?}, {:?}, {:?}, {:#X}, {:?}, {:?});", vaobj, attribindex, size, type_, normalized, relativeoffset);
      }
      let p = self.glVertexArrayAttribFormat_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLint, GLenum, GLboolean, GLuint)>,
      >(p)
      {
        Some(fn_p) => {
          fn_p(vaobj, attribindex, size, type_, normalized, relativeoffset)
        }
        None => go_panic_because_fn_not_loaded("glVertexArrayAttribFormat"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexArrayAttribFormat" != "glGetError" {
          report_error_as_necessary_from(
            "VertexArrayAttribFormat",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexArrayAttribFormat_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexArrayAttribFormat\0");
      self.glVertexArrayAttribFormat_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexArrayAttribFormat_is_loaded(&self) -> bool {
      !self.glVertexArrayAttribFormat_p.load(RELAX).is_null()
    }
    /// [glVertexArrayAttribIFormat](http://docs.gl/gl4/glVertexArrayAttribIFormat)(vaobj, attribindex, size, type_, relativeoffset)
    /// * `type_` group: VertexAttribIType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexArrayAttribIFormat(
      &self,
      vaobj: GLuint,
      attribindex: GLuint,
      size: GLint,
      type_: GLenum,
      relativeoffset: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexArrayAttribIFormat({:?}, {:?}, {:?}, {:#X}, {:?});",
          vaobj,
          attribindex,
          size,
          type_,
          relativeoffset
        );
      }
      let p = self.glVertexArrayAttribIFormat_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLint, GLenum, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(vaobj, attribindex, size, type_, relativeoffset),
        None => go_panic_because_fn_not_loaded("glVertexArrayAttribIFormat"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexArrayAttribIFormat" != "glGetError" {
          report_error_as_necessary_from(
            "VertexArrayAttribIFormat",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexArrayAttribIFormat_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexArrayAttribIFormat\0");
      self.glVertexArrayAttribIFormat_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexArrayAttribIFormat_is_loaded(&self) -> bool {
      !self.glVertexArrayAttribIFormat_p.load(RELAX).is_null()
    }
    /// [glVertexArrayAttribLFormat](http://docs.gl/gl4/glVertexArrayAttribLFormat)(vaobj, attribindex, size, type_, relativeoffset)
    /// * `type_` group: VertexAttribLType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexArrayAttribLFormat(
      &self,
      vaobj: GLuint,
      attribindex: GLuint,
      size: GLint,
      type_: GLenum,
      relativeoffset: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexArrayAttribLFormat({:?}, {:?}, {:?}, {:#X}, {:?});",
          vaobj,
          attribindex,
          size,
          type_,
          relativeoffset
        );
      }
      let p = self.glVertexArrayAttribLFormat_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLint, GLenum, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(vaobj, attribindex, size, type_, relativeoffset),
        None => go_panic_because_fn_not_loaded("glVertexArrayAttribLFormat"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexArrayAttribLFormat" != "glGetError" {
          report_error_as_necessary_from(
            "VertexArrayAttribLFormat",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexArrayAttribLFormat_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexArrayAttribLFormat\0");
      self.glVertexArrayAttribLFormat_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexArrayAttribLFormat_is_loaded(&self) -> bool {
      !self.glVertexArrayAttribLFormat_p.load(RELAX).is_null()
    }
    /// [glVertexArrayBindingDivisor](http://docs.gl/gl4/glVertexArrayBindingDivisor)(vaobj, bindingindex, divisor)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexArrayBindingDivisor(
      &self,
      vaobj: GLuint,
      bindingindex: GLuint,
      divisor: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexArrayBindingDivisor({:?}, {:?}, {:?});",
          vaobj,
          bindingindex,
          divisor
        );
      }
      let p = self.glVertexArrayBindingDivisor_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p)
      {
        Some(fn_p) => fn_p(vaobj, bindingindex, divisor),
        None => go_panic_because_fn_not_loaded("glVertexArrayBindingDivisor"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexArrayBindingDivisor" != "glGetError" {
          report_error_as_necessary_from(
            "VertexArrayBindingDivisor",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexArrayBindingDivisor_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexArrayBindingDivisor\0");
      self.glVertexArrayBindingDivisor_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexArrayBindingDivisor_is_loaded(&self) -> bool {
      !self.glVertexArrayBindingDivisor_p.load(RELAX).is_null()
    }
    /// [glVertexArrayElementBuffer](http://docs.gl/gl4/glVertexArrayElementBuffer)(vaobj, buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexArrayElementBuffer(
      &self,
      vaobj: GLuint,
      buffer: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexArrayElementBuffer({:?}, {:?});",
          vaobj,
          buffer
        );
      }
      let p = self.glVertexArrayElementBuffer_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(vaobj, buffer),
        None => go_panic_because_fn_not_loaded("glVertexArrayElementBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexArrayElementBuffer" != "glGetError" {
          report_error_as_necessary_from(
            "VertexArrayElementBuffer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexArrayElementBuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexArrayElementBuffer\0");
      self.glVertexArrayElementBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexArrayElementBuffer_is_loaded(&self) -> bool {
      !self.glVertexArrayElementBuffer_p.load(RELAX).is_null()
    }
    /// [glVertexArrayVertexBuffer](http://docs.gl/gl4/glVertexArrayVertexBuffer)(vaobj, bindingindex, buffer, offset, stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexArrayVertexBuffer(
      &self,
      vaobj: GLuint,
      bindingindex: GLuint,
      buffer: GLuint,
      offset: GLintptr,
      stride: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexArrayVertexBuffer({:?}, {:?}, {:?}, {:?}, {:?});",
          vaobj,
          bindingindex,
          buffer,
          offset,
          stride
        );
      }
      let p = self.glVertexArrayVertexBuffer_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLuint, GLintptr, GLsizei)>,
      >(p)
      {
        Some(fn_p) => fn_p(vaobj, bindingindex, buffer, offset, stride),
        None => go_panic_because_fn_not_loaded("glVertexArrayVertexBuffer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexArrayVertexBuffer" != "glGetError" {
          report_error_as_necessary_from(
            "VertexArrayVertexBuffer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexArrayVertexBuffer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexArrayVertexBuffer\0");
      self.glVertexArrayVertexBuffer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexArrayVertexBuffer_is_loaded(&self) -> bool {
      !self.glVertexArrayVertexBuffer_p.load(RELAX).is_null()
    }
    /// [glVertexArrayVertexBuffers](http://docs.gl/gl4/glVertexArrayVertexBuffers)(vaobj, first, count, buffers, offsets, strides)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexArrayVertexBuffers(
      &self,
      vaobj: GLuint,
      first: GLuint,
      count: GLsizei,
      buffers: *const GLuint,
      offsets: *const GLintptr,
      strides: *const GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexArrayVertexBuffers({:?}, {:?}, {:?}, {:p}, {:p}, {:p});", vaobj, first, count, buffers, offsets, strides);
      }
      let p = self.glVertexArrayVertexBuffers_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLuint,
            GLsizei,
            *const GLuint,
            *const GLintptr,
            *const GLsizei,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(vaobj, first, count, buffers, offsets, strides),
        None => go_panic_because_fn_not_loaded("glVertexArrayVertexBuffers"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexArrayVertexBuffers" != "glGetError" {
          report_error_as_necessary_from(
            "VertexArrayVertexBuffers",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexArrayVertexBuffers_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexArrayVertexBuffers\0");
      self.glVertexArrayVertexBuffers_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexArrayVertexBuffers_is_loaded(&self) -> bool {
      !self.glVertexArrayVertexBuffers_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib1d](http://docs.gl/gl4/glVertexAttrib1d)(index, x)
    /// * vector equivalent: [`glVertexAttrib1dv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib1d(&self, index: GLuint, x: GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib1d({:?}, {:?});", index, x);
      }
      let p = self.glVertexAttrib1d_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLdouble)>>(p) {
        Some(fn_p) => fn_p(index, x),
        None => go_panic_because_fn_not_loaded("glVertexAttrib1d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib1d" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib1d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib1d_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib1d\0");
      self.glVertexAttrib1d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib1d_is_loaded(&self) -> bool {
      !self.glVertexAttrib1d_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib1dv](http://docs.gl/gl4/glVertexAttrib1dv)(index, v)
    /// * `v` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib1dv(&self, index: GLuint, v: *const GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib1dv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib1dv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib1dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib1dv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib1dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib1dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib1dv\0");
      self.glVertexAttrib1dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib1dv_is_loaded(&self) -> bool {
      !self.glVertexAttrib1dv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib1f](http://docs.gl/gl4/glVertexAttrib1f)(index, x)
    /// * vector equivalent: [`glVertexAttrib1fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib1f(&self, index: GLuint, x: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib1f({:?}, {:?});", index, x);
      }
      let p = self.glVertexAttrib1f_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLfloat)>>(p) {
        Some(fn_p) => fn_p(index, x),
        None => go_panic_because_fn_not_loaded("glVertexAttrib1f"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib1f" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib1f", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib1f_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib1f\0");
      self.glVertexAttrib1f_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib1f_is_loaded(&self) -> bool {
      !self.glVertexAttrib1f_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib1fv](http://docs.gl/gl4/glVertexAttrib1fv)(index, v)
    /// * `v` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib1fv(&self, index: GLuint, v: *const GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib1fv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib1fv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib1fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib1fv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib1fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib1fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib1fv\0");
      self.glVertexAttrib1fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib1fv_is_loaded(&self) -> bool {
      !self.glVertexAttrib1fv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib1s](http://docs.gl/gl4/glVertexAttrib1s)(index, x)
    /// * vector equivalent: [`glVertexAttrib1sv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib1s(&self, index: GLuint, x: GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib1s({:?}, {:?});", index, x);
      }
      let p = self.glVertexAttrib1s_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLshort)>>(p) {
        Some(fn_p) => fn_p(index, x),
        None => go_panic_because_fn_not_loaded("glVertexAttrib1s"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib1s" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib1s", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib1s_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib1s\0");
      self.glVertexAttrib1s_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib1s_is_loaded(&self) -> bool {
      !self.glVertexAttrib1s_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib1sv](http://docs.gl/gl4/glVertexAttrib1sv)(index, v)
    /// * `v` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib1sv(&self, index: GLuint, v: *const GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib1sv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib1sv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLshort)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib1sv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib1sv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib1sv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib1sv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib1sv\0");
      self.glVertexAttrib1sv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib1sv_is_loaded(&self) -> bool {
      !self.glVertexAttrib1sv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib2d](http://docs.gl/gl4/glVertexAttrib2d)(index, x, y)
    /// * vector equivalent: [`glVertexAttrib2dv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib2d(
      &self,
      index: GLuint,
      x: GLdouble,
      y: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib2d({:?}, {:?}, {:?});", index, x, y);
      }
      let p = self.glVertexAttrib2d_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLdouble, GLdouble)>>(p) {
          Some(fn_p) => fn_p(index, x, y),
          None => go_panic_because_fn_not_loaded("glVertexAttrib2d"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib2d" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib2d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib2d_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib2d\0");
      self.glVertexAttrib2d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib2d_is_loaded(&self) -> bool {
      !self.glVertexAttrib2d_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib2dv](http://docs.gl/gl4/glVertexAttrib2dv)(index, v)
    /// * `v` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib2dv(&self, index: GLuint, v: *const GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib2dv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib2dv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib2dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib2dv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib2dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib2dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib2dv\0");
      self.glVertexAttrib2dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib2dv_is_loaded(&self) -> bool {
      !self.glVertexAttrib2dv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib2f](http://docs.gl/gl4/glVertexAttrib2f)(index, x, y)
    /// * vector equivalent: [`glVertexAttrib2fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib2f(&self, index: GLuint, x: GLfloat, y: GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib2f({:?}, {:?}, {:?});", index, x, y);
      }
      let p = self.glVertexAttrib2f_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLfloat, GLfloat)>>(p) {
          Some(fn_p) => fn_p(index, x, y),
          None => go_panic_because_fn_not_loaded("glVertexAttrib2f"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib2f" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib2f", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib2f_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib2f\0");
      self.glVertexAttrib2f_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib2f_is_loaded(&self) -> bool {
      !self.glVertexAttrib2f_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib2fv](http://docs.gl/gl4/glVertexAttrib2fv)(index, v)
    /// * `v` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib2fv(&self, index: GLuint, v: *const GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib2fv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib2fv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib2fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib2fv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib2fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib2fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib2fv\0");
      self.glVertexAttrib2fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib2fv_is_loaded(&self) -> bool {
      !self.glVertexAttrib2fv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib2s](http://docs.gl/gl4/glVertexAttrib2s)(index, x, y)
    /// * vector equivalent: [`glVertexAttrib2sv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib2s(&self, index: GLuint, x: GLshort, y: GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib2s({:?}, {:?}, {:?});", index, x, y);
      }
      let p = self.glVertexAttrib2s_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLshort, GLshort)>>(p) {
          Some(fn_p) => fn_p(index, x, y),
          None => go_panic_because_fn_not_loaded("glVertexAttrib2s"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib2s" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib2s", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib2s_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib2s\0");
      self.glVertexAttrib2s_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib2s_is_loaded(&self) -> bool {
      !self.glVertexAttrib2s_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib2sv](http://docs.gl/gl4/glVertexAttrib2sv)(index, v)
    /// * `v` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib2sv(&self, index: GLuint, v: *const GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib2sv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib2sv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLshort)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib2sv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib2sv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib2sv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib2sv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib2sv\0");
      self.glVertexAttrib2sv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib2sv_is_loaded(&self) -> bool {
      !self.glVertexAttrib2sv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib3d](http://docs.gl/gl4/glVertexAttrib3d)(index, x, y, z)
    /// * vector equivalent: [`glVertexAttrib3dv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib3d(
      &self,
      index: GLuint,
      x: GLdouble,
      y: GLdouble,
      z: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib3d({:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z
        );
      }
      let p = self.glVertexAttrib3d_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, x, y, z),
        None => go_panic_because_fn_not_loaded("glVertexAttrib3d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib3d" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib3d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib3d_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib3d\0");
      self.glVertexAttrib3d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib3d_is_loaded(&self) -> bool {
      !self.glVertexAttrib3d_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib3dv](http://docs.gl/gl4/glVertexAttrib3dv)(index, v)
    /// * `v` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib3dv(&self, index: GLuint, v: *const GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib3dv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib3dv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib3dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib3dv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib3dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib3dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib3dv\0");
      self.glVertexAttrib3dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib3dv_is_loaded(&self) -> bool {
      !self.glVertexAttrib3dv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib3f](http://docs.gl/gl4/glVertexAttrib3f)(index, x, y, z)
    /// * vector equivalent: [`glVertexAttrib3fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib3f(
      &self,
      index: GLuint,
      x: GLfloat,
      y: GLfloat,
      z: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib3f({:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z
        );
      }
      let p = self.glVertexAttrib3f_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, x, y, z),
        None => go_panic_because_fn_not_loaded("glVertexAttrib3f"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib3f" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib3f", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib3f_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib3f\0");
      self.glVertexAttrib3f_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib3f_is_loaded(&self) -> bool {
      !self.glVertexAttrib3f_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib3fv](http://docs.gl/gl4/glVertexAttrib3fv)(index, v)
    /// * `v` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib3fv(&self, index: GLuint, v: *const GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib3fv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib3fv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib3fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib3fv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib3fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib3fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib3fv\0");
      self.glVertexAttrib3fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib3fv_is_loaded(&self) -> bool {
      !self.glVertexAttrib3fv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib3s](http://docs.gl/gl4/glVertexAttrib3s)(index, x, y, z)
    /// * vector equivalent: [`glVertexAttrib3sv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib3s(
      &self,
      index: GLuint,
      x: GLshort,
      y: GLshort,
      z: GLshort,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib3s({:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z
        );
      }
      let p = self.glVertexAttrib3s_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLshort, GLshort, GLshort)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, x, y, z),
        None => go_panic_because_fn_not_loaded("glVertexAttrib3s"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib3s" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib3s", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib3s_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib3s\0");
      self.glVertexAttrib3s_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib3s_is_loaded(&self) -> bool {
      !self.glVertexAttrib3s_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib3sv](http://docs.gl/gl4/glVertexAttrib3sv)(index, v)
    /// * `v` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib3sv(&self, index: GLuint, v: *const GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib3sv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib3sv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLshort)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib3sv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib3sv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib3sv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib3sv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib3sv\0");
      self.glVertexAttrib3sv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib3sv_is_loaded(&self) -> bool {
      !self.glVertexAttrib3sv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Nbv](http://docs.gl/gl4/glVertexAttrib4Nbv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Nbv(&self, index: GLuint, v: *const GLbyte) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4Nbv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4Nbv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLbyte)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4Nbv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4Nbv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4Nbv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4Nbv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4Nbv\0");
      self.glVertexAttrib4Nbv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Nbv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Nbv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Niv](http://docs.gl/gl4/glVertexAttrib4Niv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Niv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4Niv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4Niv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4Niv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4Niv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4Niv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4Niv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4Niv\0");
      self.glVertexAttrib4Niv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Niv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Niv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Nsv](http://docs.gl/gl4/glVertexAttrib4Nsv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Nsv(&self, index: GLuint, v: *const GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4Nsv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4Nsv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLshort)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4Nsv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4Nsv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4Nsv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4Nsv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4Nsv\0");
      self.glVertexAttrib4Nsv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Nsv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Nsv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Nub](http://docs.gl/gl4/glVertexAttrib4Nub)(index, x, y, z, w)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Nub(
      &self,
      index: GLuint,
      x: GLubyte,
      y: GLubyte,
      z: GLubyte,
      w: GLubyte,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib4Nub({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let p = self.glVertexAttrib4Nub_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLubyte, GLubyte, GLubyte, GLubyte)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, x, y, z, w),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4Nub"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4Nub" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4Nub", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4Nub_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4Nub\0");
      self.glVertexAttrib4Nub_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Nub_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Nub_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Nubv](http://docs.gl/gl4/glVertexAttrib4Nubv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Nubv(&self, index: GLuint, v: *const GLubyte) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4Nubv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4Nubv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLubyte)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4Nubv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4Nubv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4Nubv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4Nubv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4Nubv\0");
      self.glVertexAttrib4Nubv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Nubv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Nubv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Nuiv](http://docs.gl/gl4/glVertexAttrib4Nuiv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Nuiv(&self, index: GLuint, v: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4Nuiv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4Nuiv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4Nuiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4Nuiv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4Nuiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4Nuiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4Nuiv\0");
      self.glVertexAttrib4Nuiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Nuiv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Nuiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4Nusv](http://docs.gl/gl4/glVertexAttrib4Nusv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4Nusv(&self, index: GLuint, v: *const GLushort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4Nusv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4Nusv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLushort)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4Nusv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4Nusv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4Nusv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4Nusv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4Nusv\0");
      self.glVertexAttrib4Nusv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4Nusv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4Nusv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4bv](http://docs.gl/gl4/glVertexAttrib4bv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4bv(&self, index: GLuint, v: *const GLbyte) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4bv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4bv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLbyte)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4bv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4bv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4bv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4bv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4bv\0");
      self.glVertexAttrib4bv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4bv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4bv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4d](http://docs.gl/gl4/glVertexAttrib4d)(index, x, y, z, w)
    /// * vector equivalent: [`glVertexAttrib4dv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4d(
      &self,
      index: GLuint,
      x: GLdouble,
      y: GLdouble,
      z: GLdouble,
      w: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib4d({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let p = self.glVertexAttrib4d_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble, GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, x, y, z, w),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4d" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4d_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4d\0");
      self.glVertexAttrib4d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4d_is_loaded(&self) -> bool {
      !self.glVertexAttrib4d_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4dv](http://docs.gl/gl4/glVertexAttrib4dv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4dv(&self, index: GLuint, v: *const GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4dv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4dv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4dv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4dv\0");
      self.glVertexAttrib4dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4dv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4dv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4f](http://docs.gl/gl4/glVertexAttrib4f)(index, x, y, z, w)
    /// * vector equivalent: [`glVertexAttrib4fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4f(
      &self,
      index: GLuint,
      x: GLfloat,
      y: GLfloat,
      z: GLfloat,
      w: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib4f({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let p = self.glVertexAttrib4f_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat, GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, x, y, z, w),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4f"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4f" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4f", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4f_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4f\0");
      self.glVertexAttrib4f_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4f_is_loaded(&self) -> bool {
      !self.glVertexAttrib4f_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4fv](http://docs.gl/gl4/glVertexAttrib4fv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4fv(&self, index: GLuint, v: *const GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4fv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4fv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4fv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4fv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4fv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4fv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4fv\0");
      self.glVertexAttrib4fv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4fv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4fv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4iv](http://docs.gl/gl4/glVertexAttrib4iv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4iv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4iv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4iv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4iv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4iv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4iv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4iv\0");
      self.glVertexAttrib4iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4iv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4iv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4s](http://docs.gl/gl4/glVertexAttrib4s)(index, x, y, z, w)
    /// * vector equivalent: [`glVertexAttrib4sv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4s(
      &self,
      index: GLuint,
      x: GLshort,
      y: GLshort,
      z: GLshort,
      w: GLshort,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttrib4s({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let p = self.glVertexAttrib4s_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLshort, GLshort, GLshort, GLshort)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, x, y, z, w),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4s"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4s" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4s", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4s_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4s\0");
      self.glVertexAttrib4s_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4s_is_loaded(&self) -> bool {
      !self.glVertexAttrib4s_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4sv](http://docs.gl/gl4/glVertexAttrib4sv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4sv(&self, index: GLuint, v: *const GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4sv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4sv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLshort)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4sv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4sv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4sv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4sv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4sv\0");
      self.glVertexAttrib4sv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4sv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4sv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4ubv](http://docs.gl/gl4/glVertexAttrib4ubv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4ubv(&self, index: GLuint, v: *const GLubyte) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4ubv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4ubv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLubyte)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4ubv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4ubv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4ubv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4ubv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4ubv\0");
      self.glVertexAttrib4ubv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4ubv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4ubv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4uiv](http://docs.gl/gl4/glVertexAttrib4uiv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4uiv(&self, index: GLuint, v: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4uiv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4uiv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4uiv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4uiv\0");
      self.glVertexAttrib4uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4uiv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttrib4usv](http://docs.gl/gl4/glVertexAttrib4usv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttrib4usv(&self, index: GLuint, v: *const GLushort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttrib4usv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttrib4usv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLushort)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttrib4usv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttrib4usv" != "glGetError" {
          report_error_as_necessary_from("VertexAttrib4usv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttrib4usv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttrib4usv\0");
      self.glVertexAttrib4usv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttrib4usv_is_loaded(&self) -> bool {
      !self.glVertexAttrib4usv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribBinding](http://docs.gl/gl4/glVertexAttribBinding)(attribindex, bindingindex)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribBinding(
      &self,
      attribindex: GLuint,
      bindingindex: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribBinding({:?}, {:?});",
          attribindex,
          bindingindex
        );
      }
      let p = self.glVertexAttribBinding_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(attribindex, bindingindex),
        None => go_panic_because_fn_not_loaded("glVertexAttribBinding"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribBinding" != "glGetError" {
          report_error_as_necessary_from(
            "VertexAttribBinding",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribBinding_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribBinding\0");
      self.glVertexAttribBinding_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribBinding_is_loaded(&self) -> bool {
      !self.glVertexAttribBinding_p.load(RELAX).is_null()
    }
    /// [glVertexAttribDivisor](http://docs.gl/gl4/glVertexAttribDivisor)(index, divisor)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribDivisor(&self, index: GLuint, divisor: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribDivisor({:?}, {:?});", index, divisor);
      }
      let p = self.glVertexAttribDivisor_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(index, divisor),
        None => go_panic_because_fn_not_loaded("glVertexAttribDivisor"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribDivisor" != "glGetError" {
          report_error_as_necessary_from(
            "VertexAttribDivisor",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribDivisor_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribDivisor\0");
      self.glVertexAttribDivisor_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribDivisor_is_loaded(&self) -> bool {
      !self.glVertexAttribDivisor_p.load(RELAX).is_null()
    }
    /// [glVertexAttribFormat](http://docs.gl/gl4/glVertexAttribFormat)(attribindex, size, type_, normalized, relativeoffset)
    /// * `type_` group: VertexAttribType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribFormat(
      &self,
      attribindex: GLuint,
      size: GLint,
      type_: GLenum,
      normalized: GLboolean,
      relativeoffset: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribFormat({:?}, {:?}, {:#X}, {:?}, {:?});",
          attribindex,
          size,
          type_,
          normalized,
          relativeoffset
        );
      }
      let p = self.glVertexAttribFormat_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLenum, GLboolean, GLuint)>,
      >(p)
      {
        Some(fn_p) => {
          fn_p(attribindex, size, type_, normalized, relativeoffset)
        }
        None => go_panic_because_fn_not_loaded("glVertexAttribFormat"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribFormat" != "glGetError" {
          report_error_as_necessary_from("VertexAttribFormat", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribFormat_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribFormat\0");
      self.glVertexAttribFormat_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribFormat_is_loaded(&self) -> bool {
      !self.glVertexAttribFormat_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI1i](http://docs.gl/gl4/glVertexAttribI1i)(index, x)
    /// * vector equivalent: [`glVertexAttribI1iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI1i(&self, index: GLuint, x: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI1i({:?}, {:?});", index, x);
      }
      let p = self.glVertexAttribI1i_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLint)>>(p) {
        Some(fn_p) => fn_p(index, x),
        None => go_panic_because_fn_not_loaded("glVertexAttribI1i"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI1i" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI1i", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI1i_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI1i\0");
      self.glVertexAttribI1i_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI1i_is_loaded(&self) -> bool {
      !self.glVertexAttribI1i_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI1iv](http://docs.gl/gl4/glVertexAttribI1iv)(index, v)
    /// * `v` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI1iv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI1iv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribI1iv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribI1iv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI1iv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI1iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI1iv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI1iv\0");
      self.glVertexAttribI1iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI1iv_is_loaded(&self) -> bool {
      !self.glVertexAttribI1iv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI1ui](http://docs.gl/gl4/glVertexAttribI1ui)(index, x)
    /// * vector equivalent: [`glVertexAttribI1uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI1ui(&self, index: GLuint, x: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI1ui({:?}, {:?});", index, x);
      }
      let p = self.glVertexAttribI1ui_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(index, x),
        None => go_panic_because_fn_not_loaded("glVertexAttribI1ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI1ui" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI1ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI1ui_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI1ui\0");
      self.glVertexAttribI1ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI1ui_is_loaded(&self) -> bool {
      !self.glVertexAttribI1ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI1uiv](http://docs.gl/gl4/glVertexAttribI1uiv)(index, v)
    /// * `v` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI1uiv(&self, index: GLuint, v: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI1uiv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribI1uiv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribI1uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI1uiv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI1uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI1uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI1uiv\0");
      self.glVertexAttribI1uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI1uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribI1uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI2i](http://docs.gl/gl4/glVertexAttribI2i)(index, x, y)
    /// * vector equivalent: [`glVertexAttribI2iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI2i(&self, index: GLuint, x: GLint, y: GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI2i({:?}, {:?}, {:?});", index, x, y);
      }
      let p = self.glVertexAttribI2i_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLint, GLint)>>(p) {
        Some(fn_p) => fn_p(index, x, y),
        None => go_panic_because_fn_not_loaded("glVertexAttribI2i"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI2i" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI2i", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI2i_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI2i\0");
      self.glVertexAttribI2i_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI2i_is_loaded(&self) -> bool {
      !self.glVertexAttribI2i_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI2iv](http://docs.gl/gl4/glVertexAttribI2iv)(index, v)
    /// * `v` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI2iv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI2iv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribI2iv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribI2iv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI2iv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI2iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI2iv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI2iv\0");
      self.glVertexAttribI2iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI2iv_is_loaded(&self) -> bool {
      !self.glVertexAttribI2iv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI2ui](http://docs.gl/gl4/glVertexAttribI2ui)(index, x, y)
    /// * vector equivalent: [`glVertexAttribI2uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI2ui(&self, index: GLuint, x: GLuint, y: GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI2ui({:?}, {:?}, {:?});", index, x, y);
      }
      let p = self.glVertexAttribI2ui_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint)>>(p)
      {
        Some(fn_p) => fn_p(index, x, y),
        None => go_panic_because_fn_not_loaded("glVertexAttribI2ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI2ui" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI2ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI2ui_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI2ui\0");
      self.glVertexAttribI2ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI2ui_is_loaded(&self) -> bool {
      !self.glVertexAttribI2ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI2uiv](http://docs.gl/gl4/glVertexAttribI2uiv)(index, v)
    /// * `v` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI2uiv(&self, index: GLuint, v: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI2uiv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribI2uiv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribI2uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI2uiv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI2uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI2uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI2uiv\0");
      self.glVertexAttribI2uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI2uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribI2uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI3i](http://docs.gl/gl4/glVertexAttribI3i)(index, x, y, z)
    /// * vector equivalent: [`glVertexAttribI3iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI3i(
      &self,
      index: GLuint,
      x: GLint,
      y: GLint,
      z: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribI3i({:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z
        );
      }
      let p = self.glVertexAttribI3i_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLint, GLint, GLint)>>(p) {
          Some(fn_p) => fn_p(index, x, y, z),
          None => go_panic_because_fn_not_loaded("glVertexAttribI3i"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI3i" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI3i", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI3i_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI3i\0");
      self.glVertexAttribI3i_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI3i_is_loaded(&self) -> bool {
      !self.glVertexAttribI3i_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI3iv](http://docs.gl/gl4/glVertexAttribI3iv)(index, v)
    /// * `v` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI3iv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI3iv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribI3iv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribI3iv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI3iv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI3iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI3iv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI3iv\0");
      self.glVertexAttribI3iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI3iv_is_loaded(&self) -> bool {
      !self.glVertexAttribI3iv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI3ui](http://docs.gl/gl4/glVertexAttribI3ui)(index, x, y, z)
    /// * vector equivalent: [`glVertexAttribI3uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI3ui(
      &self,
      index: GLuint,
      x: GLuint,
      y: GLuint,
      z: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribI3ui({:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z
        );
      }
      let p = self.glVertexAttribI3ui_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLuint, GLuint, GLuint)>>(p)
        {
          Some(fn_p) => fn_p(index, x, y, z),
          None => go_panic_because_fn_not_loaded("glVertexAttribI3ui"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI3ui" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI3ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI3ui_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI3ui\0");
      self.glVertexAttribI3ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI3ui_is_loaded(&self) -> bool {
      !self.glVertexAttribI3ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI3uiv](http://docs.gl/gl4/glVertexAttribI3uiv)(index, v)
    /// * `v` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI3uiv(&self, index: GLuint, v: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI3uiv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribI3uiv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribI3uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI3uiv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI3uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI3uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI3uiv\0");
      self.glVertexAttribI3uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI3uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribI3uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4bv](http://docs.gl/gl4/glVertexAttribI4bv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4bv(&self, index: GLuint, v: *const GLbyte) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI4bv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribI4bv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLbyte)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribI4bv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI4bv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI4bv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI4bv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI4bv\0");
      self.glVertexAttribI4bv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4bv_is_loaded(&self) -> bool {
      !self.glVertexAttribI4bv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4i](http://docs.gl/gl4/glVertexAttribI4i)(index, x, y, z, w)
    /// * vector equivalent: [`glVertexAttribI4iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4i(
      &self,
      index: GLuint,
      x: GLint,
      y: GLint,
      z: GLint,
      w: GLint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribI4i({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let p = self.glVertexAttribI4i_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLint, GLint, GLint)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, x, y, z, w),
        None => go_panic_because_fn_not_loaded("glVertexAttribI4i"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI4i" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI4i", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI4i_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI4i\0");
      self.glVertexAttribI4i_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4i_is_loaded(&self) -> bool {
      !self.glVertexAttribI4i_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4iv](http://docs.gl/gl4/glVertexAttribI4iv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4iv(&self, index: GLuint, v: *const GLint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI4iv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribI4iv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribI4iv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI4iv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI4iv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI4iv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI4iv\0");
      self.glVertexAttribI4iv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4iv_is_loaded(&self) -> bool {
      !self.glVertexAttribI4iv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4sv](http://docs.gl/gl4/glVertexAttribI4sv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4sv(&self, index: GLuint, v: *const GLshort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI4sv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribI4sv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLshort)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribI4sv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI4sv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI4sv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI4sv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI4sv\0");
      self.glVertexAttribI4sv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4sv_is_loaded(&self) -> bool {
      !self.glVertexAttribI4sv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4ubv](http://docs.gl/gl4/glVertexAttribI4ubv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4ubv(&self, index: GLuint, v: *const GLubyte) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI4ubv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribI4ubv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLubyte)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribI4ubv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI4ubv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI4ubv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI4ubv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI4ubv\0");
      self.glVertexAttribI4ubv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4ubv_is_loaded(&self) -> bool {
      !self.glVertexAttribI4ubv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4ui](http://docs.gl/gl4/glVertexAttribI4ui)(index, x, y, z, w)
    /// * vector equivalent: [`glVertexAttribI4uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4ui(
      &self,
      index: GLuint,
      x: GLuint,
      y: GLuint,
      z: GLuint,
      w: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribI4ui({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let p = self.glVertexAttribI4ui_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLuint, GLuint, GLuint, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, x, y, z, w),
        None => go_panic_because_fn_not_loaded("glVertexAttribI4ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI4ui" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI4ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI4ui_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI4ui\0");
      self.glVertexAttribI4ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4ui_is_loaded(&self) -> bool {
      !self.glVertexAttribI4ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4uiv](http://docs.gl/gl4/glVertexAttribI4uiv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4uiv(&self, index: GLuint, v: *const GLuint) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI4uiv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribI4uiv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLuint)>>(p) {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribI4uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI4uiv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI4uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI4uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI4uiv\0");
      self.glVertexAttribI4uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribI4uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribI4usv](http://docs.gl/gl4/glVertexAttribI4usv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribI4usv(&self, index: GLuint, v: *const GLushort) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribI4usv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribI4usv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLushort)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribI4usv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribI4usv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribI4usv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribI4usv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribI4usv\0");
      self.glVertexAttribI4usv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribI4usv_is_loaded(&self) -> bool {
      !self.glVertexAttribI4usv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribIFormat](http://docs.gl/gl4/glVertexAttribIFormat)(attribindex, size, type_, relativeoffset)
    /// * `type_` group: VertexAttribIType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribIFormat(
      &self,
      attribindex: GLuint,
      size: GLint,
      type_: GLenum,
      relativeoffset: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribIFormat({:?}, {:?}, {:#X}, {:?});",
          attribindex,
          size,
          type_,
          relativeoffset
        );
      }
      let p = self.glVertexAttribIFormat_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLenum, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(attribindex, size, type_, relativeoffset),
        None => go_panic_because_fn_not_loaded("glVertexAttribIFormat"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribIFormat" != "glGetError" {
          report_error_as_necessary_from(
            "VertexAttribIFormat",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribIFormat_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribIFormat\0");
      self.glVertexAttribIFormat_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribIFormat_is_loaded(&self) -> bool {
      !self.glVertexAttribIFormat_p.load(RELAX).is_null()
    }
    /// [glVertexAttribIPointer](http://docs.gl/gl4/glVertexAttribIPointer)(index, size, type_, stride, pointer)
    /// * `type_` group: VertexAttribIType
    /// * `pointer` len: COMPSIZE(size,type,stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribIPointer(
      &self,
      index: GLuint,
      size: GLint,
      type_: GLenum,
      stride: GLsizei,
      pointer: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribIPointer({:?}, {:?}, {:#X}, {:?}, {:p});",
          index,
          size,
          type_,
          stride,
          pointer
        );
      }
      let p = self.glVertexAttribIPointer_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLenum, GLsizei, *const c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, size, type_, stride, pointer),
        None => go_panic_because_fn_not_loaded("glVertexAttribIPointer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribIPointer" != "glGetError" {
          report_error_as_necessary_from(
            "VertexAttribIPointer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribIPointer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribIPointer\0");
      self.glVertexAttribIPointer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribIPointer_is_loaded(&self) -> bool {
      !self.glVertexAttribIPointer_p.load(RELAX).is_null()
    }
    /// [glVertexAttribL1d](http://docs.gl/gl4/glVertexAttribL1d)(index, x)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribL1d(&self, index: GLuint, x: GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribL1d({:?}, {:?});", index, x);
      }
      let p = self.glVertexAttribL1d_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLdouble)>>(p) {
        Some(fn_p) => fn_p(index, x),
        None => go_panic_because_fn_not_loaded("glVertexAttribL1d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribL1d" != "glGetError" {
          report_error_as_necessary_from("VertexAttribL1d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribL1d_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribL1d\0");
      self.glVertexAttribL1d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribL1d_is_loaded(&self) -> bool {
      !self.glVertexAttribL1d_p.load(RELAX).is_null()
    }
    /// [glVertexAttribL1dv](http://docs.gl/gl4/glVertexAttribL1dv)(index, v)
    /// * `v` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribL1dv(&self, index: GLuint, v: *const GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribL1dv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribL1dv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribL1dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribL1dv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribL1dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribL1dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribL1dv\0");
      self.glVertexAttribL1dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribL1dv_is_loaded(&self) -> bool {
      !self.glVertexAttribL1dv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribL2d](http://docs.gl/gl4/glVertexAttribL2d)(index, x, y)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribL2d(
      &self,
      index: GLuint,
      x: GLdouble,
      y: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribL2d({:?}, {:?}, {:?});", index, x, y);
      }
      let p = self.glVertexAttribL2d_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLuint, GLdouble, GLdouble)>>(p) {
          Some(fn_p) => fn_p(index, x, y),
          None => go_panic_because_fn_not_loaded("glVertexAttribL2d"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribL2d" != "glGetError" {
          report_error_as_necessary_from("VertexAttribL2d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribL2d_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribL2d\0");
      self.glVertexAttribL2d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribL2d_is_loaded(&self) -> bool {
      !self.glVertexAttribL2d_p.load(RELAX).is_null()
    }
    /// [glVertexAttribL2dv](http://docs.gl/gl4/glVertexAttribL2dv)(index, v)
    /// * `v` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribL2dv(&self, index: GLuint, v: *const GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribL2dv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribL2dv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribL2dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribL2dv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribL2dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribL2dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribL2dv\0");
      self.glVertexAttribL2dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribL2dv_is_loaded(&self) -> bool {
      !self.glVertexAttribL2dv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribL3d](http://docs.gl/gl4/glVertexAttribL3d)(index, x, y, z)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribL3d(
      &self,
      index: GLuint,
      x: GLdouble,
      y: GLdouble,
      z: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribL3d({:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z
        );
      }
      let p = self.glVertexAttribL3d_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, x, y, z),
        None => go_panic_because_fn_not_loaded("glVertexAttribL3d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribL3d" != "glGetError" {
          report_error_as_necessary_from("VertexAttribL3d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribL3d_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribL3d\0");
      self.glVertexAttribL3d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribL3d_is_loaded(&self) -> bool {
      !self.glVertexAttribL3d_p.load(RELAX).is_null()
    }
    /// [glVertexAttribL3dv](http://docs.gl/gl4/glVertexAttribL3dv)(index, v)
    /// * `v` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribL3dv(&self, index: GLuint, v: *const GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribL3dv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribL3dv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribL3dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribL3dv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribL3dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribL3dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribL3dv\0");
      self.glVertexAttribL3dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribL3dv_is_loaded(&self) -> bool {
      !self.glVertexAttribL3dv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribL4d](http://docs.gl/gl4/glVertexAttribL4d)(index, x, y, z, w)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribL4d(
      &self,
      index: GLuint,
      x: GLdouble,
      y: GLdouble,
      z: GLdouble,
      w: GLdouble,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribL4d({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          z,
          w
        );
      }
      let p = self.glVertexAttribL4d_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble, GLdouble)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, x, y, z, w),
        None => go_panic_because_fn_not_loaded("glVertexAttribL4d"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribL4d" != "glGetError" {
          report_error_as_necessary_from("VertexAttribL4d", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribL4d_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribL4d\0");
      self.glVertexAttribL4d_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribL4d_is_loaded(&self) -> bool {
      !self.glVertexAttribL4d_p.load(RELAX).is_null()
    }
    /// [glVertexAttribL4dv](http://docs.gl/gl4/glVertexAttribL4dv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribL4dv(&self, index: GLuint, v: *const GLdouble) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribL4dv({:?}, {:p});", index, v);
      }
      let p = self.glVertexAttribL4dv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLdouble)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glVertexAttribL4dv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribL4dv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribL4dv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribL4dv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribL4dv\0");
      self.glVertexAttribL4dv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribL4dv_is_loaded(&self) -> bool {
      !self.glVertexAttribL4dv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribLFormat](http://docs.gl/gl4/glVertexAttribLFormat)(attribindex, size, type_, relativeoffset)
    /// * `type_` group: VertexAttribLType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribLFormat(
      &self,
      attribindex: GLuint,
      size: GLint,
      type_: GLenum,
      relativeoffset: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribLFormat({:?}, {:?}, {:#X}, {:?});",
          attribindex,
          size,
          type_,
          relativeoffset
        );
      }
      let p = self.glVertexAttribLFormat_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLenum, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(attribindex, size, type_, relativeoffset),
        None => go_panic_because_fn_not_loaded("glVertexAttribLFormat"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribLFormat" != "glGetError" {
          report_error_as_necessary_from(
            "VertexAttribLFormat",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribLFormat_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribLFormat\0");
      self.glVertexAttribLFormat_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribLFormat_is_loaded(&self) -> bool {
      !self.glVertexAttribLFormat_p.load(RELAX).is_null()
    }
    /// [glVertexAttribLPointer](http://docs.gl/gl4/glVertexAttribLPointer)(index, size, type_, stride, pointer)
    /// * `type_` group: VertexAttribLType
    /// * `pointer` len: size
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribLPointer(
      &self,
      index: GLuint,
      size: GLint,
      type_: GLenum,
      stride: GLsizei,
      pointer: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribLPointer({:?}, {:?}, {:#X}, {:?}, {:p});",
          index,
          size,
          type_,
          stride,
          pointer
        );
      }
      let p = self.glVertexAttribLPointer_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLint, GLenum, GLsizei, *const c_void)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, size, type_, stride, pointer),
        None => go_panic_because_fn_not_loaded("glVertexAttribLPointer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribLPointer" != "glGetError" {
          report_error_as_necessary_from(
            "VertexAttribLPointer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribLPointer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribLPointer\0");
      self.glVertexAttribLPointer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribLPointer_is_loaded(&self) -> bool {
      !self.glVertexAttribLPointer_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP1ui](http://docs.gl/gl4/glVertexAttribP1ui)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP1ui(
      &self,
      index: GLuint,
      type_: GLenum,
      normalized: GLboolean,
      value: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP1ui({:?}, {:#X}, {:?}, {:?});",
          index,
          type_,
          normalized,
          value
        );
      }
      let p = self.glVertexAttribP1ui_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLboolean, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, type_, normalized, value),
        None => go_panic_because_fn_not_loaded("glVertexAttribP1ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribP1ui" != "glGetError" {
          report_error_as_necessary_from("VertexAttribP1ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribP1ui_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribP1ui\0");
      self.glVertexAttribP1ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP1ui_is_loaded(&self) -> bool {
      !self.glVertexAttribP1ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP1uiv](http://docs.gl/gl4/glVertexAttribP1uiv)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    /// * `value` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP1uiv(
      &self,
      index: GLuint,
      type_: GLenum,
      normalized: GLboolean,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP1uiv({:?}, {:#X}, {:?}, {:p});",
          index,
          type_,
          normalized,
          value
        );
      }
      let p = self.glVertexAttribP1uiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, type_, normalized, value),
        None => go_panic_because_fn_not_loaded("glVertexAttribP1uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribP1uiv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribP1uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribP1uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribP1uiv\0");
      self.glVertexAttribP1uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP1uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribP1uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP2ui](http://docs.gl/gl4/glVertexAttribP2ui)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP2ui(
      &self,
      index: GLuint,
      type_: GLenum,
      normalized: GLboolean,
      value: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP2ui({:?}, {:#X}, {:?}, {:?});",
          index,
          type_,
          normalized,
          value
        );
      }
      let p = self.glVertexAttribP2ui_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLboolean, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, type_, normalized, value),
        None => go_panic_because_fn_not_loaded("glVertexAttribP2ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribP2ui" != "glGetError" {
          report_error_as_necessary_from("VertexAttribP2ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribP2ui_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribP2ui\0");
      self.glVertexAttribP2ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP2ui_is_loaded(&self) -> bool {
      !self.glVertexAttribP2ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP2uiv](http://docs.gl/gl4/glVertexAttribP2uiv)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    /// * `value` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP2uiv(
      &self,
      index: GLuint,
      type_: GLenum,
      normalized: GLboolean,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP2uiv({:?}, {:#X}, {:?}, {:p});",
          index,
          type_,
          normalized,
          value
        );
      }
      let p = self.glVertexAttribP2uiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, type_, normalized, value),
        None => go_panic_because_fn_not_loaded("glVertexAttribP2uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribP2uiv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribP2uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribP2uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribP2uiv\0");
      self.glVertexAttribP2uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP2uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribP2uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP3ui](http://docs.gl/gl4/glVertexAttribP3ui)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP3ui(
      &self,
      index: GLuint,
      type_: GLenum,
      normalized: GLboolean,
      value: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP3ui({:?}, {:#X}, {:?}, {:?});",
          index,
          type_,
          normalized,
          value
        );
      }
      let p = self.glVertexAttribP3ui_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLboolean, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, type_, normalized, value),
        None => go_panic_because_fn_not_loaded("glVertexAttribP3ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribP3ui" != "glGetError" {
          report_error_as_necessary_from("VertexAttribP3ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribP3ui_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribP3ui\0");
      self.glVertexAttribP3ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP3ui_is_loaded(&self) -> bool {
      !self.glVertexAttribP3ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP3uiv](http://docs.gl/gl4/glVertexAttribP3uiv)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    /// * `value` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP3uiv(
      &self,
      index: GLuint,
      type_: GLenum,
      normalized: GLboolean,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP3uiv({:?}, {:#X}, {:?}, {:p});",
          index,
          type_,
          normalized,
          value
        );
      }
      let p = self.glVertexAttribP3uiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, type_, normalized, value),
        None => go_panic_because_fn_not_loaded("glVertexAttribP3uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribP3uiv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribP3uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribP3uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribP3uiv\0");
      self.glVertexAttribP3uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP3uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribP3uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP4ui](http://docs.gl/gl4/glVertexAttribP4ui)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP4ui(
      &self,
      index: GLuint,
      type_: GLenum,
      normalized: GLboolean,
      value: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP4ui({:?}, {:#X}, {:?}, {:?});",
          index,
          type_,
          normalized,
          value
        );
      }
      let p = self.glVertexAttribP4ui_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLboolean, GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, type_, normalized, value),
        None => go_panic_because_fn_not_loaded("glVertexAttribP4ui"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribP4ui" != "glGetError" {
          report_error_as_necessary_from("VertexAttribP4ui", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribP4ui_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribP4ui\0");
      self.glVertexAttribP4ui_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP4ui_is_loaded(&self) -> bool {
      !self.glVertexAttribP4ui_p.load(RELAX).is_null()
    }
    /// [glVertexAttribP4uiv](http://docs.gl/gl4/glVertexAttribP4uiv)(index, type_, normalized, value)
    /// * `type_` group: VertexAttribPointerType
    /// * `value` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribP4uiv(
      &self,
      index: GLuint,
      type_: GLenum,
      normalized: GLboolean,
      value: *const GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexAttribP4uiv({:?}, {:#X}, {:?}, {:p});",
          index,
          type_,
          normalized,
          value
        );
      }
      let p = self.glVertexAttribP4uiv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, type_, normalized, value),
        None => go_panic_because_fn_not_loaded("glVertexAttribP4uiv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribP4uiv" != "glGetError" {
          report_error_as_necessary_from("VertexAttribP4uiv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribP4uiv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribP4uiv\0");
      self.glVertexAttribP4uiv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribP4uiv_is_loaded(&self) -> bool {
      !self.glVertexAttribP4uiv_p.load(RELAX).is_null()
    }
    /// [glVertexAttribPointer](http://docs.gl/gl4/glVertexAttribPointer)(index, size, type_, normalized, stride, pointer)
    /// * `type_` group: VertexAttribPointerType
    /// * `pointer` len: COMPSIZE(size,type,stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexAttribPointer(
      &self,
      index: GLuint,
      size: GLint,
      type_: GLenum,
      normalized: GLboolean,
      stride: GLsizei,
      pointer: *const c_void,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.VertexAttribPointer({:?}, {:?}, {:#X}, {:?}, {:?}, {:p});", index, size, type_, normalized, stride, pointer);
      }
      let p = self.glVertexAttribPointer_p.load(RELAX);
      let out = match t_::<
        _,
        O<
          extern "system" fn(
            GLuint,
            GLint,
            GLenum,
            GLboolean,
            GLsizei,
            *const c_void,
          ),
        >,
      >(p)
      {
        Some(fn_p) => fn_p(index, size, type_, normalized, stride, pointer),
        None => go_panic_because_fn_not_loaded("glVertexAttribPointer"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexAttribPointer" != "glGetError" {
          report_error_as_necessary_from(
            "VertexAttribPointer",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexAttribPointer_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexAttribPointer\0");
      self.glVertexAttribPointer_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexAttribPointer_is_loaded(&self) -> bool {
      !self.glVertexAttribPointer_p.load(RELAX).is_null()
    }
    /// [glVertexBindingDivisor](http://docs.gl/gl4/glVertexBindingDivisor)(bindingindex, divisor)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn VertexBindingDivisor(
      &self,
      bindingindex: GLuint,
      divisor: GLuint,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.VertexBindingDivisor({:?}, {:?});",
          bindingindex,
          divisor
        );
      }
      let p = self.glVertexBindingDivisor_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, GLuint)>>(p) {
        Some(fn_p) => fn_p(bindingindex, divisor),
        None => go_panic_because_fn_not_loaded("glVertexBindingDivisor"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glVertexBindingDivisor" != "glGetError" {
          report_error_as_necessary_from(
            "VertexBindingDivisor",
            self.GetError(),
          );
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn VertexBindingDivisor_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glVertexBindingDivisor\0");
      self.glVertexBindingDivisor_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn VertexBindingDivisor_is_loaded(&self) -> bool {
      !self.glVertexBindingDivisor_p.load(RELAX).is_null()
    }
    /// [glViewport](http://docs.gl/gl4/glViewport)(x, y, width, height)
    /// * `x` group: WinCoord
    /// * `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn Viewport(
      &self,
      x: GLint,
      y: GLint,
      width: GLsizei,
      height: GLsizei,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.Viewport({:?}, {:?}, {:?}, {:?});",
          x,
          y,
          width,
          height
        );
      }
      let p = self.glViewport_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLint, GLint, GLsizei, GLsizei)>>(p)
        {
          Some(fn_p) => fn_p(x, y, width, height),
          None => go_panic_because_fn_not_loaded("glViewport"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glViewport" != "glGetError" {
          report_error_as_necessary_from("Viewport", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn Viewport_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glViewport\0");
      self.glViewport_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn Viewport_is_loaded(&self) -> bool {
      !self.glViewport_p.load(RELAX).is_null()
    }
    /// [glViewportArrayv](http://docs.gl/gl4/glViewportArrayv)(first, count, v)
    /// * `v` len: COMPSIZE(count)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ViewportArrayv(
      &self,
      first: GLuint,
      count: GLsizei,
      v: *const GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ViewportArrayv({:?}, {:?}, {:p});", first, count, v);
      }
      let p = self.glViewportArrayv_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLsizei, *const GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(first, count, v),
        None => go_panic_because_fn_not_loaded("glViewportArrayv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glViewportArrayv" != "glGetError" {
          report_error_as_necessary_from("ViewportArrayv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ViewportArrayv_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glViewportArrayv\0");
      self.glViewportArrayv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ViewportArrayv_is_loaded(&self) -> bool {
      !self.glViewportArrayv_p.load(RELAX).is_null()
    }
    /// [glViewportIndexedf](http://docs.gl/gl4/glViewportIndexedf)(index, x, y, w, h)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ViewportIndexedf(
      &self,
      index: GLuint,
      x: GLfloat,
      y: GLfloat,
      w: GLfloat,
      h: GLfloat,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!(
          "calling gl.ViewportIndexedf({:?}, {:?}, {:?}, {:?}, {:?});",
          index,
          x,
          y,
          w,
          h
        );
      }
      let p = self.glViewportIndexedf_p.load(RELAX);
      let out = match t_::<
        _,
        O<extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat, GLfloat)>,
      >(p)
      {
        Some(fn_p) => fn_p(index, x, y, w, h),
        None => go_panic_because_fn_not_loaded("glViewportIndexedf"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glViewportIndexedf" != "glGetError" {
          report_error_as_necessary_from("ViewportIndexedf", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ViewportIndexedf_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glViewportIndexedf\0");
      self.glViewportIndexedf_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ViewportIndexedf_is_loaded(&self) -> bool {
      !self.glViewportIndexedf_p.load(RELAX).is_null()
    }
    /// [glViewportIndexedfv](http://docs.gl/gl4/glViewportIndexedfv)(index, v)
    /// * `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn ViewportIndexedfv(&self, index: GLuint, v: *const GLfloat) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.ViewportIndexedfv({:?}, {:p});", index, v);
      }
      let p = self.glViewportIndexedfv_p.load(RELAX);
      let out = match t_::<_, O<extern "system" fn(GLuint, *const GLfloat)>>(p)
      {
        Some(fn_p) => fn_p(index, v),
        None => go_panic_because_fn_not_loaded("glViewportIndexedfv"),
      };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glViewportIndexedfv" != "glGetError" {
          report_error_as_necessary_from("ViewportIndexedfv", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn ViewportIndexedfv_load_with(
      &self,
      get_proc_address: &mut GPA,
    ) -> bool {
      let p = do_the_load(get_proc_address, b"glViewportIndexedfv\0");
      self.glViewportIndexedfv_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn ViewportIndexedfv_is_loaded(&self) -> bool {
      !self.glViewportIndexedfv_p.load(RELAX).is_null()
    }
    /// [glWaitSync](http://docs.gl/gl4/glWaitSync)(sync, flags, timeout)
    /// * `sync` group: sync
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn WaitSync(
      &self,
      sync: GLsync,
      flags: GLbitfield,
      timeout: GLuint64,
    ) {
      #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
      {
        trace!("calling gl.WaitSync({:p}, {:?}, {:?});", sync, flags, timeout);
      }
      let p = self.glWaitSync_p.load(RELAX);
      let out =
        match t_::<_, O<extern "system" fn(GLsync, GLbitfield, GLuint64)>>(p) {
          Some(fn_p) => fn_p(sync, flags, timeout),
          None => go_panic_because_fn_not_loaded("glWaitSync"),
        };
      #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
      {
        if "glWaitSync" != "glGetError" {
          report_error_as_necessary_from("WaitSync", self.GetError());
        }
      }
      out
    }
    #[doc(hidden)]
    pub fn WaitSync_load_with(&self, get_proc_address: &mut GPA) -> bool {
      let p = do_the_load(get_proc_address, b"glWaitSync\0");
      self.glWaitSync_p.store(p, RELAX);
      !p.is_null()
    }
    #[inline]
    #[doc(hidden)]
    pub fn WaitSync_is_loaded(&self) -> bool {
      !self.glWaitSync_p.load(RELAX).is_null()
    }
  }
  /// This holds the many, many function pointers for GL.
  ///
  /// It's typically quite large (hundreds of pointers), depending on what API
  /// level and extensions you selected during the generation.
  #[repr(C)]
  pub struct GlFns {
    glActiveShaderProgram_p: APcv,
    glActiveTexture_p: APcv,
    glAttachShader_p: APcv,
    glBeginConditionalRender_p: APcv,
    glBeginQuery_p: APcv,
    glBeginQueryIndexed_p: APcv,
    glBeginTransformFeedback_p: APcv,
    glBindAttribLocation_p: APcv,
    glBindBuffer_p: APcv,
    glBindBufferBase_p: APcv,
    glBindBufferRange_p: APcv,
    glBindBuffersBase_p: APcv,
    glBindBuffersRange_p: APcv,
    glBindFragDataLocation_p: APcv,
    glBindFragDataLocationIndexed_p: APcv,
    glBindFramebuffer_p: APcv,
    glBindImageTexture_p: APcv,
    glBindImageTextures_p: APcv,
    glBindProgramPipeline_p: APcv,
    glBindRenderbuffer_p: APcv,
    glBindSampler_p: APcv,
    glBindSamplers_p: APcv,
    glBindTexture_p: APcv,
    glBindTextureUnit_p: APcv,
    glBindTextures_p: APcv,
    glBindTransformFeedback_p: APcv,
    glBindVertexArray_p: APcv,
    glBindVertexBuffer_p: APcv,
    glBindVertexBuffers_p: APcv,
    glBlendColor_p: APcv,
    glBlendEquation_p: APcv,
    glBlendEquationSeparate_p: APcv,
    glBlendEquationSeparatei_p: APcv,
    glBlendEquationSeparateiARB_p: APcv,
    glBlendEquationi_p: APcv,
    glBlendEquationiARB_p: APcv,
    glBlendFunc_p: APcv,
    glBlendFuncSeparate_p: APcv,
    glBlendFuncSeparatei_p: APcv,
    glBlendFuncSeparateiARB_p: APcv,
    glBlendFunci_p: APcv,
    glBlendFunciARB_p: APcv,
    glBlitFramebuffer_p: APcv,
    glBlitNamedFramebuffer_p: APcv,
    glBufferData_p: APcv,
    glBufferStorage_p: APcv,
    glBufferSubData_p: APcv,
    glCheckFramebufferStatus_p: APcv,
    glCheckNamedFramebufferStatus_p: APcv,
    glClampColor_p: APcv,
    glClear_p: APcv,
    glClearBufferData_p: APcv,
    glClearBufferSubData_p: APcv,
    glClearBufferfi_p: APcv,
    glClearBufferfv_p: APcv,
    glClearBufferiv_p: APcv,
    glClearBufferuiv_p: APcv,
    glClearColor_p: APcv,
    glClearDepth_p: APcv,
    glClearDepthf_p: APcv,
    glClearNamedBufferData_p: APcv,
    glClearNamedBufferSubData_p: APcv,
    glClearNamedFramebufferfi_p: APcv,
    glClearNamedFramebufferfv_p: APcv,
    glClearNamedFramebufferiv_p: APcv,
    glClearNamedFramebufferuiv_p: APcv,
    glClearStencil_p: APcv,
    glClearTexImage_p: APcv,
    glClearTexSubImage_p: APcv,
    glClientWaitSync_p: APcv,
    glClipControl_p: APcv,
    glColorMask_p: APcv,
    glColorMaski_p: APcv,
    glCompileShader_p: APcv,
    glCompressedTexImage1D_p: APcv,
    glCompressedTexImage2D_p: APcv,
    glCompressedTexImage3D_p: APcv,
    glCompressedTexSubImage1D_p: APcv,
    glCompressedTexSubImage2D_p: APcv,
    glCompressedTexSubImage3D_p: APcv,
    glCompressedTextureSubImage1D_p: APcv,
    glCompressedTextureSubImage2D_p: APcv,
    glCompressedTextureSubImage3D_p: APcv,
    glCopyBufferSubData_p: APcv,
    glCopyImageSubData_p: APcv,
    glCopyNamedBufferSubData_p: APcv,
    glCopyTexImage1D_p: APcv,
    glCopyTexImage2D_p: APcv,
    glCopyTexSubImage1D_p: APcv,
    glCopyTexSubImage2D_p: APcv,
    glCopyTexSubImage3D_p: APcv,
    glCopyTextureSubImage1D_p: APcv,
    glCopyTextureSubImage2D_p: APcv,
    glCopyTextureSubImage3D_p: APcv,
    glCreateBuffers_p: APcv,
    glCreateFramebuffers_p: APcv,
    glCreateProgram_p: APcv,
    glCreateProgramPipelines_p: APcv,
    glCreateQueries_p: APcv,
    glCreateRenderbuffers_p: APcv,
    glCreateSamplers_p: APcv,
    glCreateShader_p: APcv,
    glCreateShaderProgramv_p: APcv,
    glCreateTextures_p: APcv,
    glCreateTransformFeedbacks_p: APcv,
    glCreateVertexArrays_p: APcv,
    glCullFace_p: APcv,
    glDebugMessageCallback_p: APcv,
    glDebugMessageControl_p: APcv,
    glDebugMessageInsert_p: APcv,
    glDeleteBuffers_p: APcv,
    glDeleteFramebuffers_p: APcv,
    glDeleteProgram_p: APcv,
    glDeleteProgramPipelines_p: APcv,
    glDeleteQueries_p: APcv,
    glDeleteRenderbuffers_p: APcv,
    glDeleteSamplers_p: APcv,
    glDeleteShader_p: APcv,
    glDeleteSync_p: APcv,
    glDeleteTextures_p: APcv,
    glDeleteTransformFeedbacks_p: APcv,
    glDeleteVertexArrays_p: APcv,
    glDepthFunc_p: APcv,
    glDepthMask_p: APcv,
    glDepthRange_p: APcv,
    glDepthRangeArrayv_p: APcv,
    glDepthRangeIndexed_p: APcv,
    glDepthRangef_p: APcv,
    glDetachShader_p: APcv,
    glDisable_p: APcv,
    glDisableVertexArrayAttrib_p: APcv,
    glDisableVertexAttribArray_p: APcv,
    glDisablei_p: APcv,
    glDispatchCompute_p: APcv,
    glDispatchComputeIndirect_p: APcv,
    glDrawArrays_p: APcv,
    glDrawArraysIndirect_p: APcv,
    glDrawArraysInstanced_p: APcv,
    glDrawArraysInstancedBaseInstance_p: APcv,
    glDrawBuffer_p: APcv,
    glDrawBuffers_p: APcv,
    glDrawElements_p: APcv,
    glDrawElementsBaseVertex_p: APcv,
    glDrawElementsIndirect_p: APcv,
    glDrawElementsInstanced_p: APcv,
    glDrawElementsInstancedBaseInstance_p: APcv,
    glDrawElementsInstancedBaseVertex_p: APcv,
    glDrawElementsInstancedBaseVertexBaseInstance_p: APcv,
    glDrawRangeElements_p: APcv,
    glDrawRangeElementsBaseVertex_p: APcv,
    glDrawTransformFeedback_p: APcv,
    glDrawTransformFeedbackInstanced_p: APcv,
    glDrawTransformFeedbackStream_p: APcv,
    glDrawTransformFeedbackStreamInstanced_p: APcv,
    glEnable_p: APcv,
    glEnableVertexArrayAttrib_p: APcv,
    glEnableVertexAttribArray_p: APcv,
    glEnablei_p: APcv,
    glEndConditionalRender_p: APcv,
    glEndQuery_p: APcv,
    glEndQueryIndexed_p: APcv,
    glEndTransformFeedback_p: APcv,
    glFenceSync_p: APcv,
    glFinish_p: APcv,
    glFlush_p: APcv,
    glFlushMappedBufferRange_p: APcv,
    glFlushMappedNamedBufferRange_p: APcv,
    glFramebufferParameteri_p: APcv,
    glFramebufferRenderbuffer_p: APcv,
    glFramebufferTexture_p: APcv,
    glFramebufferTexture1D_p: APcv,
    glFramebufferTexture2D_p: APcv,
    glFramebufferTexture3D_p: APcv,
    glFramebufferTextureLayer_p: APcv,
    glFrontFace_p: APcv,
    glGenBuffers_p: APcv,
    glGenFramebuffers_p: APcv,
    glGenProgramPipelines_p: APcv,
    glGenQueries_p: APcv,
    glGenRenderbuffers_p: APcv,
    glGenSamplers_p: APcv,
    glGenTextures_p: APcv,
    glGenTransformFeedbacks_p: APcv,
    glGenVertexArrays_p: APcv,
    glGenerateMipmap_p: APcv,
    glGenerateTextureMipmap_p: APcv,
    glGetActiveAtomicCounterBufferiv_p: APcv,
    glGetActiveAttrib_p: APcv,
    glGetActiveSubroutineName_p: APcv,
    glGetActiveSubroutineUniformName_p: APcv,
    glGetActiveSubroutineUniformiv_p: APcv,
    glGetActiveUniform_p: APcv,
    glGetActiveUniformBlockName_p: APcv,
    glGetActiveUniformBlockiv_p: APcv,
    glGetActiveUniformName_p: APcv,
    glGetActiveUniformsiv_p: APcv,
    glGetAttachedShaders_p: APcv,
    glGetAttribLocation_p: APcv,
    glGetBooleani_v_p: APcv,
    glGetBooleanv_p: APcv,
    glGetBufferParameteri64v_p: APcv,
    glGetBufferParameteriv_p: APcv,
    glGetBufferPointerv_p: APcv,
    glGetBufferSubData_p: APcv,
    glGetCompressedTexImage_p: APcv,
    glGetCompressedTextureImage_p: APcv,
    glGetCompressedTextureSubImage_p: APcv,
    glGetDebugMessageLog_p: APcv,
    glGetDoublei_v_p: APcv,
    glGetDoublev_p: APcv,
    glGetError_p: APcv,
    glGetFloati_v_p: APcv,
    glGetFloatv_p: APcv,
    glGetFragDataIndex_p: APcv,
    glGetFragDataLocation_p: APcv,
    glGetFramebufferAttachmentParameteriv_p: APcv,
    glGetFramebufferParameteriv_p: APcv,
    glGetGraphicsResetStatus_p: APcv,
    glGetInteger64i_v_p: APcv,
    glGetInteger64v_p: APcv,
    glGetIntegeri_v_p: APcv,
    glGetIntegerv_p: APcv,
    glGetInternalformati64v_p: APcv,
    glGetInternalformativ_p: APcv,
    glGetMultisamplefv_p: APcv,
    glGetNamedBufferParameteri64v_p: APcv,
    glGetNamedBufferParameteriv_p: APcv,
    glGetNamedBufferPointerv_p: APcv,
    glGetNamedBufferSubData_p: APcv,
    glGetNamedFramebufferAttachmentParameteriv_p: APcv,
    glGetNamedFramebufferParameteriv_p: APcv,
    glGetNamedRenderbufferParameteriv_p: APcv,
    glGetObjectLabel_p: APcv,
    glGetObjectPtrLabel_p: APcv,
    glGetPointerv_p: APcv,
    glGetProgramBinary_p: APcv,
    glGetProgramInfoLog_p: APcv,
    glGetProgramInterfaceiv_p: APcv,
    glGetProgramPipelineInfoLog_p: APcv,
    glGetProgramPipelineiv_p: APcv,
    glGetProgramResourceIndex_p: APcv,
    glGetProgramResourceLocation_p: APcv,
    glGetProgramResourceLocationIndex_p: APcv,
    glGetProgramResourceName_p: APcv,
    glGetProgramResourceiv_p: APcv,
    glGetProgramStageiv_p: APcv,
    glGetProgramiv_p: APcv,
    glGetQueryBufferObjecti64v_p: APcv,
    glGetQueryBufferObjectiv_p: APcv,
    glGetQueryBufferObjectui64v_p: APcv,
    glGetQueryBufferObjectuiv_p: APcv,
    glGetQueryIndexediv_p: APcv,
    glGetQueryObjecti64v_p: APcv,
    glGetQueryObjectiv_p: APcv,
    glGetQueryObjectui64v_p: APcv,
    glGetQueryObjectuiv_p: APcv,
    glGetQueryiv_p: APcv,
    glGetRenderbufferParameteriv_p: APcv,
    glGetSamplerParameterIiv_p: APcv,
    glGetSamplerParameterIuiv_p: APcv,
    glGetSamplerParameterfv_p: APcv,
    glGetSamplerParameteriv_p: APcv,
    glGetShaderInfoLog_p: APcv,
    glGetShaderPrecisionFormat_p: APcv,
    glGetShaderSource_p: APcv,
    glGetShaderiv_p: APcv,
    glGetString_p: APcv,
    glGetStringi_p: APcv,
    glGetSubroutineIndex_p: APcv,
    glGetSubroutineUniformLocation_p: APcv,
    glGetSynciv_p: APcv,
    glGetTexImage_p: APcv,
    glGetTexLevelParameterfv_p: APcv,
    glGetTexLevelParameteriv_p: APcv,
    glGetTexParameterIiv_p: APcv,
    glGetTexParameterIuiv_p: APcv,
    glGetTexParameterfv_p: APcv,
    glGetTexParameteriv_p: APcv,
    glGetTextureImage_p: APcv,
    glGetTextureLevelParameterfv_p: APcv,
    glGetTextureLevelParameteriv_p: APcv,
    glGetTextureParameterIiv_p: APcv,
    glGetTextureParameterIuiv_p: APcv,
    glGetTextureParameterfv_p: APcv,
    glGetTextureParameteriv_p: APcv,
    glGetTextureSubImage_p: APcv,
    glGetTransformFeedbackVarying_p: APcv,
    glGetTransformFeedbacki64_v_p: APcv,
    glGetTransformFeedbacki_v_p: APcv,
    glGetTransformFeedbackiv_p: APcv,
    glGetUniformBlockIndex_p: APcv,
    glGetUniformIndices_p: APcv,
    glGetUniformLocation_p: APcv,
    glGetUniformSubroutineuiv_p: APcv,
    glGetUniformdv_p: APcv,
    glGetUniformfv_p: APcv,
    glGetUniformiv_p: APcv,
    glGetUniformuiv_p: APcv,
    glGetVertexArrayIndexed64iv_p: APcv,
    glGetVertexArrayIndexediv_p: APcv,
    glGetVertexArrayiv_p: APcv,
    glGetVertexAttribIiv_p: APcv,
    glGetVertexAttribIuiv_p: APcv,
    glGetVertexAttribLdv_p: APcv,
    glGetVertexAttribPointerv_p: APcv,
    glGetVertexAttribdv_p: APcv,
    glGetVertexAttribfv_p: APcv,
    glGetVertexAttribiv_p: APcv,
    glGetnCompressedTexImage_p: APcv,
    glGetnTexImage_p: APcv,
    glGetnUniformdv_p: APcv,
    glGetnUniformfv_p: APcv,
    glGetnUniformiv_p: APcv,
    glGetnUniformuiv_p: APcv,
    glHint_p: APcv,
    glInvalidateBufferData_p: APcv,
    glInvalidateBufferSubData_p: APcv,
    glInvalidateFramebuffer_p: APcv,
    glInvalidateNamedFramebufferData_p: APcv,
    glInvalidateNamedFramebufferSubData_p: APcv,
    glInvalidateSubFramebuffer_p: APcv,
    glInvalidateTexImage_p: APcv,
    glInvalidateTexSubImage_p: APcv,
    glIsBuffer_p: APcv,
    glIsEnabled_p: APcv,
    glIsEnabledi_p: APcv,
    glIsFramebuffer_p: APcv,
    glIsProgram_p: APcv,
    glIsProgramPipeline_p: APcv,
    glIsQuery_p: APcv,
    glIsRenderbuffer_p: APcv,
    glIsSampler_p: APcv,
    glIsShader_p: APcv,
    glIsSync_p: APcv,
    glIsTexture_p: APcv,
    glIsTransformFeedback_p: APcv,
    glIsVertexArray_p: APcv,
    glLineWidth_p: APcv,
    glLinkProgram_p: APcv,
    glLogicOp_p: APcv,
    glMapBuffer_p: APcv,
    glMapBufferRange_p: APcv,
    glMapNamedBuffer_p: APcv,
    glMapNamedBufferRange_p: APcv,
    glMemoryBarrier_p: APcv,
    glMemoryBarrierByRegion_p: APcv,
    glMinSampleShading_p: APcv,
    glMultiDrawArrays_p: APcv,
    glMultiDrawArraysIndirect_p: APcv,
    glMultiDrawArraysIndirectCount_p: APcv,
    glMultiDrawElements_p: APcv,
    glMultiDrawElementsBaseVertex_p: APcv,
    glMultiDrawElementsIndirect_p: APcv,
    glMultiDrawElementsIndirectCount_p: APcv,
    glNamedBufferData_p: APcv,
    glNamedBufferStorage_p: APcv,
    glNamedBufferSubData_p: APcv,
    glNamedFramebufferDrawBuffer_p: APcv,
    glNamedFramebufferDrawBuffers_p: APcv,
    glNamedFramebufferParameteri_p: APcv,
    glNamedFramebufferReadBuffer_p: APcv,
    glNamedFramebufferRenderbuffer_p: APcv,
    glNamedFramebufferTexture_p: APcv,
    glNamedFramebufferTextureLayer_p: APcv,
    glNamedRenderbufferStorage_p: APcv,
    glNamedRenderbufferStorageMultisample_p: APcv,
    glObjectLabel_p: APcv,
    glObjectPtrLabel_p: APcv,
    glPatchParameterfv_p: APcv,
    glPatchParameteri_p: APcv,
    glPauseTransformFeedback_p: APcv,
    glPixelStoref_p: APcv,
    glPixelStorei_p: APcv,
    glPointParameterf_p: APcv,
    glPointParameterfv_p: APcv,
    glPointParameteri_p: APcv,
    glPointParameteriv_p: APcv,
    glPointSize_p: APcv,
    glPolygonMode_p: APcv,
    glPolygonOffset_p: APcv,
    glPolygonOffsetClamp_p: APcv,
    glPopDebugGroup_p: APcv,
    glPrimitiveRestartIndex_p: APcv,
    glProgramBinary_p: APcv,
    glProgramParameteri_p: APcv,
    glProgramUniform1d_p: APcv,
    glProgramUniform1dv_p: APcv,
    glProgramUniform1f_p: APcv,
    glProgramUniform1fv_p: APcv,
    glProgramUniform1i_p: APcv,
    glProgramUniform1iv_p: APcv,
    glProgramUniform1ui_p: APcv,
    glProgramUniform1uiv_p: APcv,
    glProgramUniform2d_p: APcv,
    glProgramUniform2dv_p: APcv,
    glProgramUniform2f_p: APcv,
    glProgramUniform2fv_p: APcv,
    glProgramUniform2i_p: APcv,
    glProgramUniform2iv_p: APcv,
    glProgramUniform2ui_p: APcv,
    glProgramUniform2uiv_p: APcv,
    glProgramUniform3d_p: APcv,
    glProgramUniform3dv_p: APcv,
    glProgramUniform3f_p: APcv,
    glProgramUniform3fv_p: APcv,
    glProgramUniform3i_p: APcv,
    glProgramUniform3iv_p: APcv,
    glProgramUniform3ui_p: APcv,
    glProgramUniform3uiv_p: APcv,
    glProgramUniform4d_p: APcv,
    glProgramUniform4dv_p: APcv,
    glProgramUniform4f_p: APcv,
    glProgramUniform4fv_p: APcv,
    glProgramUniform4i_p: APcv,
    glProgramUniform4iv_p: APcv,
    glProgramUniform4ui_p: APcv,
    glProgramUniform4uiv_p: APcv,
    glProgramUniformMatrix2dv_p: APcv,
    glProgramUniformMatrix2fv_p: APcv,
    glProgramUniformMatrix2x3dv_p: APcv,
    glProgramUniformMatrix2x3fv_p: APcv,
    glProgramUniformMatrix2x4dv_p: APcv,
    glProgramUniformMatrix2x4fv_p: APcv,
    glProgramUniformMatrix3dv_p: APcv,
    glProgramUniformMatrix3fv_p: APcv,
    glProgramUniformMatrix3x2dv_p: APcv,
    glProgramUniformMatrix3x2fv_p: APcv,
    glProgramUniformMatrix3x4dv_p: APcv,
    glProgramUniformMatrix3x4fv_p: APcv,
    glProgramUniformMatrix4dv_p: APcv,
    glProgramUniformMatrix4fv_p: APcv,
    glProgramUniformMatrix4x2dv_p: APcv,
    glProgramUniformMatrix4x2fv_p: APcv,
    glProgramUniformMatrix4x3dv_p: APcv,
    glProgramUniformMatrix4x3fv_p: APcv,
    glProvokingVertex_p: APcv,
    glPushDebugGroup_p: APcv,
    glQueryCounter_p: APcv,
    glReadBuffer_p: APcv,
    glReadPixels_p: APcv,
    glReadnPixels_p: APcv,
    glReleaseShaderCompiler_p: APcv,
    glRenderbufferStorage_p: APcv,
    glRenderbufferStorageMultisample_p: APcv,
    glResumeTransformFeedback_p: APcv,
    glSampleCoverage_p: APcv,
    glSampleMaski_p: APcv,
    glSamplerParameterIiv_p: APcv,
    glSamplerParameterIuiv_p: APcv,
    glSamplerParameterf_p: APcv,
    glSamplerParameterfv_p: APcv,
    glSamplerParameteri_p: APcv,
    glSamplerParameteriv_p: APcv,
    glScissor_p: APcv,
    glScissorArrayv_p: APcv,
    glScissorIndexed_p: APcv,
    glScissorIndexedv_p: APcv,
    glShaderBinary_p: APcv,
    glShaderSource_p: APcv,
    glShaderStorageBlockBinding_p: APcv,
    glSpecializeShader_p: APcv,
    glStencilFunc_p: APcv,
    glStencilFuncSeparate_p: APcv,
    glStencilMask_p: APcv,
    glStencilMaskSeparate_p: APcv,
    glStencilOp_p: APcv,
    glStencilOpSeparate_p: APcv,
    glTexBuffer_p: APcv,
    glTexBufferRange_p: APcv,
    glTexImage1D_p: APcv,
    glTexImage2D_p: APcv,
    glTexImage2DMultisample_p: APcv,
    glTexImage3D_p: APcv,
    glTexImage3DMultisample_p: APcv,
    glTexParameterIiv_p: APcv,
    glTexParameterIuiv_p: APcv,
    glTexParameterf_p: APcv,
    glTexParameterfv_p: APcv,
    glTexParameteri_p: APcv,
    glTexParameteriv_p: APcv,
    glTexStorage1D_p: APcv,
    glTexStorage2D_p: APcv,
    glTexStorage2DMultisample_p: APcv,
    glTexStorage3D_p: APcv,
    glTexStorage3DMultisample_p: APcv,
    glTexSubImage1D_p: APcv,
    glTexSubImage2D_p: APcv,
    glTexSubImage3D_p: APcv,
    glTextureBarrier_p: APcv,
    glTextureBuffer_p: APcv,
    glTextureBufferRange_p: APcv,
    glTextureParameterIiv_p: APcv,
    glTextureParameterIuiv_p: APcv,
    glTextureParameterf_p: APcv,
    glTextureParameterfv_p: APcv,
    glTextureParameteri_p: APcv,
    glTextureParameteriv_p: APcv,
    glTextureStorage1D_p: APcv,
    glTextureStorage2D_p: APcv,
    glTextureStorage2DMultisample_p: APcv,
    glTextureStorage3D_p: APcv,
    glTextureStorage3DMultisample_p: APcv,
    glTextureSubImage1D_p: APcv,
    glTextureSubImage2D_p: APcv,
    glTextureSubImage3D_p: APcv,
    glTextureView_p: APcv,
    glTransformFeedbackBufferBase_p: APcv,
    glTransformFeedbackBufferRange_p: APcv,
    glTransformFeedbackVaryings_p: APcv,
    glUniform1d_p: APcv,
    glUniform1dv_p: APcv,
    glUniform1f_p: APcv,
    glUniform1fv_p: APcv,
    glUniform1i_p: APcv,
    glUniform1iv_p: APcv,
    glUniform1ui_p: APcv,
    glUniform1uiv_p: APcv,
    glUniform2d_p: APcv,
    glUniform2dv_p: APcv,
    glUniform2f_p: APcv,
    glUniform2fv_p: APcv,
    glUniform2i_p: APcv,
    glUniform2iv_p: APcv,
    glUniform2ui_p: APcv,
    glUniform2uiv_p: APcv,
    glUniform3d_p: APcv,
    glUniform3dv_p: APcv,
    glUniform3f_p: APcv,
    glUniform3fv_p: APcv,
    glUniform3i_p: APcv,
    glUniform3iv_p: APcv,
    glUniform3ui_p: APcv,
    glUniform3uiv_p: APcv,
    glUniform4d_p: APcv,
    glUniform4dv_p: APcv,
    glUniform4f_p: APcv,
    glUniform4fv_p: APcv,
    glUniform4i_p: APcv,
    glUniform4iv_p: APcv,
    glUniform4ui_p: APcv,
    glUniform4uiv_p: APcv,
    glUniformBlockBinding_p: APcv,
    glUniformMatrix2dv_p: APcv,
    glUniformMatrix2fv_p: APcv,
    glUniformMatrix2x3dv_p: APcv,
    glUniformMatrix2x3fv_p: APcv,
    glUniformMatrix2x4dv_p: APcv,
    glUniformMatrix2x4fv_p: APcv,
    glUniformMatrix3dv_p: APcv,
    glUniformMatrix3fv_p: APcv,
    glUniformMatrix3x2dv_p: APcv,
    glUniformMatrix3x2fv_p: APcv,
    glUniformMatrix3x4dv_p: APcv,
    glUniformMatrix3x4fv_p: APcv,
    glUniformMatrix4dv_p: APcv,
    glUniformMatrix4fv_p: APcv,
    glUniformMatrix4x2dv_p: APcv,
    glUniformMatrix4x2fv_p: APcv,
    glUniformMatrix4x3dv_p: APcv,
    glUniformMatrix4x3fv_p: APcv,
    glUniformSubroutinesuiv_p: APcv,
    glUnmapBuffer_p: APcv,
    glUnmapNamedBuffer_p: APcv,
    glUseProgram_p: APcv,
    glUseProgramStages_p: APcv,
    glValidateProgram_p: APcv,
    glValidateProgramPipeline_p: APcv,
    glVertexArrayAttribBinding_p: APcv,
    glVertexArrayAttribFormat_p: APcv,
    glVertexArrayAttribIFormat_p: APcv,
    glVertexArrayAttribLFormat_p: APcv,
    glVertexArrayBindingDivisor_p: APcv,
    glVertexArrayElementBuffer_p: APcv,
    glVertexArrayVertexBuffer_p: APcv,
    glVertexArrayVertexBuffers_p: APcv,
    glVertexAttrib1d_p: APcv,
    glVertexAttrib1dv_p: APcv,
    glVertexAttrib1f_p: APcv,
    glVertexAttrib1fv_p: APcv,
    glVertexAttrib1s_p: APcv,
    glVertexAttrib1sv_p: APcv,
    glVertexAttrib2d_p: APcv,
    glVertexAttrib2dv_p: APcv,
    glVertexAttrib2f_p: APcv,
    glVertexAttrib2fv_p: APcv,
    glVertexAttrib2s_p: APcv,
    glVertexAttrib2sv_p: APcv,
    glVertexAttrib3d_p: APcv,
    glVertexAttrib3dv_p: APcv,
    glVertexAttrib3f_p: APcv,
    glVertexAttrib3fv_p: APcv,
    glVertexAttrib3s_p: APcv,
    glVertexAttrib3sv_p: APcv,
    glVertexAttrib4Nbv_p: APcv,
    glVertexAttrib4Niv_p: APcv,
    glVertexAttrib4Nsv_p: APcv,
    glVertexAttrib4Nub_p: APcv,
    glVertexAttrib4Nubv_p: APcv,
    glVertexAttrib4Nuiv_p: APcv,
    glVertexAttrib4Nusv_p: APcv,
    glVertexAttrib4bv_p: APcv,
    glVertexAttrib4d_p: APcv,
    glVertexAttrib4dv_p: APcv,
    glVertexAttrib4f_p: APcv,
    glVertexAttrib4fv_p: APcv,
    glVertexAttrib4iv_p: APcv,
    glVertexAttrib4s_p: APcv,
    glVertexAttrib4sv_p: APcv,
    glVertexAttrib4ubv_p: APcv,
    glVertexAttrib4uiv_p: APcv,
    glVertexAttrib4usv_p: APcv,
    glVertexAttribBinding_p: APcv,
    glVertexAttribDivisor_p: APcv,
    glVertexAttribFormat_p: APcv,
    glVertexAttribI1i_p: APcv,
    glVertexAttribI1iv_p: APcv,
    glVertexAttribI1ui_p: APcv,
    glVertexAttribI1uiv_p: APcv,
    glVertexAttribI2i_p: APcv,
    glVertexAttribI2iv_p: APcv,
    glVertexAttribI2ui_p: APcv,
    glVertexAttribI2uiv_p: APcv,
    glVertexAttribI3i_p: APcv,
    glVertexAttribI3iv_p: APcv,
    glVertexAttribI3ui_p: APcv,
    glVertexAttribI3uiv_p: APcv,
    glVertexAttribI4bv_p: APcv,
    glVertexAttribI4i_p: APcv,
    glVertexAttribI4iv_p: APcv,
    glVertexAttribI4sv_p: APcv,
    glVertexAttribI4ubv_p: APcv,
    glVertexAttribI4ui_p: APcv,
    glVertexAttribI4uiv_p: APcv,
    glVertexAttribI4usv_p: APcv,
    glVertexAttribIFormat_p: APcv,
    glVertexAttribIPointer_p: APcv,
    glVertexAttribL1d_p: APcv,
    glVertexAttribL1dv_p: APcv,
    glVertexAttribL2d_p: APcv,
    glVertexAttribL2dv_p: APcv,
    glVertexAttribL3d_p: APcv,
    glVertexAttribL3dv_p: APcv,
    glVertexAttribL4d_p: APcv,
    glVertexAttribL4dv_p: APcv,
    glVertexAttribLFormat_p: APcv,
    glVertexAttribLPointer_p: APcv,
    glVertexAttribP1ui_p: APcv,
    glVertexAttribP1uiv_p: APcv,
    glVertexAttribP2ui_p: APcv,
    glVertexAttribP2uiv_p: APcv,
    glVertexAttribP3ui_p: APcv,
    glVertexAttribP3uiv_p: APcv,
    glVertexAttribP4ui_p: APcv,
    glVertexAttribP4uiv_p: APcv,
    glVertexAttribPointer_p: APcv,
    glVertexBindingDivisor_p: APcv,
    glViewport_p: APcv,
    glViewportArrayv_p: APcv,
    glViewportIndexedf_p: APcv,
    glViewportIndexedfv_p: APcv,
    glWaitSync_p: APcv,
  }
  #[cfg(feature = "bytemuck")]
  unsafe impl bytemuck::Zeroable for GlFns {}
  impl core::fmt::Debug for GlFns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      write!(f, "GlFns")
    }
  }
}
// end of module
